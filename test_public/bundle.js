(function () {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, basedir, module) {
		return module = {
		  path: basedir,
		  exports: {},
		  require: function (path, base) {
	      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
	    }
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var runtime_1 = createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var runtime = (function (exports) {

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined$1; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  exports.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };

	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }

	  exports.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  exports.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  exports.awrap = function(arg) {
	    return { __await: arg };
	  };

	  function AsyncIterator(generator, PromiseImpl) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return PromiseImpl.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return PromiseImpl.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration.
	          result.value = unwrapped;
	          resolve(result);
	        }, function(error) {
	          // If a rejected Promise was yielded, throw the rejection back
	          // into the async generator function so it can be handled there.
	          return invoke("throw", error, resolve, reject);
	        });
	      }
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new PromiseImpl(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	    return this;
	  };
	  exports.AsyncIterator = AsyncIterator;

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
	    if (PromiseImpl === void 0) PromiseImpl = Promise;

	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList),
	      PromiseImpl
	    );

	    return exports.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;

	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);

	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined$1) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;

	      if (context.method === "throw") {
	        // Note: ["return"] must be used for ES3 parsing compatibility.
	        if (delegate.iterator["return"]) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined$1;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;

	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;

	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined$1;
	      }

	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }

	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  Gp[toStringTagSymbol] = "Generator";

	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  exports.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined$1;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  exports.values = values;

	  function doneResult() {
	    return { value: undefined$1, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined$1;
	      this.done = false;
	      this.delegate = null;

	      this.method = "next";
	      this.arg = undefined$1;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined$1;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined$1;
	        }

	        return !! caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined$1;
	      }

	      return ContinueSentinel;
	    }
	  };

	  // Regardless of whether this script is executing as a CommonJS module
	  // or not, return the runtime object so that we can declare the variable
	  // regeneratorRuntime in the outer scope, which allows this module to be
	  // injected easily by `bin/regenerator --include-runtime script.js`.
	  return exports;

	}(
	  // If this script is executing as a CommonJS module, use module.exports
	  // as the regeneratorRuntime namespace. Otherwise create a new empty
	  // object. Either way, the resulting object will be used to initialize
	  // the regeneratorRuntime variable at the top of this file.
	   module.exports 
	));

	try {
	  regeneratorRuntime = runtime;
	} catch (accidentalStrictMode) {
	  // This module should not be running in strict mode, so the above
	  // assignment should always work unless something is misconfigured. Just
	  // in case runtime.js accidentally runs in strict mode, we can escape
	  // strict mode using a global Function call. This could conceivably fail
	  // if a Content Security Policy forbids using Function, but in that case
	  // the proper solution is to fix the accidental strict mode problem. If
	  // you've misconfigured your bundler to force strict mode and applied a
	  // CSP to forbid Function, and you're not willing to fix either of those
	  // problems, please detail your unique predicament in a GitHub issue.
	  Function("r", "regeneratorRuntime = r")(runtime);
	}
	});

	var regenerator = runtime_1;

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	var defineProperty = _defineProperty;

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }

	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}

	function _asyncToGenerator(fn) {
	  return function () {
	    var self = this,
	        args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);

	      function _next(value) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
	      }

	      function _throw(err) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
	      }

	      _next(undefined);
	    });
	  };
	}

	var asyncToGenerator = _asyncToGenerator;

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	var arrayWithHoles = _arrayWithHoles;

	function _iterableToArrayLimit(arr, i) {
	  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
	  var _arr = [];
	  var _n = true;
	  var _d = false;
	  var _e = undefined;

	  try {
	    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	var iterableToArrayLimit = _iterableToArrayLimit;

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) {
	    arr2[i] = arr[i];
	  }

	  return arr2;
	}

	var arrayLikeToArray = _arrayLikeToArray;

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
	}

	var unsupportedIterableToArray = _unsupportedIterableToArray;

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	var nonIterableRest = _nonIterableRest;

	function _slicedToArray(arr, i) {
	  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
	}

	var slicedToArray = _slicedToArray;

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return arrayLikeToArray(arr);
	}

	var arrayWithoutHoles = _arrayWithoutHoles;

	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
	}

	var iterableToArray = _iterableToArray;

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	var nonIterableSpread = _nonIterableSpread;

	function _toConsumableArray(arr) {
	  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
	}

	var toConsumableArray = _toConsumableArray;

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	var classCallCheck = _classCallCheck;

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	var createClass = _createClass;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	var _freeGlobal = freeGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = _freeGlobal || freeSelf || Function('return this')();

	var _root = root;

	/** Built-in value references. */
	var Symbol$1 = _root.Symbol;

	var _Symbol = Symbol$1;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	var _getRawTag = getRawTag;

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$1.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString$1.call(value);
	}

	var _objectToString = objectToString;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag$1 && symToStringTag$1 in Object(value))
	    ? _getRawTag(value)
	    : _objectToString(value);
	}

	var _baseGetTag = baseGetTag;

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	var isObject_1 = isObject;

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject_1(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = _baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	var isFunction_1 = isFunction;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = _root['__core-js_shared__'];

	var _coreJsData = coreJsData;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	var _isMasked = isMasked;

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	var _toSource = toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype,
	    objectProto$2 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject_1(value) || _isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(_toSource(value));
	}

	var _baseIsNative = baseIsNative;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	var _getValue = getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = _getValue(object, key);
	  return _baseIsNative(value) ? value : undefined;
	}

	var _getNative = getNative;

	var defineProperty$1 = (function() {
	  try {
	    var func = _getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	var _defineProperty$1 = defineProperty$1;

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && _defineProperty$1) {
	    _defineProperty$1(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	var _baseAssignValue = baseAssignValue;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	var eq_1 = eq;

	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty$2.call(object, key) && eq_1(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    _baseAssignValue(object, key, value);
	  }
	}

	var _assignValue = assignValue;

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	var isArray_1 = isArray;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	var isObjectLike_1 = isObjectLike;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
	}

	var isSymbol_1 = isSymbol;

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray_1(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol_1(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	var _isKey = isKey;

	/* Built-in method references that are verified to be native. */
	var nativeCreate = _getNative(Object, 'create');

	var _nativeCreate = nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
	  this.size = 0;
	}

	var _hashClear = hashClear;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _hashDelete = hashDelete;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (_nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty$3.call(data, key) ? data[key] : undefined;
	}

	var _hashGet = hashGet;

	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$4.call(data, key);
	}

	var _hashHas = hashHas;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	var _hashSet = hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = _hashClear;
	Hash.prototype['delete'] = _hashDelete;
	Hash.prototype.get = _hashGet;
	Hash.prototype.has = _hashHas;
	Hash.prototype.set = _hashSet;

	var _Hash = Hash;

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	var _listCacheClear = listCacheClear;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq_1(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	var _assocIndexOf = assocIndexOf;

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	var _listCacheDelete = listCacheDelete;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	var _listCacheGet = listCacheGet;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return _assocIndexOf(this.__data__, key) > -1;
	}

	var _listCacheHas = listCacheHas;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	var _listCacheSet = listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = _listCacheClear;
	ListCache.prototype['delete'] = _listCacheDelete;
	ListCache.prototype.get = _listCacheGet;
	ListCache.prototype.has = _listCacheHas;
	ListCache.prototype.set = _listCacheSet;

	var _ListCache = ListCache;

	/* Built-in method references that are verified to be native. */
	var Map$1 = _getNative(_root, 'Map');

	var _Map = Map$1;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new _Hash,
	    'map': new (_Map || _ListCache),
	    'string': new _Hash
	  };
	}

	var _mapCacheClear = mapCacheClear;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	var _isKeyable = isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return _isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	var _getMapData = getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = _getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _mapCacheDelete = mapCacheDelete;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return _getMapData(this, key).get(key);
	}

	var _mapCacheGet = mapCacheGet;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return _getMapData(this, key).has(key);
	}

	var _mapCacheHas = mapCacheHas;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = _getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	var _mapCacheSet = mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = _mapCacheClear;
	MapCache.prototype['delete'] = _mapCacheDelete;
	MapCache.prototype.get = _mapCacheGet;
	MapCache.prototype.has = _mapCacheHas;
	MapCache.prototype.set = _mapCacheSet;

	var _MapCache = MapCache;

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || _MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = _MapCache;

	var memoize_1 = memoize;

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize_1(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	var _memoizeCapped = memoizeCapped;

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = _memoizeCapped(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	var _stringToPath = stringToPath;

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	var _arrayMap = arrayMap;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = _Symbol ? _Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray_1(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return _arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol_1(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	var _baseToString = baseToString;

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : _baseToString(value);
	}

	var toString_1 = toString;

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray_1(value)) {
	    return value;
	  }
	  return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
	}

	var _castPath = castPath;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	var _isIndex = isIndex;

	/** Used as references for various `Number` constants. */
	var INFINITY$1 = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol_1(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
	}

	var _toKey = toKey;

	/**
	 * The base implementation of `_.set`.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @param {Function} [customizer] The function to customize path creation.
	 * @returns {Object} Returns `object`.
	 */
	function baseSet(object, path, value, customizer) {
	  if (!isObject_1(object)) {
	    return object;
	  }
	  path = _castPath(path, object);

	  var index = -1,
	      length = path.length,
	      lastIndex = length - 1,
	      nested = object;

	  while (nested != null && ++index < length) {
	    var key = _toKey(path[index]),
	        newValue = value;

	    if (index != lastIndex) {
	      var objValue = nested[key];
	      newValue = customizer ? customizer(objValue, key, nested) : undefined;
	      if (newValue === undefined) {
	        newValue = isObject_1(objValue)
	          ? objValue
	          : (_isIndex(path[index + 1]) ? [] : {});
	      }
	    }
	    _assignValue(nested, key, newValue);
	    nested = nested[key];
	  }
	  return object;
	}

	var _baseSet = baseSet;

	/**
	 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	 * it's created. Arrays are created for missing index properties while objects
	 * are created for all other missing properties. Use `_.setWith` to customize
	 * `path` creation.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.set(object, 'a[0].b.c', 4);
	 * console.log(object.a[0].b.c);
	 * // => 4
	 *
	 * _.set(object, ['x', '0', 'y', 'z'], 5);
	 * console.log(object.x[0].y.z);
	 * // => 5
	 */
	function set(object, path, value) {
	  return object == null ? object : _baseSet(object, path, value);
	}

	var set_1 = set;

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new _ListCache;
	  this.size = 0;
	}

	var _stackClear = stackClear;

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	var _stackDelete = stackDelete;

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	var _stackGet = stackGet;

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	var _stackHas = stackHas;

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof _ListCache) {
	    var pairs = data.__data__;
	    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new _MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	var _stackSet = stackSet;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new _ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = _stackClear;
	Stack.prototype['delete'] = _stackDelete;
	Stack.prototype.get = _stackGet;
	Stack.prototype.has = _stackHas;
	Stack.prototype.set = _stackSet;

	var _Stack = Stack;

	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	var _arrayEach = arrayEach;

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      _baseAssignValue(object, key, newValue);
	    } else {
	      _assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	var _copyObject = copyObject;

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	var _baseTimes = baseTimes;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
	}

	var _baseIsArguments = baseIsArguments;

	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
	  return isObjectLike_1(value) && hasOwnProperty$5.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	var isArguments_1 = isArguments;

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	var stubFalse_1 = stubFalse;

	var isBuffer_1 = createCommonjsModule(function (module, exports) {
	/** Detect free variable `exports`. */
	var freeExports =  exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? _root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse_1;

	module.exports = isBuffer;
	});

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$1 = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
	}

	var isLength_1 = isLength;

	/** `Object#toString` result references. */
	var argsTag$1 = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag$1 = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike_1(value) &&
	    isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
	}

	var _baseIsTypedArray = baseIsTypedArray;

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	var _baseUnary = baseUnary;

	var _nodeUtil = createCommonjsModule(function (module, exports) {
	/** Detect free variable `exports`. */
	var freeExports =  exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && _freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    // Use `util.types` for Node.js 10+.
	    var types = freeModule && freeModule.require && freeModule.require('util').types;

	    if (types) {
	      return types;
	    }

	    // Legacy `process.binding('util')` for Node.js < 10.
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	module.exports = nodeUtil;
	});

	/* Node.js helper references. */
	var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

	var isTypedArray_1 = isTypedArray;

	/** Used for built-in method references. */
	var objectProto$7 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray_1(value),
	      isArg = !isArr && isArguments_1(value),
	      isBuff = !isArr && !isArg && isBuffer_1(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? _baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty$6.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           _isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _arrayLikeKeys = arrayLikeKeys;

	/** Used for built-in method references. */
	var objectProto$8 = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$8;

	  return value === proto;
	}

	var _isPrototype = isPrototype;

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	var _overArg = overArg;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = _overArg(Object.keys, Object);

	var _nativeKeys = nativeKeys;

	/** Used for built-in method references. */
	var objectProto$9 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!_isPrototype(object)) {
	    return _nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$7.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _baseKeys = baseKeys;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength_1(value.length) && !isFunction_1(value);
	}

	var isArrayLike_1 = isArrayLike;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
	}

	var keys_1 = keys;

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return object && _copyObject(source, keys_1(source), object);
	}

	var _baseAssign = baseAssign;

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _nativeKeysIn = nativeKeysIn;

	/** Used for built-in method references. */
	var objectProto$a = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject_1(object)) {
	    return _nativeKeysIn(object);
	  }
	  var isProto = _isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty$8.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _baseKeysIn = baseKeysIn;

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn$1(object) {
	  return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
	}

	var keysIn_1 = keysIn$1;

	/**
	 * The base implementation of `_.assignIn` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssignIn(object, source) {
	  return object && _copyObject(source, keysIn_1(source), object);
	}

	var _baseAssignIn = baseAssignIn;

	var _cloneBuffer = createCommonjsModule(function (module, exports) {
	/** Detect free variable `exports`. */
	var freeExports =  exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? _root.Buffer : undefined,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	  buffer.copy(result);
	  return result;
	}

	module.exports = cloneBuffer;
	});

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	var _copyArray = copyArray;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	var _arrayFilter = arrayFilter;

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	var stubArray_1 = stubArray;

	/** Used for built-in method references. */
	var objectProto$b = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return _arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable$1.call(object, symbol);
	  });
	};

	var _getSymbols = getSymbols;

	/**
	 * Copies own symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols(source, object) {
	  return _copyObject(source, _getSymbols(source), object);
	}

	var _copySymbols = copySymbols;

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	var _arrayPush = arrayPush;

	/** Built-in value references. */
	var getPrototype = _overArg(Object.getPrototypeOf, Object);

	var _getPrototype = getPrototype;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own and inherited enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbolsIn = !nativeGetSymbols$1 ? stubArray_1 : function(object) {
	  var result = [];
	  while (object) {
	    _arrayPush(result, _getSymbols(object));
	    object = _getPrototype(object);
	  }
	  return result;
	};

	var _getSymbolsIn = getSymbolsIn;

	/**
	 * Copies own and inherited symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbolsIn(source, object) {
	  return _copyObject(source, _getSymbolsIn(source), object);
	}

	var _copySymbolsIn = copySymbolsIn;

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
	}

	var _baseGetAllKeys = baseGetAllKeys;

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return _baseGetAllKeys(object, keys_1, _getSymbols);
	}

	var _getAllKeys = getAllKeys;

	/**
	 * Creates an array of own and inherited enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeysIn(object) {
	  return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
	}

	var _getAllKeysIn = getAllKeysIn;

	/* Built-in method references that are verified to be native. */
	var DataView$1 = _getNative(_root, 'DataView');

	var _DataView = DataView$1;

	/* Built-in method references that are verified to be native. */
	var Promise$1 = _getNative(_root, 'Promise');

	var _Promise = Promise$1;

	/* Built-in method references that are verified to be native. */
	var Set$1 = _getNative(_root, 'Set');

	var _Set = Set$1;

	/* Built-in method references that are verified to be native. */
	var WeakMap$1 = _getNative(_root, 'WeakMap');

	var _WeakMap = WeakMap$1;

	/** `Object#toString` result references. */
	var mapTag$1 = '[object Map]',
	    objectTag$1 = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag$1 = '[object Set]',
	    weakMapTag$1 = '[object WeakMap]';

	var dataViewTag$1 = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = _toSource(_DataView),
	    mapCtorString = _toSource(_Map),
	    promiseCtorString = _toSource(_Promise),
	    setCtorString = _toSource(_Set),
	    weakMapCtorString = _toSource(_WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = _baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$1) ||
	    (_Map && getTag(new _Map) != mapTag$1) ||
	    (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
	    (_Set && getTag(new _Set) != setTag$1) ||
	    (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
	  getTag = function(value) {
	    var result = _baseGetTag(value),
	        Ctor = result == objectTag$1 ? value.constructor : undefined,
	        ctorString = Ctor ? _toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag$1;
	        case mapCtorString: return mapTag$1;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag$1;
	        case weakMapCtorString: return weakMapTag$1;
	      }
	    }
	    return result;
	  };
	}

	var _getTag = getTag;

	/** Used for built-in method references. */
	var objectProto$c = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray(array) {
	  var length = array.length,
	      result = new array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty$9.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	var _initCloneArray = initCloneArray;

	/** Built-in value references. */
	var Uint8Array$1 = _root.Uint8Array;

	var _Uint8Array = Uint8Array$1;

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
	  return result;
	}

	var _cloneArrayBuffer = cloneArrayBuffer;

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView(dataView, isDeep) {
	  var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}

	var _cloneDataView = cloneDataView;

	/** Used to match `RegExp` flags from their coerced string values. */
	var reFlags = /\w*$/;

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}

	var _cloneRegExp = cloneRegExp;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
	    symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol(symbol) {
	  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	}

	var _cloneSymbol = cloneSymbol;

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	var _cloneTypedArray = cloneTypedArray;

	/** `Object#toString` result references. */
	var boolTag$1 = '[object Boolean]',
	    dateTag$1 = '[object Date]',
	    mapTag$2 = '[object Map]',
	    numberTag$1 = '[object Number]',
	    regexpTag$1 = '[object RegExp]',
	    setTag$2 = '[object Set]',
	    stringTag$1 = '[object String]',
	    symbolTag$1 = '[object Symbol]';

	var arrayBufferTag$1 = '[object ArrayBuffer]',
	    dataViewTag$2 = '[object DataView]',
	    float32Tag$1 = '[object Float32Array]',
	    float64Tag$1 = '[object Float64Array]',
	    int8Tag$1 = '[object Int8Array]',
	    int16Tag$1 = '[object Int16Array]',
	    int32Tag$1 = '[object Int32Array]',
	    uint8Tag$1 = '[object Uint8Array]',
	    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
	    uint16Tag$1 = '[object Uint16Array]',
	    uint32Tag$1 = '[object Uint32Array]';

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag$1:
	      return _cloneArrayBuffer(object);

	    case boolTag$1:
	    case dateTag$1:
	      return new Ctor(+object);

	    case dataViewTag$2:
	      return _cloneDataView(object, isDeep);

	    case float32Tag$1: case float64Tag$1:
	    case int8Tag$1: case int16Tag$1: case int32Tag$1:
	    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
	      return _cloneTypedArray(object, isDeep);

	    case mapTag$2:
	      return new Ctor;

	    case numberTag$1:
	    case stringTag$1:
	      return new Ctor(object);

	    case regexpTag$1:
	      return _cloneRegExp(object);

	    case setTag$2:
	      return new Ctor;

	    case symbolTag$1:
	      return _cloneSymbol(object);
	  }
	}

	var _initCloneByTag = initCloneByTag;

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject_1(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	var _baseCreate = baseCreate;

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !_isPrototype(object))
	    ? _baseCreate(_getPrototype(object))
	    : {};
	}

	var _initCloneObject = initCloneObject;

	/** `Object#toString` result references. */
	var mapTag$3 = '[object Map]';

	/**
	 * The base implementation of `_.isMap` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 */
	function baseIsMap(value) {
	  return isObjectLike_1(value) && _getTag(value) == mapTag$3;
	}

	var _baseIsMap = baseIsMap;

	/* Node.js helper references. */
	var nodeIsMap = _nodeUtil && _nodeUtil.isMap;

	/**
	 * Checks if `value` is classified as a `Map` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 * @example
	 *
	 * _.isMap(new Map);
	 * // => true
	 *
	 * _.isMap(new WeakMap);
	 * // => false
	 */
	var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;

	var isMap_1 = isMap;

	/** `Object#toString` result references. */
	var setTag$3 = '[object Set]';

	/**
	 * The base implementation of `_.isSet` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 */
	function baseIsSet(value) {
	  return isObjectLike_1(value) && _getTag(value) == setTag$3;
	}

	var _baseIsSet = baseIsSet;

	/* Node.js helper references. */
	var nodeIsSet = _nodeUtil && _nodeUtil.isSet;

	/**
	 * Checks if `value` is classified as a `Set` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 * @example
	 *
	 * _.isSet(new Set);
	 * // => true
	 *
	 * _.isSet(new WeakSet);
	 * // => false
	 */
	var isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;

	var isSet_1 = isSet;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG = 4;

	/** `Object#toString` result references. */
	var argsTag$2 = '[object Arguments]',
	    arrayTag$1 = '[object Array]',
	    boolTag$2 = '[object Boolean]',
	    dateTag$2 = '[object Date]',
	    errorTag$1 = '[object Error]',
	    funcTag$2 = '[object Function]',
	    genTag$1 = '[object GeneratorFunction]',
	    mapTag$4 = '[object Map]',
	    numberTag$2 = '[object Number]',
	    objectTag$2 = '[object Object]',
	    regexpTag$2 = '[object RegExp]',
	    setTag$4 = '[object Set]',
	    stringTag$2 = '[object String]',
	    symbolTag$2 = '[object Symbol]',
	    weakMapTag$2 = '[object WeakMap]';

	var arrayBufferTag$2 = '[object ArrayBuffer]',
	    dataViewTag$3 = '[object DataView]',
	    float32Tag$2 = '[object Float32Array]',
	    float64Tag$2 = '[object Float64Array]',
	    int8Tag$2 = '[object Int8Array]',
	    int16Tag$2 = '[object Int16Array]',
	    int32Tag$2 = '[object Int32Array]',
	    uint8Tag$2 = '[object Uint8Array]',
	    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
	    uint16Tag$2 = '[object Uint16Array]',
	    uint32Tag$2 = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] =
	cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] =
	cloneableTags[boolTag$2] = cloneableTags[dateTag$2] =
	cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] =
	cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] =
	cloneableTags[int32Tag$2] = cloneableTags[mapTag$4] =
	cloneableTags[numberTag$2] = cloneableTags[objectTag$2] =
	cloneableTags[regexpTag$2] = cloneableTags[setTag$4] =
	cloneableTags[stringTag$2] = cloneableTags[symbolTag$2] =
	cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] =
	cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
	cloneableTags[errorTag$1] = cloneableTags[funcTag$2] =
	cloneableTags[weakMapTag$2] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Deep clone
	 *  2 - Flatten inherited properties
	 *  4 - Clone symbols
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone(value, bitmask, customizer, key, object, stack) {
	  var result,
	      isDeep = bitmask & CLONE_DEEP_FLAG,
	      isFlat = bitmask & CLONE_FLAT_FLAG,
	      isFull = bitmask & CLONE_SYMBOLS_FLAG;

	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject_1(value)) {
	    return value;
	  }
	  var isArr = isArray_1(value);
	  if (isArr) {
	    result = _initCloneArray(value);
	    if (!isDeep) {
	      return _copyArray(value, result);
	    }
	  } else {
	    var tag = _getTag(value),
	        isFunc = tag == funcTag$2 || tag == genTag$1;

	    if (isBuffer_1(value)) {
	      return _cloneBuffer(value, isDeep);
	    }
	    if (tag == objectTag$2 || tag == argsTag$2 || (isFunc && !object)) {
	      result = (isFlat || isFunc) ? {} : _initCloneObject(value);
	      if (!isDeep) {
	        return isFlat
	          ? _copySymbolsIn(value, _baseAssignIn(result, value))
	          : _copySymbols(value, _baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = _initCloneByTag(value, tag, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new _Stack);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (isSet_1(value)) {
	    value.forEach(function(subValue) {
	      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	    });
	  } else if (isMap_1(value)) {
	    value.forEach(function(subValue, key) {
	      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	    });
	  }

	  var keysFunc = isFull
	    ? (isFlat ? _getAllKeysIn : _getAllKeys)
	    : (isFlat ? keysIn : keys_1);

	  var props = isArr ? undefined : keysFunc(value);
	  _arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	  });
	  return result;
	}

	var _baseClone = baseClone;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$1 = 1,
	    CLONE_SYMBOLS_FLAG$1 = 4;

	/**
	 * This method is like `_.clone` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.clone
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var deep = _.cloneDeep(objects);
	 * console.log(deep[0] === objects[0]);
	 * // => false
	 */
	function cloneDeep(value) {
	  return _baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
	}

	var cloneDeep_1 = cloneDeep;

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = _castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[_toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	var _baseGet = baseGet;

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : _baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	var get_1 = get;

	var bind = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};

	/*global toString:true*/

	// utils is a library of generic helper functions non-specific to axios

	var toString$1 = Object.prototype.toString;

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray$1(val) {
	  return toString$1.call(val) === '[object Array]';
	}

	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined(val) {
	  return typeof val === 'undefined';
	}

	/**
	 * Determine if a value is a Buffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Buffer, otherwise false
	 */
	function isBuffer(val) {
	  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
	    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	function isArrayBuffer(val) {
	  return toString$1.call(val) === '[object ArrayBuffer]';
	}

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData(val) {
	  return (typeof FormData !== 'undefined') && (val instanceof FormData);
	}

	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  var result;
	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString(val) {
	  return typeof val === 'string';
	}

	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber(val) {
	  return typeof val === 'number';
	}

	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject$1(val) {
	  return val !== null && typeof val === 'object';
	}

	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	function isDate(val) {
	  return toString$1.call(val) === '[object Date]';
	}

	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	function isFile(val) {
	  return toString$1.call(val) === '[object File]';
	}

	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	function isBlob(val) {
	  return toString$1.call(val) === '[object Blob]';
	}

	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction$1(val) {
	  return toString$1.call(val) === '[object Function]';
	}

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream(val) {
	  return isObject$1(val) && isFunction$1(val.pipe);
	}

	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	function isURLSearchParams(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim(str) {
	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
	}

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  navigator.product -> 'ReactNative'
	 * nativescript
	 *  navigator.product -> 'NativeScript' or 'NS'
	 */
	function isStandardBrowserEnv() {
	  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
	                                           navigator.product === 'NativeScript' ||
	                                           navigator.product === 'NS')) {
	    return false;
	  }
	  return (
	    typeof window !== 'undefined' &&
	    typeof document !== 'undefined'
	  );
	}

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }

	  // Force an array if not already something iterable
	  if (typeof obj !== 'object') {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }

	  if (isArray$1(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */) {
	  var result = {};
	  function assignValue(val, key) {
	    if (typeof result[key] === 'object' && typeof val === 'object') {
	      result[key] = merge(result[key], val);
	    } else {
	      result[key] = val;
	    }
	  }

	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Function equal to merge with the difference being that no reference
	 * to original objects is kept.
	 *
	 * @see merge
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function deepMerge(/* obj1, obj2, obj3, ... */) {
	  var result = {};
	  function assignValue(val, key) {
	    if (typeof result[key] === 'object' && typeof val === 'object') {
	      result[key] = deepMerge(result[key], val);
	    } else if (typeof val === 'object') {
	      result[key] = deepMerge({}, val);
	    } else {
	      result[key] = val;
	    }
	  }

	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend(a, b, thisArg) {
	  forEach(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}

	var utils = {
	  isArray: isArray$1,
	  isArrayBuffer: isArrayBuffer,
	  isBuffer: isBuffer,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject$1,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction$1,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach,
	  merge: merge,
	  deepMerge: deepMerge,
	  extend: extend,
	  trim: trim
	};

	function encode(val) {
	  return encodeURIComponent(val).
	    replace(/%40/gi, '@').
	    replace(/%3A/gi, ':').
	    replace(/%24/g, '$').
	    replace(/%2C/gi, ',').
	    replace(/%20/g, '+').
	    replace(/%5B/gi, '[').
	    replace(/%5D/gi, ']');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	var buildURL = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }

	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];

	    utils.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }

	      if (utils.isArray(val)) {
	        key = key + '[]';
	      } else {
	        val = [val];
	      }

	      utils.forEach(val, function parseValue(v) {
	        if (utils.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });

	    serializedParams = parts.join('&');
	  }

	  if (serializedParams) {
	    var hashmarkIndex = url.indexOf('#');
	    if (hashmarkIndex !== -1) {
	      url = url.slice(0, hashmarkIndex);
	    }

	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }

	  return url;
	};

	function InterceptorManager() {
	  this.handlers = [];
	}

	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */
	InterceptorManager.prototype.use = function use(fulfilled, rejected) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected
	  });
	  return this.handlers.length - 1;
	};

	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */
	InterceptorManager.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};

	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */
	InterceptorManager.prototype.forEach = function forEach(fn) {
	  utils.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};

	var InterceptorManager_1 = InterceptorManager;

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */
	var transformData = function transformData(data, headers, fns) {
	  /*eslint no-param-reassign:0*/
	  utils.forEach(fns, function transform(fn) {
	    data = fn(data, headers);
	  });

	  return data;
	};

	var isCancel = function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	};

	var global$1 = (typeof global !== "undefined" ? global :
	            typeof self !== "undefined" ? self :
	            typeof window !== "undefined" ? window : {});

	// shim for using process in browser
	// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	var cachedSetTimeout = defaultSetTimout;
	var cachedClearTimeout = defaultClearTimeout;
	if (typeof global$1.setTimeout === 'function') {
	    cachedSetTimeout = setTimeout;
	}
	if (typeof global$1.clearTimeout === 'function') {
	    cachedClearTimeout = clearTimeout;
	}

	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	function nextTick(fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	}
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	var title = 'browser';
	var platform = 'browser';
	var browser = true;
	var env = {};
	var argv = [];
	var version = ''; // empty string to avoid regexp issues
	var versions = {};
	var release = {};
	var config = {};

	function noop() {}

	var on = noop;
	var addListener = noop;
	var once = noop;
	var off = noop;
	var removeListener = noop;
	var removeAllListeners = noop;
	var emit = noop;

	function binding(name) {
	    throw new Error('process.binding is not supported');
	}

	function cwd () { return '/' }
	function chdir (dir) {
	    throw new Error('process.chdir is not supported');
	}function umask() { return 0; }

	// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
	var performance = global$1.performance || {};
	var performanceNow =
	  performance.now        ||
	  performance.mozNow     ||
	  performance.msNow      ||
	  performance.oNow       ||
	  performance.webkitNow  ||
	  function(){ return (new Date()).getTime() };

	// generate timestamp or delta
	// see http://nodejs.org/api/process.html#process_process_hrtime
	function hrtime(previousTimestamp){
	  var clocktime = performanceNow.call(performance)*1e-3;
	  var seconds = Math.floor(clocktime);
	  var nanoseconds = Math.floor((clocktime%1)*1e9);
	  if (previousTimestamp) {
	    seconds = seconds - previousTimestamp[0];
	    nanoseconds = nanoseconds - previousTimestamp[1];
	    if (nanoseconds<0) {
	      seconds--;
	      nanoseconds += 1e9;
	    }
	  }
	  return [seconds,nanoseconds]
	}

	var startTime = new Date();
	function uptime() {
	  var currentTime = new Date();
	  var dif = currentTime - startTime;
	  return dif / 1000;
	}

	var process = {
	  nextTick: nextTick,
	  title: title,
	  browser: browser,
	  env: env,
	  argv: argv,
	  version: version,
	  versions: versions,
	  on: on,
	  addListener: addListener,
	  once: once,
	  off: off,
	  removeListener: removeListener,
	  removeAllListeners: removeAllListeners,
	  emit: emit,
	  binding: binding,
	  cwd: cwd,
	  chdir: chdir,
	  umask: umask,
	  hrtime: hrtime,
	  platform: platform,
	  release: release,
	  config: config,
	  uptime: uptime
	};

	var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
	  utils.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};

	/**
	 * Update an Error with the specified config, error code, and response.
	 *
	 * @param {Error} error The error to update.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The error.
	 */
	var enhanceError = function enhanceError(error, config, code, request, response) {
	  error.config = config;
	  if (code) {
	    error.code = code;
	  }

	  error.request = request;
	  error.response = response;
	  error.isAxiosError = true;

	  error.toJSON = function() {
	    return {
	      // Standard
	      message: this.message,
	      name: this.name,
	      // Microsoft
	      description: this.description,
	      number: this.number,
	      // Mozilla
	      fileName: this.fileName,
	      lineNumber: this.lineNumber,
	      columnNumber: this.columnNumber,
	      stack: this.stack,
	      // Axios
	      config: this.config,
	      code: this.code
	    };
	  };
	  return error;
	};

	/**
	 * Create an Error with the specified message, config, error code, request and response.
	 *
	 * @param {string} message The error message.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	var createError = function createError(message, config, code, request, response) {
	  var error = new Error(message);
	  return enhanceError(error, config, code, request, response);
	};

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	var settle = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  if (!validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(createError(
	      'Request failed with status code ' + response.status,
	      response.config,
	      null,
	      response.request,
	      response
	    ));
	  }
	};

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	var isAbsoluteURL = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
	};

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */
	var combineURLs = function combineURLs(baseURL, relativeURL) {
	  return relativeURL
	    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
	    : baseURL;
	};

	/**
	 * Creates a new URL by combining the baseURL with the requestedURL,
	 * only when the requestedURL is not already an absolute URL.
	 * If the requestURL is absolute, this function returns the requestedURL untouched.
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} requestedURL Absolute or relative URL to combine
	 * @returns {string} The combined full path
	 */
	var buildFullPath = function buildFullPath(baseURL, requestedURL) {
	  if (baseURL && !isAbsoluteURL(requestedURL)) {
	    return combineURLs(baseURL, requestedURL);
	  }
	  return requestedURL;
	};

	// Headers whose duplicates are ignored by node
	// c.f. https://nodejs.org/api/http.html#http_message_headers
	var ignoreDuplicateOf = [
	  'age', 'authorization', 'content-length', 'content-type', 'etag',
	  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
	  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
	  'referer', 'retry-after', 'user-agent'
	];

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	var parseHeaders = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;

	  if (!headers) { return parsed; }

	  utils.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    val = utils.trim(line.substr(i + 1));

	    if (key) {
	      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
	        return;
	      }
	      if (key === 'set-cookie') {
	        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
	      } else {
	        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	      }
	    }
	  });

	  return parsed;
	};

	var isURLSameOrigin = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs have full support of the APIs needed to test
	  // whether the request URL is of the same origin as current location.
	    (function standardBrowserEnv() {
	      var msie = /(msie|trident)/i.test(navigator.userAgent);
	      var urlParsingNode = document.createElement('a');
	      var originURL;

	      /**
	    * Parse a URL to discover it's components
	    *
	    * @param {String} url The URL to be parsed
	    * @returns {Object}
	    */
	      function resolveURL(url) {
	        var href = url;

	        if (msie) {
	        // IE needs attribute set twice to normalize properties
	          urlParsingNode.setAttribute('href', href);
	          href = urlParsingNode.href;
	        }

	        urlParsingNode.setAttribute('href', href);

	        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	        return {
	          href: urlParsingNode.href,
	          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	          host: urlParsingNode.host,
	          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	          hostname: urlParsingNode.hostname,
	          port: urlParsingNode.port,
	          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
	            urlParsingNode.pathname :
	            '/' + urlParsingNode.pathname
	        };
	      }

	      originURL = resolveURL(window.location.href);

	      /**
	    * Determine if a URL shares the same origin as the current location
	    *
	    * @param {String} requestURL The URL to test
	    * @returns {boolean} True if URL shares the same origin, otherwise false
	    */
	      return function isURLSameOrigin(requestURL) {
	        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
	        return (parsed.protocol === originURL.protocol &&
	            parsed.host === originURL.host);
	      };
	    })() :

	  // Non standard browser envs (web workers, react-native) lack needed support.
	    (function nonStandardBrowserEnv() {
	      return function isURLSameOrigin() {
	        return true;
	      };
	    })()
	);

	var cookies = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs support document.cookie
	    (function standardBrowserEnv() {
	      return {
	        write: function write(name, value, expires, path, domain, secure) {
	          var cookie = [];
	          cookie.push(name + '=' + encodeURIComponent(value));

	          if (utils.isNumber(expires)) {
	            cookie.push('expires=' + new Date(expires).toGMTString());
	          }

	          if (utils.isString(path)) {
	            cookie.push('path=' + path);
	          }

	          if (utils.isString(domain)) {
	            cookie.push('domain=' + domain);
	          }

	          if (secure === true) {
	            cookie.push('secure');
	          }

	          document.cookie = cookie.join('; ');
	        },

	        read: function read(name) {
	          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	          return (match ? decodeURIComponent(match[3]) : null);
	        },

	        remove: function remove(name) {
	          this.write(name, '', Date.now() - 86400000);
	        }
	      };
	    })() :

	  // Non standard browser env (web workers, react-native) lack needed support.
	    (function nonStandardBrowserEnv() {
	      return {
	        write: function write() {},
	        read: function read() { return null; },
	        remove: function remove() {}
	      };
	    })()
	);

	var xhr = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;

	    if (utils.isFormData(requestData)) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }

	    var request = new XMLHttpRequest();

	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }

	    var fullPath = buildFullPath(config.baseURL, config.url);
	    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

	    // Set the request timeout in MS
	    request.timeout = config.timeout;

	    // Listen for ready state
	    request.onreadystatechange = function handleLoad() {
	      if (!request || request.readyState !== 4) {
	        return;
	      }

	      // The request errored out and we didn't get a response, this will be
	      // handled by onerror instead
	      // With one exception: request that using file: protocol, most browsers
	      // will return status as 0 even though it's a successful request
	      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	        return;
	      }

	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
	      var response = {
	        data: responseData,
	        status: request.status,
	        statusText: request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };

	      settle(resolve, reject, response);

	      // Clean up request
	      request = null;
	    };

	    // Handle browser request cancellation (as opposed to a manual cancellation)
	    request.onabort = function handleAbort() {
	      if (!request) {
	        return;
	      }

	      reject(createError('Request aborted', config, 'ECONNABORTED', request));

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(createError('Network Error', config, null, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
	      if (config.timeoutErrorMessage) {
	        timeoutErrorMessage = config.timeoutErrorMessage;
	      }
	      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
	        request));

	      // Clean up request
	      request = null;
	    };

	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils.isStandardBrowserEnv()) {
	      var cookies$1 = cookies;

	      // Add xsrf header
	      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
	        cookies$1.read(config.xsrfCookieName) :
	        undefined;

	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }

	    // Add withCredentials to request if needed
	    if (!utils.isUndefined(config.withCredentials)) {
	      request.withCredentials = !!config.withCredentials;
	    }

	    // Add responseType to request if needed
	    if (config.responseType) {
	      try {
	        request.responseType = config.responseType;
	      } catch (e) {
	        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
	        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
	        if (config.responseType !== 'json') {
	          throw e;
	        }
	      }
	    }

	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    }

	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }

	    if (config.cancelToken) {
	      // Handle cancellation
	      config.cancelToken.promise.then(function onCanceled(cancel) {
	        if (!request) {
	          return;
	        }

	        request.abort();
	        reject(cancel);
	        // Clean up request
	        request = null;
	      });
	    }

	    if (requestData === undefined) {
	      requestData = null;
	    }

	    // Send the request
	    request.send(requestData);
	  });
	};

	var DEFAULT_CONTENT_TYPE = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};

	function setContentTypeIfUnset(headers, value) {
	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}

	function getDefaultAdapter() {
	  var adapter;
	  if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = xhr;
	  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
	    // For node use HTTP adapter
	    adapter = xhr;
	  }
	  return adapter;
	}

	var defaults = {
	  adapter: getDefaultAdapter(),

	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName(headers, 'Accept');
	    normalizeHeaderName(headers, 'Content-Type');
	    if (utils.isFormData(data) ||
	      utils.isArrayBuffer(data) ||
	      utils.isBuffer(data) ||
	      utils.isStream(data) ||
	      utils.isFile(data) ||
	      utils.isBlob(data)
	    ) {
	      return data;
	    }
	    if (utils.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils.isURLSearchParams(data)) {
	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }
	    if (utils.isObject(data)) {
	      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
	      return JSON.stringify(data);
	    }
	    return data;
	  }],

	  transformResponse: [function transformResponse(data) {
	    /*eslint no-param-reassign:0*/
	    if (typeof data === 'string') {
	      try {
	        data = JSON.parse(data);
	      } catch (e) { /* Ignore */ }
	    }
	    return data;
	  }],

	  /**
	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
	   * timeout is not created.
	   */
	  timeout: 0,

	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',

	  maxContentLength: -1,

	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  }
	};

	defaults.headers = {
	  common: {
	    'Accept': 'application/json, text/plain, */*'
	  }
	};

	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  defaults.headers[method] = {};
	});

	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
	});

	var defaults_1 = defaults;

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	}

	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */
	var dispatchRequest = function dispatchRequest(config) {
	  throwIfCancellationRequested(config);

	  // Ensure headers exist
	  config.headers = config.headers || {};

	  // Transform request data
	  config.data = transformData(
	    config.data,
	    config.headers,
	    config.transformRequest
	  );

	  // Flatten headers
	  config.headers = utils.merge(
	    config.headers.common || {},
	    config.headers[config.method] || {},
	    config.headers
	  );

	  utils.forEach(
	    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
	    function cleanHeaderConfig(method) {
	      delete config.headers[method];
	    }
	  );

	  var adapter = config.adapter || defaults_1.adapter;

	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);

	    // Transform response data
	    response.data = transformData(
	      response.data,
	      response.headers,
	      config.transformResponse
	    );

	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);

	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData(
	          reason.response.data,
	          reason.response.headers,
	          config.transformResponse
	        );
	      }
	    }

	    return Promise.reject(reason);
	  });
	};

	/**
	 * Config-specific merge-function which creates a new config-object
	 * by merging two configuration objects together.
	 *
	 * @param {Object} config1
	 * @param {Object} config2
	 * @returns {Object} New object resulting from merging config2 to config1
	 */
	var mergeConfig = function mergeConfig(config1, config2) {
	  // eslint-disable-next-line no-param-reassign
	  config2 = config2 || {};
	  var config = {};

	  var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];
	  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];
	  var defaultToConfig2Keys = [
	    'baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer',
	    'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
	    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress',
	    'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent',
	    'httpsAgent', 'cancelToken', 'socketPath'
	  ];

	  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
	    if (typeof config2[prop] !== 'undefined') {
	      config[prop] = config2[prop];
	    }
	  });

	  utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
	    if (utils.isObject(config2[prop])) {
	      config[prop] = utils.deepMerge(config1[prop], config2[prop]);
	    } else if (typeof config2[prop] !== 'undefined') {
	      config[prop] = config2[prop];
	    } else if (utils.isObject(config1[prop])) {
	      config[prop] = utils.deepMerge(config1[prop]);
	    } else if (typeof config1[prop] !== 'undefined') {
	      config[prop] = config1[prop];
	    }
	  });

	  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
	    if (typeof config2[prop] !== 'undefined') {
	      config[prop] = config2[prop];
	    } else if (typeof config1[prop] !== 'undefined') {
	      config[prop] = config1[prop];
	    }
	  });

	  var axiosKeys = valueFromConfig2Keys
	    .concat(mergeDeepPropertiesKeys)
	    .concat(defaultToConfig2Keys);

	  var otherKeys = Object
	    .keys(config2)
	    .filter(function filterAxiosKeys(key) {
	      return axiosKeys.indexOf(key) === -1;
	    });

	  utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
	    if (typeof config2[prop] !== 'undefined') {
	      config[prop] = config2[prop];
	    } else if (typeof config1[prop] !== 'undefined') {
	      config[prop] = config1[prop];
	    }
	  });

	  return config;
	};

	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 */
	function Axios(instanceConfig) {
	  this.defaults = instanceConfig;
	  this.interceptors = {
	    request: new InterceptorManager_1(),
	    response: new InterceptorManager_1()
	  };
	}

	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */
	Axios.prototype.request = function request(config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof config === 'string') {
	    config = arguments[1] || {};
	    config.url = arguments[0];
	  } else {
	    config = config || {};
	  }

	  config = mergeConfig(this.defaults, config);

	  // Set config.method
	  if (config.method) {
	    config.method = config.method.toLowerCase();
	  } else if (this.defaults.method) {
	    config.method = this.defaults.method.toLowerCase();
	  } else {
	    config.method = 'get';
	  }

	  // Hook up interceptors middleware
	  var chain = [dispatchRequest, undefined];
	  var promise = Promise.resolve(config);

	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    chain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });

	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    chain.push(interceptor.fulfilled, interceptor.rejected);
	  });

	  while (chain.length) {
	    promise = promise.then(chain.shift(), chain.shift());
	  }

	  return promise;
	};

	Axios.prototype.getUri = function getUri(config) {
	  config = mergeConfig(this.defaults, config);
	  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
	};

	// Provide aliases for supported request methods
	utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url
	    }));
	  };
	});

	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, data, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url,
	      data: data
	    }));
	  };
	});

	var Axios_1 = Axios;

	/**
	 * A `Cancel` is an object that is thrown when an operation is canceled.
	 *
	 * @class
	 * @param {string=} message The message.
	 */
	function Cancel(message) {
	  this.message = message;
	}

	Cancel.prototype.toString = function toString() {
	  return 'Cancel' + (this.message ? ': ' + this.message : '');
	};

	Cancel.prototype.__CANCEL__ = true;

	var Cancel_1 = Cancel;

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @class
	 * @param {Function} executor The executor function.
	 */
	function CancelToken(executor) {
	  if (typeof executor !== 'function') {
	    throw new TypeError('executor must be a function.');
	  }

	  var resolvePromise;
	  this.promise = new Promise(function promiseExecutor(resolve) {
	    resolvePromise = resolve;
	  });

	  var token = this;
	  executor(function cancel(message) {
	    if (token.reason) {
	      // Cancellation has already been requested
	      return;
	    }

	    token.reason = new Cancel_1(message);
	    resolvePromise(token.reason);
	  });
	}

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
	  if (this.reason) {
	    throw this.reason;
	  }
	};

	/**
	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	 * cancels the `CancelToken`.
	 */
	CancelToken.source = function source() {
	  var cancel;
	  var token = new CancelToken(function executor(c) {
	    cancel = c;
	  });
	  return {
	    token: token,
	    cancel: cancel
	  };
	};

	var CancelToken_1 = CancelToken;

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */
	var spread = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};

	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  var context = new Axios_1(defaultConfig);
	  var instance = bind(Axios_1.prototype.request, context);

	  // Copy axios.prototype to instance
	  utils.extend(instance, Axios_1.prototype, context);

	  // Copy context to instance
	  utils.extend(instance, context);

	  return instance;
	}

	// Create the default instance to be exported
	var axios = createInstance(defaults_1);

	// Expose Axios class to allow class inheritance
	axios.Axios = Axios_1;

	// Factory for creating new instances
	axios.create = function create(instanceConfig) {
	  return createInstance(mergeConfig(axios.defaults, instanceConfig));
	};

	// Expose Cancel & CancelToken
	axios.Cancel = Cancel_1;
	axios.CancelToken = CancelToken_1;
	axios.isCancel = isCancel;

	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = spread;

	var axios_1 = axios;

	// Allow use of default import syntax in TypeScript
	var _default = axios;
	axios_1.default = _default;

	var axios$1 = axios_1;

	var setPrototypeOf = createCommonjsModule(function (module) {
	function _setPrototypeOf(o, p) {
	  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	module.exports = _setPrototypeOf;
	});

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) setPrototypeOf(subClass, superClass);
	}

	var inherits = _inherits;

	var _typeof_1 = createCommonjsModule(function (module) {
	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    module.exports = _typeof = function _typeof(obj) {
	      return typeof obj;
	    };
	  } else {
	    module.exports = _typeof = function _typeof(obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	module.exports = _typeof;
	});

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	var assertThisInitialized = _assertThisInitialized;

	function _possibleConstructorReturn(self, call) {
	  if (call && (_typeof_1(call) === "object" || typeof call === "function")) {
	    return call;
	  }

	  return assertThisInitialized(self);
	}

	var possibleConstructorReturn = _possibleConstructorReturn;

	var getPrototypeOf = createCommonjsModule(function (module) {
	function _getPrototypeOf(o) {
	  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	module.exports = _getPrototypeOf;
	});

	function _superPropBase(object, property) {
	  while (!Object.prototype.hasOwnProperty.call(object, property)) {
	    object = getPrototypeOf(object);
	    if (object === null) break;
	  }

	  return object;
	}

	var superPropBase = _superPropBase;

	var get$1 = createCommonjsModule(function (module) {
	function _get(target, property, receiver) {
	  if (typeof Reflect !== "undefined" && Reflect.get) {
	    module.exports = _get = Reflect.get;
	  } else {
	    module.exports = _get = function _get(target, property, receiver) {
	      var base = superPropBase(target, property);
	      if (!base) return;
	      var desc = Object.getOwnPropertyDescriptor(base, property);

	      if (desc.get) {
	        return desc.get.call(receiver);
	      }

	      return desc.value;
	    };
	  }

	  return _get(target, property, receiver || target);
	}

	module.exports = _get;
	});

	var Char = {
	  ANCHOR: '&',
	  COMMENT: '#',
	  TAG: '!',
	  DIRECTIVES_END: '-',
	  DOCUMENT_END: '.'
	};
	var Type = {
	  ALIAS: 'ALIAS',
	  BLANK_LINE: 'BLANK_LINE',
	  BLOCK_FOLDED: 'BLOCK_FOLDED',
	  BLOCK_LITERAL: 'BLOCK_LITERAL',
	  COMMENT: 'COMMENT',
	  DIRECTIVE: 'DIRECTIVE',
	  DOCUMENT: 'DOCUMENT',
	  FLOW_MAP: 'FLOW_MAP',
	  FLOW_SEQ: 'FLOW_SEQ',
	  MAP: 'MAP',
	  MAP_KEY: 'MAP_KEY',
	  MAP_VALUE: 'MAP_VALUE',
	  PLAIN: 'PLAIN',
	  QUOTE_DOUBLE: 'QUOTE_DOUBLE',
	  QUOTE_SINGLE: 'QUOTE_SINGLE',
	  SEQ: 'SEQ',
	  SEQ_ITEM: 'SEQ_ITEM'
	};

	function _isNativeFunction(fn) {
	  return Function.toString.call(fn).indexOf("[native code]") !== -1;
	}

	var isNativeFunction = _isNativeFunction;

	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;

	  try {
	    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	var isNativeReflectConstruct = _isNativeReflectConstruct;

	var construct = createCommonjsModule(function (module) {
	function _construct(Parent, args, Class) {
	  if (isNativeReflectConstruct()) {
	    module.exports = _construct = Reflect.construct;
	  } else {
	    module.exports = _construct = function _construct(Parent, args, Class) {
	      var a = [null];
	      a.push.apply(a, args);
	      var Constructor = Function.bind.apply(Parent, a);
	      var instance = new Constructor();
	      if (Class) setPrototypeOf(instance, Class.prototype);
	      return instance;
	    };
	  }

	  return _construct.apply(null, arguments);
	}

	module.exports = _construct;
	});

	var wrapNativeSuper = createCommonjsModule(function (module) {
	function _wrapNativeSuper(Class) {
	  var _cache = typeof Map === "function" ? new Map() : undefined;

	  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
	    if (Class === null || !isNativeFunction(Class)) return Class;

	    if (typeof Class !== "function") {
	      throw new TypeError("Super expression must either be null or a function");
	    }

	    if (typeof _cache !== "undefined") {
	      if (_cache.has(Class)) return _cache.get(Class);

	      _cache.set(Class, Wrapper);
	    }

	    function Wrapper() {
	      return construct(Class, arguments, getPrototypeOf(this).constructor);
	    }

	    Wrapper.prototype = Object.create(Class.prototype, {
	      constructor: {
	        value: Wrapper,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    return setPrototypeOf(Wrapper, Class);
	  };

	  return _wrapNativeSuper(Class);
	}

	module.exports = _wrapNativeSuper;
	});

	function findLineStarts(src) {
	  var ls = [0];
	  var offset = src.indexOf('\n');

	  while (offset !== -1) {
	    offset += 1;
	    ls.push(offset);
	    offset = src.indexOf('\n', offset);
	  }

	  return ls;
	}

	function getSrcInfo(cst) {
	  var lineStarts, src;

	  if (typeof cst === 'string') {
	    lineStarts = findLineStarts(cst);
	    src = cst;
	  } else {
	    if (Array.isArray(cst)) cst = cst[0];

	    if (cst && cst.context) {
	      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);
	      lineStarts = cst.lineStarts;
	      src = cst.context.src;
	    }
	  }

	  return {
	    lineStarts: lineStarts,
	    src: src
	  };
	}
	/**
	 * @typedef {Object} LinePos - One-indexed position in the source
	 * @property {number} line
	 * @property {number} col
	 */

	/**
	 * Determine the line/col position matching a character offset.
	 *
	 * Accepts a source string or a CST document as the second parameter. With
	 * the latter, starting indices for lines are cached in the document as
	 * `lineStarts: number[]`.
	 *
	 * Returns a one-indexed `{ line, col }` location if found, or
	 * `undefined` otherwise.
	 *
	 * @param {number} offset
	 * @param {string|Document|Document[]} cst
	 * @returns {?LinePos}
	 */


	function getLinePos(offset, cst) {
	  if (typeof offset !== 'number' || offset < 0) return null;

	  var _getSrcInfo = getSrcInfo(cst),
	      lineStarts = _getSrcInfo.lineStarts,
	      src = _getSrcInfo.src;

	  if (!lineStarts || !src || offset > src.length) return null;

	  for (var i = 0; i < lineStarts.length; ++i) {
	    var start = lineStarts[i];

	    if (offset < start) {
	      return {
	        line: i,
	        col: offset - lineStarts[i - 1] + 1
	      };
	    }

	    if (offset === start) return {
	      line: i + 1,
	      col: 1
	    };
	  }

	  var line = lineStarts.length;
	  return {
	    line: line,
	    col: offset - lineStarts[line - 1] + 1
	  };
	}
	/**
	 * Get a specified line from the source.
	 *
	 * Accepts a source string or a CST document as the second parameter. With
	 * the latter, starting indices for lines are cached in the document as
	 * `lineStarts: number[]`.
	 *
	 * Returns the line as a string if found, or `null` otherwise.
	 *
	 * @param {number} line One-indexed line number
	 * @param {string|Document|Document[]} cst
	 * @returns {?string}
	 */

	function getLine(line, cst) {
	  var _getSrcInfo2 = getSrcInfo(cst),
	      lineStarts = _getSrcInfo2.lineStarts,
	      src = _getSrcInfo2.src;

	  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;
	  var start = lineStarts[line - 1];
	  var end = lineStarts[line]; // undefined for last line; that's ok for slice()

	  while (end && end > start && src[end - 1] === '\n') {
	    --end;
	  }

	  return src.slice(start, end);
	}
	/**
	 * Pretty-print the starting line from the source indicated by the range `pos`
	 *
	 * Trims output to `maxWidth` chars while keeping the starting column visible,
	 * using `…` at either end to indicate dropped characters.
	 *
	 * Returns a two-line string (or `null`) with `\n` as separator; the second line
	 * will hold appropriately indented `^` marks indicating the column range.
	 *
	 * @param {Object} pos
	 * @param {LinePos} pos.start
	 * @param {LinePos} [pos.end]
	 * @param {string|Document|Document[]*} cst
	 * @param {number} [maxWidth=80]
	 * @returns {?string}
	 */

	function getPrettyContext(_ref, cst) {
	  var start = _ref.start,
	      end = _ref.end;
	  var maxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 80;
	  var src = getLine(start.line, cst);
	  if (!src) return null;
	  var col = start.col;

	  if (src.length > maxWidth) {
	    if (col <= maxWidth - 10) {
	      src = src.substr(0, maxWidth - 1) + '…';
	    } else {
	      var halfWidth = Math.round(maxWidth / 2);
	      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';
	      col -= src.length - maxWidth;
	      src = '…' + src.substr(1 - maxWidth);
	    }
	  }

	  var errLen = 1;
	  var errEnd = '';

	  if (end) {
	    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
	      errLen = end.col - start.col;
	    } else {
	      errLen = Math.min(src.length + 1, maxWidth) - col;
	      errEnd = '…';
	    }
	  }

	  var offset = col > 1 ? ' '.repeat(col - 1) : '';
	  var err = '^'.repeat(errLen);
	  return "".concat(src, "\n").concat(offset).concat(err).concat(errEnd);
	}

	var Range = /*#__PURE__*/function () {
	  createClass(Range, null, [{
	    key: "copy",
	    value: function copy(orig) {
	      return new Range(orig.start, orig.end);
	    }
	  }]);

	  function Range(start, end) {
	    classCallCheck(this, Range);

	    this.start = start;
	    this.end = end || start;
	  }

	  createClass(Range, [{
	    key: "isEmpty",
	    value: function isEmpty() {
	      return typeof this.start !== 'number' || !this.end || this.end <= this.start;
	    }
	    /**
	     * Set `origStart` and `origEnd` to point to the original source range for
	     * this node, which may differ due to dropped CR characters.
	     *
	     * @param {number[]} cr - Positions of dropped CR characters
	     * @param {number} offset - Starting index of `cr` from the last call
	     * @returns {number} - The next offset, matching the one found for `origStart`
	     */

	  }, {
	    key: "setOrigRange",
	    value: function setOrigRange(cr, offset) {
	      var start = this.start,
	          end = this.end;

	      if (cr.length === 0 || end <= cr[0]) {
	        this.origStart = start;
	        this.origEnd = end;
	        return offset;
	      }

	      var i = offset;

	      while (i < cr.length) {
	        if (cr[i] > start) break;else ++i;
	      }

	      this.origStart = start + i;
	      var nextOffset = i;

	      while (i < cr.length) {
	        // if end was at \n, it should now be at \r
	        if (cr[i] >= end) break;else ++i;
	      }

	      this.origEnd = end + i;
	      return nextOffset;
	    }
	  }]);

	  return Range;
	}();

	/** Root class of all nodes */

	var Node = /*#__PURE__*/function () {
	  createClass(Node, null, [{
	    key: "addStringTerminator",
	    value: function addStringTerminator(src, offset, str) {
	      if (str[str.length - 1] === '\n') return str;
	      var next = Node.endOfWhiteSpace(src, offset);
	      return next >= src.length || src[next] === '\n' ? str + '\n' : str;
	    } // ^(---|...)

	  }, {
	    key: "atDocumentBoundary",
	    value: function atDocumentBoundary(src, offset, sep) {
	      var ch0 = src[offset];
	      if (!ch0) return true;
	      var prev = src[offset - 1];
	      if (prev && prev !== '\n') return false;

	      if (sep) {
	        if (ch0 !== sep) return false;
	      } else {
	        if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;
	      }

	      var ch1 = src[offset + 1];
	      var ch2 = src[offset + 2];
	      if (ch1 !== ch0 || ch2 !== ch0) return false;
	      var ch3 = src[offset + 3];
	      return !ch3 || ch3 === '\n' || ch3 === '\t' || ch3 === ' ';
	    }
	  }, {
	    key: "endOfIdentifier",
	    value: function endOfIdentifier(src, offset) {
	      var ch = src[offset];
	      var isVerbatim = ch === '<';
	      var notOk = isVerbatim ? ['\n', '\t', ' ', '>'] : ['\n', '\t', ' ', '[', ']', '{', '}', ','];

	      while (ch && notOk.indexOf(ch) === -1) {
	        ch = src[offset += 1];
	      }

	      if (isVerbatim && ch === '>') offset += 1;
	      return offset;
	    }
	  }, {
	    key: "endOfIndent",
	    value: function endOfIndent(src, offset) {
	      var ch = src[offset];

	      while (ch === ' ') {
	        ch = src[offset += 1];
	      }

	      return offset;
	    }
	  }, {
	    key: "endOfLine",
	    value: function endOfLine(src, offset) {
	      var ch = src[offset];

	      while (ch && ch !== '\n') {
	        ch = src[offset += 1];
	      }

	      return offset;
	    }
	  }, {
	    key: "endOfWhiteSpace",
	    value: function endOfWhiteSpace(src, offset) {
	      var ch = src[offset];

	      while (ch === '\t' || ch === ' ') {
	        ch = src[offset += 1];
	      }

	      return offset;
	    }
	  }, {
	    key: "startOfLine",
	    value: function startOfLine(src, offset) {
	      var ch = src[offset - 1];
	      if (ch === '\n') return offset;

	      while (ch && ch !== '\n') {
	        ch = src[offset -= 1];
	      }

	      return offset + 1;
	    }
	    /**
	     * End of indentation, or null if the line's indent level is not more
	     * than `indent`
	     *
	     * @param {string} src
	     * @param {number} indent
	     * @param {number} lineStart
	     * @returns {?number}
	     */

	  }, {
	    key: "endOfBlockIndent",
	    value: function endOfBlockIndent(src, indent, lineStart) {
	      var inEnd = Node.endOfIndent(src, lineStart);

	      if (inEnd > lineStart + indent) {
	        return inEnd;
	      } else {
	        var wsEnd = Node.endOfWhiteSpace(src, inEnd);
	        var ch = src[wsEnd];
	        if (!ch || ch === '\n') return wsEnd;
	      }

	      return null;
	    }
	  }, {
	    key: "atBlank",
	    value: function atBlank(src, offset, endAsBlank) {
	      var ch = src[offset];
	      return ch === '\n' || ch === '\t' || ch === ' ' || endAsBlank && !ch;
	    }
	  }, {
	    key: "nextNodeIsIndented",
	    value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
	      if (!ch || indentDiff < 0) return false;
	      if (indentDiff > 0) return true;
	      return indicatorAsIndent && ch === '-';
	    } // should be at line or string end, or at next non-whitespace char

	  }, {
	    key: "normalizeOffset",
	    value: function normalizeOffset(src, offset) {
	      var ch = src[offset];
	      return !ch ? offset : ch !== '\n' && src[offset - 1] === '\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);
	    } // fold single newline into space, multiple newlines to N - 1 newlines
	    // presumes src[offset] === '\n'

	  }, {
	    key: "foldNewline",
	    value: function foldNewline(src, offset, indent) {
	      var inCount = 0;
	      var error = false;
	      var fold = '';
	      var ch = src[offset + 1];

	      while (ch === ' ' || ch === '\t' || ch === '\n') {
	        switch (ch) {
	          case '\n':
	            inCount = 0;
	            offset += 1;
	            fold += '\n';
	            break;

	          case '\t':
	            if (inCount <= indent) error = true;
	            offset = Node.endOfWhiteSpace(src, offset + 2) - 1;
	            break;

	          case ' ':
	            inCount += 1;
	            offset += 1;
	            break;
	        }

	        ch = src[offset + 1];
	      }

	      if (!fold) fold = ' ';
	      if (ch && inCount <= indent) error = true;
	      return {
	        fold: fold,
	        offset: offset,
	        error: error
	      };
	    }
	  }]);

	  function Node(type, props, context) {
	    classCallCheck(this, Node);

	    Object.defineProperty(this, 'context', {
	      value: context || null,
	      writable: true
	    });
	    this.error = null;
	    this.range = null;
	    this.valueRange = null;
	    this.props = props || [];
	    this.type = type;
	    this.value = null;
	  }

	  createClass(Node, [{
	    key: "getPropValue",
	    value: function getPropValue(idx, key, skipKey) {
	      if (!this.context) return null;
	      var src = this.context.src;
	      var prop = this.props[idx];
	      return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
	    }
	  }, {
	    key: "commentHasRequiredWhitespace",
	    value: function commentHasRequiredWhitespace(start) {
	      var src = this.context.src;
	      if (this.header && start === this.header.end) return false;
	      if (!this.valueRange) return false;
	      var end = this.valueRange.end;
	      return start !== end || Node.atBlank(src, end - 1);
	    }
	  }, {
	    key: "parseComment",
	    value: function parseComment(start) {
	      var src = this.context.src;

	      if (src[start] === Char.COMMENT) {
	        var end = Node.endOfLine(src, start + 1);
	        var commentRange = new Range(start, end);
	        this.props.push(commentRange);
	        return end;
	      }

	      return start;
	    }
	    /**
	     * Populates the `origStart` and `origEnd` values of all ranges for this
	     * node. Extended by child classes to handle descendant nodes.
	     *
	     * @param {number[]} cr - Positions of dropped CR characters
	     * @param {number} offset - Starting index of `cr` from the last call
	     * @returns {number} - The next offset, matching the one found for `origStart`
	     */

	  }, {
	    key: "setOrigRanges",
	    value: function setOrigRanges(cr, offset) {
	      if (this.range) offset = this.range.setOrigRange(cr, offset);
	      if (this.valueRange) this.valueRange.setOrigRange(cr, offset);
	      this.props.forEach(function (prop) {
	        return prop.setOrigRange(cr, offset);
	      });
	      return offset;
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      var src = this.context.src,
	          range = this.range,
	          value = this.value;
	      if (value != null) return value;
	      var str = src.slice(range.start, range.end);
	      return Node.addStringTerminator(src, range.end, str);
	    }
	  }, {
	    key: "anchor",
	    get: function get() {
	      for (var i = 0; i < this.props.length; ++i) {
	        var anchor = this.getPropValue(i, Char.ANCHOR, true);
	        if (anchor != null) return anchor;
	      }

	      return null;
	    }
	  }, {
	    key: "comment",
	    get: function get() {
	      var comments = [];

	      for (var i = 0; i < this.props.length; ++i) {
	        var comment = this.getPropValue(i, Char.COMMENT, true);
	        if (comment != null) comments.push(comment);
	      }

	      return comments.length > 0 ? comments.join('\n') : null;
	    }
	  }, {
	    key: "hasComment",
	    get: function get() {
	      if (this.context) {
	        var src = this.context.src;

	        for (var i = 0; i < this.props.length; ++i) {
	          if (src[this.props[i].start] === Char.COMMENT) return true;
	        }
	      }

	      return false;
	    }
	  }, {
	    key: "hasProps",
	    get: function get() {
	      if (this.context) {
	        var src = this.context.src;

	        for (var i = 0; i < this.props.length; ++i) {
	          if (src[this.props[i].start] !== Char.COMMENT) return true;
	        }
	      }

	      return false;
	    }
	  }, {
	    key: "includesTrailingLines",
	    get: function get() {
	      return false;
	    }
	  }, {
	    key: "jsonLike",
	    get: function get() {
	      var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
	      return jsonLikeTypes.indexOf(this.type) !== -1;
	    }
	  }, {
	    key: "rangeAsLinePos",
	    get: function get() {
	      if (!this.range || !this.context) return undefined;
	      var start = getLinePos(this.range.start, this.context.root);
	      if (!start) return undefined;
	      var end = getLinePos(this.range.end, this.context.root);
	      return {
	        start: start,
	        end: end
	      };
	    }
	  }, {
	    key: "rawValue",
	    get: function get() {
	      if (!this.valueRange || !this.context) return null;
	      var _this$valueRange = this.valueRange,
	          start = _this$valueRange.start,
	          end = _this$valueRange.end;
	      return this.context.src.slice(start, end);
	    }
	  }, {
	    key: "tag",
	    get: function get() {
	      for (var i = 0; i < this.props.length; ++i) {
	        var tag = this.getPropValue(i, Char.TAG, false);

	        if (tag != null) {
	          if (tag[1] === '<') {
	            return {
	              verbatim: tag.slice(2, -1)
	            };
	          } else {
	            // eslint-disable-next-line no-unused-vars
	            var _tag$match = tag.match(/^(.*!)([^!]*)$/),
	                _tag$match2 = slicedToArray(_tag$match, 3),
	                _ = _tag$match2[0],
	                handle = _tag$match2[1],
	                suffix = _tag$match2[2];

	            return {
	              handle: handle,
	              suffix: suffix
	            };
	          }
	        }
	      }

	      return null;
	    }
	  }, {
	    key: "valueRangeContainsNewline",
	    get: function get() {
	      if (!this.valueRange || !this.context) return false;
	      var _this$valueRange2 = this.valueRange,
	          start = _this$valueRange2.start,
	          end = _this$valueRange2.end;
	      var src = this.context.src;

	      for (var i = start; i < end; ++i) {
	        if (src[i] === '\n') return true;
	      }

	      return false;
	    }
	  }]);

	  return Node;
	}();

	function _createSuper(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$1()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var YAMLError = /*#__PURE__*/function (_Error) {
	  inherits(YAMLError, _Error);

	  var _super = _createSuper(YAMLError);

	  function YAMLError(name, source, message) {
	    var _this;

	    classCallCheck(this, YAMLError);

	    if (!message || !(source instanceof Node)) throw new Error("Invalid arguments for new ".concat(name));
	    _this = _super.call(this);
	    _this.name = name;
	    _this.message = message;
	    _this.source = source;
	    return _this;
	  }

	  createClass(YAMLError, [{
	    key: "makePretty",
	    value: function makePretty() {
	      if (!this.source) return;
	      this.nodeType = this.source.type;
	      var cst = this.source.context && this.source.context.root;

	      if (typeof this.offset === 'number') {
	        this.range = new Range(this.offset, this.offset + 1);
	        var start = cst && getLinePos(this.offset, cst);

	        if (start) {
	          var end = {
	            line: start.line,
	            col: start.col + 1
	          };
	          this.linePos = {
	            start: start,
	            end: end
	          };
	        }

	        delete this.offset;
	      } else {
	        this.range = this.source.range;
	        this.linePos = this.source.rangeAsLinePos;
	      }

	      if (this.linePos) {
	        var _this$linePos$start = this.linePos.start,
	            line = _this$linePos$start.line,
	            col = _this$linePos$start.col;
	        this.message += " at line ".concat(line, ", column ").concat(col);
	        var ctx = cst && getPrettyContext(this.linePos, cst);
	        if (ctx) this.message += ":\n\n".concat(ctx, "\n");
	      }

	      delete this.source;
	    }
	  }]);

	  return YAMLError;
	}( /*#__PURE__*/wrapNativeSuper(Error));
	var YAMLReferenceError = /*#__PURE__*/function (_YAMLError) {
	  inherits(YAMLReferenceError, _YAMLError);

	  var _super2 = _createSuper(YAMLReferenceError);

	  function YAMLReferenceError(source, message) {
	    classCallCheck(this, YAMLReferenceError);

	    return _super2.call(this, 'YAMLReferenceError', source, message);
	  }

	  return YAMLReferenceError;
	}(YAMLError);
	var YAMLSemanticError = /*#__PURE__*/function (_YAMLError2) {
	  inherits(YAMLSemanticError, _YAMLError2);

	  var _super3 = _createSuper(YAMLSemanticError);

	  function YAMLSemanticError(source, message) {
	    classCallCheck(this, YAMLSemanticError);

	    return _super3.call(this, 'YAMLSemanticError', source, message);
	  }

	  return YAMLSemanticError;
	}(YAMLError);
	var YAMLSyntaxError = /*#__PURE__*/function (_YAMLError3) {
	  inherits(YAMLSyntaxError, _YAMLError3);

	  var _super4 = _createSuper(YAMLSyntaxError);

	  function YAMLSyntaxError(source, message) {
	    classCallCheck(this, YAMLSyntaxError);

	    return _super4.call(this, 'YAMLSyntaxError', source, message);
	  }

	  return YAMLSyntaxError;
	}(YAMLError);
	var YAMLWarning = /*#__PURE__*/function (_YAMLError4) {
	  inherits(YAMLWarning, _YAMLError4);

	  var _super5 = _createSuper(YAMLWarning);

	  function YAMLWarning(source, message) {
	    classCallCheck(this, YAMLWarning);

	    return _super5.call(this, 'YAMLWarning', source, message);
	  }

	  return YAMLWarning;
	}(YAMLError);

	function _createSuper$1(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$2()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var BlankLine = /*#__PURE__*/function (_Node) {
	  inherits(BlankLine, _Node);

	  var _super = _createSuper$1(BlankLine);

	  function BlankLine() {
	    classCallCheck(this, BlankLine);

	    return _super.call(this, Type.BLANK_LINE);
	  }
	  /* istanbul ignore next */


	  createClass(BlankLine, [{
	    key: "parse",

	    /**
	     * Parses a blank line from the source
	     *
	     * @param {ParseContext} context
	     * @param {number} start - Index of first \n character
	     * @returns {number} - Index of the character after this
	     */
	    value: function parse(context, start) {
	      this.context = context;
	      this.range = new Range(start, start + 1);
	      return start + 1;
	    }
	  }, {
	    key: "includesTrailingLines",
	    get: function get() {
	      // This is never called from anywhere, but if it were,
	      // this is the value it should return.
	      return true;
	    }
	  }]);

	  return BlankLine;
	}(Node);

	function _createSuper$2(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$3()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var CollectionItem = /*#__PURE__*/function (_Node) {
	  inherits(CollectionItem, _Node);

	  var _super = _createSuper$2(CollectionItem);

	  function CollectionItem(type, props) {
	    var _this;

	    classCallCheck(this, CollectionItem);

	    _this = _super.call(this, type, props);
	    _this.node = null;
	    return _this;
	  }

	  createClass(CollectionItem, [{
	    key: "parse",

	    /**
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this
	     */
	    value: function parse(context, start) {
	      this.context = context;
	      var parseNode = context.parseNode,
	          src = context.src;
	      var atLineStart = context.atLineStart,
	          lineStart = context.lineStart;
	      if (!atLineStart && this.type === Type.SEQ_ITEM) this.error = new YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');
	      var indent = atLineStart ? start - lineStart : context.indent;
	      var offset = Node.endOfWhiteSpace(src, start + 1);
	      var ch = src[offset];
	      var inlineComment = ch === '#';
	      var comments = [];
	      var blankLine = null;

	      while (ch === '\n' || ch === '#') {
	        if (ch === '#') {
	          var _end = Node.endOfLine(src, offset + 1);

	          comments.push(new Range(offset, _end));
	          offset = _end;
	        } else {
	          atLineStart = true;
	          lineStart = offset + 1;
	          var wsEnd = Node.endOfWhiteSpace(src, lineStart);

	          if (src[wsEnd] === '\n' && comments.length === 0) {
	            blankLine = new BlankLine();
	            lineStart = blankLine.parse({
	              src: src
	            }, lineStart);
	          }

	          offset = Node.endOfIndent(src, lineStart);
	        }

	        ch = src[offset];
	      }

	      if (Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== Type.SEQ_ITEM)) {
	        this.node = parseNode({
	          atLineStart: atLineStart,
	          inCollection: false,
	          indent: indent,
	          lineStart: lineStart,
	          parent: this
	        }, offset);
	      } else if (ch && lineStart > start + 1) {
	        offset = lineStart - 1;
	      }

	      if (this.node) {
	        if (blankLine) {
	          // Only blank lines preceding non-empty nodes are captured. Note that
	          // this means that collection item range start indices do not always
	          // increase monotonically. -- eemeli/yaml#126
	          var items = context.parent.items || context.parent.contents;
	          if (items) items.push(blankLine);
	        }

	        if (comments.length) Array.prototype.push.apply(this.props, comments);
	        offset = this.node.range.end;
	      } else {
	        if (inlineComment) {
	          var c = comments[0];
	          this.props.push(c);
	          offset = c.end;
	        } else {
	          offset = Node.endOfLine(src, start + 1);
	        }
	      }

	      var end = this.node ? this.node.valueRange.end : offset;
	      this.valueRange = new Range(start, end);
	      return offset;
	    }
	  }, {
	    key: "setOrigRanges",
	    value: function setOrigRanges(cr, offset) {
	      offset = get$1(getPrototypeOf(CollectionItem.prototype), "setOrigRanges", this).call(this, cr, offset);
	      return this.node ? this.node.setOrigRanges(cr, offset) : offset;
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      var src = this.context.src,
	          node = this.node,
	          range = this.range,
	          value = this.value;
	      if (value != null) return value;
	      var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);
	      return Node.addStringTerminator(src, range.end, str);
	    }
	  }, {
	    key: "includesTrailingLines",
	    get: function get() {
	      return !!this.node && this.node.includesTrailingLines;
	    }
	  }]);

	  return CollectionItem;
	}(Node);

	function _createSuper$3(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$4()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var Comment = /*#__PURE__*/function (_Node) {
	  inherits(Comment, _Node);

	  var _super = _createSuper$3(Comment);

	  function Comment() {
	    classCallCheck(this, Comment);

	    return _super.call(this, Type.COMMENT);
	  }
	  /**
	   * Parses a comment line from the source
	   *
	   * @param {ParseContext} context
	   * @param {number} start - Index of first character
	   * @returns {number} - Index of the character after this scalar
	   */


	  createClass(Comment, [{
	    key: "parse",
	    value: function parse(context, start) {
	      this.context = context;
	      var offset = this.parseComment(start);
	      this.range = new Range(start, offset);
	      return offset;
	    }
	  }]);

	  return Comment;
	}(Node);

	function _createSuper$4(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$5()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	function grabCollectionEndComments(node) {
	  var cnode = node;

	  while (cnode instanceof CollectionItem) {
	    cnode = cnode.node;
	  }

	  if (!(cnode instanceof Collection)) return null;
	  var len = cnode.items.length;
	  var ci = -1;

	  for (var i = len - 1; i >= 0; --i) {
	    var n = cnode.items[i];

	    if (n.type === Type.COMMENT) {
	      // Keep sufficiently indented comments with preceding node
	      var _n$context = n.context,
	          indent = _n$context.indent,
	          lineStart = _n$context.lineStart;
	      if (indent > 0 && n.range.start >= lineStart + indent) break;
	      ci = i;
	    } else if (n.type === Type.BLANK_LINE) ci = i;else break;
	  }

	  if (ci === -1) return null;
	  var ca = cnode.items.splice(ci, len - ci);
	  var prevEnd = ca[0].range.start;

	  while (true) {
	    cnode.range.end = prevEnd;
	    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;
	    if (cnode === node) break;
	    cnode = cnode.context.parent;
	  }

	  return ca;
	}
	var Collection = /*#__PURE__*/function (_Node) {
	  inherits(Collection, _Node);

	  var _super = _createSuper$4(Collection);

	  createClass(Collection, null, [{
	    key: "nextContentHasIndent",
	    value: function nextContentHasIndent(src, offset, indent) {
	      var lineStart = Node.endOfLine(src, offset) + 1;
	      offset = Node.endOfWhiteSpace(src, lineStart);
	      var ch = src[offset];
	      if (!ch) return false;
	      if (offset >= lineStart + indent) return true;
	      if (ch !== '#' && ch !== '\n') return false;
	      return Collection.nextContentHasIndent(src, offset, indent);
	    }
	  }]);

	  function Collection(firstItem) {
	    var _this;

	    classCallCheck(this, Collection);

	    _this = _super.call(this, firstItem.type === Type.SEQ_ITEM ? Type.SEQ : Type.MAP);

	    for (var i = firstItem.props.length - 1; i >= 0; --i) {
	      if (firstItem.props[i].start < firstItem.context.lineStart) {
	        // props on previous line are assumed by the collection
	        _this.props = firstItem.props.slice(0, i + 1);
	        firstItem.props = firstItem.props.slice(i + 1);
	        var itemRange = firstItem.props[0] || firstItem.valueRange;
	        firstItem.range.start = itemRange.start;
	        break;
	      }
	    }

	    _this.items = [firstItem];
	    var ec = grabCollectionEndComments(firstItem);
	    if (ec) Array.prototype.push.apply(_this.items, ec);
	    return _this;
	  }

	  createClass(Collection, [{
	    key: "parse",

	    /**
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this
	     */
	    value: function parse(context, start) {
	      this.context = context;
	      var parseNode = context.parseNode,
	          src = context.src; // It's easier to recalculate lineStart here rather than tracking down the
	      // last context from which to read it -- eemeli/yaml#2

	      var lineStart = Node.startOfLine(src, start);
	      var firstItem = this.items[0]; // First-item context needs to be correct for later comment handling
	      // -- eemeli/yaml#17

	      firstItem.context.parent = this;
	      this.valueRange = Range.copy(firstItem.valueRange);
	      var indent = firstItem.range.start - firstItem.context.lineStart;
	      var offset = start;
	      offset = Node.normalizeOffset(src, offset);
	      var ch = src[offset];
	      var atLineStart = Node.endOfWhiteSpace(src, lineStart) === offset;
	      var prevIncludesTrailingLines = false;

	      while (ch) {
	        while (ch === '\n' || ch === '#') {
	          if (atLineStart && ch === '\n' && !prevIncludesTrailingLines) {
	            var blankLine = new BlankLine();
	            offset = blankLine.parse({
	              src: src
	            }, offset);
	            this.valueRange.end = offset;

	            if (offset >= src.length) {
	              ch = null;
	              break;
	            }

	            this.items.push(blankLine);
	            offset -= 1; // blankLine.parse() consumes terminal newline
	          } else if (ch === '#') {
	            if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {
	              return offset;
	            }

	            var comment = new Comment();
	            offset = comment.parse({
	              indent: indent,
	              lineStart: lineStart,
	              src: src
	            }, offset);
	            this.items.push(comment);
	            this.valueRange.end = offset;

	            if (offset >= src.length) {
	              ch = null;
	              break;
	            }
	          }

	          lineStart = offset + 1;
	          offset = Node.endOfIndent(src, lineStart);

	          if (Node.atBlank(src, offset)) {
	            var wsEnd = Node.endOfWhiteSpace(src, offset);
	            var next = src[wsEnd];

	            if (!next || next === '\n' || next === '#') {
	              offset = wsEnd;
	            }
	          }

	          ch = src[offset];
	          atLineStart = true;
	        }

	        if (!ch) {
	          break;
	        }

	        if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {
	          if (lineStart > start) offset = lineStart;
	          break;
	        }

	        if (firstItem.type === Type.SEQ_ITEM !== (ch === '-')) {
	          var typeswitch = true;

	          if (ch === '-') {
	            // map key may start with -, as long as it's followed by a non-whitespace char
	            var _next = src[offset + 1];
	            typeswitch = !_next || _next === '\n' || _next === '\t' || _next === ' ';
	          }

	          if (typeswitch) {
	            if (lineStart > start) offset = lineStart;
	            break;
	          }
	        }

	        var node = parseNode({
	          atLineStart: atLineStart,
	          inCollection: true,
	          indent: indent,
	          lineStart: lineStart,
	          parent: this
	        }, offset);
	        if (!node) return offset; // at next document start

	        this.items.push(node);
	        this.valueRange.end = node.valueRange.end;
	        offset = Node.normalizeOffset(src, node.range.end);
	        ch = src[offset];
	        atLineStart = false;
	        prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range
	        // has advanced to check the current line's indentation level
	        // -- eemeli/yaml#10 & eemeli/yaml#38

	        if (ch) {
	          var ls = offset - 1;
	          var prev = src[ls];

	          while (prev === ' ' || prev === '\t') {
	            prev = src[--ls];
	          }

	          if (prev === '\n') {
	            lineStart = ls + 1;
	            atLineStart = true;
	          }
	        }

	        var ec = grabCollectionEndComments(node);
	        if (ec) Array.prototype.push.apply(this.items, ec);
	      }

	      return offset;
	    }
	  }, {
	    key: "setOrigRanges",
	    value: function setOrigRanges(cr, offset) {
	      offset = get$1(getPrototypeOf(Collection.prototype), "setOrigRanges", this).call(this, cr, offset);
	      this.items.forEach(function (node) {
	        offset = node.setOrigRanges(cr, offset);
	      });
	      return offset;
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      var src = this.context.src,
	          items = this.items,
	          range = this.range,
	          value = this.value;
	      if (value != null) return value;
	      var str = src.slice(range.start, items[0].range.start) + String(items[0]);

	      for (var i = 1; i < items.length; ++i) {
	        var item = items[i];
	        var _item$context = item.context,
	            atLineStart = _item$context.atLineStart,
	            indent = _item$context.indent;
	        if (atLineStart) for (var _i = 0; _i < indent; ++_i) {
	          str += ' ';
	        }
	        str += String(item);
	      }

	      return Node.addStringTerminator(src, range.end, str);
	    }
	  }, {
	    key: "includesTrailingLines",
	    get: function get() {
	      return this.items.length > 0;
	    }
	  }]);

	  return Collection;
	}(Node);

	function _createSuper$5(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$6()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var Directive = /*#__PURE__*/function (_Node) {
	  inherits(Directive, _Node);

	  var _super = _createSuper$5(Directive);

	  function Directive() {
	    var _this;

	    classCallCheck(this, Directive);

	    _this = _super.call(this, Type.DIRECTIVE);
	    _this.name = null;
	    return _this;
	  }

	  createClass(Directive, [{
	    key: "parseName",
	    value: function parseName(start) {
	      var src = this.context.src;
	      var offset = start;
	      var ch = src[offset];

	      while (ch && ch !== '\n' && ch !== '\t' && ch !== ' ') {
	        ch = src[offset += 1];
	      }

	      this.name = src.slice(start, offset);
	      return offset;
	    }
	  }, {
	    key: "parseParameters",
	    value: function parseParameters(start) {
	      var src = this.context.src;
	      var offset = start;
	      var ch = src[offset];

	      while (ch && ch !== '\n' && ch !== '#') {
	        ch = src[offset += 1];
	      }

	      this.valueRange = new Range(start, offset);
	      return offset;
	    }
	  }, {
	    key: "parse",
	    value: function parse(context, start) {
	      this.context = context;
	      var offset = this.parseName(start + 1);
	      offset = this.parseParameters(offset);
	      offset = this.parseComment(offset);
	      this.range = new Range(start, offset);
	      return offset;
	    }
	  }, {
	    key: "parameters",
	    get: function get() {
	      var raw = this.rawValue;
	      return raw ? raw.trim().split(/[ \t]+/) : [];
	    }
	  }]);

	  return Directive;
	}(Node);

	function _createSuper$6(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$7()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var Document = /*#__PURE__*/function (_Node) {
	  inherits(Document, _Node);

	  var _super = _createSuper$6(Document);

	  createClass(Document, null, [{
	    key: "startCommentOrEndBlankLine",
	    value: function startCommentOrEndBlankLine(src, start) {
	      var offset = Node.endOfWhiteSpace(src, start);
	      var ch = src[offset];
	      return ch === '#' || ch === '\n' ? offset : start;
	    }
	  }]);

	  function Document() {
	    var _this;

	    classCallCheck(this, Document);

	    _this = _super.call(this, Type.DOCUMENT);
	    _this.directives = null;
	    _this.contents = null;
	    _this.directivesEndMarker = null;
	    _this.documentEndMarker = null;
	    return _this;
	  }

	  createClass(Document, [{
	    key: "parseDirectives",
	    value: function parseDirectives(start) {
	      var src = this.context.src;
	      this.directives = [];
	      var atLineStart = true;
	      var hasDirectives = false;
	      var offset = start;

	      while (!Node.atDocumentBoundary(src, offset, Char.DIRECTIVES_END)) {
	        offset = Document.startCommentOrEndBlankLine(src, offset);

	        switch (src[offset]) {
	          case '\n':
	            if (atLineStart) {
	              var blankLine = new BlankLine();
	              offset = blankLine.parse({
	                src: src
	              }, offset);

	              if (offset < src.length) {
	                this.directives.push(blankLine);
	              }
	            } else {
	              offset += 1;
	              atLineStart = true;
	            }

	            break;

	          case '#':
	            {
	              var comment = new Comment();
	              offset = comment.parse({
	                src: src
	              }, offset);
	              this.directives.push(comment);
	              atLineStart = false;
	            }
	            break;

	          case '%':
	            {
	              var directive = new Directive();
	              offset = directive.parse({
	                parent: this,
	                src: src
	              }, offset);
	              this.directives.push(directive);
	              hasDirectives = true;
	              atLineStart = false;
	            }
	            break;

	          default:
	            if (hasDirectives) {
	              this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');
	            } else if (this.directives.length > 0) {
	              this.contents = this.directives;
	              this.directives = [];
	            }

	            return offset;
	        }
	      }

	      if (src[offset]) {
	        this.directivesEndMarker = new Range(offset, offset + 3);
	        return offset + 3;
	      }

	      if (hasDirectives) {
	        this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');
	      } else if (this.directives.length > 0) {
	        this.contents = this.directives;
	        this.directives = [];
	      }

	      return offset;
	    }
	  }, {
	    key: "parseContents",
	    value: function parseContents(start) {
	      var _this$context = this.context,
	          parseNode = _this$context.parseNode,
	          src = _this$context.src;
	      if (!this.contents) this.contents = [];
	      var lineStart = start;

	      while (src[lineStart - 1] === '-') {
	        lineStart -= 1;
	      }

	      var offset = Node.endOfWhiteSpace(src, start);
	      var atLineStart = lineStart === start;
	      this.valueRange = new Range(offset);

	      while (!Node.atDocumentBoundary(src, offset, Char.DOCUMENT_END)) {
	        switch (src[offset]) {
	          case '\n':
	            if (atLineStart) {
	              var blankLine = new BlankLine();
	              offset = blankLine.parse({
	                src: src
	              }, offset);

	              if (offset < src.length) {
	                this.contents.push(blankLine);
	              }
	            } else {
	              offset += 1;
	              atLineStart = true;
	            }

	            lineStart = offset;
	            break;

	          case '#':
	            {
	              var comment = new Comment();
	              offset = comment.parse({
	                src: src
	              }, offset);
	              this.contents.push(comment);
	              atLineStart = false;
	            }
	            break;

	          default:
	            {
	              var iEnd = Node.endOfIndent(src, offset);
	              var context = {
	                atLineStart: atLineStart,
	                indent: -1,
	                inFlow: false,
	                inCollection: false,
	                lineStart: lineStart,
	                parent: this
	              };
	              var node = parseNode(context, iEnd);
	              if (!node) return this.valueRange.end = iEnd; // at next document start

	              this.contents.push(node);
	              offset = node.range.end;
	              atLineStart = false;
	              var ec = grabCollectionEndComments(node);
	              if (ec) Array.prototype.push.apply(this.contents, ec);
	            }
	        }

	        offset = Document.startCommentOrEndBlankLine(src, offset);
	      }

	      this.valueRange.end = offset;

	      if (src[offset]) {
	        this.documentEndMarker = new Range(offset, offset + 3);
	        offset += 3;

	        if (src[offset]) {
	          offset = Node.endOfWhiteSpace(src, offset);

	          if (src[offset] === '#') {
	            var _comment = new Comment();

	            offset = _comment.parse({
	              src: src
	            }, offset);
	            this.contents.push(_comment);
	          }

	          switch (src[offset]) {
	            case '\n':
	              offset += 1;
	              break;

	            case undefined:
	              break;

	            default:
	              this.error = new YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');
	          }
	        }
	      }

	      return offset;
	    }
	    /**
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this
	     */

	  }, {
	    key: "parse",
	    value: function parse(context, start) {
	      context.root = this;
	      this.context = context;
	      var src = context.src;
	      var offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM

	      offset = this.parseDirectives(offset);
	      offset = this.parseContents(offset);
	      return offset;
	    }
	  }, {
	    key: "setOrigRanges",
	    value: function setOrigRanges(cr, offset) {
	      offset = get$1(getPrototypeOf(Document.prototype), "setOrigRanges", this).call(this, cr, offset);
	      this.directives.forEach(function (node) {
	        offset = node.setOrigRanges(cr, offset);
	      });
	      if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);
	      this.contents.forEach(function (node) {
	        offset = node.setOrigRanges(cr, offset);
	      });
	      if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);
	      return offset;
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      var contents = this.contents,
	          directives = this.directives,
	          value = this.value;
	      if (value != null) return value;
	      var str = directives.join('');

	      if (contents.length > 0) {
	        if (directives.length > 0 || contents[0].type === Type.COMMENT) str += '---\n';
	        str += contents.join('');
	      }

	      if (str[str.length - 1] !== '\n') str += '\n';
	      return str;
	    }
	  }]);

	  return Document;
	}(Node);

	function _createSuper$7(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$8()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var Alias = /*#__PURE__*/function (_Node) {
	  inherits(Alias, _Node);

	  var _super = _createSuper$7(Alias);

	  function Alias() {
	    classCallCheck(this, Alias);

	    return _super.apply(this, arguments);
	  }

	  createClass(Alias, [{
	    key: "parse",

	    /**
	     * Parses an *alias from the source
	     *
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this scalar
	     */
	    value: function parse(context, start) {
	      this.context = context;
	      var src = context.src;
	      var offset = Node.endOfIdentifier(src, start + 1);
	      this.valueRange = new Range(start + 1, offset);
	      offset = Node.endOfWhiteSpace(src, offset);
	      offset = this.parseComment(offset);
	      return offset;
	    }
	  }]);

	  return Alias;
	}(Node);

	function _createSuper$8(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$9()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var Chomp = {
	  CLIP: 'CLIP',
	  KEEP: 'KEEP',
	  STRIP: 'STRIP'
	};
	var BlockValue = /*#__PURE__*/function (_Node) {
	  inherits(BlockValue, _Node);

	  var _super = _createSuper$8(BlockValue);

	  function BlockValue(type, props) {
	    var _this;

	    classCallCheck(this, BlockValue);

	    _this = _super.call(this, type, props);
	    _this.blockIndent = null;
	    _this.chomping = Chomp.CLIP;
	    _this.header = null;
	    return _this;
	  }

	  createClass(BlockValue, [{
	    key: "parseBlockHeader",
	    value: function parseBlockHeader(start) {
	      var src = this.context.src;
	      var offset = start + 1;
	      var bi = '';

	      while (true) {
	        var ch = src[offset];

	        switch (ch) {
	          case '-':
	            this.chomping = Chomp.STRIP;
	            break;

	          case '+':
	            this.chomping = Chomp.KEEP;
	            break;

	          case '0':
	          case '1':
	          case '2':
	          case '3':
	          case '4':
	          case '5':
	          case '6':
	          case '7':
	          case '8':
	          case '9':
	            bi += ch;
	            break;

	          default:
	            this.blockIndent = Number(bi) || null;
	            this.header = new Range(start, offset);
	            return offset;
	        }

	        offset += 1;
	      }
	    }
	  }, {
	    key: "parseBlockValue",
	    value: function parseBlockValue(start) {
	      var _this$context = this.context,
	          indent = _this$context.indent,
	          src = _this$context.src;
	      var offset = start;
	      var valueEnd = start;
	      var bi = this.blockIndent ? indent + this.blockIndent - 1 : indent;
	      var minBlockIndent = 1;

	      for (var ch = src[offset]; ch === '\n'; ch = src[offset]) {
	        offset += 1;
	        if (Node.atDocumentBoundary(src, offset)) break;
	        var end = Node.endOfBlockIndent(src, bi, offset); // should not include tab?

	        if (end === null) break;

	        if (!this.blockIndent) {
	          // no explicit block indent, none yet detected
	          var lineIndent = end - (offset + indent);

	          if (src[end] !== '\n') {
	            // first line with non-whitespace content
	            if (lineIndent < minBlockIndent) {
	              offset -= 1;
	              break;
	            }

	            this.blockIndent = lineIndent;
	            bi = indent + this.blockIndent - 1;
	          } else if (lineIndent > minBlockIndent) {
	            // empty line with more whitespace
	            minBlockIndent = lineIndent;
	          }
	        }

	        if (src[end] === '\n') {
	          offset = end;
	        } else {
	          offset = valueEnd = Node.endOfLine(src, end);
	        }
	      }

	      if (this.chomping !== Chomp.KEEP) {
	        offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
	      }

	      this.valueRange = new Range(start + 1, offset);
	      return offset;
	    }
	    /**
	     * Parses a block value from the source
	     *
	     * Accepted forms are:
	     * ```
	     * BS
	     * block
	     * lines
	     *
	     * BS #comment
	     * block
	     * lines
	     * ```
	     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
	     * are empty or have an indent level greater than `indent`.
	     *
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this block
	     */

	  }, {
	    key: "parse",
	    value: function parse(context, start) {
	      this.context = context;
	      var src = context.src;
	      var offset = this.parseBlockHeader(start);
	      offset = Node.endOfWhiteSpace(src, offset);
	      offset = this.parseComment(offset);
	      offset = this.parseBlockValue(offset);
	      return offset;
	    }
	  }, {
	    key: "setOrigRanges",
	    value: function setOrigRanges(cr, offset) {
	      offset = get$1(getPrototypeOf(BlockValue.prototype), "setOrigRanges", this).call(this, cr, offset);
	      return this.header ? this.header.setOrigRange(cr, offset) : offset;
	    }
	  }, {
	    key: "includesTrailingLines",
	    get: function get() {
	      return this.chomping === Chomp.KEEP;
	    }
	  }, {
	    key: "strValue",
	    get: function get() {
	      if (!this.valueRange || !this.context) return null;
	      var _this$valueRange = this.valueRange,
	          start = _this$valueRange.start,
	          end = _this$valueRange.end;
	      var _this$context2 = this.context,
	          indent = _this$context2.indent,
	          src = _this$context2.src;
	      if (this.valueRange.isEmpty()) return '';
	      var lastNewLine = null;
	      var ch = src[end - 1];

	      while (ch === '\n' || ch === '\t' || ch === ' ') {
	        end -= 1;

	        if (end <= start) {
	          if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens
	        }

	        if (ch === '\n') lastNewLine = end;
	        ch = src[end - 1];
	      }

	      var keepStart = end + 1;

	      if (lastNewLine) {
	        if (this.chomping === Chomp.KEEP) {
	          keepStart = lastNewLine;
	          end = this.valueRange.end;
	        } else {
	          end = lastNewLine;
	        }
	      }

	      var bi = indent + this.blockIndent;
	      var folded = this.type === Type.BLOCK_FOLDED;
	      var atStart = true;
	      var str = '';
	      var sep = '';
	      var prevMoreIndented = false;

	      for (var i = start; i < end; ++i) {
	        for (var j = 0; j < bi; ++j) {
	          if (src[i] !== ' ') break;
	          i += 1;
	        }

	        var _ch = src[i];

	        if (_ch === '\n') {
	          if (sep === '\n') str += '\n';else sep = '\n';
	        } else {
	          var lineEnd = Node.endOfLine(src, i);
	          var line = src.slice(i, lineEnd);
	          i = lineEnd;

	          if (folded && (_ch === ' ' || _ch === '\t') && i < keepStart) {
	            if (sep === ' ') sep = '\n';else if (!prevMoreIndented && !atStart && sep === '\n') sep = '\n\n';
	            str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')

	            sep = lineEnd < end && src[lineEnd] || '';
	            prevMoreIndented = true;
	          } else {
	            str += sep + line;
	            sep = folded && i < keepStart ? ' ' : '\n';
	            prevMoreIndented = false;
	          }

	          if (atStart && line !== '') atStart = false;
	        }
	      }

	      return this.chomping === Chomp.STRIP ? str : str + '\n';
	    }
	  }]);

	  return BlockValue;
	}(Node);

	function _createSuper$9(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$a()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var FlowCollection = /*#__PURE__*/function (_Node) {
	  inherits(FlowCollection, _Node);

	  var _super = _createSuper$9(FlowCollection);

	  function FlowCollection(type, props) {
	    var _this;

	    classCallCheck(this, FlowCollection);

	    _this = _super.call(this, type, props);
	    _this.items = null;
	    return _this;
	  }

	  createClass(FlowCollection, [{
	    key: "prevNodeIsJsonLike",
	    value: function prevNodeIsJsonLike() {
	      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;
	      var node = this.items[idx - 1];
	      return !!node && (node.jsonLike || node.type === Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
	    }
	    /**
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this
	     */

	  }, {
	    key: "parse",
	    value: function parse(context, start) {
	      this.context = context;
	      var parseNode = context.parseNode,
	          src = context.src;
	      var indent = context.indent,
	          lineStart = context.lineStart;
	      var char = src[start]; // { or [

	      this.items = [{
	        char: char,
	        offset: start
	      }];
	      var offset = Node.endOfWhiteSpace(src, start + 1);
	      char = src[offset];

	      while (char && char !== ']' && char !== '}') {
	        switch (char) {
	          case '\n':
	            {
	              lineStart = offset + 1;
	              var wsEnd = Node.endOfWhiteSpace(src, lineStart);

	              if (src[wsEnd] === '\n') {
	                var blankLine = new BlankLine();
	                lineStart = blankLine.parse({
	                  src: src
	                }, lineStart);
	                this.items.push(blankLine);
	              }

	              offset = Node.endOfIndent(src, lineStart);

	              if (offset <= lineStart + indent) {
	                char = src[offset];

	                if (offset < lineStart + indent || char !== ']' && char !== '}') {
	                  var msg = 'Insufficient indentation in flow collection';
	                  this.error = new YAMLSemanticError(this, msg);
	                }
	              }
	            }
	            break;

	          case ',':
	            {
	              this.items.push({
	                char: char,
	                offset: offset
	              });
	              offset += 1;
	            }
	            break;

	          case '#':
	            {
	              var comment = new Comment();
	              offset = comment.parse({
	                src: src
	              }, offset);
	              this.items.push(comment);
	            }
	            break;

	          case '?':
	          case ':':
	            {
	              var next = src[offset + 1];

	              if (next === '\n' || next === '\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace
	              char === ':' && this.prevNodeIsJsonLike()) {
	                this.items.push({
	                  char: char,
	                  offset: offset
	                });
	                offset += 1;
	                break;
	              }
	            }
	          // fallthrough

	          default:
	            {
	              var node = parseNode({
	                atLineStart: false,
	                inCollection: false,
	                inFlow: true,
	                indent: -1,
	                lineStart: lineStart,
	                parent: this
	              }, offset);

	              if (!node) {
	                // at next document start
	                this.valueRange = new Range(start, offset);
	                return offset;
	              }

	              this.items.push(node);
	              offset = Node.normalizeOffset(src, node.range.end);
	            }
	        }

	        offset = Node.endOfWhiteSpace(src, offset);
	        char = src[offset];
	      }

	      this.valueRange = new Range(start, offset + 1);

	      if (char) {
	        this.items.push({
	          char: char,
	          offset: offset
	        });
	        offset = Node.endOfWhiteSpace(src, offset + 1);
	        offset = this.parseComment(offset);
	      }

	      return offset;
	    }
	  }, {
	    key: "setOrigRanges",
	    value: function setOrigRanges(cr, offset) {
	      offset = get$1(getPrototypeOf(FlowCollection.prototype), "setOrigRanges", this).call(this, cr, offset);
	      this.items.forEach(function (node) {
	        if (node instanceof Node) {
	          offset = node.setOrigRanges(cr, offset);
	        } else if (cr.length === 0) {
	          node.origOffset = node.offset;
	        } else {
	          var i = offset;

	          while (i < cr.length) {
	            if (cr[i] > node.offset) break;else ++i;
	          }

	          node.origOffset = node.offset + i;
	          offset = i;
	        }
	      });
	      return offset;
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      var src = this.context.src,
	          items = this.items,
	          range = this.range,
	          value = this.value;
	      if (value != null) return value;
	      var nodes = items.filter(function (item) {
	        return item instanceof Node;
	      });
	      var str = '';
	      var prevEnd = range.start;
	      nodes.forEach(function (node) {
	        var prefix = src.slice(prevEnd, node.range.start);
	        prevEnd = node.range.end;
	        str += prefix + String(node);

	        if (str[str.length - 1] === '\n' && src[prevEnd - 1] !== '\n' && src[prevEnd] === '\n') {
	          // Comment range does not include the terminal newline, but its
	          // stringified value does. Without this fix, newlines at comment ends
	          // get duplicated.
	          prevEnd += 1;
	        }
	      });
	      str += src.slice(prevEnd, range.end);
	      return Node.addStringTerminator(src, range.end, str);
	    }
	  }]);

	  return FlowCollection;
	}(Node);

	function _createSuper$a(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$b()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$b() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var PlainValue = /*#__PURE__*/function (_Node) {
	  inherits(PlainValue, _Node);

	  var _super = _createSuper$a(PlainValue);

	  function PlainValue() {
	    classCallCheck(this, PlainValue);

	    return _super.apply(this, arguments);
	  }

	  createClass(PlainValue, [{
	    key: "parseBlockValue",
	    value: function parseBlockValue(start) {
	      var _this$context = this.context,
	          indent = _this$context.indent,
	          inFlow = _this$context.inFlow,
	          src = _this$context.src;
	      var offset = start;
	      var valueEnd = start;

	      for (var ch = src[offset]; ch === '\n'; ch = src[offset]) {
	        if (Node.atDocumentBoundary(src, offset + 1)) break;
	        var end = Node.endOfBlockIndent(src, indent, offset + 1);
	        if (end === null || src[end] === '#') break;

	        if (src[end] === '\n') {
	          offset = end;
	        } else {
	          valueEnd = PlainValue.endOfLine(src, end, inFlow);
	          offset = valueEnd;
	        }
	      }

	      if (this.valueRange.isEmpty()) this.valueRange.start = start;
	      this.valueRange.end = valueEnd;
	      return valueEnd;
	    }
	    /**
	     * Parses a plain value from the source
	     *
	     * Accepted forms are:
	     * ```
	     * #comment
	     *
	     * first line
	     *
	     * first line #comment
	     *
	     * first line
	     * block
	     * lines
	     *
	     * #comment
	     * block
	     * lines
	     * ```
	     * where block lines are empty or have an indent level greater than `indent`.
	     *
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this scalar, may be `\n`
	     */

	  }, {
	    key: "parse",
	    value: function parse(context, start) {
	      this.context = context;
	      var inFlow = context.inFlow,
	          src = context.src;
	      var offset = start;
	      var ch = src[offset];

	      if (ch && ch !== '#' && ch !== '\n') {
	        offset = PlainValue.endOfLine(src, start, inFlow);
	      }

	      this.valueRange = new Range(start, offset);
	      offset = Node.endOfWhiteSpace(src, offset);
	      offset = this.parseComment(offset);

	      if (!this.hasComment || this.valueRange.isEmpty()) {
	        offset = this.parseBlockValue(offset);
	      }

	      return offset;
	    }
	  }, {
	    key: "strValue",
	    get: function get() {
	      if (!this.valueRange || !this.context) return null;
	      var _this$valueRange = this.valueRange,
	          start = _this$valueRange.start,
	          end = _this$valueRange.end;
	      var src = this.context.src;
	      var ch = src[end - 1];

	      while (start < end && (ch === '\n' || ch === '\t' || ch === ' ')) {
	        ch = src[--end - 1];
	      }

	      ch = src[start];

	      while (start < end && (ch === '\n' || ch === '\t' || ch === ' ')) {
	        ch = src[++start];
	      }

	      var str = '';

	      for (var i = start; i < end; ++i) {
	        var _ch = src[i];

	        if (_ch === '\n') {
	          var _Node$foldNewline = Node.foldNewline(src, i, -1),
	              fold = _Node$foldNewline.fold,
	              offset = _Node$foldNewline.offset;

	          str += fold;
	          i = offset;
	        } else if (_ch === ' ' || _ch === '\t') {
	          // trim trailing whitespace
	          var wsStart = i;
	          var next = src[i + 1];

	          while (i < end && (next === ' ' || next === '\t')) {
	            i += 1;
	            next = src[i + 1];
	          }

	          if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;
	        } else {
	          str += _ch;
	        }
	      }

	      return str;
	    }
	  }], [{
	    key: "endOfLine",
	    value: function endOfLine(src, start, inFlow) {
	      var ch = src[start];
	      var offset = start;

	      while (ch && ch !== '\n') {
	        if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;
	        var next = src[offset + 1];
	        if (ch === ':' && (!next || next === '\n' || next === '\t' || next === ' ' || inFlow && next === ',')) break;
	        if ((ch === ' ' || ch === '\t') && next === '#') break;
	        offset += 1;
	        ch = next;
	      }

	      return offset;
	    }
	  }]);

	  return PlainValue;
	}(Node);

	function _createSuper$b(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$c()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$c() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var QuoteDouble = /*#__PURE__*/function (_Node) {
	  inherits(QuoteDouble, _Node);

	  var _super = _createSuper$b(QuoteDouble);

	  function QuoteDouble() {
	    classCallCheck(this, QuoteDouble);

	    return _super.apply(this, arguments);
	  }

	  createClass(QuoteDouble, [{
	    key: "parseCharCode",
	    value: function parseCharCode(offset, length, errors) {
	      var src = this.context.src;
	      var cc = src.substr(offset, length);
	      var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
	      var code = ok ? parseInt(cc, 16) : NaN;

	      if (isNaN(code)) {
	        errors.push(new YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(offset - 2, length + 2))));
	        return src.substr(offset - 2, length + 2);
	      }

	      return String.fromCodePoint(code);
	    }
	    /**
	     * Parses a "double quoted" value from the source
	     *
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this scalar
	     */

	  }, {
	    key: "parse",
	    value: function parse(context, start) {
	      this.context = context;
	      var src = context.src;
	      var offset = QuoteDouble.endOfQuote(src, start + 1);
	      this.valueRange = new Range(start, offset);
	      offset = Node.endOfWhiteSpace(src, offset);
	      offset = this.parseComment(offset);
	      return offset;
	    }
	  }, {
	    key: "strValue",

	    /**
	     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
	     */
	    get: function get() {
	      if (!this.valueRange || !this.context) return null;
	      var errors = [];
	      var _this$valueRange = this.valueRange,
	          start = _this$valueRange.start,
	          end = _this$valueRange.end;
	      var _this$context = this.context,
	          indent = _this$context.indent,
	          src = _this$context.src;
	      if (src[end - 1] !== '"') errors.push(new YAMLSyntaxError(this, 'Missing closing "quote')); // Using String#replace is too painful with escaped newlines preceded by
	      // escaped backslashes; also, this should be faster.

	      var str = '';

	      for (var i = start + 1; i < end - 1; ++i) {
	        var ch = src[i];

	        if (ch === '\n') {
	          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));

	          var _Node$foldNewline = Node.foldNewline(src, i, indent),
	              fold = _Node$foldNewline.fold,
	              offset = _Node$foldNewline.offset,
	              error = _Node$foldNewline.error;

	          str += fold;
	          i = offset;
	          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));
	        } else if (ch === '\\') {
	          i += 1;

	          switch (src[i]) {
	            case '0':
	              str += '\0';
	              break;
	            // null character

	            case 'a':
	              str += '\x07';
	              break;
	            // bell character

	            case 'b':
	              str += '\b';
	              break;
	            // backspace

	            case 'e':
	              str += '\x1b';
	              break;
	            // escape character

	            case 'f':
	              str += '\f';
	              break;
	            // form feed

	            case 'n':
	              str += '\n';
	              break;
	            // line feed

	            case 'r':
	              str += '\r';
	              break;
	            // carriage return

	            case 't':
	              str += '\t';
	              break;
	            // horizontal tab

	            case 'v':
	              str += '\v';
	              break;
	            // vertical tab

	            case 'N':
	              str += "\x85";
	              break;
	            // Unicode next line

	            case '_':
	              str += "\xA0";
	              break;
	            // Unicode non-breaking space

	            case 'L':
	              str += "\u2028";
	              break;
	            // Unicode line separator

	            case 'P':
	              str += "\u2029";
	              break;
	            // Unicode paragraph separator

	            case ' ':
	              str += ' ';
	              break;

	            case '"':
	              str += '"';
	              break;

	            case '/':
	              str += '/';
	              break;

	            case '\\':
	              str += '\\';
	              break;

	            case '\t':
	              str += '\t';
	              break;

	            case 'x':
	              str += this.parseCharCode(i + 1, 2, errors);
	              i += 2;
	              break;

	            case 'u':
	              str += this.parseCharCode(i + 1, 4, errors);
	              i += 4;
	              break;

	            case 'U':
	              str += this.parseCharCode(i + 1, 8, errors);
	              i += 8;
	              break;

	            case '\n':
	              // skip escaped newlines, but still trim the following line
	              while (src[i + 1] === ' ' || src[i + 1] === '\t') {
	                i += 1;
	              }

	              break;

	            default:
	              errors.push(new YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(i - 1, 2))));
	              str += '\\' + src[i];
	          }
	        } else if (ch === ' ' || ch === '\t') {
	          // trim trailing whitespace
	          var wsStart = i;
	          var next = src[i + 1];

	          while (next === ' ' || next === '\t') {
	            i += 1;
	            next = src[i + 1];
	          }

	          if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
	        } else {
	          str += ch;
	        }
	      }

	      return errors.length > 0 ? {
	        errors: errors,
	        str: str
	      } : str;
	    }
	  }], [{
	    key: "endOfQuote",
	    value: function endOfQuote(src, offset) {
	      var ch = src[offset];

	      while (ch && ch !== '"') {
	        offset += ch === '\\' ? 2 : 1;
	        ch = src[offset];
	      }

	      return offset + 1;
	    }
	  }]);

	  return QuoteDouble;
	}(Node);

	function _createSuper$c(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$d()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$d() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var QuoteSingle = /*#__PURE__*/function (_Node) {
	  inherits(QuoteSingle, _Node);

	  var _super = _createSuper$c(QuoteSingle);

	  function QuoteSingle() {
	    classCallCheck(this, QuoteSingle);

	    return _super.apply(this, arguments);
	  }

	  createClass(QuoteSingle, [{
	    key: "parse",

	    /**
	     * Parses a 'single quoted' value from the source
	     *
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this scalar
	     */
	    value: function parse(context, start) {
	      this.context = context;
	      var src = context.src;
	      var offset = QuoteSingle.endOfQuote(src, start + 1);
	      this.valueRange = new Range(start, offset);
	      offset = Node.endOfWhiteSpace(src, offset);
	      offset = this.parseComment(offset);
	      return offset;
	    }
	  }, {
	    key: "strValue",

	    /**
	     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
	     */
	    get: function get() {
	      if (!this.valueRange || !this.context) return null;
	      var errors = [];
	      var _this$valueRange = this.valueRange,
	          start = _this$valueRange.start,
	          end = _this$valueRange.end;
	      var _this$context = this.context,
	          indent = _this$context.indent,
	          src = _this$context.src;
	      if (src[end - 1] !== "'") errors.push(new YAMLSyntaxError(this, "Missing closing 'quote"));
	      var str = '';

	      for (var i = start + 1; i < end - 1; ++i) {
	        var ch = src[i];

	        if (ch === '\n') {
	          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));

	          var _Node$foldNewline = Node.foldNewline(src, i, indent),
	              fold = _Node$foldNewline.fold,
	              offset = _Node$foldNewline.offset,
	              error = _Node$foldNewline.error;

	          str += fold;
	          i = offset;
	          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));
	        } else if (ch === "'") {
	          str += ch;
	          i += 1;
	          if (src[i] !== "'") errors.push(new YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));
	        } else if (ch === ' ' || ch === '\t') {
	          // trim trailing whitespace
	          var wsStart = i;
	          var next = src[i + 1];

	          while (next === ' ' || next === '\t') {
	            i += 1;
	            next = src[i + 1];
	          }

	          if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
	        } else {
	          str += ch;
	        }
	      }

	      return errors.length > 0 ? {
	        errors: errors,
	        str: str
	      } : str;
	    }
	  }], [{
	    key: "endOfQuote",
	    value: function endOfQuote(src, offset) {
	      var ch = src[offset];

	      while (ch) {
	        if (ch === "'") {
	          if (src[offset + 1] !== "'") break;
	          ch = src[offset += 2];
	        } else {
	          ch = src[offset += 1];
	        }
	      }

	      return offset + 1;
	    }
	  }]);

	  return QuoteSingle;
	}(Node);

	function createNewNode(type, props) {
	  switch (type) {
	    case Type.ALIAS:
	      return new Alias(type, props);

	    case Type.BLOCK_FOLDED:
	    case Type.BLOCK_LITERAL:
	      return new BlockValue(type, props);

	    case Type.FLOW_MAP:
	    case Type.FLOW_SEQ:
	      return new FlowCollection(type, props);

	    case Type.MAP_KEY:
	    case Type.MAP_VALUE:
	    case Type.SEQ_ITEM:
	      return new CollectionItem(type, props);

	    case Type.COMMENT:
	    case Type.PLAIN:
	      return new PlainValue(type, props);

	    case Type.QUOTE_DOUBLE:
	      return new QuoteDouble(type, props);

	    case Type.QUOTE_SINGLE:
	      return new QuoteSingle(type, props);

	    /* istanbul ignore next */

	    default:
	      return null;
	    // should never happen
	  }
	}
	/**
	 * @param {boolean} atLineStart - Node starts at beginning of line
	 * @param {boolean} inFlow - true if currently in a flow context
	 * @param {boolean} inCollection - true if currently in a collection context
	 * @param {number} indent - Current level of indentation
	 * @param {number} lineStart - Start of the current line
	 * @param {Node} parent - The parent of the node
	 * @param {string} src - Source of the YAML document
	 */


	var ParseContext = /*#__PURE__*/function () {
	  createClass(ParseContext, null, [{
	    key: "parseType",
	    value: function parseType(src, offset, inFlow) {
	      switch (src[offset]) {
	        case '*':
	          return Type.ALIAS;

	        case '>':
	          return Type.BLOCK_FOLDED;

	        case '|':
	          return Type.BLOCK_LITERAL;

	        case '{':
	          return Type.FLOW_MAP;

	        case '[':
	          return Type.FLOW_SEQ;

	        case '?':
	          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_KEY : Type.PLAIN;

	        case ':':
	          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_VALUE : Type.PLAIN;

	        case '-':
	          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.SEQ_ITEM : Type.PLAIN;

	        case '"':
	          return Type.QUOTE_DOUBLE;

	        case "'":
	          return Type.QUOTE_SINGLE;

	        default:
	          return Type.PLAIN;
	      }
	    }
	  }]);

	  function ParseContext() {
	    var _this = this;

	    var orig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	        atLineStart = _ref.atLineStart,
	        inCollection = _ref.inCollection,
	        inFlow = _ref.inFlow,
	        indent = _ref.indent,
	        lineStart = _ref.lineStart,
	        parent = _ref.parent;

	    classCallCheck(this, ParseContext);

	    defineProperty(this, "parseNode", function (overlay, start) {
	      if (Node.atDocumentBoundary(_this.src, start)) return null;
	      var context = new ParseContext(_this, overlay);

	      var _context$parseProps = context.parseProps(start),
	          props = _context$parseProps.props,
	          type = _context$parseProps.type,
	          valueStart = _context$parseProps.valueStart;

	      var node = createNewNode(type, props);
	      var offset = node.parse(context, valueStart);
	      node.range = new Range(start, offset);
	      /* istanbul ignore if */

	      if (offset <= start) {
	        // This should never happen, but if it does, let's make sure to at least
	        // step one character forward to avoid a busy loop.
	        node.error = new Error("Node#parse consumed no characters");
	        node.error.parseEnd = offset;
	        node.error.source = node;
	        node.range.end = start + 1;
	      }

	      if (context.nodeStartsCollection(node)) {
	        if (!node.error && !context.atLineStart && context.parent.type === Type.DOCUMENT) {
	          node.error = new YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');
	        }

	        var collection = new Collection(node);
	        offset = collection.parse(new ParseContext(context), offset);
	        collection.range = new Range(start, offset);
	        return collection;
	      }

	      return node;
	    });

	    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
	    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
	    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
	    this.indent = indent != null ? indent : orig.indent;
	    this.lineStart = lineStart != null ? lineStart : orig.lineStart;
	    this.parent = parent != null ? parent : orig.parent || {};
	    this.root = orig.root;
	    this.src = orig.src;
	  }

	  createClass(ParseContext, [{
	    key: "nodeStartsCollection",
	    value: function nodeStartsCollection(node) {
	      var inCollection = this.inCollection,
	          inFlow = this.inFlow,
	          src = this.src;
	      if (inCollection || inFlow) return false;
	      if (node instanceof CollectionItem) return true; // check for implicit key

	      var offset = node.range.end;
	      if (src[offset] === '\n' || src[offset - 1] === '\n') return false;
	      offset = Node.endOfWhiteSpace(src, offset);
	      return src[offset] === ':';
	    } // Anchor and tag are before type, which determines the node implementation
	    // class; hence this intermediate step.

	  }, {
	    key: "parseProps",
	    value: function parseProps(offset) {
	      var inFlow = this.inFlow,
	          parent = this.parent,
	          src = this.src;
	      var props = [];
	      var lineHasProps = false;
	      offset = Node.endOfWhiteSpace(src, offset);
	      var ch = src[offset];

	      while (ch === Char.ANCHOR || ch === Char.COMMENT || ch === Char.TAG || ch === '\n') {
	        if (ch === '\n') {
	          var lineStart = offset + 1;
	          var inEnd = Node.endOfIndent(src, lineStart);
	          var indentDiff = inEnd - (lineStart + this.indent);
	          var noIndicatorAsIndent = parent.type === Type.SEQ_ITEM && parent.context.atLineStart;
	          if (!Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;
	          this.atLineStart = true;
	          this.lineStart = lineStart;
	          lineHasProps = false;
	          offset = inEnd;
	        } else if (ch === Char.COMMENT) {
	          var end = Node.endOfLine(src, offset + 1);
	          props.push(new Range(offset, end));
	          offset = end;
	        } else {
	          var _end = Node.endOfIdentifier(src, offset + 1);

	          if (ch === Char.TAG && src[_end] === ',' && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset + 1, _end + 13))) {
	            // Let's presume we're dealing with a YAML 1.0 domain tag here, rather
	            // than an empty but 'foo.bar' private-tagged node in a flow collection
	            // followed without whitespace by a plain string starting with a year
	            // or date divided by something.
	            _end = Node.endOfIdentifier(src, _end + 5);
	          }

	          props.push(new Range(offset, _end));
	          lineHasProps = true;
	          offset = Node.endOfWhiteSpace(src, _end);
	        }

	        ch = src[offset];
	      } // '- &a : b' has an anchor on an empty node


	      if (lineHasProps && ch === ':' && Node.atBlank(src, offset + 1, true)) offset -= 1;
	      var type = ParseContext.parseType(src, offset, inFlow);
	      return {
	        props: props,
	        type: type,
	        valueStart: offset
	      };
	    }
	    /**
	     * Parses a node from the source
	     * @param {ParseContext} overlay
	     * @param {number} start - Index of first non-whitespace character for the node
	     * @returns {?Node} - null if at a document boundary
	     */

	  }]);

	  return ParseContext;
	}();

	// Published as 'yaml/parse-cst'
	function parse(src) {
	  var cr = [];

	  if (src.indexOf('\r') !== -1) {
	    src = src.replace(/\r\n?/g, function (match, offset) {
	      if (match.length > 1) cr.push(offset);
	      return '\n';
	    });
	  }

	  var documents = [];
	  var offset = 0;

	  do {
	    var doc = new Document();
	    var context = new ParseContext({
	      src: src
	    });
	    offset = doc.parse(context, offset);
	    documents.push(doc);
	  } while (offset < src.length);

	  documents.setOrigRanges = function () {
	    if (cr.length === 0) return false;

	    for (var i = 1; i < cr.length; ++i) {
	      cr[i] -= i;
	    }

	    var crOffset = 0;

	    for (var _i = 0; _i < documents.length; ++_i) {
	      crOffset = documents[_i].setOrigRanges(cr, crOffset);
	    }

	    cr.splice(0, cr.length);
	    return true;
	  };

	  documents.toString = function () {
	    return documents.join('...\n');
	  };

	  return documents;
	}

	function addCommentBefore(str, indent, comment) {
	  if (!comment) return str;
	  var cc = comment.replace(/[\s\S]^/gm, "$&".concat(indent, "#"));
	  return "#".concat(cc, "\n").concat(indent).concat(str);
	}
	function addComment(str, indent, comment) {
	  return !comment ? str : comment.indexOf('\n') === -1 ? "".concat(str, " #").concat(comment) : "".concat(str, "\n") + comment.replace(/^/gm, "".concat(indent || '', "#"));
	}

	function toJSON(value, arg, ctx) {
	  if (Array.isArray(value)) return value.map(function (v, i) {
	    return toJSON(v, String(i), ctx);
	  });

	  if (value && typeof value.toJSON === 'function') {
	    var anchor = ctx && ctx.anchors && ctx.anchors.get(value);
	    if (anchor) ctx.onCreate = function (res) {
	      anchor.res = res;
	      delete ctx.onCreate;
	    };
	    var res = value.toJSON(arg, ctx);
	    if (anchor && ctx.onCreate) ctx.onCreate(res);
	    return res;
	  }

	  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);
	  return value;
	}

	function _toArray(arr) {
	  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();
	}

	var toArray = _toArray;

	var Node$1 = function Node() {
	  classCallCheck(this, Node);
	};

	function _createSuper$d(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$e()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$e() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var Scalar = /*#__PURE__*/function (_Node) {
	  inherits(Scalar, _Node);

	  var _super = _createSuper$d(Scalar);

	  function Scalar(value) {
	    var _this;

	    classCallCheck(this, Scalar);

	    _this = _super.call(this);
	    _this.value = value;
	    return _this;
	  }

	  createClass(Scalar, [{
	    key: "toJSON",
	    value: function toJSON$1(arg, ctx) {
	      return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      return String(this.value);
	    }
	  }]);

	  return Scalar;
	}(Node$1);

	function _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$1(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

	function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _createSuper$e(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$f()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$f() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

	function collectionFromPath(schema, path, value) {
	  var v = value;

	  for (var i = path.length - 1; i >= 0; --i) {
	    var k = path[i];
	    var o = Number.isInteger(k) && k >= 0 ? [] : {};
	    o[k] = v;
	    v = o;
	  }

	  return schema.createNode(v, false);
	} // null, undefined, or an empty non-string iterable (e.g. [])


	var isEmptyPath = function isEmptyPath(path) {
	  return path == null || _typeof_1(path) === 'object' && path[Symbol.iterator]().next().done;
	};
	var Collection$1 = /*#__PURE__*/function (_Node) {
	  inherits(Collection, _Node);

	  var _super = _createSuper$e(Collection);

	  function Collection(schema) {
	    var _this;

	    classCallCheck(this, Collection);

	    _this = _super.call(this);

	    defineProperty(assertThisInitialized(_this), "items", []);

	    _this.schema = schema;
	    return _this;
	  }

	  createClass(Collection, [{
	    key: "addIn",
	    value: function addIn(path, value) {
	      if (isEmptyPath(path)) this.add(value);else {
	        var _path = toArray(path),
	            key = _path[0],
	            rest = _path.slice(1);

	        var node = this.get(key, true);
	        if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
	      }
	    }
	  }, {
	    key: "deleteIn",
	    value: function deleteIn(_ref) {
	      var _ref2 = toArray(_ref),
	          key = _ref2[0],
	          rest = _ref2.slice(1);

	      if (rest.length === 0) return this.delete(key);
	      var node = this.get(key, true);
	      if (node instanceof Collection) return node.deleteIn(rest);else throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
	    }
	  }, {
	    key: "getIn",
	    value: function getIn(_ref3, keepScalar) {
	      var _ref4 = toArray(_ref3),
	          key = _ref4[0],
	          rest = _ref4.slice(1);

	      var node = this.get(key, true);
	      if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;
	    }
	  }, {
	    key: "hasAllNullValues",
	    value: function hasAllNullValues() {
	      return this.items.every(function (node) {
	        if (!node || node.type !== 'PAIR') return false;
	        var n = node.value;
	        return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;
	      });
	    }
	  }, {
	    key: "hasIn",
	    value: function hasIn(_ref5) {
	      var _ref6 = toArray(_ref5),
	          key = _ref6[0],
	          rest = _ref6.slice(1);

	      if (rest.length === 0) return this.has(key);
	      var node = this.get(key, true);
	      return node instanceof Collection ? node.hasIn(rest) : false;
	    }
	  }, {
	    key: "setIn",
	    value: function setIn(_ref7, value) {
	      var _ref8 = toArray(_ref7),
	          key = _ref8[0],
	          rest = _ref8.slice(1);

	      if (rest.length === 0) {
	        this.set(key, value);
	      } else {
	        var node = this.get(key, true);
	        if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
	      }
	    } // overridden in implementations

	    /* istanbul ignore next */

	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      return null;
	    }
	  }, {
	    key: "toString",
	    value: function toString(ctx, _ref9, onComment, onChompKeep) {
	      var _this2 = this;

	      var blockItem = _ref9.blockItem,
	          flowChars = _ref9.flowChars,
	          isMap = _ref9.isMap,
	          itemIndent = _ref9.itemIndent;
	      var _ctx = ctx,
	          doc = _ctx.doc,
	          indent = _ctx.indent,
	          indentStep = _ctx.indentStep;
	      var inFlow = this.type === Type.FLOW_MAP || this.type === Type.FLOW_SEQ || ctx.inFlow;
	      if (inFlow) itemIndent += indentStep;
	      var allNullValues = isMap && this.hasAllNullValues();
	      ctx = Object.assign({}, ctx, {
	        allNullValues: allNullValues,
	        indent: itemIndent,
	        inFlow: inFlow,
	        type: null
	      });
	      var chompKeep = false;
	      var hasItemWithNewLine = false;
	      var nodes = this.items.reduce(function (nodes, item, i) {
	        var comment;

	        if (item) {
	          if (!chompKeep && item.spaceBefore) nodes.push({
	            type: 'comment',
	            str: ''
	          });
	          if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(function (line) {
	            nodes.push({
	              type: 'comment',
	              str: "#".concat(line)
	            });
	          });
	          if (item.comment) comment = item.comment;
	          if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;
	        }

	        chompKeep = false;
	        var str = doc.schema.stringify(item, ctx, function () {
	          return comment = null;
	        }, function () {
	          return chompKeep = true;
	        });
	        if (inFlow && !hasItemWithNewLine && str.includes('\n')) hasItemWithNewLine = true;
	        if (inFlow && i < _this2.items.length - 1) str += ',';
	        str = addComment(str, itemIndent, comment);
	        if (chompKeep && (comment || inFlow)) chompKeep = false;
	        nodes.push({
	          type: 'item',
	          str: str
	        });
	        return nodes;
	      }, []);
	      var str;

	      if (nodes.length === 0) {
	        str = flowChars.start + flowChars.end;
	      } else if (inFlow) {
	        var start = flowChars.start,
	            end = flowChars.end;
	        var strings = nodes.map(function (n) {
	          return n.str;
	        });

	        if (hasItemWithNewLine || strings.reduce(function (sum, str) {
	          return sum + str.length + 2;
	        }, 2) > Collection.maxFlowStringSingleLineLength) {
	          str = start;

	          var _iterator = _createForOfIteratorHelper(strings),
	              _step;

	          try {
	            for (_iterator.s(); !(_step = _iterator.n()).done;) {
	              var s = _step.value;
	              str += s ? "\n".concat(indentStep).concat(indent).concat(s) : '\n';
	            }
	          } catch (err) {
	            _iterator.e(err);
	          } finally {
	            _iterator.f();
	          }

	          str += "\n".concat(indent).concat(end);
	        } else {
	          str = "".concat(start, " ").concat(strings.join(' '), " ").concat(end);
	        }
	      } else {
	        var _strings = nodes.map(blockItem);

	        str = _strings.shift();

	        var _iterator2 = _createForOfIteratorHelper(_strings),
	            _step2;

	        try {
	          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	            var _s = _step2.value;
	            str += _s ? "\n".concat(indent).concat(_s) : '\n';
	          }
	        } catch (err) {
	          _iterator2.e(err);
	        } finally {
	          _iterator2.f();
	        }
	      }

	      if (this.comment) {
	        str += '\n' + this.comment.replace(/^/gm, "".concat(indent, "#"));
	        if (onComment) onComment();
	      } else if (chompKeep && onChompKeep) onChompKeep();

	      return str;
	    }
	  }]);

	  return Collection;
	}(Node$1);

	defineProperty(Collection$1, "maxFlowStringSingleLineLength", 60);

	function _createForOfIteratorHelper$1(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$2(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

	function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _createSuper$f(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$g()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$g() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

	function asItemIndex(key) {
	  var idx = key instanceof Scalar ? key.value : key;
	  if (idx && typeof idx === 'string') idx = Number(idx);
	  return Number.isInteger(idx) && idx >= 0 ? idx : null;
	}

	var YAMLSeq = /*#__PURE__*/function (_Collection) {
	  inherits(YAMLSeq, _Collection);

	  var _super = _createSuper$f(YAMLSeq);

	  function YAMLSeq() {
	    classCallCheck(this, YAMLSeq);

	    return _super.apply(this, arguments);
	  }

	  createClass(YAMLSeq, [{
	    key: "add",
	    value: function add(value) {
	      this.items.push(value);
	    }
	  }, {
	    key: "delete",
	    value: function _delete(key) {
	      var idx = asItemIndex(key);
	      if (typeof idx !== 'number') return false;
	      var del = this.items.splice(idx, 1);
	      return del.length > 0;
	    }
	  }, {
	    key: "get",
	    value: function get(key, keepScalar) {
	      var idx = asItemIndex(key);
	      if (typeof idx !== 'number') return undefined;
	      var it = this.items[idx];
	      return !keepScalar && it instanceof Scalar ? it.value : it;
	    }
	  }, {
	    key: "has",
	    value: function has(key) {
	      var idx = asItemIndex(key);
	      return typeof idx === 'number' && idx < this.items.length;
	    }
	  }, {
	    key: "set",
	    value: function set(key, value) {
	      var idx = asItemIndex(key);
	      if (typeof idx !== 'number') throw new Error("Expected a valid index, not ".concat(key, "."));
	      this.items[idx] = value;
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON$1(_, ctx) {
	      var seq = [];
	      if (ctx && ctx.onCreate) ctx.onCreate(seq);
	      var i = 0;

	      var _iterator = _createForOfIteratorHelper$1(this.items),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var item = _step.value;
	          seq.push(toJSON(item, String(i++), ctx));
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }

	      return seq;
	    }
	  }, {
	    key: "toString",
	    value: function toString(ctx, onComment, onChompKeep) {
	      if (!ctx) return JSON.stringify(this);
	      return get$1(getPrototypeOf(YAMLSeq.prototype), "toString", this).call(this, ctx, {
	        blockItem: function blockItem(n) {
	          return n.type === 'comment' ? n.str : "- ".concat(n.str);
	        },
	        flowChars: {
	          start: '[',
	          end: ']'
	        },
	        isMap: false,
	        itemIndent: (ctx.indent || '') + '  '
	      }, onComment, onChompKeep);
	    }
	  }]);

	  return YAMLSeq;
	}(Collection$1);

	function _createSuper$g(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$h()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$h() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

	var stringifyKey = function stringifyKey(key, jsKey, ctx) {
	  if (jsKey === null) return '';
	  if (_typeof_1(jsKey) !== 'object') return String(jsKey);
	  if (key instanceof Node$1 && ctx && ctx.doc) return key.toString({
	    anchors: {},
	    doc: ctx.doc,
	    indent: '',
	    indentStep: ctx.indentStep,
	    inFlow: true,
	    inStringifyKey: true
	  });
	  return JSON.stringify(jsKey);
	};

	var Pair = /*#__PURE__*/function (_Node) {
	  inherits(Pair, _Node);

	  var _super = _createSuper$g(Pair);

	  function Pair(key) {
	    var _this;

	    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	    classCallCheck(this, Pair);

	    _this = _super.call(this);
	    _this.key = key;
	    _this.value = value;
	    _this.type = Pair.Type.PAIR;
	    return _this;
	  }

	  createClass(Pair, [{
	    key: "addToJSMap",
	    value: function addToJSMap(ctx, map) {
	      var key = toJSON(this.key, '', ctx);

	      if (map instanceof Map) {
	        var value = toJSON(this.value, key, ctx);
	        map.set(key, value);
	      } else if (map instanceof Set) {
	        map.add(key);
	      } else {
	        var stringKey = stringifyKey(this.key, key, ctx);
	        map[stringKey] = toJSON(this.value, stringKey, ctx);
	      }

	      return map;
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON(_, ctx) {
	      var pair = ctx && ctx.mapAsMap ? new Map() : {};
	      return this.addToJSMap(ctx, pair);
	    }
	  }, {
	    key: "toString",
	    value: function toString(ctx, onComment, onChompKeep) {
	      if (!ctx || !ctx.doc) return JSON.stringify(this);
	      var _ctx$doc$options = ctx.doc.options,
	          indentSize = _ctx$doc$options.indent,
	          indentSeq = _ctx$doc$options.indentSeq,
	          simpleKeys = _ctx$doc$options.simpleKeys;
	      var key = this.key,
	          value = this.value;
	      var keyComment = key instanceof Node$1 && key.comment;

	      if (simpleKeys) {
	        if (keyComment) {
	          throw new Error('With simple keys, key nodes cannot have comments');
	        }

	        if (key instanceof Collection$1) {
	          var msg = 'With simple keys, collection cannot be used as a key value';
	          throw new Error(msg);
	        }
	      }

	      var explicitKey = !simpleKeys && (!key || keyComment || key instanceof Collection$1 || key.type === Type.BLOCK_FOLDED || key.type === Type.BLOCK_LITERAL);
	      var _ctx = ctx,
	          doc = _ctx.doc,
	          indent = _ctx.indent,
	          indentStep = _ctx.indentStep;
	      ctx = Object.assign({}, ctx, {
	        implicitKey: !explicitKey,
	        indent: indent + indentStep
	      });
	      var chompKeep = false;
	      var str = doc.schema.stringify(key, ctx, function () {
	        return keyComment = null;
	      }, function () {
	        return chompKeep = true;
	      });
	      str = addComment(str, ctx.indent, keyComment);

	      if (ctx.allNullValues && !simpleKeys) {
	        if (this.comment) {
	          str = addComment(str, ctx.indent, this.comment);
	          if (onComment) onComment();
	        } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();

	        return ctx.inFlow ? str : "? ".concat(str);
	      }

	      str = explicitKey ? "? ".concat(str, "\n").concat(indent, ":") : "".concat(str, ":");

	      if (this.comment) {
	        // expected (but not strictly required) to be a single-line comment
	        str = addComment(str, ctx.indent, this.comment);
	        if (onComment) onComment();
	      }

	      var vcb = '';
	      var valueComment = null;

	      if (value instanceof Node$1) {
	        if (value.spaceBefore) vcb = '\n';

	        if (value.commentBefore) {
	          var cs = value.commentBefore.replace(/^/gm, "".concat(ctx.indent, "#"));
	          vcb += "\n".concat(cs);
	        }

	        valueComment = value.comment;
	      } else if (value && _typeof_1(value) === 'object') {
	        value = doc.schema.createNode(value, true);
	      }

	      ctx.implicitKey = false;
	      if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;
	      chompKeep = false;

	      if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
	        // If indentSeq === false, consider '- ' as part of indentation where possible
	        ctx.indent = ctx.indent.substr(2);
	      }

	      var valueStr = doc.schema.stringify(value, ctx, function () {
	        return valueComment = null;
	      }, function () {
	        return chompKeep = true;
	      });
	      var ws = ' ';

	      if (vcb || this.comment) {
	        ws = "".concat(vcb, "\n").concat(ctx.indent);
	      } else if (!explicitKey && value instanceof Collection$1) {
	        var flow = valueStr[0] === '[' || valueStr[0] === '{';
	        if (!flow || valueStr.includes('\n')) ws = "\n".concat(ctx.indent);
	      }

	      if (chompKeep && !valueComment && onChompKeep) onChompKeep();
	      return addComment(str + ws + valueStr, ctx.indent, valueComment);
	    }
	  }, {
	    key: "commentBefore",
	    get: function get() {
	      return this.key && this.key.commentBefore;
	    },
	    set: function set(cb) {
	      if (this.key == null) this.key = new Scalar(null);
	      this.key.commentBefore = cb;
	    }
	  }]);

	  return Pair;
	}(Node$1);

	defineProperty(Pair, "Type", {
	  PAIR: 'PAIR',
	  MERGE_PAIR: 'MERGE_PAIR'
	});

	function _createSuper$h(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$i()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$i() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

	function _createForOfIteratorHelper$2(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$3(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

	function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	var getAliasCount = function getAliasCount(node, anchors) {
	  if (node instanceof Alias$1) {
	    var anchor = anchors.get(node.source);
	    return anchor.count * anchor.aliasCount;
	  } else if (node instanceof Collection$1) {
	    var count = 0;

	    var _iterator = _createForOfIteratorHelper$2(node.items),
	        _step;

	    try {
	      for (_iterator.s(); !(_step = _iterator.n()).done;) {
	        var item = _step.value;
	        var c = getAliasCount(item, anchors);
	        if (c > count) count = c;
	      }
	    } catch (err) {
	      _iterator.e(err);
	    } finally {
	      _iterator.f();
	    }

	    return count;
	  } else if (node instanceof Pair) {
	    var kc = getAliasCount(node.key, anchors);
	    var vc = getAliasCount(node.value, anchors);
	    return Math.max(kc, vc);
	  }

	  return 1;
	};

	var Alias$1 = /*#__PURE__*/function (_Node) {
	  inherits(Alias, _Node);

	  var _super = _createSuper$h(Alias);

	  createClass(Alias, null, [{
	    key: "stringify",
	    value: function stringify(_ref, _ref2) {
	      var range = _ref.range,
	          source = _ref.source;
	      var anchors = _ref2.anchors,
	          doc = _ref2.doc,
	          implicitKey = _ref2.implicitKey,
	          inStringifyKey = _ref2.inStringifyKey;
	      var anchor = Object.keys(anchors).find(function (a) {
	        return anchors[a] === source;
	      });
	      if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();
	      if (anchor) return "*".concat(anchor).concat(implicitKey ? ' ' : '');
	      var msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';
	      throw new Error("".concat(msg, " [").concat(range, "]"));
	    }
	  }]);

	  function Alias(source) {
	    var _this;

	    classCallCheck(this, Alias);

	    _this = _super.call(this);
	    _this.source = source;
	    _this.type = Type.ALIAS;
	    return _this;
	  }

	  createClass(Alias, [{
	    key: "toJSON",
	    value: function toJSON$1(arg, ctx) {
	      if (!ctx) return toJSON(this.source, arg, ctx);
	      var anchors = ctx.anchors,
	          maxAliasCount = ctx.maxAliasCount;
	      var anchor = anchors.get(this.source);
	      /* istanbul ignore if */

	      if (!anchor || anchor.res === undefined) {
	        var msg = 'This should not happen: Alias anchor was not resolved?';
	        if (this.cstNode) throw new YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);
	      }

	      if (maxAliasCount >= 0) {
	        anchor.count += 1;
	        if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);

	        if (anchor.count * anchor.aliasCount > maxAliasCount) {
	          var _msg = 'Excessive alias count indicates a resource exhaustion attack';
	          if (this.cstNode) throw new YAMLReferenceError(this.cstNode, _msg);else throw new ReferenceError(_msg);
	        }
	      }

	      return anchor.res;
	    } // Only called when stringifying an alias mapping key while constructing
	    // Object output.

	  }, {
	    key: "toString",
	    value: function toString(ctx) {
	      return Alias.stringify(this, ctx);
	    }
	  }, {
	    key: "tag",
	    set: function set(t) {
	      throw new Error('Alias nodes cannot have tags');
	    }
	  }]);

	  return Alias;
	}(Node$1);

	defineProperty(Alias$1, "default", true);

	function _createSuper$i(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$j()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$j() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

	function _createForOfIteratorHelper$3(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$4(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }

	function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	function findPair(items, key) {
	  var k = key instanceof Scalar ? key.value : key;

	  var _iterator = _createForOfIteratorHelper$3(items),
	      _step;

	  try {
	    for (_iterator.s(); !(_step = _iterator.n()).done;) {
	      var it = _step.value;

	      if (it instanceof Pair) {
	        if (it.key === key || it.key === k) return it;
	        if (it.key && it.key.value === k) return it;
	      }
	    }
	  } catch (err) {
	    _iterator.e(err);
	  } finally {
	    _iterator.f();
	  }

	  return undefined;
	}
	var YAMLMap = /*#__PURE__*/function (_Collection) {
	  inherits(YAMLMap, _Collection);

	  var _super = _createSuper$i(YAMLMap);

	  function YAMLMap() {
	    classCallCheck(this, YAMLMap);

	    return _super.apply(this, arguments);
	  }

	  createClass(YAMLMap, [{
	    key: "add",
	    value: function add(pair, overwrite) {
	      if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);
	      var prev = findPair(this.items, pair.key);
	      var sortEntries = this.schema && this.schema.sortMapEntries;

	      if (prev) {
	        if (overwrite) prev.value = pair.value;else throw new Error("Key ".concat(pair.key, " already set"));
	      } else if (sortEntries) {
	        var i = this.items.findIndex(function (item) {
	          return sortEntries(pair, item) < 0;
	        });
	        if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);
	      } else {
	        this.items.push(pair);
	      }
	    }
	  }, {
	    key: "delete",
	    value: function _delete(key) {
	      var it = findPair(this.items, key);
	      if (!it) return false;
	      var del = this.items.splice(this.items.indexOf(it), 1);
	      return del.length > 0;
	    }
	  }, {
	    key: "get",
	    value: function get(key, keepScalar) {
	      var it = findPair(this.items, key);
	      var node = it && it.value;
	      return !keepScalar && node instanceof Scalar ? node.value : node;
	    }
	  }, {
	    key: "has",
	    value: function has(key) {
	      return !!findPair(this.items, key);
	    }
	  }, {
	    key: "set",
	    value: function set(key, value) {
	      this.add(new Pair(key, value), true);
	    }
	    /**
	     * @param {*} arg ignored
	     * @param {*} ctx Conversion context, originally set in Document#toJSON()
	     * @param {Class} Type If set, forces the returned collection type
	     * @returns {*} Instance of Type, Map, or Object
	     */

	  }, {
	    key: "toJSON",
	    value: function toJSON(_, ctx, Type) {
	      var map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};
	      if (ctx && ctx.onCreate) ctx.onCreate(map);

	      var _iterator2 = _createForOfIteratorHelper$3(this.items),
	          _step2;

	      try {
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          var item = _step2.value;
	          item.addToJSMap(ctx, map);
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }

	      return map;
	    }
	  }, {
	    key: "toString",
	    value: function toString(ctx, onComment, onChompKeep) {
	      if (!ctx) return JSON.stringify(this);

	      var _iterator3 = _createForOfIteratorHelper$3(this.items),
	          _step3;

	      try {
	        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	          var item = _step3.value;
	          if (!(item instanceof Pair)) throw new Error("Map items must all be pairs; found ".concat(JSON.stringify(item), " instead"));
	        }
	      } catch (err) {
	        _iterator3.e(err);
	      } finally {
	        _iterator3.f();
	      }

	      return get$1(getPrototypeOf(YAMLMap.prototype), "toString", this).call(this, ctx, {
	        blockItem: function blockItem(n) {
	          return n.str;
	        },
	        flowChars: {
	          start: '{',
	          end: '}'
	        },
	        isMap: true,
	        itemIndent: ctx.indent || ''
	      }, onComment, onChompKeep);
	    }
	  }]);

	  return YAMLMap;
	}(Collection$1);

	function _createForOfIteratorHelper$4(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$5(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }

	function _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _createSuper$j(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$k()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$k() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var MERGE_KEY = '<<';
	var Merge = /*#__PURE__*/function (_Pair) {
	  inherits(Merge, _Pair);

	  var _super = _createSuper$j(Merge);

	  function Merge(pair) {
	    var _this;

	    classCallCheck(this, Merge);

	    if (pair instanceof Pair) {
	      var seq = pair.value;

	      if (!(seq instanceof YAMLSeq)) {
	        seq = new YAMLSeq();
	        seq.items.push(pair.value);
	        seq.range = pair.value.range;
	      }

	      _this = _super.call(this, pair.key, seq);
	      _this.range = pair.range;
	    } else {
	      _this = _super.call(this, new Scalar(MERGE_KEY), new YAMLSeq());
	    }

	    _this.type = Pair.Type.MERGE_PAIR;
	    return possibleConstructorReturn(_this);
	  } // If the value associated with a merge key is a single mapping node, each of
	  // its key/value pairs is inserted into the current mapping, unless the key
	  // already exists in it. If the value associated with the merge key is a
	  // sequence, then this sequence is expected to contain mapping nodes and each
	  // of these nodes is merged in turn according to its order in the sequence.
	  // Keys in mapping nodes earlier in the sequence override keys specified in
	  // later mapping nodes. -- http://yaml.org/type/merge.html


	  createClass(Merge, [{
	    key: "addToJSMap",
	    value: function addToJSMap(ctx, map) {
	      var _iterator = _createForOfIteratorHelper$4(this.value.items),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var source = _step.value.source;
	          if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');
	          var srcMap = source.toJSON(null, ctx, Map);

	          var _iterator2 = _createForOfIteratorHelper$4(srcMap),
	              _step2;

	          try {
	            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	              var _step2$value = slicedToArray(_step2.value, 2),
	                  key = _step2$value[0],
	                  value = _step2$value[1];

	              if (map instanceof Map) {
	                if (!map.has(key)) map.set(key, value);
	              } else if (map instanceof Set) {
	                map.add(key);
	              } else {
	                if (!Object.prototype.hasOwnProperty.call(map, key)) map[key] = value;
	              }
	            }
	          } catch (err) {
	            _iterator2.e(err);
	          } finally {
	            _iterator2.f();
	          }
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }

	      return map;
	    }
	  }, {
	    key: "toString",
	    value: function toString(ctx, onComment) {
	      var seq = this.value;
	      if (seq.items.length > 1) return get$1(getPrototypeOf(Merge.prototype), "toString", this).call(this, ctx, onComment);
	      this.value = seq.items[0];

	      var str = get$1(getPrototypeOf(Merge.prototype), "toString", this).call(this, ctx, onComment);

	      this.value = seq;
	      return str;
	    }
	  }]);

	  return Merge;
	}(Pair);

	var Anchors = /*#__PURE__*/function () {
	  createClass(Anchors, null, [{
	    key: "validAnchorNode",
	    value: function validAnchorNode(node) {
	      return node instanceof Scalar || node instanceof YAMLSeq || node instanceof YAMLMap;
	    }
	  }]);

	  function Anchors(prefix) {
	    classCallCheck(this, Anchors);

	    defineProperty(this, "map", {});

	    this.prefix = prefix;
	  }

	  createClass(Anchors, [{
	    key: "createAlias",
	    value: function createAlias(node, name) {
	      this.setAnchor(node, name);
	      return new Alias$1(node);
	    }
	  }, {
	    key: "createMergePair",
	    value: function createMergePair() {
	      var _this = this;

	      var merge = new Merge();

	      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
	        sources[_key] = arguments[_key];
	      }

	      merge.value.items = sources.map(function (s) {
	        if (s instanceof Alias$1) {
	          if (s.source instanceof YAMLMap) return s;
	        } else if (s instanceof YAMLMap) {
	          return _this.createAlias(s);
	        }

	        throw new Error('Merge sources must be Map nodes or their Aliases');
	      });
	      return merge;
	    }
	  }, {
	    key: "getName",
	    value: function getName(node) {
	      var map = this.map;
	      return Object.keys(map).find(function (a) {
	        return map[a] === node;
	      });
	    }
	  }, {
	    key: "getNode",
	    value: function getNode(name) {
	      return this.map[name];
	    }
	  }, {
	    key: "newName",
	    value: function newName(prefix) {
	      if (!prefix) prefix = this.prefix;
	      var names = Object.keys(this.map);

	      for (var i = 1; true; ++i) {
	        var name = "".concat(prefix).concat(i);
	        if (!names.includes(name)) return name;
	      }
	    } // During parsing, map & aliases contain CST nodes

	  }, {
	    key: "resolveNodes",
	    value: function resolveNodes() {
	      var map = this.map,
	          _cstAliases = this._cstAliases;
	      Object.keys(map).forEach(function (a) {
	        map[a] = map[a].resolved;
	      });

	      _cstAliases.forEach(function (a) {
	        a.source = a.source.resolved;
	      });

	      delete this._cstAliases;
	    }
	  }, {
	    key: "setAnchor",
	    value: function setAnchor(node, name) {
	      if (node != null && !Anchors.validAnchorNode(node)) {
	        throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');
	      }

	      if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
	        throw new Error('Anchor names must not contain whitespace or control characters');
	      }

	      var map = this.map;
	      var prev = node && Object.keys(map).find(function (a) {
	        return map[a] === node;
	      });

	      if (prev) {
	        if (!name) {
	          return prev;
	        } else if (prev !== name) {
	          delete map[prev];
	          map[name] = node;
	        }
	      } else {
	        if (!name) {
	          if (!node) return null;
	          name = this.newName();
	        }

	        map[name] = node;
	      }

	      return name;
	    }
	  }]);

	  return Anchors;
	}();

	var visit = function visit(node, tags) {
	  if (node && _typeof_1(node) === 'object') {
	    var tag = node.tag;

	    if (node instanceof Collection$1) {
	      if (tag) tags[tag] = true;
	      node.items.forEach(function (n) {
	        return visit(n, tags);
	      });
	    } else if (node instanceof Pair) {
	      visit(node.key, tags);
	      visit(node.value, tags);
	    } else if (node instanceof Scalar) {
	      if (tag) tags[tag] = true;
	    }
	  }

	  return tags;
	};

	var listTagNames = function listTagNames(node) {
	  return Object.keys(visit(node, {}));
	};

	/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */
	function shouldWarn(deprecation) {
	  var env = typeof process !== 'undefined' && process.env || {};

	  if (deprecation) {
	    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;
	    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
	  }

	  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;
	  return !env.YAML_SILENCE_WARNINGS;
	}

	function warn(warning, type) {
	  if (shouldWarn(false)) {
	    var emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to
	    // https://github.com/facebook/jest/issues/2549

	    if (emit) emit(warning, type);else {
	      // eslint-disable-next-line no-console
	      console.warn(type ? "".concat(type, ": ").concat(warning) : warning);
	    }
	  }
	}
	var warned = {};
	function warnOptionDeprecation(name, alternative) {
	  if (!warned[name] && shouldWarn(true)) {
	    warned[name] = true;
	    var msg = "The option '".concat(name, "' will be removed in a future release");
	    msg += alternative ? ", use '".concat(alternative, "' instead.") : '.';
	    warn(msg, 'DeprecationWarning');
	  }
	}

	var FOLD_FLOW = 'flow';
	var FOLD_BLOCK = 'block';
	var FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line
	// returns index of last newline in more-indented block

	var consumeMoreIndentedLines = function consumeMoreIndentedLines(text, i) {
	  var ch = text[i + 1];

	  while (ch === ' ' || ch === '\t') {
	    do {
	      ch = text[i += 1];
	    } while (ch && ch !== '\n');

	    ch = text[i + 1];
	  }

	  return i;
	};
	/**
	 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
	 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
	 * terminated with `\n` and started with `indent`.
	 *
	 * @param {string} text
	 * @param {string} indent
	 * @param {string} [mode='flow'] `'block'` prevents more-indented lines
	 *   from being folded; `'quoted'` allows for `\` escapes, including escaped
	 *   newlines
	 * @param {Object} options
	 * @param {number} [options.indentAtStart] Accounts for leading contents on
	 *   the first line, defaulting to `indent.length`
	 * @param {number} [options.lineWidth=80]
	 * @param {number} [options.minContentWidth=20] Allow highly indented lines to
	 *   stretch the line width
	 * @param {function} options.onFold Called once if the text is folded
	 * @param {function} options.onFold Called once if any line of text exceeds
	 *   lineWidth characters
	 */


	function foldFlowLines(text, indent, mode, _ref) {
	  var indentAtStart = _ref.indentAtStart,
	      _ref$lineWidth = _ref.lineWidth,
	      lineWidth = _ref$lineWidth === void 0 ? 80 : _ref$lineWidth,
	      _ref$minContentWidth = _ref.minContentWidth,
	      minContentWidth = _ref$minContentWidth === void 0 ? 20 : _ref$minContentWidth,
	      onFold = _ref.onFold,
	      onOverflow = _ref.onOverflow;
	  if (!lineWidth || lineWidth < 0) return text;
	  var endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
	  if (text.length <= endStep) return text;
	  var folds = [];
	  var escapedFolds = {};
	  var end = lineWidth - (typeof indentAtStart === 'number' ? indentAtStart : indent.length);
	  var split = undefined;
	  var prev = undefined;
	  var overflow = false;
	  var i = -1;

	  if (mode === FOLD_BLOCK) {
	    i = consumeMoreIndentedLines(text, i);
	    if (i !== -1) end = i + endStep;
	  }

	  for (var ch; ch = text[i += 1];) {
	    if (mode === FOLD_QUOTED && ch === '\\') {
	      switch (text[i + 1]) {
	        case 'x':
	          i += 3;
	          break;

	        case 'u':
	          i += 5;
	          break;

	        case 'U':
	          i += 9;
	          break;

	        default:
	          i += 1;
	      }
	    }

	    if (ch === '\n') {
	      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);
	      end = i + endStep;
	      split = undefined;
	    } else {
	      if (ch === ' ' && prev && prev !== ' ' && prev !== '\n' && prev !== '\t') {
	        // space surrounded by non-space can be replaced with newline + indent
	        var next = text[i + 1];
	        if (next && next !== ' ' && next !== '\n' && next !== '\t') split = i;
	      }

	      if (i >= end) {
	        if (split) {
	          folds.push(split);
	          end = split + endStep;
	          split = undefined;
	        } else if (mode === FOLD_QUOTED) {
	          // white-space collected at end may stretch past lineWidth
	          while (prev === ' ' || prev === '\t') {
	            prev = ch;
	            ch = text[i += 1];
	            overflow = true;
	          } // i - 2 accounts for not-dropped last char + newline-escaping \


	          folds.push(i - 2);
	          escapedFolds[i - 2] = true;
	          end = i - 2 + endStep;
	          split = undefined;
	        } else {
	          overflow = true;
	        }
	      }
	    }

	    prev = ch;
	  }

	  if (overflow && onOverflow) onOverflow();
	  if (folds.length === 0) return text;
	  if (onFold) onFold();
	  var res = text.slice(0, folds[0]);

	  for (var _i = 0; _i < folds.length; ++_i) {
	    var fold = folds[_i];

	    var _end = folds[_i + 1] || text.length;

	    if (mode === FOLD_QUOTED && escapedFolds[fold]) res += "".concat(text[fold], "\\");
	    res += "\n".concat(indent).concat(text.slice(fold + 1, _end));
	  }

	  return res;
	}

	var binaryOptions = {
	  defaultType: Type.BLOCK_LITERAL,
	  lineWidth: 76
	};
	var boolOptions = {
	  trueStr: 'true',
	  falseStr: 'false'
	};
	var intOptions = {
	  asBigInt: false
	};
	var nullOptions = {
	  nullStr: 'null'
	};
	var strOptions = {
	  defaultType: Type.PLAIN,
	  doubleQuoted: {
	    jsonEncoding: false,
	    minMultiLineLength: 40
	  },
	  fold: {
	    lineWidth: 80,
	    minContentWidth: 20
	  }
	};

	var getFoldOptions = function getFoldOptions(_ref) {
	  var indentAtStart = _ref.indentAtStart;
	  return indentAtStart ? Object.assign({
	    indentAtStart: indentAtStart
	  }, strOptions.fold) : strOptions.fold;
	};

	function stringifyNumber(_ref2) {
	  var format = _ref2.format,
	      minFractionDigits = _ref2.minFractionDigits,
	      tag = _ref2.tag,
	      value = _ref2.value;
	  if (typeof value === 'bigint') return String(value);
	  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';
	  var n = JSON.stringify(value);

	  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\d/.test(n)) {
	    var i = n.indexOf('.');

	    if (i < 0) {
	      i = n.length;
	      n += '.';
	    }

	    var d = minFractionDigits - (n.length - i - 1);

	    while (d-- > 0) {
	      n += '0';
	    }
	  }

	  return n;
	}

	function lineLengthOverLimit(str, limit) {
	  var strLen = str.length;
	  if (strLen <= limit) return false;

	  for (var i = 0, start = 0; i < strLen; ++i) {
	    if (str[i] === '\n') {
	      if (i - start > limit) return true;
	      start = i + 1;
	      if (strLen - start <= limit) return false;
	    }
	  }

	  return true;
	}

	function doubleQuotedString(value, ctx) {
	  var implicitKey = ctx.implicitKey,
	      indent = ctx.indent;
	  var _strOptions$doubleQuo = strOptions.doubleQuoted,
	      jsonEncoding = _strOptions$doubleQuo.jsonEncoding,
	      minMultiLineLength = _strOptions$doubleQuo.minMultiLineLength;
	  var json = JSON.stringify(value);
	  if (jsonEncoding) return json;
	  var str = '';
	  var start = 0;

	  for (var i = 0, ch = json[i]; ch; ch = json[++i]) {
	    if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
	      // space before newline needs to be escaped to not be folded
	      str += json.slice(start, i) + '\\ ';
	      i += 1;
	      start = i;
	      ch = '\\';
	    }

	    if (ch === '\\') switch (json[i + 1]) {
	      case 'u':
	        {
	          str += json.slice(start, i);
	          var code = json.substr(i + 2, 4);

	          switch (code) {
	            case '0000':
	              str += '\\0';
	              break;

	            case '0007':
	              str += '\\a';
	              break;

	            case '000b':
	              str += '\\v';
	              break;

	            case '001b':
	              str += '\\e';
	              break;

	            case '0085':
	              str += '\\N';
	              break;

	            case '00a0':
	              str += '\\_';
	              break;

	            case '2028':
	              str += '\\L';
	              break;

	            case '2029':
	              str += '\\P';
	              break;

	            default:
	              if (code.substr(0, 2) === '00') str += '\\x' + code.substr(2);else str += json.substr(i, 6);
	          }

	          i += 5;
	          start = i + 1;
	        }
	        break;

	      case 'n':
	        if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
	          i += 1;
	        } else {
	          // folding will eat first newline
	          str += json.slice(start, i) + '\n\n';

	          while (json[i + 2] === '\\' && json[i + 3] === 'n' && json[i + 4] !== '"') {
	            str += '\n';
	            i += 2;
	          }

	          str += indent; // space after newline needs to be escaped to not be folded

	          if (json[i + 2] === ' ') str += '\\';
	          i += 1;
	          start = i + 1;
	        }

	        break;

	      default:
	        i += 1;
	    }
	  }

	  str = start ? str + json.slice(start) : json;
	  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
	}

	function singleQuotedString(value, ctx) {
	  var indent = ctx.indent,
	      implicitKey = ctx.implicitKey;

	  if (implicitKey) {
	    if (/\n/.test(value)) return doubleQuotedString(value, ctx);
	  } else {
	    // single quoted string can't have leading or trailing whitespace around newline
	    if (/[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
	  }

	  var res = "'" + value.replace(/'/g, "''").replace(/\n+/g, "$&\n".concat(indent)) + "'";
	  return implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
	}

	function blockString(_ref3, ctx, onComment, onChompKeep) {
	  var comment = _ref3.comment,
	      type = _ref3.type,
	      value = _ref3.value;

	  // 1. Block can't end in whitespace unless the last line is non-empty.
	  // 2. Strings consisting of only whitespace are best rendered explicitly.
	  if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
	    return doubleQuotedString(value, ctx);
	  }

	  var indent = ctx.indent || (ctx.forceBlockIndent ? ' ' : '');
	  var indentSize = indent ? '2' : '1'; // root is at -1

	  var literal = type === Type.BLOCK_FOLDED ? false : type === Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth - indent.length);
	  var header = literal ? '|' : '>';
	  if (!value) return header + '\n';
	  var wsStart = '';
	  var wsEnd = '';
	  value = value.replace(/[\n\t ]*$/, function (ws) {
	    var n = ws.indexOf('\n');

	    if (n === -1) {
	      header += '-'; // strip
	    } else if (value === ws || n !== ws.length - 1) {
	      header += '+'; // keep

	      if (onChompKeep) onChompKeep();
	    }

	    wsEnd = ws.replace(/\n$/, '');
	    return '';
	  }).replace(/^[\n ]*/, function (ws) {
	    if (ws.indexOf(' ') !== -1) header += indentSize;
	    var m = ws.match(/ +$/);

	    if (m) {
	      wsStart = ws.slice(0, -m[0].length);
	      return m[0];
	    } else {
	      wsStart = ws;
	      return '';
	    }
	  });
	  if (wsEnd) wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, "$&".concat(indent));
	  if (wsStart) wsStart = wsStart.replace(/\n+/g, "$&".concat(indent));

	  if (comment) {
	    header += ' #' + comment.replace(/ ?[\r\n]+/g, ' ');
	    if (onComment) onComment();
	  }

	  if (!value) return "".concat(header).concat(indentSize, "\n").concat(indent).concat(wsEnd);

	  if (literal) {
	    value = value.replace(/\n+/g, "$&".concat(indent));
	    return "".concat(header, "\n").concat(indent).concat(wsStart).concat(value).concat(wsEnd);
	  }

	  value = value.replace(/\n+/g, '\n$&').replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
	  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent
	  .replace(/\n+/g, "$&".concat(indent));
	  var body = foldFlowLines("".concat(wsStart).concat(value).concat(wsEnd), indent, FOLD_BLOCK, strOptions.fold);
	  return "".concat(header, "\n").concat(indent).concat(body);
	}

	function plainString(item, ctx, onComment, onChompKeep) {
	  var comment = item.comment,
	      type = item.type,
	      value = item.value;
	  var actualString = ctx.actualString,
	      implicitKey = ctx.implicitKey,
	      indent = ctx.indent,
	      inFlow = ctx.inFlow,
	      tags = ctx.tags;

	  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
	    return doubleQuotedString(value, ctx);
	  }

	  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
	    // not allowed:
	    // - empty string, '-' or '?'
	    // - start with an indicator character (except [?:-]) or /[?-] /
	    // - '\n ', ': ' or ' \n' anywhere
	    // - '#' not preceded by a non-space char
	    // - end with ' ' or ':'
	    return implicitKey || inFlow || value.indexOf('\n') === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
	  }

	  if (!implicitKey && !inFlow && type !== Type.PLAIN && value.indexOf('\n') !== -1) {
	    // Where allowed & type not set explicitly, prefer block style for multiline strings
	    return blockString(item, ctx, onComment, onChompKeep);
	  }

	  var str = value.replace(/\n+/g, "$&\n".concat(indent)); // Verify that output will be parsed as a string, as e.g. plain numbers and
	  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
	  // and others in v1.1.

	  if (actualString && typeof tags.resolveScalar(str).value !== 'string') {
	    return doubleQuotedString(value, ctx);
	  }

	  var body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));

	  if (comment && !inFlow && (body.indexOf('\n') !== -1 || comment.indexOf('\n') !== -1)) {
	    if (onComment) onComment();
	    return addCommentBefore(body, indent, comment);
	  }

	  return body;
	}

	function stringifyString(item, ctx, onComment, onChompKeep) {
	  var defaultType = strOptions.defaultType;
	  var implicitKey = ctx.implicitKey,
	      inFlow = ctx.inFlow;
	  var _item = item,
	      type = _item.type,
	      value = _item.value;

	  if (typeof value !== 'string') {
	    value = String(value);
	    item = Object.assign({}, item, {
	      value: value
	    });
	  }

	  var _stringify = function _stringify(_type) {
	    switch (_type) {
	      case Type.BLOCK_FOLDED:
	      case Type.BLOCK_LITERAL:
	        return blockString(item, ctx, onComment, onChompKeep);

	      case Type.QUOTE_DOUBLE:
	        return doubleQuotedString(value, ctx);

	      case Type.QUOTE_SINGLE:
	        return singleQuotedString(value, ctx);

	      case Type.PLAIN:
	        return plainString(item, ctx, onComment, onChompKeep);

	      default:
	        return null;
	    }
	  };

	  if (type !== Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
	    // force double quotes on control characters
	    type = Type.QUOTE_DOUBLE;
	  } else if ((implicitKey || inFlow) && (type === Type.BLOCK_FOLDED || type === Type.BLOCK_LITERAL)) {
	    // should not happen; blocks are not valid inside flow containers
	    type = Type.QUOTE_DOUBLE;
	  }

	  var res = _stringify(type);

	  if (res === null) {
	    res = _stringify(defaultType);
	    if (res === null) throw new Error("Unsupported default string type ".concat(defaultType));
	  }

	  return res;
	}

	function _createForOfIteratorHelper$5(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$6(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$6(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$6(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }

	function _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	function checkFlowCollectionEnd(errors, cst) {
	  var char, name;

	  switch (cst.type) {
	    case Type.FLOW_MAP:
	      char = '}';
	      name = 'flow map';
	      break;

	    case Type.FLOW_SEQ:
	      char = ']';
	      name = 'flow sequence';
	      break;

	    default:
	      errors.push(new YAMLSemanticError(cst, 'Not a flow collection!?'));
	      return;
	  }

	  var lastItem;

	  for (var i = cst.items.length - 1; i >= 0; --i) {
	    var item = cst.items[i];

	    if (!item || item.type !== Type.COMMENT) {
	      lastItem = item;
	      break;
	    }
	  }

	  if (lastItem && lastItem.char !== char) {
	    var msg = "Expected ".concat(name, " to end with ").concat(char);
	    var err;

	    if (typeof lastItem.offset === 'number') {
	      err = new YAMLSemanticError(cst, msg);
	      err.offset = lastItem.offset + 1;
	    } else {
	      err = new YAMLSemanticError(lastItem, msg);
	      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;
	    }

	    errors.push(err);
	  }
	}
	function checkKeyLength(errors, node, itemIdx, key, keyStart) {
	  if (!key || typeof keyStart !== 'number') return;
	  var item = node.items[itemIdx];
	  var keyEnd = item && item.range && item.range.start;

	  if (!keyEnd) {
	    for (var i = itemIdx - 1; i >= 0; --i) {
	      var it = node.items[i];

	      if (it && it.range) {
	        keyEnd = it.range.end + 2 * (itemIdx - i);
	        break;
	      }
	    }
	  }

	  if (keyEnd > keyStart + 1024) {
	    var k = String(key).substr(0, 8) + '...' + String(key).substr(-8);
	    errors.push(new YAMLSemanticError(node, "The \"".concat(k, "\" key is too long")));
	  }
	}
	function resolveComments(collection, comments) {
	  var _iterator = _createForOfIteratorHelper$5(comments),
	      _step;

	  try {
	    for (_iterator.s(); !(_step = _iterator.n()).done;) {
	      var _step$value = _step.value,
	          afterKey = _step$value.afterKey,
	          before = _step$value.before,
	          comment = _step$value.comment;
	      var item = collection.items[before];

	      if (!item) {
	        if (comment !== undefined) {
	          if (collection.comment) collection.comment += '\n' + comment;else collection.comment = comment;
	        }
	      } else {
	        if (afterKey && item.value) item = item.value;

	        if (comment === undefined) {
	          if (afterKey || !item.commentBefore) item.spaceBefore = true;
	        } else {
	          if (item.commentBefore) item.commentBefore += '\n' + comment;else item.commentBefore = comment;
	        }
	      }
	    }
	  } catch (err) {
	    _iterator.e(err);
	  } finally {
	    _iterator.f();
	  }
	}

	function parseMap(doc, cst) {
	  if (cst.type !== Type.MAP && cst.type !== Type.FLOW_MAP) {
	    var msg = "A ".concat(cst.type, " node cannot be resolved as a mapping");
	    doc.errors.push(new YAMLSyntaxError(cst, msg));
	    return null;
	  }

	  var _ref = cst.type === Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst),
	      comments = _ref.comments,
	      items = _ref.items;

	  var map = new YAMLMap();
	  map.items = items;
	  resolveComments(map, comments);
	  var hasCollectionKey = false;

	  for (var i = 0; i < items.length; ++i) {
	    var iKey = items[i].key;
	    if (iKey instanceof Collection$1) hasCollectionKey = true;

	    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
	      items[i] = new Merge(items[i]);
	      var sources = items[i].value.items;
	      var error = null;
	      sources.some(function (node) {
	        if (node instanceof Alias$1) {
	          // During parsing, alias sources are CST nodes; to account for
	          // circular references their resolved values can't be used here.
	          var type = node.source.type;
	          if (type === Type.MAP || type === Type.FLOW_MAP) return false;
	          return error = 'Merge nodes aliases can only point to maps';
	        }

	        return error = 'Merge nodes can only have Alias nodes as values';
	      });
	      if (error) doc.errors.push(new YAMLSemanticError(cst, error));
	    } else {
	      for (var j = i + 1; j < items.length; ++j) {
	        var jKey = items[j].key;

	        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {
	          var _msg = "Map keys must be unique; \"".concat(iKey, "\" is repeated");

	          doc.errors.push(new YAMLSemanticError(cst, _msg));
	          break;
	        }
	      }
	    }
	  }

	  if (hasCollectionKey && !doc.options.mapAsMap) {
	    var warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
	    doc.warnings.push(new YAMLWarning(cst, warn));
	  }

	  cst.resolved = map;
	  return map;
	}

	var valueHasPairComment = function valueHasPairComment(_ref2) {
	  var _ref2$context = _ref2.context,
	      lineStart = _ref2$context.lineStart,
	      node = _ref2$context.node,
	      src = _ref2$context.src,
	      props = _ref2.props;
	  if (props.length === 0) return false;
	  var start = props[0].start;
	  if (node && start > node.valueRange.start) return false;
	  if (src[start] !== Char.COMMENT) return false;

	  for (var i = lineStart; i < start; ++i) {
	    if (src[i] === '\n') return false;
	  }

	  return true;
	};

	function resolvePairComment(item, pair) {
	  if (!valueHasPairComment(item)) return;
	  var comment = item.getPropValue(0, Char.COMMENT, true);
	  var found = false;
	  var cb = pair.value.commentBefore;

	  if (cb && cb.startsWith(comment)) {
	    pair.value.commentBefore = cb.substr(comment.length + 1);
	    found = true;
	  } else {
	    var cc = pair.value.comment;

	    if (!item.node && cc && cc.startsWith(comment)) {
	      pair.value.comment = cc.substr(comment.length + 1);
	      found = true;
	    }
	  }

	  if (found) pair.comment = comment;
	}

	function resolveBlockMapItems(doc, cst) {
	  var comments = [];
	  var items = [];
	  var key = undefined;
	  var keyStart = null;

	  for (var i = 0; i < cst.items.length; ++i) {
	    var item = cst.items[i];

	    switch (item.type) {
	      case Type.BLANK_LINE:
	        comments.push({
	          afterKey: !!key,
	          before: items.length
	        });
	        break;

	      case Type.COMMENT:
	        comments.push({
	          afterKey: !!key,
	          before: items.length,
	          comment: item.comment
	        });
	        break;

	      case Type.MAP_KEY:
	        if (key !== undefined) items.push(new Pair(key));
	        if (item.error) doc.errors.push(item.error);
	        key = doc.resolveNode(item.node);
	        keyStart = null;
	        break;

	      case Type.MAP_VALUE:
	        {
	          if (key === undefined) key = null;
	          if (item.error) doc.errors.push(item.error);

	          if (!item.context.atLineStart && item.node && item.node.type === Type.MAP && !item.node.context.atLineStart) {
	            var msg = 'Nested mappings are not allowed in compact mappings';
	            doc.errors.push(new YAMLSemanticError(item.node, msg));
	          }

	          var valueNode = item.node;

	          if (!valueNode && item.props.length > 0) {
	            // Comments on an empty mapping value need to be preserved, so we
	            // need to construct a minimal empty node here to use instead of the
	            // missing `item.node`. -- eemeli/yaml#19
	            valueNode = new PlainValue(Type.PLAIN, []);
	            valueNode.context = {
	              parent: item,
	              src: item.context.src
	            };
	            var pos = item.range.start + 1;
	            valueNode.range = {
	              start: pos,
	              end: pos
	            };
	            valueNode.valueRange = {
	              start: pos,
	              end: pos
	            };

	            if (typeof item.range.origStart === 'number') {
	              var origPos = item.range.origStart + 1;
	              valueNode.range.origStart = valueNode.range.origEnd = origPos;
	              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
	            }
	          }

	          var pair = new Pair(key, doc.resolveNode(valueNode));
	          resolvePairComment(item, pair);
	          items.push(pair);
	          checkKeyLength(doc.errors, cst, i, key, keyStart);
	          key = undefined;
	          keyStart = null;
	        }
	        break;

	      default:
	        if (key !== undefined) items.push(new Pair(key));
	        key = doc.resolveNode(item);
	        keyStart = item.range.start;
	        if (item.error) doc.errors.push(item.error);

	        next: for (var j = i + 1;; ++j) {
	          var nextItem = cst.items[j];

	          switch (nextItem && nextItem.type) {
	            case Type.BLANK_LINE:
	            case Type.COMMENT:
	              continue next;

	            case Type.MAP_VALUE:
	              break next;

	            default:
	              doc.errors.push(new YAMLSemanticError(item, 'Implicit map keys need to be followed by map values'));
	              break next;
	          }
	        }

	        if (item.valueRangeContainsNewline) {
	          var _msg2 = 'Implicit map keys need to be on a single line';
	          doc.errors.push(new YAMLSemanticError(item, _msg2));
	        }

	    }
	  }

	  if (key !== undefined) items.push(new Pair(key));
	  return {
	    comments: comments,
	    items: items
	  };
	}

	function resolveFlowMapItems(doc, cst) {
	  var comments = [];
	  var items = [];
	  var key = undefined;
	  var keyStart = null;
	  var explicitKey = false;
	  var next = '{';

	  for (var i = 0; i < cst.items.length; ++i) {
	    checkKeyLength(doc.errors, cst, i, key, keyStart);
	    var item = cst.items[i];

	    if (typeof item.char === 'string') {
	      var char = item.char,
	          offset = item.offset;

	      if (char === '?' && key === undefined && !explicitKey) {
	        explicitKey = true;
	        next = ':';
	        continue;
	      }

	      if (char === ':') {
	        if (key === undefined) key = null;

	        if (next === ':') {
	          next = ',';
	          continue;
	        }
	      } else {
	        if (explicitKey) {
	          if (key === undefined && char !== ',') key = null;
	          explicitKey = false;
	        }

	        if (key !== undefined) {
	          items.push(new Pair(key));
	          key = undefined;
	          keyStart = null;

	          if (char === ',') {
	            next = ':';
	            continue;
	          }
	        }
	      }

	      if (char === '}') {
	        if (i === cst.items.length - 1) continue;
	      } else if (char === next) {
	        next = ':';
	        continue;
	      }

	      var msg = "Flow map contains an unexpected ".concat(char);
	      var err = new YAMLSyntaxError(cst, msg);
	      err.offset = offset;
	      doc.errors.push(err);
	    } else if (item.type === Type.BLANK_LINE) {
	      comments.push({
	        afterKey: !!key,
	        before: items.length
	      });
	    } else if (item.type === Type.COMMENT) {
	      comments.push({
	        afterKey: !!key,
	        before: items.length,
	        comment: item.comment
	      });
	    } else if (key === undefined) {
	      if (next === ',') doc.errors.push(new YAMLSemanticError(item, 'Separator , missing in flow map'));
	      key = doc.resolveNode(item);
	      keyStart = explicitKey ? null : item.range.start; // TODO: add error for non-explicit multiline plain key
	    } else {
	      if (next !== ',') doc.errors.push(new YAMLSemanticError(item, 'Indicator : missing in flow map entry'));
	      items.push(new Pair(key, doc.resolveNode(item)));
	      key = undefined;
	      explicitKey = false;
	    }
	  }

	  checkFlowCollectionEnd(doc.errors, cst);
	  if (key !== undefined) items.push(new Pair(key));
	  return {
	    comments: comments,
	    items: items
	  };
	}

	function _createForOfIteratorHelper$6(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$7(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$7(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$7(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen); }

	function _arrayLikeToArray$7(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function createMap(schema, obj, ctx) {
	  var map = new YAMLMap(schema);

	  if (obj instanceof Map) {
	    var _iterator = _createForOfIteratorHelper$6(obj),
	        _step;

	    try {
	      for (_iterator.s(); !(_step = _iterator.n()).done;) {
	        var _step$value = slicedToArray(_step.value, 2),
	            key = _step$value[0],
	            value = _step$value[1];

	        map.items.push(schema.createPair(key, value, ctx));
	      }
	    } catch (err) {
	      _iterator.e(err);
	    } finally {
	      _iterator.f();
	    }
	  } else if (obj && _typeof_1(obj) === 'object') {
	    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
	      var _key = _Object$keys[_i];
	      map.items.push(schema.createPair(_key, obj[_key], ctx));
	    }
	  }

	  if (typeof schema.sortMapEntries === 'function') {
	    map.items.sort(schema.sortMapEntries);
	  }

	  return map;
	}

	var map = {
	  createNode: createMap,
	  default: true,
	  nodeClass: YAMLMap,
	  tag: 'tag:yaml.org,2002:map',
	  resolve: parseMap
	};

	function parseSeq(doc, cst) {
	  if (cst.type !== Type.SEQ && cst.type !== Type.FLOW_SEQ) {
	    var msg = "A ".concat(cst.type, " node cannot be resolved as a sequence");
	    doc.errors.push(new YAMLSyntaxError(cst, msg));
	    return null;
	  }

	  var _ref = cst.type === Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst),
	      comments = _ref.comments,
	      items = _ref.items;

	  var seq = new YAMLSeq();
	  seq.items = items;
	  resolveComments(seq, comments);

	  if (!doc.options.mapAsMap && items.some(function (it) {
	    return it instanceof Pair && it.key instanceof Collection$1;
	  })) {
	    var warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
	    doc.warnings.push(new YAMLWarning(cst, warn));
	  }

	  cst.resolved = seq;
	  return seq;
	}

	function resolveBlockSeqItems(doc, cst) {
	  var comments = [];
	  var items = [];

	  for (var i = 0; i < cst.items.length; ++i) {
	    var item = cst.items[i];

	    switch (item.type) {
	      case Type.BLANK_LINE:
	        comments.push({
	          before: items.length
	        });
	        break;

	      case Type.COMMENT:
	        comments.push({
	          comment: item.comment,
	          before: items.length
	        });
	        break;

	      case Type.SEQ_ITEM:
	        if (item.error) doc.errors.push(item.error);
	        items.push(doc.resolveNode(item.node));

	        if (item.hasProps) {
	          var msg = 'Sequence items cannot have tags or anchors before the - indicator';
	          doc.errors.push(new YAMLSemanticError(item, msg));
	        }

	        break;

	      default:
	        if (item.error) doc.errors.push(item.error);
	        doc.errors.push(new YAMLSyntaxError(item, "Unexpected ".concat(item.type, " node in sequence")));
	    }
	  }

	  return {
	    comments: comments,
	    items: items
	  };
	}

	function resolveFlowSeqItems(doc, cst) {
	  var comments = [];
	  var items = [];
	  var explicitKey = false;
	  var key = undefined;
	  var keyStart = null;
	  var next = '[';

	  for (var i = 0; i < cst.items.length; ++i) {
	    var item = cst.items[i];

	    if (typeof item.char === 'string') {
	      var char = item.char,
	          offset = item.offset;

	      if (char !== ':' && (explicitKey || key !== undefined)) {
	        if (explicitKey && key === undefined) key = next ? items.pop() : null;
	        items.push(new Pair(key));
	        explicitKey = false;
	        key = undefined;
	        keyStart = null;
	      }

	      if (char === next) {
	        next = null;
	      } else if (!next && char === '?') {
	        explicitKey = true;
	      } else if (next !== '[' && char === ':' && key === undefined) {
	        if (next === ',') {
	          key = items.pop();

	          if (key instanceof Pair) {
	            var msg = 'Chaining flow sequence pairs is invalid';
	            var err = new YAMLSemanticError(cst, msg);
	            err.offset = offset;
	            doc.errors.push(err);
	          }

	          if (!explicitKey) checkKeyLength(doc.errors, cst, i, key, keyStart);
	        } else {
	          key = null;
	        }

	        keyStart = null;
	        explicitKey = false; // TODO: add error for non-explicit multiline plain key

	        next = null;
	      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {
	        var _msg = "Flow sequence contains an unexpected ".concat(char);

	        var _err = new YAMLSyntaxError(cst, _msg);

	        _err.offset = offset;
	        doc.errors.push(_err);
	      }
	    } else if (item.type === Type.BLANK_LINE) {
	      comments.push({
	        before: items.length
	      });
	    } else if (item.type === Type.COMMENT) {
	      comments.push({
	        comment: item.comment,
	        before: items.length
	      });
	    } else {
	      if (next) {
	        var _msg2 = "Expected a ".concat(next, " in flow sequence");

	        doc.errors.push(new YAMLSemanticError(item, _msg2));
	      }

	      var value = doc.resolveNode(item);

	      if (key === undefined) {
	        items.push(value);
	      } else {
	        items.push(new Pair(key, value));
	        key = undefined;
	      }

	      keyStart = item.range.start;
	      next = ',';
	    }
	  }

	  checkFlowCollectionEnd(doc.errors, cst);
	  if (key !== undefined) items.push(new Pair(key));
	  return {
	    comments: comments,
	    items: items
	  };
	}

	function _createForOfIteratorHelper$7(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$8(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$8(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$8(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen); }

	function _arrayLikeToArray$8(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function createSeq(schema, obj, ctx) {
	  var seq = new YAMLSeq(schema);

	  if (obj && obj[Symbol.iterator]) {
	    var _iterator = _createForOfIteratorHelper$7(obj),
	        _step;

	    try {
	      for (_iterator.s(); !(_step = _iterator.n()).done;) {
	        var it = _step.value;
	        var v = schema.createNode(it, ctx.wrapScalars, null, ctx);
	        seq.items.push(v);
	      }
	    } catch (err) {
	      _iterator.e(err);
	    } finally {
	      _iterator.f();
	    }
	  }

	  return seq;
	}

	var seq = {
	  createNode: createSeq,
	  default: true,
	  nodeClass: YAMLSeq,
	  tag: 'tag:yaml.org,2002:seq',
	  resolve: parseSeq
	};

	var resolveString = function resolveString(doc, node) {
	  // on error, will return { str: string, errors: Error[] }
	  var res = node.strValue;
	  if (!res) return '';
	  if (typeof res === 'string') return res;
	  res.errors.forEach(function (error) {
	    if (!error.source) error.source = node;
	    doc.errors.push(error);
	  });
	  return res.str;
	};
	var string = {
	  identify: function identify(value) {
	    return typeof value === 'string';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:str',
	  resolve: resolveString,
	  stringify: function stringify(item, ctx, onComment, onChompKeep) {
	    ctx = Object.assign({
	      actualString: true
	    }, ctx);
	    return stringifyString(item, ctx, onComment, onChompKeep);
	  },
	  options: strOptions
	};

	var failsafe = [map, seq, string];

	/* global BigInt */

	var intIdentify = function intIdentify(value) {
	  return typeof value === 'bigint' || Number.isInteger(value);
	};

	var intResolve = function intResolve(src, part, radix) {
	  return intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);
	};

	function intStringify(node, radix, prefix) {
	  var value = node.value;
	  if (intIdentify(value) && value >= 0) return prefix + value.toString(radix);
	  return stringifyNumber(node);
	}

	var nullObj = {
	  identify: function identify(value) {
	    return value == null;
	  },
	  createNode: function createNode(schema, value, ctx) {
	    return ctx.wrapScalars ? new Scalar(null) : null;
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:null',
	  test: /^(?:~|[Nn]ull|NULL)?$/,
	  resolve: function resolve() {
	    return null;
	  },
	  options: nullOptions,
	  stringify: function stringify() {
	    return nullOptions.nullStr;
	  }
	};
	var boolObj = {
	  identify: function identify(value) {
	    return typeof value === 'boolean';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:bool',
	  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
	  resolve: function resolve(str) {
	    return str[0] === 't' || str[0] === 'T';
	  },
	  options: boolOptions,
	  stringify: function stringify(_ref) {
	    var value = _ref.value;
	    return value ? boolOptions.trueStr : boolOptions.falseStr;
	  }
	};
	var octObj = {
	  identify: function identify(value) {
	    return intIdentify(value) && value >= 0;
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'OCT',
	  test: /^0o([0-7]+)$/,
	  resolve: function resolve(str, oct) {
	    return intResolve(str, oct, 8);
	  },
	  options: intOptions,
	  stringify: function stringify(node) {
	    return intStringify(node, 8, '0o');
	  }
	};
	var intObj = {
	  identify: intIdentify,
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  test: /^[-+]?[0-9]+$/,
	  resolve: function resolve(str) {
	    return intResolve(str, str, 10);
	  },
	  options: intOptions,
	  stringify: stringifyNumber
	};
	var hexObj = {
	  identify: function identify(value) {
	    return intIdentify(value) && value >= 0;
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'HEX',
	  test: /^0x([0-9a-fA-F]+)$/,
	  resolve: function resolve(str, hex) {
	    return intResolve(str, hex, 16);
	  },
	  options: intOptions,
	  stringify: function stringify(node) {
	    return intStringify(node, 16, '0x');
	  }
	};
	var nanObj = {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  test: /^(?:[-+]?\.inf|(\.nan))$/i,
	  resolve: function resolve(str, nan) {
	    return nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
	  },
	  stringify: stringifyNumber
	};
	var expObj = {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  format: 'EXP',
	  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
	  resolve: function resolve(str) {
	    return parseFloat(str);
	  },
	  stringify: function stringify(_ref2) {
	    var value = _ref2.value;
	    return Number(value).toExponential();
	  }
	};
	var floatObj = {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
	  resolve: function resolve(str, frac1, frac2) {
	    var frac = frac1 || frac2;
	    var node = new Scalar(parseFloat(str));
	    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;
	    return node;
	  },
	  stringify: stringifyNumber
	};
	var core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);

	/* global BigInt */

	var intIdentify$1 = function intIdentify(value) {
	  return typeof value === 'bigint' || Number.isInteger(value);
	};

	var stringifyJSON = function stringifyJSON(_ref) {
	  var value = _ref.value;
	  return JSON.stringify(value);
	};

	var json = [map, seq, {
	  identify: function identify(value) {
	    return typeof value === 'string';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:str',
	  resolve: resolveString,
	  stringify: stringifyJSON
	}, {
	  identify: function identify(value) {
	    return value == null;
	  },
	  createNode: function createNode(schema, value, ctx) {
	    return ctx.wrapScalars ? new Scalar(null) : null;
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:null',
	  test: /^null$/,
	  resolve: function resolve() {
	    return null;
	  },
	  stringify: stringifyJSON
	}, {
	  identify: function identify(value) {
	    return typeof value === 'boolean';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:bool',
	  test: /^true|false$/,
	  resolve: function resolve(str) {
	    return str === 'true';
	  },
	  stringify: stringifyJSON
	}, {
	  identify: intIdentify$1,
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  test: /^-?(?:0|[1-9][0-9]*)$/,
	  resolve: function resolve(str) {
	    return intOptions.asBigInt ? BigInt(str) : parseInt(str, 10);
	  },
	  stringify: function stringify(_ref2) {
	    var value = _ref2.value;
	    return intIdentify$1(value) ? value.toString() : JSON.stringify(value);
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
	  resolve: function resolve(str) {
	    return parseFloat(str);
	  },
	  stringify: stringifyJSON
	}];

	json.scalarFallback = function (str) {
	  throw new SyntaxError("Unresolved plain scalar ".concat(JSON.stringify(str)));
	};

	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	var inited = false;
	function init () {
	  inited = true;
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	  for (var i = 0, len = code.length; i < len; ++i) {
	    lookup[i] = code[i];
	    revLookup[code.charCodeAt(i)] = i;
	  }

	  revLookup['-'.charCodeAt(0)] = 62;
	  revLookup['_'.charCodeAt(0)] = 63;
	}

	function toByteArray (b64) {
	  if (!inited) {
	    init();
	  }
	  var i, j, l, tmp, placeHolders, arr;
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

	  // base64 is 4/3 + up to two characters of the original data
	  arr = new Arr(len * 3 / 4 - placeHolders);

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len;

	  var L = 0;

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
	    arr[L++] = (tmp >> 16) & 0xFF;
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
	    arr[L++] = tmp & 0xFF;
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  if (!inited) {
	    init();
	  }
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var output = '';
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    output += lookup[tmp >> 2];
	    output += lookup[(tmp << 4) & 0x3F];
	    output += '==';
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
	    output += lookup[tmp >> 10];
	    output += lookup[(tmp >> 4) & 0x3F];
	    output += lookup[(tmp << 2) & 0x3F];
	    output += '=';
	  }

	  parts.push(output);

	  return parts.join('')
	}

	function read (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	function write (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	}

	var toString$2 = {}.toString;

	var isArray$2 = Array.isArray || function (arr) {
	  return toString$2.call(arr) == '[object Array]';
	};

	var INSPECT_MAX_BYTES = 50;

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
	  ? global$1.TYPED_ARRAY_SUPPORT
	  : true;

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length);
	    that.__proto__ = Buffer.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length);
	    }
	    that.length = length;
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer.poolSize = 8192; // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype;
	  return arr
	};

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	};

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype;
	  Buffer.__proto__ = Uint8Array;
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size);
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	};

	function allocUnsafe (that, size) {
	  assertSize(size);
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0;
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	};
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	};

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8';
	  }

	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0;
	  that = createBuffer(that, length);

	  var actual = that.write(string, encoding);

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual);
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0;
	  that = createBuffer(that, length);
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array);
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset);
	  } else {
	    array = new Uint8Array(array, byteOffset, length);
	  }

	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array;
	    that.__proto__ = Buffer.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array);
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (internalIsBuffer(obj)) {
	    var len = checked(obj.length) | 0;
	    that = createBuffer(that, len);

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len);
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray$2(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	Buffer.isBuffer = isBuffer$1;
	function internalIsBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	};

	Buffer.concat = function concat (list, length) {
	  if (!isArray$2(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }

	  var i;
	  if (length === undefined) {
	    length = 0;
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length;
	    }
	  }

	  var buffer = Buffer.allocUnsafe(length);
	  var pos = 0;
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i];
	    if (!internalIsBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos);
	    pos += buf.length;
	  }
	  return buffer
	};

	function byteLength (string, encoding) {
	  if (internalIsBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string;
	  }

	  var len = string.length;
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	}
	Buffer.byteLength = byteLength;

	function slowToString (encoding, start, end) {
	  var loweredCase = false;

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0;
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length;
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0;
	  start >>>= 0;

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8';

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase();
	        loweredCase = true;
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true;

	function swap (b, n, m) {
	  var i = b[n];
	  b[n] = b[m];
	  b[m] = i;
	}

	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length;
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1);
	  }
	  return this
	};

	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length;
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3);
	    swap(this, i + 1, i + 2);
	  }
	  return this
	};

	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length;
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7);
	    swap(this, i + 1, i + 6);
	    swap(this, i + 2, i + 5);
	    swap(this, i + 3, i + 4);
	  }
	  return this
	};

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0;
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	};

	Buffer.prototype.equals = function equals (b) {
	  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	};

	Buffer.prototype.inspect = function inspect () {
	  var str = '';
	  var max = INSPECT_MAX_BYTES;
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
	    if (this.length > max) str += ' ... ';
	  }
	  return '<Buffer ' + str + '>'
	};

	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!internalIsBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0;
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0;
	  }
	  if (thisStart === undefined) {
	    thisStart = 0;
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length;
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0;
	  end >>>= 0;
	  thisStart >>>= 0;
	  thisEnd >>>= 0;

	  if (this === target) return 0

	  var x = thisEnd - thisStart;
	  var y = end - start;
	  var len = Math.min(x, y);

	  var thisCopy = this.slice(thisStart, thisEnd);
	  var targetCopy = target.slice(start, end);

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i];
	      y = targetCopy[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset;
	    byteOffset = 0;
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff;
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000;
	  }
	  byteOffset = +byteOffset;  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1);
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1;
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0;
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding);
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (internalIsBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF; // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1;
	  var arrLength = arr.length;
	  var valLength = val.length;

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase();
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2;
	      arrLength /= 2;
	      valLength /= 2;
	      byteOffset /= 2;
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i;
	  if (dir) {
	    var foundIndex = -1;
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i;
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex;
	        foundIndex = -1;
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true;
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false;
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	};

	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	};

	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	};

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0;
	  var remaining = buf.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = Number(length);
	    if (length > remaining) {
	      length = remaining;
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length;
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2;
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16);
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed;
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8';
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset;
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0;
	    if (isFinite(length)) {
	      length = length | 0;
	      if (encoding === undefined) encoding = 'utf8';
	    } else {
	      encoding = length;
	      length = undefined;
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset;
	  if (length === undefined || length > remaining) length = remaining;

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8';

	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	};

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	};

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return fromByteArray(buf)
	  } else {
	    return fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end);
	  var res = [];

	  var i = start;
	  while (i < end) {
	    var firstByte = buf[i];
	    var codePoint = null;
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1;

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint;

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte;
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1];
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          fourthByte = buf[i + 3];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint;
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD;
	      bytesPerSequence = 1;
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000;
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	      codePoint = 0xDC00 | codePoint & 0x3FF;
	    }

	    res.push(codePoint);
	    i += bytesPerSequence;
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000;

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length;
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = '';
	  var i = 0;
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    );
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F);
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i]);
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length;

	  if (!start || start < 0) start = 0;
	  if (!end || end < 0 || end > len) end = len;

	  var out = '';
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i]);
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end);
	  var res = '';
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length;
	  start = ~~start;
	  end = end === undefined ? len : ~~end;

	  if (start < 0) {
	    start += len;
	    if (start < 0) start = 0;
	  } else if (start > len) {
	    start = len;
	  }

	  if (end < 0) {
	    end += len;
	    if (end < 0) end = 0;
	  } else if (end > len) {
	    end = len;
	  }

	  if (end < start) end = start;

	  var newBuf;
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end);
	    newBuf.__proto__ = Buffer.prototype;
	  } else {
	    var sliceLen = end - start;
	    newBuf = new Buffer(sliceLen, undefined);
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start];
	    }
	  }

	  return newBuf
	};

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }

	  return val
	};

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length);
	  }

	  var val = this[offset + --byteLength];
	  var mul = 1;
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul;
	  }

	  return val
	};

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  return this[offset]
	};

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return this[offset] | (this[offset + 1] << 8)
	};

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return (this[offset] << 8) | this[offset + 1]
	};

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	};

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	};

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var i = byteLength;
	  var mul = 1;
	  var val = this[offset + --i];
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	};

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset] | (this[offset + 1] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset + 1] | (this[offset] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	};

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	};

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, true, 23, 4)
	};

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, false, 23, 4)
	};

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, true, 52, 8)
	};

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, false, 52, 8)
	};

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var mul = 1;
	  var i = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8;
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 1] = (value >>> 8);
	    this[offset] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = 0;
	  var mul = 1;
	  var sub = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  var sub = 0;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  if (value < 0) value = 0xff + value + 1;
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 3] = (value >>> 24);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (value < 0) value = 0xffffffff + value + 1;
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4);
	  }
	  write(buf, value, offset, littleEndian, 23, 4);
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	};

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	};

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8);
	  }
	  write(buf, value, offset, littleEndian, 52, 8);
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	};

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	};

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0;
	  if (!end && end !== 0) end = this.length;
	  if (targetStart >= target.length) targetStart = target.length;
	  if (!targetStart) targetStart = 0;
	  if (end > 0 && end < start) end = start;

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length;
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start;
	  }

	  var len = end - start;
	  var i;

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    );
	  }

	  return len
	};

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start;
	      start = 0;
	      end = this.length;
	    } else if (typeof end === 'string') {
	      encoding = end;
	      end = this.length;
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0);
	      if (code < 256) {
	        val = code;
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255;
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0;
	  end = end === undefined ? this.length : end >>> 0;

	  if (!val) val = 0;

	  var i;
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val;
	    }
	  } else {
	    var bytes = internalIsBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString());
	    var len = bytes.length;
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len];
	    }
	  }

	  return this
	};

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '=';
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity;
	  var codePoint;
	  var length = string.length;
	  var leadSurrogate = null;
	  var bytes = [];

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i);

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint;

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	        leadSurrogate = codePoint;
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	    }

	    leadSurrogate = null;

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint);
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF);
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo;
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i);
	    hi = c >> 8;
	    lo = c % 256;
	    byteArray.push(lo);
	    byteArray.push(hi);
	  }

	  return byteArray
	}


	function base64ToBytes (str) {
	  return toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i];
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}


	// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	function isBuffer$1(obj) {
	  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
	}

	function isFastBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
	}

	var binary = {
	  identify: function identify(value) {
	    return value instanceof Uint8Array;
	  },
	  // Buffer inherits from Uint8Array
	  default: false,
	  tag: 'tag:yaml.org,2002:binary',

	  /**
	   * Returns a Buffer in node and an Uint8Array in browsers
	   *
	   * To use the resulting buffer as an image, you'll want to do something like:
	   *
	   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
	   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
	   */
	  resolve: function resolve(doc, node) {
	    var src = resolveString(doc, node);

	    if (typeof Buffer === 'function') {
	      return Buffer.from(src, 'base64');
	    } else if (typeof atob === 'function') {
	      // On IE 11, atob() can't handle newlines
	      var str = atob(src.replace(/[\n\r]/g, ''));
	      var buffer = new Uint8Array(str.length);

	      for (var i = 0; i < str.length; ++i) {
	        buffer[i] = str.charCodeAt(i);
	      }

	      return buffer;
	    } else {
	      var msg = 'This environment does not support reading binary tags; either Buffer or atob is required';
	      doc.errors.push(new YAMLReferenceError(node, msg));
	      return null;
	    }
	  },
	  options: binaryOptions,
	  stringify: function stringify(_ref, ctx, onComment, onChompKeep) {
	    var comment = _ref.comment,
	        type = _ref.type,
	        value = _ref.value;
	    var src;

	    if (typeof Buffer === 'function') {
	      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');
	    } else if (typeof btoa === 'function') {
	      var s = '';

	      for (var i = 0; i < value.length; ++i) {
	        s += String.fromCharCode(value[i]);
	      }

	      src = btoa(s);
	    } else {
	      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
	    }

	    if (!type) type = binaryOptions.defaultType;

	    if (type === Type.QUOTE_DOUBLE) {
	      value = src;
	    } else {
	      var lineWidth = binaryOptions.lineWidth;
	      var n = Math.ceil(src.length / lineWidth);
	      var lines = new Array(n);

	      for (var _i = 0, o = 0; _i < n; ++_i, o += lineWidth) {
	        lines[_i] = src.substr(o, lineWidth);
	      }

	      value = lines.join(type === Type.BLOCK_LITERAL ? '\n' : ' ');
	    }

	    return stringifyString({
	      comment: comment,
	      type: type,
	      value: value
	    }, ctx, onComment, onChompKeep);
	  }
	};

	function _createForOfIteratorHelper$8(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$9(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$9(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$9(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen); }

	function _arrayLikeToArray$9(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	function parsePairs(doc, cst) {
	  var seq = parseSeq(doc, cst);

	  for (var i = 0; i < seq.items.length; ++i) {
	    var item = seq.items[i];
	    if (item instanceof Pair) continue;else if (item instanceof YAMLMap) {
	      if (item.items.length > 1) {
	        var msg = 'Each pair must have its own sequence indicator';
	        throw new YAMLSemanticError(cst, msg);
	      }

	      var pair = item.items[0] || new Pair();
	      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? "".concat(item.commentBefore, "\n").concat(pair.commentBefore) : item.commentBefore;
	      if (item.comment) pair.comment = pair.comment ? "".concat(item.comment, "\n").concat(pair.comment) : item.comment;
	      item = pair;
	    }
	    seq.items[i] = item instanceof Pair ? item : new Pair(item);
	  }

	  return seq;
	}
	function createPairs(schema, iterable, ctx) {
	  var pairs = new YAMLSeq(schema);
	  pairs.tag = 'tag:yaml.org,2002:pairs';

	  var _iterator = _createForOfIteratorHelper$8(iterable),
	      _step;

	  try {
	    for (_iterator.s(); !(_step = _iterator.n()).done;) {
	      var it = _step.value;
	      var key = void 0,
	          value = void 0;

	      if (Array.isArray(it)) {
	        if (it.length === 2) {
	          key = it[0];
	          value = it[1];
	        } else throw new TypeError("Expected [key, value] tuple: ".concat(it));
	      } else if (it && it instanceof Object) {
	        var keys = Object.keys(it);

	        if (keys.length === 1) {
	          key = keys[0];
	          value = it[key];
	        } else throw new TypeError("Expected { key: value } tuple: ".concat(it));
	      } else {
	        key = it;
	      }

	      var pair = schema.createPair(key, value, ctx);
	      pairs.items.push(pair);
	    }
	  } catch (err) {
	    _iterator.e(err);
	  } finally {
	    _iterator.f();
	  }

	  return pairs;
	}
	var pairs = {
	  default: false,
	  tag: 'tag:yaml.org,2002:pairs',
	  resolve: parsePairs,
	  createNode: createPairs
	};

	function _createForOfIteratorHelper$9(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$a(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$a(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$a(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$a(o, minLen); }

	function _arrayLikeToArray$a(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _createSuper$k(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$l()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$l() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var YAMLOMap = /*#__PURE__*/function (_YAMLSeq) {
	  inherits(YAMLOMap, _YAMLSeq);

	  var _super = _createSuper$k(YAMLOMap);

	  function YAMLOMap() {
	    var _this;

	    classCallCheck(this, YAMLOMap);

	    _this = _super.call(this);

	    defineProperty(assertThisInitialized(_this), "add", YAMLMap.prototype.add.bind(assertThisInitialized(_this)));

	    defineProperty(assertThisInitialized(_this), "delete", YAMLMap.prototype.delete.bind(assertThisInitialized(_this)));

	    defineProperty(assertThisInitialized(_this), "get", YAMLMap.prototype.get.bind(assertThisInitialized(_this)));

	    defineProperty(assertThisInitialized(_this), "has", YAMLMap.prototype.has.bind(assertThisInitialized(_this)));

	    defineProperty(assertThisInitialized(_this), "set", YAMLMap.prototype.set.bind(assertThisInitialized(_this)));

	    _this.tag = YAMLOMap.tag;
	    return _this;
	  }

	  createClass(YAMLOMap, [{
	    key: "toJSON",
	    value: function toJSON$1(_, ctx) {
	      var map = new Map();
	      if (ctx && ctx.onCreate) ctx.onCreate(map);

	      var _iterator = _createForOfIteratorHelper$9(this.items),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var pair = _step.value;
	          var key = void 0,
	              value = void 0;

	          if (pair instanceof Pair) {
	            key = toJSON(pair.key, '', ctx);
	            value = toJSON(pair.value, key, ctx);
	          } else {
	            key = toJSON(pair, '', ctx);
	          }

	          if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');
	          map.set(key, value);
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }

	      return map;
	    }
	  }]);

	  return YAMLOMap;
	}(YAMLSeq);

	defineProperty(YAMLOMap, "tag", 'tag:yaml.org,2002:omap');

	function parseOMap(doc, cst) {
	  var pairs = parsePairs(doc, cst);
	  var seenKeys = [];

	  var _iterator2 = _createForOfIteratorHelper$9(pairs.items),
	      _step2;

	  try {
	    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	      var key = _step2.value.key;

	      if (key instanceof Scalar) {
	        if (seenKeys.includes(key.value)) {
	          var msg = 'Ordered maps must not include duplicate keys';
	          throw new YAMLSemanticError(cst, msg);
	        } else {
	          seenKeys.push(key.value);
	        }
	      }
	    }
	  } catch (err) {
	    _iterator2.e(err);
	  } finally {
	    _iterator2.f();
	  }

	  return Object.assign(new YAMLOMap(), pairs);
	}

	function createOMap(schema, iterable, ctx) {
	  var pairs = createPairs(schema, iterable, ctx);
	  var omap = new YAMLOMap();
	  omap.items = pairs.items;
	  return omap;
	}

	var omap = {
	  identify: function identify(value) {
	    return value instanceof Map;
	  },
	  nodeClass: YAMLOMap,
	  default: false,
	  tag: 'tag:yaml.org,2002:omap',
	  resolve: parseOMap,
	  createNode: createOMap
	};

	function _createForOfIteratorHelper$a(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$b(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$b(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$b(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$b(o, minLen); }

	function _arrayLikeToArray$b(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _createSuper$l(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$m()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$m() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var YAMLSet = /*#__PURE__*/function (_YAMLMap) {
	  inherits(YAMLSet, _YAMLMap);

	  var _super = _createSuper$l(YAMLSet);

	  function YAMLSet() {
	    var _this;

	    classCallCheck(this, YAMLSet);

	    _this = _super.call(this);
	    _this.tag = YAMLSet.tag;
	    return _this;
	  }

	  createClass(YAMLSet, [{
	    key: "add",
	    value: function add(key) {
	      var pair = key instanceof Pair ? key : new Pair(key);
	      var prev = findPair(this.items, pair.key);
	      if (!prev) this.items.push(pair);
	    }
	  }, {
	    key: "get",
	    value: function get(key, keepPair) {
	      var pair = findPair(this.items, key);
	      return !keepPair && pair instanceof Pair ? pair.key instanceof Scalar ? pair.key.value : pair.key : pair;
	    }
	  }, {
	    key: "set",
	    value: function set(key, value) {
	      if (typeof value !== 'boolean') throw new Error("Expected boolean value for set(key, value) in a YAML set, not ".concat(_typeof_1(value)));
	      var prev = findPair(this.items, key);

	      if (prev && !value) {
	        this.items.splice(this.items.indexOf(prev), 1);
	      } else if (!prev && value) {
	        this.items.push(new Pair(key));
	      }
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON(_, ctx) {
	      return get$1(getPrototypeOf(YAMLSet.prototype), "toJSON", this).call(this, _, ctx, Set);
	    }
	  }, {
	    key: "toString",
	    value: function toString(ctx, onComment, onChompKeep) {
	      if (!ctx) return JSON.stringify(this);
	      if (this.hasAllNullValues()) return get$1(getPrototypeOf(YAMLSet.prototype), "toString", this).call(this, ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');
	    }
	  }]);

	  return YAMLSet;
	}(YAMLMap);

	defineProperty(YAMLSet, "tag", 'tag:yaml.org,2002:set');

	function parseSet(doc, cst) {
	  var map = parseMap(doc, cst);
	  if (!map.hasAllNullValues()) throw new YAMLSemanticError(cst, 'Set items must all have null values');
	  return Object.assign(new YAMLSet(), map);
	}

	function createSet(schema, iterable, ctx) {
	  var set = new YAMLSet();

	  var _iterator = _createForOfIteratorHelper$a(iterable),
	      _step;

	  try {
	    for (_iterator.s(); !(_step = _iterator.n()).done;) {
	      var value = _step.value;
	      set.items.push(schema.createPair(value, null, ctx));
	    }
	  } catch (err) {
	    _iterator.e(err);
	  } finally {
	    _iterator.f();
	  }

	  return set;
	}

	var set$1 = {
	  identify: function identify(value) {
	    return value instanceof Set;
	  },
	  nodeClass: YAMLSet,
	  default: false,
	  tag: 'tag:yaml.org,2002:set',
	  resolve: parseSet,
	  createNode: createSet
	};

	var parseSexagesimal = function parseSexagesimal(sign, parts) {
	  var n = parts.split(':').reduce(function (n, p) {
	    return n * 60 + Number(p);
	  }, 0);
	  return sign === '-' ? -n : n;
	}; // hhhh:mm:ss.sss


	var stringifySexagesimal = function stringifySexagesimal(_ref) {
	  var value = _ref.value;
	  if (isNaN(value) || !isFinite(value)) return stringifyNumber(value);
	  var sign = '';

	  if (value < 0) {
	    sign = '-';
	    value = Math.abs(value);
	  }

	  var parts = [value % 60]; // seconds, including ms

	  if (value < 60) {
	    parts.unshift(0); // at least one : is required
	  } else {
	    value = Math.round((value - parts[0]) / 60);
	    parts.unshift(value % 60); // minutes

	    if (value >= 60) {
	      value = Math.round((value - parts[0]) / 60);
	      parts.unshift(value); // hours
	    }
	  }

	  return sign + parts.map(function (n) {
	    return n < 10 ? '0' + String(n) : String(n);
	  }).join(':').replace(/000000\d*$/, '') // % 60 may introduce error
	  ;
	};

	var intTime = {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'TIME',
	  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
	  resolve: function resolve(str, sign, parts) {
	    return parseSexagesimal(sign, parts.replace(/_/g, ''));
	  },
	  stringify: stringifySexagesimal
	};
	var floatTime = {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  format: 'TIME',
	  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
	  resolve: function resolve(str, sign, parts) {
	    return parseSexagesimal(sign, parts.replace(/_/g, ''));
	  },
	  stringify: stringifySexagesimal
	};
	var timestamp = {
	  identify: function identify(value) {
	    return value instanceof Date;
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:timestamp',
	  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
	  // may be omitted altogether, resulting in a date format. In such a case, the time part is
	  // assumed to be 00:00:00Z (start of day, UTC).
	  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
	  '(?:(?:t|T|[ \\t]+)' + // t | T | whitespace
	  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
	  '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
	  ')?' + ')$'),
	  resolve: function resolve(str, year, month, day, hour, minute, second, millisec, tz) {
	    if (millisec) millisec = (millisec + '00').substr(1, 3);
	    var date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);

	    if (tz && tz !== 'Z') {
	      var d = parseSexagesimal(tz[0], tz.slice(1));
	      if (Math.abs(d) < 30) d *= 60;
	      date -= 60000 * d;
	    }

	    return new Date(date);
	  },
	  stringify: function stringify(_ref2) {
	    var value = _ref2.value;
	    return value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '');
	  }
	};

	/* global BigInt */

	var boolStringify = function boolStringify(_ref) {
	  var value = _ref.value;
	  return value ? boolOptions.trueStr : boolOptions.falseStr;
	};

	var intIdentify$2 = function intIdentify(value) {
	  return typeof value === 'bigint' || Number.isInteger(value);
	};

	function intResolve$1(sign, src, radix) {
	  var str = src.replace(/_/g, '');

	  if (intOptions.asBigInt) {
	    switch (radix) {
	      case 2:
	        str = "0b".concat(str);
	        break;

	      case 8:
	        str = "0o".concat(str);
	        break;

	      case 16:
	        str = "0x".concat(str);
	        break;
	    }

	    var _n = BigInt(str);

	    return sign === '-' ? BigInt(-1) * _n : _n;
	  }

	  var n = parseInt(str, radix);
	  return sign === '-' ? -1 * n : n;
	}

	function intStringify$1(node, radix, prefix) {
	  var value = node.value;

	  if (intIdentify$2(value)) {
	    var str = value.toString(radix);
	    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
	  }

	  return stringifyNumber(node);
	}

	var yaml11 = failsafe.concat([{
	  identify: function identify(value) {
	    return value == null;
	  },
	  createNode: function createNode(schema, value, ctx) {
	    return ctx.wrapScalars ? new Scalar(null) : null;
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:null',
	  test: /^(?:~|[Nn]ull|NULL)?$/,
	  resolve: function resolve() {
	    return null;
	  },
	  options: nullOptions,
	  stringify: function stringify() {
	    return nullOptions.nullStr;
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'boolean';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:bool',
	  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
	  resolve: function resolve() {
	    return true;
	  },
	  options: boolOptions,
	  stringify: boolStringify
	}, {
	  identify: function identify(value) {
	    return typeof value === 'boolean';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:bool',
	  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
	  resolve: function resolve() {
	    return false;
	  },
	  options: boolOptions,
	  stringify: boolStringify
	}, {
	  identify: intIdentify$2,
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'BIN',
	  test: /^([-+]?)0b([0-1_]+)$/,
	  resolve: function resolve(str, sign, bin) {
	    return intResolve$1(sign, bin, 2);
	  },
	  stringify: function stringify(node) {
	    return intStringify$1(node, 2, '0b');
	  }
	}, {
	  identify: intIdentify$2,
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'OCT',
	  test: /^([-+]?)0([0-7_]+)$/,
	  resolve: function resolve(str, sign, oct) {
	    return intResolve$1(sign, oct, 8);
	  },
	  stringify: function stringify(node) {
	    return intStringify$1(node, 8, '0');
	  }
	}, {
	  identify: intIdentify$2,
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  test: /^([-+]?)([0-9][0-9_]*)$/,
	  resolve: function resolve(str, sign, abs) {
	    return intResolve$1(sign, abs, 10);
	  },
	  stringify: stringifyNumber
	}, {
	  identify: intIdentify$2,
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'HEX',
	  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
	  resolve: function resolve(str, sign, hex) {
	    return intResolve$1(sign, hex, 16);
	  },
	  stringify: function stringify(node) {
	    return intStringify$1(node, 16, '0x');
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  test: /^(?:[-+]?\.inf|(\.nan))$/i,
	  resolve: function resolve(str, nan) {
	    return nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
	  },
	  stringify: stringifyNumber
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  format: 'EXP',
	  test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
	  resolve: function resolve(str) {
	    return parseFloat(str.replace(/_/g, ''));
	  },
	  stringify: function stringify(_ref2) {
	    var value = _ref2.value;
	    return Number(value).toExponential();
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
	  resolve: function resolve(str, frac) {
	    var node = new Scalar(parseFloat(str.replace(/_/g, '')));

	    if (frac) {
	      var f = frac.replace(/_/g, '');
	      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;
	    }

	    return node;
	  },
	  stringify: stringifyNumber
	}], binary, omap, pairs, set$1, intTime, floatTime, timestamp);

	var schemas = {
	  core: core,
	  failsafe: failsafe,
	  json: json,
	  yaml11: yaml11
	};
	var tags = {
	  binary: binary,
	  bool: boolObj,
	  float: floatObj,
	  floatExp: expObj,
	  floatNaN: nanObj,
	  floatTime: floatTime,
	  int: intObj,
	  intHex: hexObj,
	  intOct: octObj,
	  intTime: intTime,
	  map: map,
	  null: nullObj,
	  omap: omap,
	  pairs: pairs,
	  seq: seq,
	  set: set$1,
	  timestamp: timestamp
	};

	function _createForOfIteratorHelper$b(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$c(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$c(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$c(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$c(o, minLen); }

	function _arrayLikeToArray$c(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	var isMap$1 = function isMap(_ref) {
	  var type = _ref.type;
	  return type === Type.FLOW_MAP || type === Type.MAP;
	};

	var isSeq = function isSeq(_ref2) {
	  var type = _ref2.type;
	  return type === Type.FLOW_SEQ || type === Type.SEQ;
	};

	var Schema = /*#__PURE__*/function () {
	  function Schema(_ref3) {
	    var customTags = _ref3.customTags,
	        merge = _ref3.merge,
	        schema = _ref3.schema,
	        sortMapEntries = _ref3.sortMapEntries,
	        deprecatedCustomTags = _ref3.tags;

	    classCallCheck(this, Schema);

	    this.merge = !!merge;
	    this.name = schema;
	    this.sortMapEntries = sortMapEntries === true ? function (a, b) {
	      return a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
	    } : sortMapEntries || null;
	    this.tags = schemas[schema.replace(/\W/g, '')]; // 'yaml-1.1' -> 'yaml11'

	    if (!this.tags) {
	      var keys = Object.keys(schemas).map(function (key) {
	        return JSON.stringify(key);
	      }).join(', ');
	      throw new Error("Unknown schema \"".concat(schema, "\"; use one of ").concat(keys));
	    }

	    if (!customTags && deprecatedCustomTags) {
	      customTags = deprecatedCustomTags;
	      warnOptionDeprecation('tags', 'customTags');
	    }

	    if (Array.isArray(customTags)) {
	      var _iterator = _createForOfIteratorHelper$b(customTags),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var tag = _step.value;
	          this.tags = this.tags.concat(tag);
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }
	    } else if (typeof customTags === 'function') {
	      this.tags = customTags(this.tags.slice());
	    }

	    for (var i = 0; i < this.tags.length; ++i) {
	      var _tag = this.tags[i];

	      if (typeof _tag === 'string') {
	        var tagObj = tags[_tag];

	        if (!tagObj) {
	          var _keys = Object.keys(tags).map(function (key) {
	            return JSON.stringify(key);
	          }).join(', ');

	          throw new Error("Unknown custom tag \"".concat(_tag, "\"; use one of ").concat(_keys));
	        }

	        this.tags[i] = tagObj;
	      }
	    }
	  }

	  createClass(Schema, [{
	    key: "createNode",
	    value: function createNode(value, wrapScalars, tag, ctx) {
	      if (value instanceof Node$1) return value;
	      var tagObj;

	      if (tag) {
	        if (tag.startsWith('!!')) tag = Schema.defaultPrefix + tag.slice(2);
	        var match = this.tags.filter(function (t) {
	          return t.tag === tag;
	        });
	        tagObj = match.find(function (t) {
	          return !t.format;
	        }) || match[0];
	        if (!tagObj) throw new Error("Tag ".concat(tag, " not found"));
	      } else {
	        // TODO: deprecate/remove class check
	        tagObj = this.tags.find(function (t) {
	          return (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format;
	        });

	        if (!tagObj) {
	          if (typeof value.toJSON === 'function') value = value.toJSON();
	          if (_typeof_1(value) !== 'object') return wrapScalars ? new Scalar(value) : value;
	          tagObj = value instanceof Map ? tags.map : value[Symbol.iterator] ? tags.seq : tags.map;
	        }
	      }

	      if (!ctx) ctx = {
	        wrapScalars: wrapScalars
	      };else ctx.wrapScalars = wrapScalars;

	      if (ctx.onTagObj) {
	        ctx.onTagObj(tagObj);
	        delete ctx.onTagObj;
	      }

	      var obj = {};

	      if (value && _typeof_1(value) === 'object' && ctx.prevObjects) {
	        var prev = ctx.prevObjects.get(value);

	        if (prev) {
	          var alias = new Alias$1(prev); // leaves source dirty; must be cleaned by caller

	          ctx.aliasNodes.push(alias);
	          return alias;
	        }

	        obj.value = value;
	        ctx.prevObjects.set(value, obj);
	      }

	      obj.node = tagObj.createNode ? tagObj.createNode(this, value, ctx) : wrapScalars ? new Scalar(value) : value;
	      if (tag && obj.node instanceof Node$1) obj.node.tag = tag;
	      return obj.node;
	    }
	  }, {
	    key: "createPair",
	    value: function createPair(key, value, ctx) {
	      var k = this.createNode(key, ctx.wrapScalars, null, ctx);
	      var v = this.createNode(value, ctx.wrapScalars, null, ctx);
	      return new Pair(k, v);
	    } // falls back to string on no match

	  }, {
	    key: "resolveScalar",
	    value: function resolveScalar(str, tags) {
	      if (!tags) tags = this.tags;

	      for (var i = 0; i < tags.length; ++i) {
	        var _tags$i = tags[i],
	            format = _tags$i.format,
	            test = _tags$i.test,
	            resolve = _tags$i.resolve;

	        if (test) {
	          var match = str.match(test);

	          if (match) {
	            var res = resolve.apply(null, match);
	            if (!(res instanceof Scalar)) res = new Scalar(res);
	            if (format) res.format = format;
	            return res;
	          }
	        }
	      }

	      if (this.tags.scalarFallback) str = this.tags.scalarFallback(str);
	      return new Scalar(str);
	    } // sets node.resolved on success

	  }, {
	    key: "resolveNode",
	    value: function resolveNode(doc, node, tagName) {
	      var tags = this.tags.filter(function (_ref4) {
	        var tag = _ref4.tag;
	        return tag === tagName;
	      });
	      var generic = tags.find(function (_ref5) {
	        var test = _ref5.test;
	        return !test;
	      });
	      if (node.error) doc.errors.push(node.error);

	      try {
	        if (generic) {
	          var res = generic.resolve(doc, node);
	          if (!(res instanceof Collection$1)) res = new Scalar(res);
	          node.resolved = res;
	        } else {
	          var str = resolveString(doc, node);

	          if (typeof str === 'string' && tags.length > 0) {
	            node.resolved = this.resolveScalar(str, tags);
	          }
	        }
	      } catch (error) {
	        /* istanbul ignore if */
	        if (!error.source) error.source = node;
	        doc.errors.push(error);
	        node.resolved = null;
	      }

	      if (!node.resolved) return null;
	      if (tagName && node.tag) node.resolved.tag = tagName;
	      return node.resolved;
	    }
	  }, {
	    key: "resolveNodeWithFallback",
	    value: function resolveNodeWithFallback(doc, node, tagName) {
	      var res = this.resolveNode(doc, node, tagName);
	      if (Object.prototype.hasOwnProperty.call(node, 'resolved')) return res;
	      var fallback = isMap$1(node) ? Schema.defaultTags.MAP : isSeq(node) ? Schema.defaultTags.SEQ : Schema.defaultTags.STR;
	      /* istanbul ignore else */

	      if (fallback) {
	        doc.warnings.push(new YAMLWarning(node, "The tag ".concat(tagName, " is unavailable, falling back to ").concat(fallback)));

	        var _res = this.resolveNode(doc, node, fallback);

	        _res.tag = tagName;
	        return _res;
	      } else {
	        doc.errors.push(new YAMLReferenceError(node, "The tag ".concat(tagName, " is unavailable")));
	        return null;
	      }
	    }
	  }, {
	    key: "getTagObject",
	    value: function getTagObject(item) {
	      if (item instanceof Alias$1) return Alias$1;

	      if (item.tag) {
	        var match = this.tags.filter(function (t) {
	          return t.tag === item.tag;
	        });
	        if (match.length > 0) return match.find(function (t) {
	          return t.format === item.format;
	        }) || match[0];
	      }

	      var tagObj, obj;

	      if (item instanceof Scalar) {
	        obj = item.value; // TODO: deprecate/remove class check

	        var _match = this.tags.filter(function (t) {
	          return t.identify && t.identify(obj) || t.class && obj instanceof t.class;
	        });

	        tagObj = _match.find(function (t) {
	          return t.format === item.format;
	        }) || _match.find(function (t) {
	          return !t.format;
	        });
	      } else {
	        obj = item;
	        tagObj = this.tags.find(function (t) {
	          return t.nodeClass && obj instanceof t.nodeClass;
	        });
	      }

	      if (!tagObj) {
	        var name = obj && obj.constructor ? obj.constructor.name : _typeof_1(obj);
	        throw new Error("Tag not resolved for ".concat(name, " value"));
	      }

	      return tagObj;
	    } // needs to be called before stringifier to allow for circular anchor refs

	  }, {
	    key: "stringifyProps",
	    value: function stringifyProps(node, tagObj, _ref6) {
	      var anchors = _ref6.anchors,
	          doc = _ref6.doc;
	      var props = [];
	      var anchor = doc.anchors.getName(node);

	      if (anchor) {
	        anchors[anchor] = node;
	        props.push("&".concat(anchor));
	      }

	      if (node.tag) {
	        props.push(doc.stringifyTag(node.tag));
	      } else if (!tagObj.default) {
	        props.push(doc.stringifyTag(tagObj.tag));
	      }

	      return props.join(' ');
	    }
	  }, {
	    key: "stringify",
	    value: function stringify(item, ctx, onComment, onChompKeep) {
	      var tagObj;

	      if (!(item instanceof Node$1)) {
	        var createCtx = {
	          aliasNodes: [],
	          onTagObj: function onTagObj(o) {
	            return tagObj = o;
	          },
	          prevObjects: new Map()
	        };
	        item = this.createNode(item, true, null, createCtx);
	        var anchors = ctx.doc.anchors;

	        var _iterator2 = _createForOfIteratorHelper$b(createCtx.aliasNodes),
	            _step2;

	        try {
	          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	            var alias = _step2.value;
	            alias.source = alias.source.node;
	            var name = anchors.getName(alias.source);

	            if (!name) {
	              name = anchors.newName();
	              anchors.map[name] = alias.source;
	            }
	          }
	        } catch (err) {
	          _iterator2.e(err);
	        } finally {
	          _iterator2.f();
	        }
	      }

	      ctx.tags = this;
	      if (item instanceof Pair) return item.toString(ctx, onComment, onChompKeep);
	      if (!tagObj) tagObj = this.getTagObject(item);
	      var props = this.stringifyProps(item, tagObj, ctx);
	      if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
	      var str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof Collection$1 ? item.toString(ctx, onComment, onChompKeep) : stringifyString(item, ctx, onComment, onChompKeep);
	      return props ? item instanceof Collection$1 && str[0] !== '{' && str[0] !== '[' ? "".concat(props, "\n").concat(ctx.indent).concat(str) : "".concat(props, " ").concat(str) : str;
	    }
	  }]);

	  return Schema;
	}();

	defineProperty(Schema, "defaultPrefix", 'tag:yaml.org,2002:');

	defineProperty(Schema, "defaultTags", {
	  MAP: 'tag:yaml.org,2002:map',
	  SEQ: 'tag:yaml.org,2002:seq',
	  STR: 'tag:yaml.org,2002:str'
	});

	function _createForOfIteratorHelper$c(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$d(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$d(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$d(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$d(o, minLen); }

	function _arrayLikeToArray$d(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	var isCollectionItem = function isCollectionItem(node) {
	  return node && [Type.MAP_KEY, Type.MAP_VALUE, Type.SEQ_ITEM].includes(node.type);
	};

	var Document$1 = /*#__PURE__*/function () {
	  function Document(options) {
	    classCallCheck(this, Document);

	    this.anchors = new Anchors(options.anchorPrefix);
	    this.commentBefore = null;
	    this.comment = null;
	    this.contents = null;
	    this.directivesEndMarker = null;
	    this.errors = [];
	    this.options = options;
	    this.schema = null;
	    this.tagPrefixes = [];
	    this.version = null;
	    this.warnings = [];
	  }

	  createClass(Document, [{
	    key: "assertCollectionContents",
	    value: function assertCollectionContents() {
	      if (this.contents instanceof Collection$1) return true;
	      throw new Error('Expected a YAML collection as document contents');
	    }
	  }, {
	    key: "add",
	    value: function add(value) {
	      this.assertCollectionContents();
	      return this.contents.add(value);
	    }
	  }, {
	    key: "addIn",
	    value: function addIn(path, value) {
	      this.assertCollectionContents();
	      this.contents.addIn(path, value);
	    }
	  }, {
	    key: "delete",
	    value: function _delete(key) {
	      this.assertCollectionContents();
	      return this.contents.delete(key);
	    }
	  }, {
	    key: "deleteIn",
	    value: function deleteIn(path) {
	      if (isEmptyPath(path)) {
	        if (this.contents == null) return false;
	        this.contents = null;
	        return true;
	      }

	      this.assertCollectionContents();
	      return this.contents.deleteIn(path);
	    }
	  }, {
	    key: "getDefaults",
	    value: function getDefaults() {
	      return Document.defaults[this.version] || Document.defaults[this.options.version] || {};
	    }
	  }, {
	    key: "get",
	    value: function get(key, keepScalar) {
	      return this.contents instanceof Collection$1 ? this.contents.get(key, keepScalar) : undefined;
	    }
	  }, {
	    key: "getIn",
	    value: function getIn(path, keepScalar) {
	      if (isEmptyPath(path)) return !keepScalar && this.contents instanceof Scalar ? this.contents.value : this.contents;
	      return this.contents instanceof Collection$1 ? this.contents.getIn(path, keepScalar) : undefined;
	    }
	  }, {
	    key: "has",
	    value: function has(key) {
	      return this.contents instanceof Collection$1 ? this.contents.has(key) : false;
	    }
	  }, {
	    key: "hasIn",
	    value: function hasIn(path) {
	      if (isEmptyPath(path)) return this.contents !== undefined;
	      return this.contents instanceof Collection$1 ? this.contents.hasIn(path) : false;
	    }
	  }, {
	    key: "set",
	    value: function set(key, value) {
	      this.assertCollectionContents();
	      this.contents.set(key, value);
	    }
	  }, {
	    key: "setIn",
	    value: function setIn(path, value) {
	      if (isEmptyPath(path)) this.contents = value;else {
	        this.assertCollectionContents();
	        this.contents.setIn(path, value);
	      }
	    }
	  }, {
	    key: "setSchema",
	    value: function setSchema(id, customTags) {
	      if (!id && !customTags && this.schema) return;
	      if (typeof id === 'number') id = id.toFixed(1);

	      if (id === '1.0' || id === '1.1' || id === '1.2') {
	        if (this.version) this.version = id;else this.options.version = id;
	        delete this.options.schema;
	      } else if (id && typeof id === 'string') {
	        this.options.schema = id;
	      }

	      if (Array.isArray(customTags)) this.options.customTags = customTags;
	      var opt = Object.assign({}, this.getDefaults(), this.options);
	      this.schema = new Schema(opt);
	    }
	  }, {
	    key: "parse",
	    value: function parse(node, prevDoc) {
	      if (this.options.keepCstNodes) this.cstNode = node;
	      if (this.options.keepNodeTypes) this.type = 'DOCUMENT';
	      var _node$directives = node.directives,
	          directives = _node$directives === void 0 ? [] : _node$directives,
	          _node$contents = node.contents,
	          contents = _node$contents === void 0 ? [] : _node$contents,
	          directivesEndMarker = node.directivesEndMarker,
	          error = node.error,
	          valueRange = node.valueRange;

	      if (error) {
	        if (!error.source) error.source = this;
	        this.errors.push(error);
	      }

	      this.parseDirectives(directives, prevDoc);
	      if (directivesEndMarker) this.directivesEndMarker = true;
	      this.range = valueRange ? [valueRange.start, valueRange.end] : null;
	      this.setSchema();
	      this.anchors._cstAliases = [];
	      this.parseContents(contents);
	      this.anchors.resolveNodes();

	      if (this.options.prettyErrors) {
	        var _iterator = _createForOfIteratorHelper$c(this.errors),
	            _step;

	        try {
	          for (_iterator.s(); !(_step = _iterator.n()).done;) {
	            var _error = _step.value;
	            if (_error instanceof YAMLError) _error.makePretty();
	          }
	        } catch (err) {
	          _iterator.e(err);
	        } finally {
	          _iterator.f();
	        }

	        var _iterator2 = _createForOfIteratorHelper$c(this.warnings),
	            _step2;

	        try {
	          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	            var warn = _step2.value;
	            if (warn instanceof YAMLError) warn.makePretty();
	          }
	        } catch (err) {
	          _iterator2.e(err);
	        } finally {
	          _iterator2.f();
	        }
	      }

	      return this;
	    }
	  }, {
	    key: "parseDirectives",
	    value: function parseDirectives(directives, prevDoc) {
	      var _this = this;

	      var directiveComments = [];
	      var hasDirectives = false;
	      directives.forEach(function (directive) {
	        var comment = directive.comment,
	            name = directive.name;

	        switch (name) {
	          case 'TAG':
	            _this.resolveTagDirective(directive);

	            hasDirectives = true;
	            break;

	          case 'YAML':
	          case 'YAML:1.0':
	            _this.resolveYamlDirective(directive);

	            hasDirectives = true;
	            break;

	          default:
	            if (name) {
	              var msg = "YAML only supports %TAG and %YAML directives, and not %".concat(name);

	              _this.warnings.push(new YAMLWarning(directive, msg));
	            }

	        }

	        if (comment) directiveComments.push(comment);
	      });

	      if (prevDoc && !hasDirectives && '1.1' === (this.version || prevDoc.version || this.options.version)) {
	        var copyTagPrefix = function copyTagPrefix(_ref) {
	          var handle = _ref.handle,
	              prefix = _ref.prefix;
	          return {
	            handle: handle,
	            prefix: prefix
	          };
	        };

	        this.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
	        this.version = prevDoc.version;
	      }

	      this.commentBefore = directiveComments.join('\n') || null;
	    }
	  }, {
	    key: "parseContents",
	    value: function parseContents(contents) {
	      var _this2 = this;

	      var comments = {
	        before: [],
	        after: []
	      };
	      var contentNodes = [];
	      var spaceBefore = false;
	      contents.forEach(function (node) {
	        if (node.valueRange) {
	          if (contentNodes.length === 1) {
	            var msg = 'Document is not valid YAML (bad indentation?)';

	            _this2.errors.push(new YAMLSyntaxError(node, msg));
	          }

	          var res = _this2.resolveNode(node);

	          if (spaceBefore) {
	            res.spaceBefore = true;
	            spaceBefore = false;
	          }

	          contentNodes.push(res);
	        } else if (node.comment !== null) {
	          var cc = contentNodes.length === 0 ? comments.before : comments.after;
	          cc.push(node.comment);
	        } else if (node.type === Type.BLANK_LINE) {
	          spaceBefore = true;

	          if (contentNodes.length === 0 && comments.before.length > 0 && !_this2.commentBefore) {
	            // space-separated comments at start are parsed as document comments
	            _this2.commentBefore = comments.before.join('\n');
	            comments.before = [];
	          }
	        }
	      });

	      switch (contentNodes.length) {
	        case 0:
	          this.contents = null;
	          comments.after = comments.before;
	          break;

	        case 1:
	          this.contents = contentNodes[0];

	          if (this.contents) {
	            var cb = comments.before.join('\n') || null;

	            if (cb) {
	              var cbNode = this.contents instanceof Collection$1 && this.contents.items[0] ? this.contents.items[0] : this.contents;
	              cbNode.commentBefore = cbNode.commentBefore ? "".concat(cb, "\n").concat(cbNode.commentBefore) : cb;
	            }
	          } else {
	            comments.after = comments.before.concat(comments.after);
	          }

	          break;

	        default:
	          this.contents = contentNodes;

	          if (this.contents[0]) {
	            this.contents[0].commentBefore = comments.before.join('\n') || null;
	          } else {
	            comments.after = comments.before.concat(comments.after);
	          }

	      }

	      this.comment = comments.after.join('\n') || null;
	    }
	  }, {
	    key: "resolveTagDirective",
	    value: function resolveTagDirective(directive) {
	      var _directive$parameters = slicedToArray(directive.parameters, 2),
	          handle = _directive$parameters[0],
	          prefix = _directive$parameters[1];

	      if (handle && prefix) {
	        if (this.tagPrefixes.every(function (p) {
	          return p.handle !== handle;
	        })) {
	          this.tagPrefixes.push({
	            handle: handle,
	            prefix: prefix
	          });
	        } else {
	          var msg = 'The %TAG directive must only be given at most once per handle in the same document.';
	          this.errors.push(new YAMLSemanticError(directive, msg));
	        }
	      } else {
	        var _msg = 'Insufficient parameters given for %TAG directive';
	        this.errors.push(new YAMLSemanticError(directive, _msg));
	      }
	    }
	  }, {
	    key: "resolveYamlDirective",
	    value: function resolveYamlDirective(directive) {
	      var _directive$parameters2 = slicedToArray(directive.parameters, 1),
	          version = _directive$parameters2[0];

	      if (directive.name === 'YAML:1.0') version = '1.0';

	      if (this.version) {
	        var msg = 'The %YAML directive must only be given at most once per document.';
	        this.errors.push(new YAMLSemanticError(directive, msg));
	      }

	      if (!version) {
	        var _msg2 = 'Insufficient parameters given for %YAML directive';
	        this.errors.push(new YAMLSemanticError(directive, _msg2));
	      } else {
	        if (!Document.defaults[version]) {
	          var v0 = this.version || this.options.version;

	          var _msg3 = "Document will be parsed as YAML ".concat(v0, " rather than YAML ").concat(version);

	          this.warnings.push(new YAMLWarning(directive, _msg3));
	        }

	        this.version = version;
	      }
	    }
	  }, {
	    key: "resolveTagName",
	    value: function resolveTagName(node) {
	      var tag = node.tag,
	          type = node.type;
	      var nonSpecific = false;

	      if (tag) {
	        var handle = tag.handle,
	            suffix = tag.suffix,
	            verbatim = tag.verbatim;

	        if (verbatim) {
	          if (verbatim !== '!' && verbatim !== '!!') return verbatim;
	          var msg = "Verbatim tags aren't resolved, so ".concat(verbatim, " is invalid.");
	          this.errors.push(new YAMLSemanticError(node, msg));
	        } else if (handle === '!' && !suffix) {
	          nonSpecific = true;
	        } else {
	          var prefix = this.tagPrefixes.find(function (p) {
	            return p.handle === handle;
	          });

	          if (!prefix) {
	            var dtp = this.getDefaults().tagPrefixes;
	            if (dtp) prefix = dtp.find(function (p) {
	              return p.handle === handle;
	            });
	          }

	          if (prefix) {
	            if (suffix) {
	              if (handle === '!' && (this.version || this.options.version) === '1.0') {
	                if (suffix[0] === '^') return suffix;

	                if (/[:/]/.test(suffix)) {
	                  // word/foo -> tag:word.yaml.org,2002:foo
	                  var vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
	                  return vocab ? "tag:".concat(vocab[1], ".yaml.org,2002:").concat(vocab[2]) : "tag:".concat(suffix);
	                }
	              }

	              return prefix.prefix + decodeURIComponent(suffix);
	            }

	            this.errors.push(new YAMLSemanticError(node, "The ".concat(handle, " tag has no suffix.")));
	          } else {
	            var _msg4 = "The ".concat(handle, " tag handle is non-default and was not declared.");

	            this.errors.push(new YAMLSemanticError(node, _msg4));
	          }
	        }
	      }

	      switch (type) {
	        case Type.BLOCK_FOLDED:
	        case Type.BLOCK_LITERAL:
	        case Type.QUOTE_DOUBLE:
	        case Type.QUOTE_SINGLE:
	          return Schema.defaultTags.STR;

	        case Type.FLOW_MAP:
	        case Type.MAP:
	          return Schema.defaultTags.MAP;

	        case Type.FLOW_SEQ:
	        case Type.SEQ:
	          return Schema.defaultTags.SEQ;

	        case Type.PLAIN:
	          return nonSpecific ? Schema.defaultTags.STR : null;

	        default:
	          return null;
	      }
	    }
	  }, {
	    key: "resolveNode",
	    value: function resolveNode(node) {
	      if (!node) return null;
	      var anchors = this.anchors,
	          errors = this.errors,
	          schema = this.schema;
	      var hasAnchor = false;
	      var hasTag = false;
	      var comments = {
	        before: [],
	        after: []
	      };
	      var props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;

	      var _iterator3 = _createForOfIteratorHelper$c(props),
	          _step3;

	      try {
	        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	          var _step3$value = _step3.value,
	              start = _step3$value.start,
	              end = _step3$value.end;

	          switch (node.context.src[start]) {
	            case Char.COMMENT:
	              {
	                if (!node.commentHasRequiredWhitespace(start)) {
	                  var _msg7 = 'Comments must be separated from other tokens by white space characters';
	                  errors.push(new YAMLSemanticError(node, _msg7));
	                }

	                var c = node.context.src.slice(start + 1, end);
	                var header = node.header,
	                    valueRange = node.valueRange;

	                if (valueRange && (start > valueRange.start || header && start > header.start)) {
	                  comments.after.push(c);
	                } else {
	                  comments.before.push(c);
	                }
	              }
	              break;

	            case Char.ANCHOR:
	              if (hasAnchor) {
	                var _msg8 = 'A node can have at most one anchor';
	                errors.push(new YAMLSemanticError(node, _msg8));
	              }

	              hasAnchor = true;
	              break;

	            case Char.TAG:
	              if (hasTag) {
	                var _msg9 = 'A node can have at most one tag';
	                errors.push(new YAMLSemanticError(node, _msg9));
	              }

	              hasTag = true;
	              break;
	          }
	        }
	      } catch (err) {
	        _iterator3.e(err);
	      } finally {
	        _iterator3.f();
	      }

	      if (hasAnchor) {
	        var name = node.anchor;
	        var prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor
	        // name have already been resolved, so it may safely be renamed.

	        if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as
	        // anchors need to be available during resolution to allow for
	        // circular references.

	        anchors.map[name] = node;
	      }

	      var res;

	      if (node.type === Type.ALIAS) {
	        if (hasAnchor || hasTag) {
	          var msg = 'An alias node must not specify any properties';
	          errors.push(new YAMLSemanticError(node, msg));
	        }

	        var _name = node.rawValue;
	        var src = anchors.getNode(_name);

	        if (!src) {
	          var _msg5 = "Aliased anchor not found: ".concat(_name);

	          errors.push(new YAMLReferenceError(node, _msg5));
	          return null;
	        } // Lazy resolution for circular references


	        res = new Alias$1(src);

	        anchors._cstAliases.push(res);
	      } else {
	        var tagName = this.resolveTagName(node);

	        if (tagName) {
	          res = schema.resolveNodeWithFallback(this, node, tagName);
	        } else {
	          if (node.type !== Type.PLAIN) {
	            var _msg6 = "Failed to resolve ".concat(node.type, " node here");

	            errors.push(new YAMLSyntaxError(node, _msg6));
	            return null;
	          }

	          try {
	            res = schema.resolveScalar(node.strValue || '');
	          } catch (error) {
	            if (!error.source) error.source = node;
	            errors.push(error);
	            return null;
	          }
	        }
	      }

	      if (res) {
	        res.range = [node.range.start, node.range.end];
	        if (this.options.keepCstNodes) res.cstNode = node;
	        if (this.options.keepNodeTypes) res.type = node.type;
	        var cb = comments.before.join('\n');

	        if (cb) {
	          res.commentBefore = res.commentBefore ? "".concat(res.commentBefore, "\n").concat(cb) : cb;
	        }

	        var ca = comments.after.join('\n');
	        if (ca) res.comment = res.comment ? "".concat(res.comment, "\n").concat(ca) : ca;
	      }

	      return node.resolved = res;
	    }
	  }, {
	    key: "listNonDefaultTags",
	    value: function listNonDefaultTags() {
	      return listTagNames(this.contents).filter(function (t) {
	        return t.indexOf(Schema.defaultPrefix) !== 0;
	      });
	    }
	  }, {
	    key: "setTagPrefix",
	    value: function setTagPrefix(handle, prefix) {
	      if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');

	      if (prefix) {
	        var prev = this.tagPrefixes.find(function (p) {
	          return p.handle === handle;
	        });
	        if (prev) prev.prefix = prefix;else this.tagPrefixes.push({
	          handle: handle,
	          prefix: prefix
	        });
	      } else {
	        this.tagPrefixes = this.tagPrefixes.filter(function (p) {
	          return p.handle !== handle;
	        });
	      }
	    }
	  }, {
	    key: "stringifyTag",
	    value: function stringifyTag(tag) {
	      if ((this.version || this.options.version) === '1.0') {
	        var priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
	        if (priv) return '!' + priv[1];
	        var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
	        return vocab ? "!".concat(vocab[1], "/").concat(vocab[2]) : "!".concat(tag.replace(/^tag:/, ''));
	      } else {
	        var p = this.tagPrefixes.find(function (p) {
	          return tag.indexOf(p.prefix) === 0;
	        });

	        if (!p) {
	          var dtp = this.getDefaults().tagPrefixes;
	          p = dtp && dtp.find(function (p) {
	            return tag.indexOf(p.prefix) === 0;
	          });
	        }

	        if (!p) return tag[0] === '!' ? tag : "!<".concat(tag, ">");
	        var suffix = tag.substr(p.prefix.length).replace(/[!,[\]{}]/g, function (ch) {
	          return {
	            '!': '%21',
	            ',': '%2C',
	            '[': '%5B',
	            ']': '%5D',
	            '{': '%7B',
	            '}': '%7D'
	          }[ch];
	        });
	        return p.handle + suffix;
	      }
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON$1(arg, onAnchor) {
	      var _this3 = this;

	      var _this$options = this.options,
	          keepBlobsInJSON = _this$options.keepBlobsInJSON,
	          mapAsMap = _this$options.mapAsMap,
	          maxAliasCount = _this$options.maxAliasCount;
	      var keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof Scalar));
	      var ctx = {
	        doc: this,
	        indentStep: '  ',
	        keep: keep,
	        mapAsMap: keep && !!mapAsMap,
	        maxAliasCount: maxAliasCount
	      };
	      var anchorNames = Object.keys(this.anchors.map);
	      if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(function (name) {
	        return [_this3.anchors.map[name], {
	          alias: [],
	          aliasCount: 0,
	          count: 1
	        }];
	      }));

	      var res = toJSON(this.contents, arg, ctx);

	      if (typeof onAnchor === 'function' && ctx.anchors) {
	        var _iterator4 = _createForOfIteratorHelper$c(ctx.anchors.values()),
	            _step4;

	        try {
	          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
	            var _step4$value = _step4.value,
	                count = _step4$value.count,
	                _res = _step4$value.res;
	            onAnchor(_res, count);
	          }
	        } catch (err) {
	          _iterator4.e(err);
	        } finally {
	          _iterator4.f();
	        }
	      }

	      return res;
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');
	      var indentSize = this.options.indent;

	      if (!Number.isInteger(indentSize) || indentSize <= 0) {
	        var s = JSON.stringify(indentSize);
	        throw new Error("\"indent\" option must be a positive integer, not ".concat(s));
	      }

	      this.setSchema();
	      var lines = [];
	      var hasDirectives = false;

	      if (this.version) {
	        var vd = '%YAML 1.2';

	        if (this.schema.name === 'yaml-1.1') {
	          if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';
	        }

	        lines.push(vd);
	        hasDirectives = true;
	      }

	      var tagNames = this.listNonDefaultTags();
	      this.tagPrefixes.forEach(function (_ref2) {
	        var handle = _ref2.handle,
	            prefix = _ref2.prefix;

	        if (tagNames.some(function (t) {
	          return t.indexOf(prefix) === 0;
	        })) {
	          lines.push("%TAG ".concat(handle, " ").concat(prefix));
	          hasDirectives = true;
	        }
	      });
	      if (hasDirectives || this.directivesEndMarker) lines.push('---');

	      if (this.commentBefore) {
	        if (hasDirectives || !this.directivesEndMarker) lines.unshift('');
	        lines.unshift(this.commentBefore.replace(/^/gm, '#'));
	      }

	      var ctx = {
	        anchors: {},
	        doc: this,
	        indent: '',
	        indentStep: ' '.repeat(indentSize)
	      };
	      var chompKeep = false;
	      var contentComment = null;

	      if (this.contents) {
	        if (this.contents instanceof Node$1) {
	          if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');
	          if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment

	          ctx.forceBlockIndent = !!this.comment;
	          contentComment = this.contents.comment;
	        }

	        var onChompKeep = contentComment ? null : function () {
	          return chompKeep = true;
	        };
	        var body = this.schema.stringify(this.contents, ctx, function () {
	          return contentComment = null;
	        }, onChompKeep);
	        lines.push(addComment(body, '', contentComment));
	      } else if (this.contents !== undefined) {
	        lines.push(this.schema.stringify(this.contents, ctx));
	      }

	      if (this.comment) {
	        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');
	        lines.push(this.comment.replace(/^/gm, '#'));
	      }

	      return lines.join('\n') + '\n';
	    }
	  }]);

	  return Document;
	}();

	defineProperty(Document$1, "defaults", {
	  '1.0': {
	    schema: 'yaml-1.1',
	    merge: true,
	    tagPrefixes: [{
	      handle: '!',
	      prefix: Schema.defaultPrefix
	    }, {
	      handle: '!!',
	      prefix: 'tag:private.yaml.org,2002:'
	    }]
	  },
	  '1.1': {
	    schema: 'yaml-1.1',
	    merge: true,
	    tagPrefixes: [{
	      handle: '!',
	      prefix: '!'
	    }, {
	      handle: '!!',
	      prefix: Schema.defaultPrefix
	    }]
	  },
	  '1.2': {
	    schema: 'core',
	    merge: false,
	    tagPrefixes: [{
	      handle: '!',
	      prefix: '!'
	    }, {
	      handle: '!!',
	      prefix: Schema.defaultPrefix
	    }]
	  }
	});

	function _createForOfIteratorHelper$d(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$e(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$e(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$e(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$e(o, minLen); }

	function _arrayLikeToArray$e(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function _createSuper$m(Derived) { return function () { var Super = getPrototypeOf(Derived), result; if (_isNativeReflectConstruct$n()) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$n() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var defaultOptions = {
	  anchorPrefix: 'a',
	  customTags: null,
	  indent: 2,
	  indentSeq: true,
	  keepCstNodes: false,
	  keepNodeTypes: true,
	  keepBlobsInJSON: true,
	  mapAsMap: false,
	  maxAliasCount: 100,
	  prettyErrors: false,
	  // TODO Set true in v2
	  simpleKeys: false,
	  version: '1.2'
	};
	var scalarOptions = {
	  get binary() {
	    return binaryOptions;
	  },

	  set binary(opt) {
	    Object.assign(binaryOptions, opt);
	  },

	  get bool() {
	    return boolOptions;
	  },

	  set bool(opt) {
	    Object.assign(boolOptions, opt);
	  },

	  get int() {
	    return intOptions;
	  },

	  set int(opt) {
	    Object.assign(intOptions, opt);
	  },

	  get null() {
	    return nullOptions;
	  },

	  set null(opt) {
	    Object.assign(nullOptions, opt);
	  },

	  get str() {
	    return strOptions;
	  },

	  set str(opt) {
	    Object.assign(strOptions, opt);
	  }

	};

	function createNode(value) {
	  var wrapScalars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	  var tag = arguments.length > 2 ? arguments[2] : undefined;

	  if (tag === undefined && typeof wrapScalars === 'string') {
	    tag = wrapScalars;
	    wrapScalars = true;
	  }

	  var options = Object.assign({}, Document$1.defaults[defaultOptions.version], defaultOptions);
	  var schema = new Schema(options);
	  return schema.createNode(value, wrapScalars, tag);
	}

	var Document$2 = /*#__PURE__*/function (_YAMLDocument) {
	  inherits(Document, _YAMLDocument);

	  var _super = _createSuper$m(Document);

	  function Document(options) {
	    classCallCheck(this, Document);

	    return _super.call(this, Object.assign({}, defaultOptions, options));
	  }

	  return Document;
	}(Document$1);

	function parseAllDocuments(src, options) {
	  var stream = [];
	  var prev;

	  var _iterator = _createForOfIteratorHelper$d(parse(src)),
	      _step;

	  try {
	    for (_iterator.s(); !(_step = _iterator.n()).done;) {
	      var cstDoc = _step.value;
	      var doc = new Document$2(options);
	      doc.parse(cstDoc, prev);
	      stream.push(doc);
	      prev = doc;
	    }
	  } catch (err) {
	    _iterator.e(err);
	  } finally {
	    _iterator.f();
	  }

	  return stream;
	}

	function parseDocument(src, options) {
	  var cst = parse(src);
	  var doc = new Document$2(options).parse(cst[0]);

	  if (cst.length > 1) {
	    var errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';
	    doc.errors.unshift(new YAMLSemanticError(cst[1], errMsg));
	  }

	  return doc;
	}

	function parse$1(src, options) {
	  var doc = parseDocument(src, options);
	  doc.warnings.forEach(function (warning) {
	    return warn(warning);
	  });
	  if (doc.errors.length > 0) throw doc.errors[0];
	  return doc.toJSON();
	}

	function stringify(value, options) {
	  var doc = new Document$2(options);
	  doc.contents = value;
	  return String(doc);
	}

	var YAML = {
	  createNode: createNode,
	  defaultOptions: defaultOptions,
	  Document: Document$2,
	  parse: parse$1,
	  parseAllDocuments: parseAllDocuments,
	  parseCST: parse,
	  parseDocument: parseDocument,
	  scalarOptions: scalarOptions,
	  stringify: stringify
	};

	function _process (v, mod) {
	  var i;
	  var r;

	  if (typeof mod === 'function') {
	    r = mod(v);
	    if (r !== undefined) {
	      v = r;
	    }
	  } else if (Array.isArray(mod)) {
	    for (i = 0; i < mod.length; i++) {
	      r = mod[i](v);
	      if (r !== undefined) {
	        v = r;
	      }
	    }
	  }

	  return v
	}

	function parseKey (key, val) {
	  // detect negative index notation
	  if (key[0] === '-' && Array.isArray(val) && /^-\d+$/.test(key)) {
	    return val.length + parseInt(key, 10)
	  }
	  return key
	}

	function isIndex$1 (k) {
	  return /^\d+$/.test(k)
	}

	function isObject$2 (val) {
	  return Object.prototype.toString.call(val) === '[object Object]'
	}

	function isArrayOrObject (val) {
	  return Object(val) === val
	}

	function isEmptyObject (val) {
	  return Object.keys(val).length === 0
	}

	var blacklist = ['__proto__', 'prototype', 'constructor'];
	var blacklistFilter = function (part) { return blacklist.indexOf(part) === -1 };

	function parsePath (path, sep) {
	  if (path.indexOf('[') >= 0) {
	    path = path.replace(/\[/g, '.').replace(/]/g, '');
	  }

	  var parts = path.split(sep);

	  var check = parts.filter(blacklistFilter);

	  if (check.length !== parts.length) {
	    throw Error('Refusing to update blacklisted property ' + path)
	  }

	  return parts
	}

	var hasOwnProperty$a = Object.prototype.hasOwnProperty;

	function DotObject (separator, override, useArray, useBrackets) {
	  if (!(this instanceof DotObject)) {
	    return new DotObject(separator, override, useArray, useBrackets)
	  }

	  if (typeof override === 'undefined') override = false;
	  if (typeof useArray === 'undefined') useArray = true;
	  if (typeof useBrackets === 'undefined') useBrackets = true;
	  this.separator = separator || '.';
	  this.override = override;
	  this.useArray = useArray;
	  this.useBrackets = useBrackets;
	  this.keepArray = false;

	  // contains touched arrays
	  this.cleanup = [];
	}

	var dotDefault = new DotObject('.', false, true, true);
	function wrap (method) {
	  return function () {
	    return dotDefault[method].apply(dotDefault, arguments)
	  }
	}

	DotObject.prototype._fill = function (a, obj, v, mod) {
	  var k = a.shift();

	  if (a.length > 0) {
	    obj[k] = obj[k] || (this.useArray && isIndex$1(a[0]) ? [] : {});

	    if (!isArrayOrObject(obj[k])) {
	      if (this.override) {
	        obj[k] = {};
	      } else {
	        if (!(isArrayOrObject(v) && isEmptyObject(v))) {
	          throw new Error(
	            'Trying to redefine `' + k + '` which is a ' + typeof obj[k]
	          )
	        }

	        return
	      }
	    }

	    this._fill(a, obj[k], v, mod);
	  } else {
	    if (!this.override && isArrayOrObject(obj[k]) && !isEmptyObject(obj[k])) {
	      if (!(isArrayOrObject(v) && isEmptyObject(v))) {
	        throw new Error("Trying to redefine non-empty obj['" + k + "']")
	      }

	      return
	    }

	    obj[k] = _process(v, mod);
	  }
	};

	/**
	 *
	 * Converts an object with dotted-key/value pairs to it's expanded version
	 *
	 * Optionally transformed by a set of modifiers.
	 *
	 * Usage:
	 *
	 *   var row = {
	 *     'nr': 200,
	 *     'doc.name': '  My Document  '
	 *   }
	 *
	 *   var mods = {
	 *     'doc.name': [_s.trim, _s.underscored]
	 *   }
	 *
	 *   dot.object(row, mods)
	 *
	 * @param {Object} obj
	 * @param {Object} mods
	 */
	DotObject.prototype.object = function (obj, mods) {
	  var self = this;

	  Object.keys(obj).forEach(function (k) {
	    var mod = mods === undefined ? null : mods[k];
	    // normalize array notation.
	    var ok = parsePath(k, self.separator).join(self.separator);

	    if (ok.indexOf(self.separator) !== -1) {
	      self._fill(ok.split(self.separator), obj, obj[k], mod);
	      delete obj[k];
	    } else {
	      obj[k] = _process(obj[k], mod);
	    }
	  });

	  return obj
	};

	/**
	 * @param {String} path dotted path
	 * @param {String} v value to be set
	 * @param {Object} obj object to be modified
	 * @param {Function|Array} mod optional modifier
	 */
	DotObject.prototype.str = function (path, v, obj, mod) {
	  var ok = parsePath(path, this.separator).join(this.separator);

	  if (path.indexOf(this.separator) !== -1) {
	    this._fill(ok.split(this.separator), obj, v, mod);
	  } else {
	    obj[path] = _process(v, mod);
	  }

	  return obj
	};

	/**
	 *
	 * Pick a value from an object using dot notation.
	 *
	 * Optionally remove the value
	 *
	 * @param {String} path
	 * @param {Object} obj
	 * @param {Boolean} remove
	 */
	DotObject.prototype.pick = function (path, obj, remove, reindexArray) {
	  var i;
	  var keys;
	  var val;
	  var key;
	  var cp;

	  keys = parsePath(path, this.separator);
	  for (i = 0; i < keys.length; i++) {
	    key = parseKey(keys[i], obj);
	    if (obj && typeof obj === 'object' && key in obj) {
	      if (i === keys.length - 1) {
	        if (remove) {
	          val = obj[key];
	          if (reindexArray && Array.isArray(obj)) {
	            obj.splice(key, 1);
	          } else {
	            delete obj[key];
	          }
	          if (Array.isArray(obj)) {
	            cp = keys.slice(0, -1).join('.');
	            if (this.cleanup.indexOf(cp) === -1) {
	              this.cleanup.push(cp);
	            }
	          }
	          return val
	        } else {
	          return obj[key]
	        }
	      } else {
	        obj = obj[key];
	      }
	    } else {
	      return undefined
	    }
	  }
	  if (remove && Array.isArray(obj)) {
	    obj = obj.filter(function (n) {
	      return n !== undefined
	    });
	  }
	  return obj
	};
	/**
	 *
	 * Delete value from an object using dot notation.
	 *
	 * @param {String} path
	 * @param {Object} obj
	 * @return {any} The removed value
	 */
	DotObject.prototype.delete = function (path, obj) {
	  return this.remove(path, obj, true)
	};

	/**
	 *
	 * Remove value from an object using dot notation.
	 *
	 * Will remove multiple items if path is an array.
	 * In this case array indexes will be retained until all
	 * removals have been processed.
	 *
	 * Use dot.delete() to automatically  re-index arrays.
	 *
	 * @param {String|Array<String>} path
	 * @param {Object} obj
	 * @param {Boolean} reindexArray
	 * @return {any} The removed value
	 */
	DotObject.prototype.remove = function (path, obj, reindexArray) {
	  var i;

	  this.cleanup = [];
	  if (Array.isArray(path)) {
	    for (i = 0; i < path.length; i++) {
	      this.pick(path[i], obj, true, reindexArray);
	    }
	    if (!reindexArray) {
	      this._cleanup(obj);
	    }
	    return obj
	  } else {
	    return this.pick(path, obj, true, reindexArray)
	  }
	};

	DotObject.prototype._cleanup = function (obj) {
	  var ret;
	  var i;
	  var keys;
	  var root;
	  if (this.cleanup.length) {
	    for (i = 0; i < this.cleanup.length; i++) {
	      keys = this.cleanup[i].split('.');
	      root = keys.splice(0, -1).join('.');
	      ret = root ? this.pick(root, obj) : obj;
	      ret = ret[keys[0]].filter(function (v) {
	        return v !== undefined
	      });
	      this.set(this.cleanup[i], ret, obj);
	    }
	    this.cleanup = [];
	  }
	};

	/**
	 * Alias method  for `dot.remove`
	 *
	 * Note: this is not an alias for dot.delete()
	 *
	 * @param {String|Array<String>} path
	 * @param {Object} obj
	 * @param {Boolean} reindexArray
	 * @return {any} The removed value
	 */
	DotObject.prototype.del = DotObject.prototype.remove;

	/**
	 *
	 * Move a property from one place to the other.
	 *
	 * If the source path does not exist (undefined)
	 * the target property will not be set.
	 *
	 * @param {String} source
	 * @param {String} target
	 * @param {Object} obj
	 * @param {Function|Array} mods
	 * @param {Boolean} merge
	 */
	DotObject.prototype.move = function (source, target, obj, mods, merge) {
	  if (typeof mods === 'function' || Array.isArray(mods)) {
	    this.set(target, _process(this.pick(source, obj, true), mods), obj, merge);
	  } else {
	    merge = mods;
	    this.set(target, this.pick(source, obj, true), obj, merge);
	  }

	  return obj
	};

	/**
	 *
	 * Transfer a property from one object to another object.
	 *
	 * If the source path does not exist (undefined)
	 * the property on the other object will not be set.
	 *
	 * @param {String} source
	 * @param {String} target
	 * @param {Object} obj1
	 * @param {Object} obj2
	 * @param {Function|Array} mods
	 * @param {Boolean} merge
	 */
	DotObject.prototype.transfer = function (
	  source,
	  target,
	  obj1,
	  obj2,
	  mods,
	  merge
	) {
	  if (typeof mods === 'function' || Array.isArray(mods)) {
	    this.set(
	      target,
	      _process(this.pick(source, obj1, true), mods),
	      obj2,
	      merge
	    );
	  } else {
	    merge = mods;
	    this.set(target, this.pick(source, obj1, true), obj2, merge);
	  }

	  return obj2
	};

	/**
	 *
	 * Copy a property from one object to another object.
	 *
	 * If the source path does not exist (undefined)
	 * the property on the other object will not be set.
	 *
	 * @param {String} source
	 * @param {String} target
	 * @param {Object} obj1
	 * @param {Object} obj2
	 * @param {Function|Array} mods
	 * @param {Boolean} merge
	 */
	DotObject.prototype.copy = function (source, target, obj1, obj2, mods, merge) {
	  if (typeof mods === 'function' || Array.isArray(mods)) {
	    this.set(
	      target,
	      _process(
	        // clone what is picked
	        JSON.parse(JSON.stringify(this.pick(source, obj1, false))),
	        mods
	      ),
	      obj2,
	      merge
	    );
	  } else {
	    merge = mods;
	    this.set(target, this.pick(source, obj1, false), obj2, merge);
	  }

	  return obj2
	};

	/**
	 *
	 * Set a property on an object using dot notation.
	 *
	 * @param {String} path
	 * @param {any} val
	 * @param {Object} obj
	 * @param {Boolean} merge
	 */
	DotObject.prototype.set = function (path, val, obj, merge) {
	  var i;
	  var k;
	  var keys;
	  var key;

	  // Do not operate if the value is undefined.
	  if (typeof val === 'undefined') {
	    return obj
	  }
	  keys = parsePath(path, this.separator);

	  for (i = 0; i < keys.length; i++) {
	    key = keys[i];
	    if (i === keys.length - 1) {
	      if (merge && isObject$2(val) && isObject$2(obj[key])) {
	        for (k in val) {
	          if (hasOwnProperty$a.call(val, k)) {
	            obj[key][k] = val[k];
	          }
	        }
	      } else if (merge && Array.isArray(obj[key]) && Array.isArray(val)) {
	        for (var j = 0; j < val.length; j++) {
	          obj[keys[i]].push(val[j]);
	        }
	      } else {
	        obj[key] = val;
	      }
	    } else if (
	      // force the value to be an object
	      !hasOwnProperty$a.call(obj, key) ||
	      (!isObject$2(obj[key]) && !Array.isArray(obj[key]))
	    ) {
	      // initialize as array if next key is numeric
	      if (/^\d+$/.test(keys[i + 1])) {
	        obj[key] = [];
	      } else {
	        obj[key] = {};
	      }
	    }
	    obj = obj[key];
	  }
	  return obj
	};

	/**
	 *
	 * Transform an object
	 *
	 * Usage:
	 *
	 *   var obj = {
	 *     "id": 1,
	 *    "some": {
	 *      "thing": "else"
	 *    }
	 *   }
	 *
	 *   var transform = {
	 *     "id": "nr",
	 *    "some.thing": "name"
	 *   }
	 *
	 *   var tgt = dot.transform(transform, obj)
	 *
	 * @param {Object} recipe Transform recipe
	 * @param {Object} obj Object to be transformed
	 * @param {Array} mods modifiers for the target
	 */
	DotObject.prototype.transform = function (recipe, obj, tgt) {
	  obj = obj || {};
	  tgt = tgt || {};
	  Object.keys(recipe).forEach(
	    function (key) {
	      this.set(recipe[key], this.pick(key, obj), tgt);
	    }.bind(this)
	  );
	  return tgt
	};

	/**
	 *
	 * Convert object to dotted-key/value pair
	 *
	 * Usage:
	 *
	 *   var tgt = dot.dot(obj)
	 *
	 *   or
	 *
	 *   var tgt = {}
	 *   dot.dot(obj, tgt)
	 *
	 * @param {Object} obj source object
	 * @param {Object} tgt target object
	 * @param {Array} path path array (internal)
	 */
	DotObject.prototype.dot = function (obj, tgt, path) {
	  tgt = tgt || {};
	  path = path || [];
	  var isArray = Array.isArray(obj);

	  Object.keys(obj).forEach(
	    function (key) {
	      var index = isArray && this.useBrackets ? '[' + key + ']' : key;
	      if (
	        isArrayOrObject(obj[key]) &&
	        ((isObject$2(obj[key]) && !isEmptyObject(obj[key])) ||
	          (Array.isArray(obj[key]) && !this.keepArray && obj[key].length !== 0))
	      ) {
	        if (isArray && this.useBrackets) {
	          var previousKey = path[path.length - 1] || '';
	          return this.dot(
	            obj[key],
	            tgt,
	            path.slice(0, -1).concat(previousKey + index)
	          )
	        } else {
	          return this.dot(obj[key], tgt, path.concat(index))
	        }
	      } else {
	        if (isArray && this.useBrackets) {
	          tgt[path.join(this.separator).concat('[' + key + ']')] = obj[key];
	        } else {
	          tgt[path.concat(index).join(this.separator)] = obj[key];
	        }
	      }
	    }.bind(this)
	  );
	  return tgt
	};

	DotObject.pick = wrap('pick');
	DotObject.move = wrap('move');
	DotObject.transfer = wrap('transfer');
	DotObject.transform = wrap('transform');
	DotObject.copy = wrap('copy');
	DotObject.object = wrap('object');
	DotObject.str = wrap('str');
	DotObject.set = wrap('set');
	DotObject.delete = wrap('delete');
	DotObject.del = DotObject.remove = wrap('remove');
	DotObject.dot = wrap('dot');
	['override', 'overwrite'].forEach(function (prop) {
	  Object.defineProperty(DotObject, prop, {
	    get: function () {
	      return dotDefault.override
	    },
	    set: function (val) {
	      dotDefault.override = !!val;
	    }
	  });
	});
	['useArray', 'keepArray', 'useBrackets'].forEach(function (prop) {
	  Object.defineProperty(DotObject, prop, {
	    get: function () {
	      return dotDefault[prop]
	    },
	    set: function (val) {
	      dotDefault[prop] = val;
	    }
	  });
	});

	DotObject._process = _process;

	var dotObject = DotObject;

	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;

	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }

	  return target;
	}

	var objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;

	function _objectWithoutProperties(source, excluded) {
	  if (source == null) return {};
	  var target = objectWithoutPropertiesLoose(source, excluded);
	  var key, i;

	  if (Object.getOwnPropertySymbols) {
	    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

	    for (i = 0; i < sourceSymbolKeys.length; i++) {
	      key = sourceSymbolKeys[i];
	      if (excluded.indexOf(key) >= 0) continue;
	      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
	      target[key] = source[key];
	    }
	  }

	  return target;
	}

	var objectWithoutProperties = _objectWithoutProperties;

	/** Used to compose bitmasks for cloning. */
	var CLONE_SYMBOLS_FLAG$2 = 4;

	/**
	 * Creates a shallow clone of `value`.
	 *
	 * **Note:** This method is loosely based on the
	 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	 * and supports cloning arrays, array buffers, booleans, date objects, maps,
	 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	 * arrays. The own enumerable properties of `arguments` objects are cloned
	 * as plain objects. An empty object is returned for uncloneable values such
	 * as error objects, functions, DOM nodes, and WeakMaps.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to clone.
	 * @returns {*} Returns the cloned value.
	 * @see _.cloneDeep
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var shallow = _.clone(objects);
	 * console.log(shallow[0] === objects[0]);
	 * // => true
	 */
	function clone(value) {
	  return _baseClone(value, CLONE_SYMBOLS_FLAG$2);
	}

	var clone_1 = clone;

	var check = function (it) {
	  return it && it.Math == Math && it;
	};

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global_1 =
	  // eslint-disable-next-line no-undef
	  check(typeof globalThis == 'object' && globalThis) ||
	  check(typeof window == 'object' && window) ||
	  check(typeof self == 'object' && self) ||
	  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
	  // eslint-disable-next-line no-new-func
	  Function('return this')();

	var fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var descriptors = !fails(function () {
	  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
	});

	var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// Nashorn ~ JDK8 bug
	var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

	// `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
	var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : nativePropertyIsEnumerable;

	var objectPropertyIsEnumerable = {
		f: f
	};

	var createPropertyDescriptor = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var toString$3 = {}.toString;

	var classofRaw = function (it) {
	  return toString$3.call(it).slice(8, -1);
	};

	var split = ''.split;

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var indexedObject = fails(function () {
	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
	  // eslint-disable-next-line no-prototype-builtins
	  return !Object('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
	} : Object;

	// `RequireObjectCoercible` abstract operation
	// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
	var requireObjectCoercible = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on " + it);
	  return it;
	};

	// toObject with fallback for non-array-like ES3 strings



	var toIndexedObject = function (it) {
	  return indexedObject(requireObjectCoercible(it));
	};

	var isObject$3 = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	// `ToPrimitive` abstract operation
	// https://tc39.github.io/ecma262/#sec-toprimitive
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var toPrimitive = function (input, PREFERRED_STRING) {
	  if (!isObject$3(input)) return input;
	  var fn, val;
	  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject$3(val = fn.call(input))) return val;
	  if (typeof (fn = input.valueOf) == 'function' && !isObject$3(val = fn.call(input))) return val;
	  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject$3(val = fn.call(input))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var hasOwnProperty$b = {}.hasOwnProperty;

	var has = function (it, key) {
	  return hasOwnProperty$b.call(it, key);
	};

	var document$1 = global_1.document;
	// typeof document.createElement is 'object' in old IE
	var EXISTS = isObject$3(document$1) && isObject$3(document$1.createElement);

	var documentCreateElement = function (it) {
	  return EXISTS ? document$1.createElement(it) : {};
	};

	// Thank's IE8 for his funny defineProperty
	var ie8DomDefine = !descriptors && !fails(function () {
	  return Object.defineProperty(documentCreateElement('div'), 'a', {
	    get: function () { return 7; }
	  }).a != 7;
	});

	var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
	var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject(O);
	  P = toPrimitive(P, true);
	  if (ie8DomDefine) try {
	    return nativeGetOwnPropertyDescriptor(O, P);
	  } catch (error) { /* empty */ }
	  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
	};

	var objectGetOwnPropertyDescriptor = {
		f: f$1
	};

	var anObject = function (it) {
	  if (!isObject$3(it)) {
	    throw TypeError(String(it) + ' is not an object');
	  } return it;
	};

	var nativeDefineProperty = Object.defineProperty;

	// `Object.defineProperty` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperty
	var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (ie8DomDefine) try {
	    return nativeDefineProperty(O, P, Attributes);
	  } catch (error) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var objectDefineProperty = {
		f: f$2
	};

	var createNonEnumerableProperty = descriptors ? function (object, key, value) {
	  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var setGlobal = function (key, value) {
	  try {
	    createNonEnumerableProperty(global_1, key, value);
	  } catch (error) {
	    global_1[key] = value;
	  } return value;
	};

	var SHARED = '__core-js_shared__';
	var store = global_1[SHARED] || setGlobal(SHARED, {});

	var sharedStore = store;

	var functionToString = Function.toString;

	// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
	if (typeof sharedStore.inspectSource != 'function') {
	  sharedStore.inspectSource = function (it) {
	    return functionToString.call(it);
	  };
	}

	var inspectSource = sharedStore.inspectSource;

	var WeakMap$2 = global_1.WeakMap;

	var nativeWeakMap = typeof WeakMap$2 === 'function' && /native code/.test(inspectSource(WeakMap$2));

	var isPure = false;

	var shared = createCommonjsModule(function (module) {
	(module.exports = function (key, value) {
	  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: '3.6.5',
	  mode:  'global',
	  copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
	});
	});

	var id = 0;
	var postfix = Math.random();

	var uid = function (key) {
	  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
	};

	var keys$1 = shared('keys');

	var sharedKey = function (key) {
	  return keys$1[key] || (keys$1[key] = uid(key));
	};

	var hiddenKeys = {};

	var WeakMap$3 = global_1.WeakMap;
	var set$2, get$2, has$1;

	var enforce = function (it) {
	  return has$1(it) ? get$2(it) : set$2(it, {});
	};

	var getterFor = function (TYPE) {
	  return function (it) {
	    var state;
	    if (!isObject$3(it) || (state = get$2(it)).type !== TYPE) {
	      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
	    } return state;
	  };
	};

	if (nativeWeakMap) {
	  var store$1 = new WeakMap$3();
	  var wmget = store$1.get;
	  var wmhas = store$1.has;
	  var wmset = store$1.set;
	  set$2 = function (it, metadata) {
	    wmset.call(store$1, it, metadata);
	    return metadata;
	  };
	  get$2 = function (it) {
	    return wmget.call(store$1, it) || {};
	  };
	  has$1 = function (it) {
	    return wmhas.call(store$1, it);
	  };
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys[STATE] = true;
	  set$2 = function (it, metadata) {
	    createNonEnumerableProperty(it, STATE, metadata);
	    return metadata;
	  };
	  get$2 = function (it) {
	    return has(it, STATE) ? it[STATE] : {};
	  };
	  has$1 = function (it) {
	    return has(it, STATE);
	  };
	}

	var internalState = {
	  set: set$2,
	  get: get$2,
	  has: has$1,
	  enforce: enforce,
	  getterFor: getterFor
	};

	var redefine = createCommonjsModule(function (module) {
	var getInternalState = internalState.get;
	var enforceInternalState = internalState.enforce;
	var TEMPLATE = String(String).split('String');

	(module.exports = function (O, key, value, options) {
	  var unsafe = options ? !!options.unsafe : false;
	  var simple = options ? !!options.enumerable : false;
	  var noTargetGet = options ? !!options.noTargetGet : false;
	  if (typeof value == 'function') {
	    if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
	    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
	  }
	  if (O === global_1) {
	    if (simple) O[key] = value;
	    else setGlobal(key, value);
	    return;
	  } else if (!unsafe) {
	    delete O[key];
	  } else if (!noTargetGet && O[key]) {
	    simple = true;
	  }
	  if (simple) O[key] = value;
	  else createNonEnumerableProperty(O, key, value);
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, 'toString', function toString() {
	  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
	});
	});

	var path = global_1;

	var aFunction = function (variable) {
	  return typeof variable == 'function' ? variable : undefined;
	};

	var getBuiltIn = function (namespace, method) {
	  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace])
	    : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
	};

	var ceil = Math.ceil;
	var floor = Math.floor;

	// `ToInteger` abstract operation
	// https://tc39.github.io/ecma262/#sec-tointeger
	var toInteger = function (argument) {
	  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
	};

	var min = Math.min;

	// `ToLength` abstract operation
	// https://tc39.github.io/ecma262/#sec-tolength
	var toLength = function (argument) {
	  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
	};

	var max = Math.max;
	var min$1 = Math.min;

	// Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
	var toAbsoluteIndex = function (index, length) {
	  var integer = toInteger(index);
	  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
	};

	// `Array.prototype.{ indexOf, includes }` methods implementation
	var createMethod = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var arrayIncludes = {
	  // `Array.prototype.includes` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
	  includes: createMethod(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod(false)
	};

	var indexOf = arrayIncludes.indexOf;


	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (has(O, key = names[i++])) {
	    ~indexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	// IE8- don't enum bug keys
	var enumBugKeys = [
	  'constructor',
	  'hasOwnProperty',
	  'isPrototypeOf',
	  'propertyIsEnumerable',
	  'toLocaleString',
	  'toString',
	  'valueOf'
	];

	var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');

	// `Object.getOwnPropertyNames` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
	var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return objectKeysInternal(O, hiddenKeys$1);
	};

	var objectGetOwnPropertyNames = {
		f: f$3
	};

	var f$4 = Object.getOwnPropertySymbols;

	var objectGetOwnPropertySymbols = {
		f: f$4
	};

	// all object keys, includes non-enumerable and symbols
	var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
	  var keys = objectGetOwnPropertyNames.f(anObject(it));
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
	};

	var copyConstructorProperties = function (target, source) {
	  var keys = ownKeys(source);
	  var defineProperty = objectDefineProperty.f;
	  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
	  }
	};

	var replacement = /#|\.prototype\./;

	var isForced = function (feature, detection) {
	  var value = data[normalize(feature)];
	  return value == POLYFILL ? true
	    : value == NATIVE ? false
	    : typeof detection == 'function' ? fails(detection)
	    : !!detection;
	};

	var normalize = isForced.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};

	var data = isForced.data = {};
	var NATIVE = isForced.NATIVE = 'N';
	var POLYFILL = isForced.POLYFILL = 'P';

	var isForced_1 = isForced;

	var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






	/*
	  options.target      - name of the target object
	  options.global      - target is the global object
	  options.stat        - export as static methods of target
	  options.proto       - export as prototype methods of target
	  options.real        - real prototype method for the `pure` version
	  options.forced      - export even if the native feature is available
	  options.bind        - bind methods to the target, required for the `pure` version
	  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
	  options.sham        - add a flag to not completely full polyfills
	  options.enumerable  - export as enumerable property
	  options.noTargetGet - prevent calling a getter on target
	*/
	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
	  if (GLOBAL) {
	    target = global_1;
	  } else if (STATIC) {
	    target = global_1[TARGET] || setGlobal(TARGET, {});
	  } else {
	    target = (global_1[TARGET] || {}).prototype;
	  }
	  if (target) for (key in source) {
	    sourceProperty = source[key];
	    if (options.noTargetGet) {
	      descriptor = getOwnPropertyDescriptor$1(target, key);
	      targetProperty = descriptor && descriptor.value;
	    } else targetProperty = target[key];
	    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
	    // contained in target
	    if (!FORCED && targetProperty !== undefined) {
	      if (typeof sourceProperty === typeof targetProperty) continue;
	      copyConstructorProperties(sourceProperty, targetProperty);
	    }
	    // add a flag to not completely full polyfills
	    if (options.sham || (targetProperty && targetProperty.sham)) {
	      createNonEnumerableProperty(sourceProperty, 'sham', true);
	    }
	    // extend global
	    redefine(target, key, sourceProperty, options);
	  }
	};

	var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
	  // Chrome 38 Symbol has incorrect toString conversion
	  // eslint-disable-next-line no-undef
	  return !String(Symbol());
	});

	var useSymbolAsUid = nativeSymbol
	  // eslint-disable-next-line no-undef
	  && !Symbol.sham
	  // eslint-disable-next-line no-undef
	  && typeof Symbol.iterator == 'symbol';

	// `IsArray` abstract operation
	// https://tc39.github.io/ecma262/#sec-isarray
	var isArray$3 = Array.isArray || function isArray(arg) {
	  return classofRaw(arg) == 'Array';
	};

	// `ToObject` abstract operation
	// https://tc39.github.io/ecma262/#sec-toobject
	var toObject = function (argument) {
	  return Object(requireObjectCoercible(argument));
	};

	// `Object.keys` method
	// https://tc39.github.io/ecma262/#sec-object.keys
	var objectKeys = Object.keys || function keys(O) {
	  return objectKeysInternal(O, enumBugKeys);
	};

	// `Object.defineProperties` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperties
	var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;
	  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
	  return O;
	};

	var html = getBuiltIn('document', 'documentElement');

	var GT = '>';
	var LT = '<';
	var PROTOTYPE = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO = sharedKey('IE_PROTO');

	var EmptyConstructor = function () { /* empty */ };

	var scriptTag = function (content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	};

	// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
	var NullProtoObjectViaActiveX = function (activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null; // avoid memory leak
	  return temp;
	};

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var NullProtoObjectViaIFrame = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  // https://github.com/zloirock/core-js/issues/475
	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	};

	// Check for document.domain and active x support
	// No need to use active x approach when document.domain is not set
	// see https://github.com/es-shims/es5-shim/issues/150
	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	// avoid IE GC bug
	var activeXDocument;
	var NullProtoObject = function () {
	  try {
	    /* global ActiveXObject */
	    activeXDocument = document.domain && new ActiveXObject('htmlfile');
	  } catch (error) { /* ignore */ }
	  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
	  var length = enumBugKeys.length;
	  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
	  return NullProtoObject();
	};

	hiddenKeys[IE_PROTO] = true;

	// `Object.create` method
	// https://tc39.github.io/ecma262/#sec-object.create
	var objectCreate$1 = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE] = anObject(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = NullProtoObject();
	  return Properties === undefined ? result : objectDefineProperties(result, Properties);
	};

	var nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;

	var toString$4 = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function (it) {
	  try {
	    return nativeGetOwnPropertyNames(it);
	  } catch (error) {
	    return windowNames.slice();
	  }
	};

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var f$5 = function getOwnPropertyNames(it) {
	  return windowNames && toString$4.call(it) == '[object Window]'
	    ? getWindowNames(it)
	    : nativeGetOwnPropertyNames(toIndexedObject(it));
	};

	var objectGetOwnPropertyNamesExternal = {
		f: f$5
	};

	var WellKnownSymbolsStore = shared('wks');
	var Symbol$2 = global_1.Symbol;
	var createWellKnownSymbol = useSymbolAsUid ? Symbol$2 : Symbol$2 && Symbol$2.withoutSetter || uid;

	var wellKnownSymbol = function (name) {
	  if (!has(WellKnownSymbolsStore, name)) {
	    if (nativeSymbol && has(Symbol$2, name)) WellKnownSymbolsStore[name] = Symbol$2[name];
	    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
	  } return WellKnownSymbolsStore[name];
	};

	var f$6 = wellKnownSymbol;

	var wellKnownSymbolWrapped = {
		f: f$6
	};

	var defineProperty$2 = objectDefineProperty.f;

	var defineWellKnownSymbol = function (NAME) {
	  var Symbol = path.Symbol || (path.Symbol = {});
	  if (!has(Symbol, NAME)) defineProperty$2(Symbol, NAME, {
	    value: wellKnownSymbolWrapped.f(NAME)
	  });
	};

	var defineProperty$3 = objectDefineProperty.f;



	var TO_STRING_TAG = wellKnownSymbol('toStringTag');

	var setToStringTag = function (it, TAG, STATIC) {
	  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
	    defineProperty$3(it, TO_STRING_TAG, { configurable: true, value: TAG });
	  }
	};

	var aFunction$1 = function (it) {
	  if (typeof it != 'function') {
	    throw TypeError(String(it) + ' is not a function');
	  } return it;
	};

	// optional / simple context binding
	var functionBindContext = function (fn, that, length) {
	  aFunction$1(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 0: return function () {
	      return fn.call(that);
	    };
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var SPECIES = wellKnownSymbol('species');

	// `ArraySpeciesCreate` abstract operation
	// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
	var arraySpeciesCreate = function (originalArray, length) {
	  var C;
	  if (isArray$3(originalArray)) {
	    C = originalArray.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray$3(C.prototype))) C = undefined;
	    else if (isObject$3(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
	};

	var push = [].push;

	// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
	var createMethod$1 = function (TYPE) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  return function ($this, callbackfn, that, specificCreate) {
	    var O = toObject($this);
	    var self = indexedObject(O);
	    var boundFunction = functionBindContext(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var create = specificCreate || arraySpeciesCreate;
	    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var value, result;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      value = self[index];
	      result = boundFunction(value, index, O);
	      if (TYPE) {
	        if (IS_MAP) target[index] = result; // map
	        else if (result) switch (TYPE) {
	          case 3: return true;              // some
	          case 5: return value;             // find
	          case 6: return index;             // findIndex
	          case 2: push.call(target, value); // filter
	        } else if (IS_EVERY) return false;  // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
	  };
	};

	var arrayIteration = {
	  // `Array.prototype.forEach` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	  forEach: createMethod$1(0),
	  // `Array.prototype.map` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.map
	  map: createMethod$1(1),
	  // `Array.prototype.filter` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
	  filter: createMethod$1(2),
	  // `Array.prototype.some` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.some
	  some: createMethod$1(3),
	  // `Array.prototype.every` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.every
	  every: createMethod$1(4),
	  // `Array.prototype.find` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.find
	  find: createMethod$1(5),
	  // `Array.prototype.findIndex` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
	  findIndex: createMethod$1(6)
	};

	var $forEach = arrayIteration.forEach;

	var HIDDEN = sharedKey('hidden');
	var SYMBOL = 'Symbol';
	var PROTOTYPE$1 = 'prototype';
	var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
	var setInternalState = internalState.set;
	var getInternalState = internalState.getterFor(SYMBOL);
	var ObjectPrototype = Object[PROTOTYPE$1];
	var $Symbol = global_1.Symbol;
	var $stringify = getBuiltIn('JSON', 'stringify');
	var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
	var nativeDefineProperty$1 = objectDefineProperty.f;
	var nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;
	var nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;
	var AllSymbols = shared('symbols');
	var ObjectPrototypeSymbols = shared('op-symbols');
	var StringToSymbolRegistry = shared('string-to-symbol-registry');
	var SymbolToStringRegistry = shared('symbol-to-string-registry');
	var WellKnownSymbolsStore$1 = shared('wks');
	var QObject = global_1.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDescriptor = descriptors && fails(function () {
	  return objectCreate$1(nativeDefineProperty$1({}, 'a', {
	    get: function () { return nativeDefineProperty$1(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (O, P, Attributes) {
	  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype, P);
	  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
	  nativeDefineProperty$1(O, P, Attributes);
	  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
	    nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);
	  }
	} : nativeDefineProperty$1;

	var wrap$1 = function (tag, description) {
	  var symbol = AllSymbols[tag] = objectCreate$1($Symbol[PROTOTYPE$1]);
	  setInternalState(symbol, {
	    type: SYMBOL,
	    tag: tag,
	    description: description
	  });
	  if (!descriptors) symbol.description = description;
	  return symbol;
	};

	var isSymbol$1 = useSymbolAsUid ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return Object(it) instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(O, P, Attributes) {
	  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
	  anObject(O);
	  var key = toPrimitive(P, true);
	  anObject(Attributes);
	  if (has(AllSymbols, key)) {
	    if (!Attributes.enumerable) {
	      if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));
	      O[HIDDEN][key] = true;
	    } else {
	      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
	      Attributes = objectCreate$1(Attributes, { enumerable: createPropertyDescriptor(0, false) });
	    } return setSymbolDescriptor(O, key, Attributes);
	  } return nativeDefineProperty$1(O, key, Attributes);
	};

	var $defineProperties = function defineProperties(O, Properties) {
	  anObject(O);
	  var properties = toIndexedObject(Properties);
	  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
	  $forEach(keys, function (key) {
	    if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
	  });
	  return O;
	};

	var $create = function create(O, Properties) {
	  return Properties === undefined ? objectCreate$1(O) : $defineProperties(objectCreate$1(O), Properties);
	};

	var $propertyIsEnumerable = function propertyIsEnumerable(V) {
	  var P = toPrimitive(V, true);
	  var enumerable = nativePropertyIsEnumerable$1.call(this, P);
	  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
	  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
	};

	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
	  var it = toIndexedObject(O);
	  var key = toPrimitive(P, true);
	  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
	  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);
	  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
	    descriptor.enumerable = true;
	  }
	  return descriptor;
	};

	var $getOwnPropertyNames = function getOwnPropertyNames(O) {
	  var names = nativeGetOwnPropertyNames$1(toIndexedObject(O));
	  var result = [];
	  $forEach(names, function (key) {
	    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
	  });
	  return result;
	};

	var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
	  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
	  var names = nativeGetOwnPropertyNames$1(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
	  var result = [];
	  $forEach(names, function (key) {
	    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
	      result.push(AllSymbols[key]);
	    }
	  });
	  return result;
	};

	// `Symbol` constructor
	// https://tc39.github.io/ecma262/#sec-symbol-constructor
	if (!nativeSymbol) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
	    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
	    var tag = uid(description);
	    var setter = function (value) {
	      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
	    };
	    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
	    return wrap$1(tag, description);
	  };

	  redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
	    return getInternalState(this).tag;
	  });

	  redefine($Symbol, 'withoutSetter', function (description) {
	    return wrap$1(uid(description), description);
	  });

	  objectPropertyIsEnumerable.f = $propertyIsEnumerable;
	  objectDefineProperty.f = $defineProperty;
	  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
	  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
	  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

	  wellKnownSymbolWrapped.f = function (name) {
	    return wrap$1(wellKnownSymbol(name), name);
	  };

	  if (descriptors) {
	    // https://github.com/tc39/proposal-Symbol-description
	    nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {
	      configurable: true,
	      get: function description() {
	        return getInternalState(this).description;
	      }
	    });
	    {
	      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
	    }
	  }
	}

	_export({ global: true, wrap: true, forced: !nativeSymbol, sham: !nativeSymbol }, {
	  Symbol: $Symbol
	});

	$forEach(objectKeys(WellKnownSymbolsStore$1), function (name) {
	  defineWellKnownSymbol(name);
	});

	_export({ target: SYMBOL, stat: true, forced: !nativeSymbol }, {
	  // `Symbol.for` method
	  // https://tc39.github.io/ecma262/#sec-symbol.for
	  'for': function (key) {
	    var string = String(key);
	    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
	    var symbol = $Symbol(string);
	    StringToSymbolRegistry[string] = symbol;
	    SymbolToStringRegistry[symbol] = string;
	    return symbol;
	  },
	  // `Symbol.keyFor` method
	  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
	  keyFor: function keyFor(sym) {
	    if (!isSymbol$1(sym)) throw TypeError(sym + ' is not a symbol');
	    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
	  },
	  useSetter: function () { USE_SETTER = true; },
	  useSimple: function () { USE_SETTER = false; }
	});

	_export({ target: 'Object', stat: true, forced: !nativeSymbol, sham: !descriptors }, {
	  // `Object.create` method
	  // https://tc39.github.io/ecma262/#sec-object.create
	  create: $create,
	  // `Object.defineProperty` method
	  // https://tc39.github.io/ecma262/#sec-object.defineproperty
	  defineProperty: $defineProperty,
	  // `Object.defineProperties` method
	  // https://tc39.github.io/ecma262/#sec-object.defineproperties
	  defineProperties: $defineProperties,
	  // `Object.getOwnPropertyDescriptor` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
	});

	_export({ target: 'Object', stat: true, forced: !nativeSymbol }, {
	  // `Object.getOwnPropertyNames` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // `Object.getOwnPropertySymbols` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
	// https://bugs.chromium.org/p/v8/issues/detail?id=3443
	_export({ target: 'Object', stat: true, forced: fails(function () { objectGetOwnPropertySymbols.f(1); }) }, {
	  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
	    return objectGetOwnPropertySymbols.f(toObject(it));
	  }
	});

	// `JSON.stringify` method behavior with symbols
	// https://tc39.github.io/ecma262/#sec-json.stringify
	if ($stringify) {
	  var FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function () {
	    var symbol = $Symbol();
	    // MS Edge converts symbol values to JSON as {}
	    return $stringify([symbol]) != '[null]'
	      // WebKit converts symbol values to JSON as null
	      || $stringify({ a: symbol }) != '{}'
	      // V8 throws on boxed symbols
	      || $stringify(Object(symbol)) != '{}';
	  });

	  _export({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
	    // eslint-disable-next-line no-unused-vars
	    stringify: function stringify(it, replacer, space) {
	      var args = [it];
	      var index = 1;
	      var $replacer;
	      while (arguments.length > index) args.push(arguments[index++]);
	      $replacer = replacer;
	      if (!isObject$3(replacer) && it === undefined || isSymbol$1(it)) return; // IE8 returns string on undefined
	      if (!isArray$3(replacer)) replacer = function (key, value) {
	        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	        if (!isSymbol$1(value)) return value;
	      };
	      args[1] = replacer;
	      return $stringify.apply(null, args);
	    }
	  });
	}

	// `Symbol.prototype[@@toPrimitive]` method
	// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
	if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {
	  createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
	}
	// `Symbol.prototype[@@toStringTag]` property
	// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
	setToStringTag($Symbol, SYMBOL);

	hiddenKeys[HIDDEN] = true;

	// `Symbol.asyncIterator` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.asynciterator
	defineWellKnownSymbol('asyncIterator');

	var defineProperty$4 = objectDefineProperty.f;


	var NativeSymbol = global_1.Symbol;

	if (descriptors && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
	  // Safari 12 bug
	  NativeSymbol().description !== undefined
	)) {
	  var EmptyStringDescriptionStore = {};
	  // wrap Symbol constructor for correct work with undefined description
	  var SymbolWrapper = function Symbol() {
	    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
	    var result = this instanceof SymbolWrapper
	      ? new NativeSymbol(description)
	      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
	      : description === undefined ? NativeSymbol() : NativeSymbol(description);
	    if (description === '') EmptyStringDescriptionStore[result] = true;
	    return result;
	  };
	  copyConstructorProperties(SymbolWrapper, NativeSymbol);
	  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
	  symbolPrototype.constructor = SymbolWrapper;

	  var symbolToString$1 = symbolPrototype.toString;
	  var native = String(NativeSymbol('test')) == 'Symbol(test)';
	  var regexp = /^Symbol\((.*)\)[^)]+$/;
	  defineProperty$4(symbolPrototype, 'description', {
	    configurable: true,
	    get: function description() {
	      var symbol = isObject$3(this) ? this.valueOf() : this;
	      var string = symbolToString$1.call(symbol);
	      if (has(EmptyStringDescriptionStore, symbol)) return '';
	      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
	      return desc === '' ? undefined : desc;
	    }
	  });

	  _export({ global: true, forced: true }, {
	    Symbol: SymbolWrapper
	  });
	}

	// `Symbol.hasInstance` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.hasinstance
	defineWellKnownSymbol('hasInstance');

	// `Symbol.isConcatSpreadable` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.isconcatspreadable
	defineWellKnownSymbol('isConcatSpreadable');

	// `Symbol.iterator` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.iterator
	defineWellKnownSymbol('iterator');

	// `Symbol.match` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.match
	defineWellKnownSymbol('match');

	// `Symbol.matchAll` well-known symbol
	defineWellKnownSymbol('matchAll');

	// `Symbol.replace` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.replace
	defineWellKnownSymbol('replace');

	// `Symbol.search` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.search
	defineWellKnownSymbol('search');

	// `Symbol.species` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.species
	defineWellKnownSymbol('species');

	// `Symbol.split` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.split
	defineWellKnownSymbol('split');

	// `Symbol.toPrimitive` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.toprimitive
	defineWellKnownSymbol('toPrimitive');

	// `Symbol.toStringTag` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.tostringtag
	defineWellKnownSymbol('toStringTag');

	// `Symbol.unscopables` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.unscopables
	defineWellKnownSymbol('unscopables');

	var nativeAssign = Object.assign;
	var defineProperty$5 = Object.defineProperty;

	// `Object.assign` method
	// https://tc39.github.io/ecma262/#sec-object.assign
	var objectAssign = !nativeAssign || fails(function () {
	  // should have correct order of operations (Edge bug)
	  if (descriptors && nativeAssign({ b: 1 }, nativeAssign(defineProperty$5({}, 'a', {
	    enumerable: true,
	    get: function () {
	      defineProperty$5(this, 'b', {
	        value: 3,
	        enumerable: false
	      });
	    }
	  }), { b: 2 })).b !== 1) return true;
	  // should work with symbols and should have deterministic property order (V8 bug)
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var symbol = Symbol();
	  var alphabet = 'abcdefghijklmnopqrst';
	  A[symbol] = 7;
	  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
	  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
	}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
	  var T = toObject(target);
	  var argumentsLength = arguments.length;
	  var index = 1;
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  var propertyIsEnumerable = objectPropertyIsEnumerable.f;
	  while (argumentsLength > index) {
	    var S = indexedObject(arguments[index++]);
	    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) {
	      key = keys[j++];
	      if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];
	    }
	  } return T;
	} : nativeAssign;

	// `Object.assign` method
	// https://tc39.github.io/ecma262/#sec-object.assign
	_export({ target: 'Object', stat: true, forced: Object.assign !== objectAssign }, {
	  assign: objectAssign
	});

	// `Object.create` method
	// https://tc39.github.io/ecma262/#sec-object.create
	_export({ target: 'Object', stat: true, sham: !descriptors }, {
	  create: objectCreate$1
	});

	// `Object.defineProperty` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperty
	_export({ target: 'Object', stat: true, forced: !descriptors, sham: !descriptors }, {
	  defineProperty: objectDefineProperty.f
	});

	// `Object.defineProperties` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperties
	_export({ target: 'Object', stat: true, forced: !descriptors, sham: !descriptors }, {
	  defineProperties: objectDefineProperties
	});

	var propertyIsEnumerable$2 = objectPropertyIsEnumerable.f;

	// `Object.{ entries, values }` methods implementation
	var createMethod$2 = function (TO_ENTRIES) {
	  return function (it) {
	    var O = toIndexedObject(it);
	    var keys = objectKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) {
	      key = keys[i++];
	      if (!descriptors || propertyIsEnumerable$2.call(O, key)) {
	        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
	      }
	    }
	    return result;
	  };
	};

	var objectToArray = {
	  // `Object.entries` method
	  // https://tc39.github.io/ecma262/#sec-object.entries
	  entries: createMethod$2(true),
	  // `Object.values` method
	  // https://tc39.github.io/ecma262/#sec-object.values
	  values: createMethod$2(false)
	};

	var $entries = objectToArray.entries;

	// `Object.entries` method
	// https://tc39.github.io/ecma262/#sec-object.entries
	_export({ target: 'Object', stat: true }, {
	  entries: function entries(O) {
	    return $entries(O);
	  }
	});

	var freezing = !fails(function () {
	  return Object.isExtensible(Object.preventExtensions({}));
	});

	var internalMetadata = createCommonjsModule(function (module) {
	var defineProperty = objectDefineProperty.f;



	var METADATA = uid('meta');
	var id = 0;

	var isExtensible = Object.isExtensible || function () {
	  return true;
	};

	var setMetadata = function (it) {
	  defineProperty(it, METADATA, { value: {
	    objectID: 'O' + ++id, // object ID
	    weakData: {}          // weak collections IDs
	  } });
	};

	var fastKey = function (it, create) {
	  // return a primitive with prefix
	  if (!isObject$3(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!has(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMetadata(it);
	  // return object ID
	  } return it[METADATA].objectID;
	};

	var getWeakData = function (it, create) {
	  if (!has(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMetadata(it);
	  // return the store of weak collections IDs
	  } return it[METADATA].weakData;
	};

	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
	  return it;
	};

	var meta = module.exports = {
	  REQUIRED: false,
	  fastKey: fastKey,
	  getWeakData: getWeakData,
	  onFreeze: onFreeze
	};

	hiddenKeys[METADATA] = true;
	});
	var internalMetadata_1 = internalMetadata.REQUIRED;
	var internalMetadata_2 = internalMetadata.fastKey;
	var internalMetadata_3 = internalMetadata.getWeakData;
	var internalMetadata_4 = internalMetadata.onFreeze;

	var onFreeze = internalMetadata.onFreeze;

	var nativeFreeze = Object.freeze;
	var FAILS_ON_PRIMITIVES = fails(function () { nativeFreeze(1); });

	// `Object.freeze` method
	// https://tc39.github.io/ecma262/#sec-object.freeze
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !freezing }, {
	  freeze: function freeze(it) {
	    return nativeFreeze && isObject$3(it) ? nativeFreeze(onFreeze(it)) : it;
	  }
	});

	var iterators = {};

	var ITERATOR = wellKnownSymbol('iterator');
	var ArrayPrototype = Array.prototype;

	// check on default Array iterator
	var isArrayIteratorMethod = function (it) {
	  return it !== undefined && (iterators.Array === it || ArrayPrototype[ITERATOR] === it);
	};

	var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
	var test = {};

	test[TO_STRING_TAG$1] = 'z';

	var toStringTagSupport = String(test) === '[object z]';

	var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
	// ES3 wrong here
	var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (error) { /* empty */ }
	};

	// getting tag from ES6+ `Object.prototype.toString`
	var classof = toStringTagSupport ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == 'string' ? tag
	    // builtinTag case
	    : CORRECT_ARGUMENTS ? classofRaw(O)
	    // ES3 arguments fallback
	    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
	};

	var ITERATOR$1 = wellKnownSymbol('iterator');

	var getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$1]
	    || it['@@iterator']
	    || iterators[classof(it)];
	};

	// call something on iterator step with safe closing on error
	var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
	  try {
	    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (error) {
	    var returnMethod = iterator['return'];
	    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
	    throw error;
	  }
	};

	var iterate_1 = createCommonjsModule(function (module) {
	var Result = function (stopped, result) {
	  this.stopped = stopped;
	  this.result = result;
	};

	var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
	  var boundFunction = functionBindContext(fn, that, AS_ENTRIES ? 2 : 1);
	  var iterator, iterFn, index, length, result, next, step;

	  if (IS_ITERATOR) {
	    iterator = iterable;
	  } else {
	    iterFn = getIteratorMethod(iterable);
	    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
	    // optimisation for array iterators
	    if (isArrayIteratorMethod(iterFn)) {
	      for (index = 0, length = toLength(iterable.length); length > index; index++) {
	        result = AS_ENTRIES
	          ? boundFunction(anObject(step = iterable[index])[0], step[1])
	          : boundFunction(iterable[index]);
	        if (result && result instanceof Result) return result;
	      } return new Result(false);
	    }
	    iterator = iterFn.call(iterable);
	  }

	  next = iterator.next;
	  while (!(step = next.call(iterator)).done) {
	    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
	    if (typeof result == 'object' && result && result instanceof Result) return result;
	  } return new Result(false);
	};

	iterate.stop = function (result) {
	  return new Result(true, result);
	};
	});

	var createProperty = function (object, key, value) {
	  var propertyKey = toPrimitive(key);
	  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
	  else object[propertyKey] = value;
	};

	// `Object.fromEntries` method
	// https://github.com/tc39/proposal-object-from-entries
	_export({ target: 'Object', stat: true }, {
	  fromEntries: function fromEntries(iterable) {
	    var obj = {};
	    iterate_1(iterable, function (k, v) {
	      createProperty(obj, k, v);
	    }, undefined, true);
	    return obj;
	  }
	});

	var nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;


	var FAILS_ON_PRIMITIVES$1 = fails(function () { nativeGetOwnPropertyDescriptor$2(1); });
	var FORCED = !descriptors || FAILS_ON_PRIMITIVES$1;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
	_export({ target: 'Object', stat: true, forced: FORCED, sham: !descriptors }, {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
	    return nativeGetOwnPropertyDescriptor$2(toIndexedObject(it), key);
	  }
	});

	// `Object.getOwnPropertyDescriptors` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
	_export({ target: 'Object', stat: true, sham: !descriptors }, {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
	    var O = toIndexedObject(object);
	    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	    var keys = ownKeys(O);
	    var result = {};
	    var index = 0;
	    var key, descriptor;
	    while (keys.length > index) {
	      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
	      if (descriptor !== undefined) createProperty(result, key, descriptor);
	    }
	    return result;
	  }
	});

	var nativeGetOwnPropertyNames$2 = objectGetOwnPropertyNamesExternal.f;

	var FAILS_ON_PRIMITIVES$2 = fails(function () { return !Object.getOwnPropertyNames(1); });

	// `Object.getOwnPropertyNames` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$2 }, {
	  getOwnPropertyNames: nativeGetOwnPropertyNames$2
	});

	var correctPrototypeGetter = !fails(function () {
	  function F() { /* empty */ }
	  F.prototype.constructor = null;
	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var IE_PROTO$1 = sharedKey('IE_PROTO');
	var ObjectPrototype$1 = Object.prototype;

	// `Object.getPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.getprototypeof
	var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
	  O = toObject(O);
	  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectPrototype$1 : null;
	};

	var FAILS_ON_PRIMITIVES$3 = fails(function () { objectGetPrototypeOf(1); });

	// `Object.getPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.getprototypeof
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$3, sham: !correctPrototypeGetter }, {
	  getPrototypeOf: function getPrototypeOf(it) {
	    return objectGetPrototypeOf(toObject(it));
	  }
	});

	// `SameValue` abstract operation
	// https://tc39.github.io/ecma262/#sec-samevalue
	var sameValue = Object.is || function is(x, y) {
	  // eslint-disable-next-line no-self-compare
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

	// `Object.is` method
	// https://tc39.github.io/ecma262/#sec-object.is
	_export({ target: 'Object', stat: true }, {
	  is: sameValue
	});

	var nativeIsExtensible = Object.isExtensible;
	var FAILS_ON_PRIMITIVES$4 = fails(function () { nativeIsExtensible(1); });

	// `Object.isExtensible` method
	// https://tc39.github.io/ecma262/#sec-object.isextensible
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$4 }, {
	  isExtensible: function isExtensible(it) {
	    return isObject$3(it) ? nativeIsExtensible ? nativeIsExtensible(it) : true : false;
	  }
	});

	var nativeIsFrozen = Object.isFrozen;
	var FAILS_ON_PRIMITIVES$5 = fails(function () { nativeIsFrozen(1); });

	// `Object.isFrozen` method
	// https://tc39.github.io/ecma262/#sec-object.isfrozen
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$5 }, {
	  isFrozen: function isFrozen(it) {
	    return isObject$3(it) ? nativeIsFrozen ? nativeIsFrozen(it) : false : true;
	  }
	});

	var nativeIsSealed = Object.isSealed;
	var FAILS_ON_PRIMITIVES$6 = fails(function () { nativeIsSealed(1); });

	// `Object.isSealed` method
	// https://tc39.github.io/ecma262/#sec-object.issealed
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$6 }, {
	  isSealed: function isSealed(it) {
	    return isObject$3(it) ? nativeIsSealed ? nativeIsSealed(it) : false : true;
	  }
	});

	var FAILS_ON_PRIMITIVES$7 = fails(function () { objectKeys(1); });

	// `Object.keys` method
	// https://tc39.github.io/ecma262/#sec-object.keys
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$7 }, {
	  keys: function keys(it) {
	    return objectKeys(toObject(it));
	  }
	});

	var onFreeze$1 = internalMetadata.onFreeze;



	var nativePreventExtensions = Object.preventExtensions;
	var FAILS_ON_PRIMITIVES$8 = fails(function () { nativePreventExtensions(1); });

	// `Object.preventExtensions` method
	// https://tc39.github.io/ecma262/#sec-object.preventextensions
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$8, sham: !freezing }, {
	  preventExtensions: function preventExtensions(it) {
	    return nativePreventExtensions && isObject$3(it) ? nativePreventExtensions(onFreeze$1(it)) : it;
	  }
	});

	var onFreeze$2 = internalMetadata.onFreeze;



	var nativeSeal = Object.seal;
	var FAILS_ON_PRIMITIVES$9 = fails(function () { nativeSeal(1); });

	// `Object.seal` method
	// https://tc39.github.io/ecma262/#sec-object.seal
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$9, sham: !freezing }, {
	  seal: function seal(it) {
	    return nativeSeal && isObject$3(it) ? nativeSeal(onFreeze$2(it)) : it;
	  }
	});

	var aPossiblePrototype = function (it) {
	  if (!isObject$3(it) && it !== null) {
	    throw TypeError("Can't set " + String(it) + ' as a prototype');
	  } return it;
	};

	// `Object.setPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.setprototypeof
	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
	  var CORRECT_SETTER = false;
	  var test = {};
	  var setter;
	  try {
	    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
	    setter.call(test, []);
	    CORRECT_SETTER = test instanceof Array;
	  } catch (error) { /* empty */ }
	  return function setPrototypeOf(O, proto) {
	    anObject(O);
	    aPossiblePrototype(proto);
	    if (CORRECT_SETTER) setter.call(O, proto);
	    else O.__proto__ = proto;
	    return O;
	  };
	}() : undefined);

	// `Object.setPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.setprototypeof
	_export({ target: 'Object', stat: true }, {
	  setPrototypeOf: objectSetPrototypeOf
	});

	var $values = objectToArray.values;

	// `Object.values` method
	// https://tc39.github.io/ecma262/#sec-object.values
	_export({ target: 'Object', stat: true }, {
	  values: function values(O) {
	    return $values(O);
	  }
	});

	// `Object.prototype.toString` method implementation
	// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
	var objectToString$1 = toStringTagSupport ? {}.toString : function toString() {
	  return '[object ' + classof(this) + ']';
	};

	// `Object.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
	if (!toStringTagSupport) {
	  redefine(Object.prototype, 'toString', objectToString$1, { unsafe: true });
	}

	// Forced replacement object prototype accessors methods
	var objectPrototypeAccessorsForced =  !fails(function () {
	  var key = Math.random();
	  // In FF throws only define methods
	  // eslint-disable-next-line no-undef, no-useless-call
	  __defineSetter__.call(null, key, function () { /* empty */ });
	  delete global_1[key];
	});

	// `Object.prototype.__defineGetter__` method
	// https://tc39.github.io/ecma262/#sec-object.prototype.__defineGetter__
	if (descriptors) {
	  _export({ target: 'Object', proto: true, forced: objectPrototypeAccessorsForced }, {
	    __defineGetter__: function __defineGetter__(P, getter) {
	      objectDefineProperty.f(toObject(this), P, { get: aFunction$1(getter), enumerable: true, configurable: true });
	    }
	  });
	}

	// `Object.prototype.__defineSetter__` method
	// https://tc39.github.io/ecma262/#sec-object.prototype.__defineSetter__
	if (descriptors) {
	  _export({ target: 'Object', proto: true, forced: objectPrototypeAccessorsForced }, {
	    __defineSetter__: function __defineSetter__(P, setter) {
	      objectDefineProperty.f(toObject(this), P, { set: aFunction$1(setter), enumerable: true, configurable: true });
	    }
	  });
	}

	var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;

	// `Object.prototype.__lookupGetter__` method
	// https://tc39.github.io/ecma262/#sec-object.prototype.__lookupGetter__
	if (descriptors) {
	  _export({ target: 'Object', proto: true, forced: objectPrototypeAccessorsForced }, {
	    __lookupGetter__: function __lookupGetter__(P) {
	      var O = toObject(this);
	      var key = toPrimitive(P, true);
	      var desc;
	      do {
	        if (desc = getOwnPropertyDescriptor$2(O, key)) return desc.get;
	      } while (O = objectGetPrototypeOf(O));
	    }
	  });
	}

	var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;

	// `Object.prototype.__lookupSetter__` method
	// https://tc39.github.io/ecma262/#sec-object.prototype.__lookupSetter__
	if (descriptors) {
	  _export({ target: 'Object', proto: true, forced: objectPrototypeAccessorsForced }, {
	    __lookupSetter__: function __lookupSetter__(P) {
	      var O = toObject(this);
	      var key = toPrimitive(P, true);
	      var desc;
	      do {
	        if (desc = getOwnPropertyDescriptor$3(O, key)) return desc.set;
	      } while (O = objectGetPrototypeOf(O));
	    }
	  });
	}

	var slice = [].slice;
	var factories = {};

	var construct$1 = function (C, argsLength, args) {
	  if (!(argsLength in factories)) {
	    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
	    // eslint-disable-next-line no-new-func
	    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
	  } return factories[argsLength](C, args);
	};

	// `Function.prototype.bind` method implementation
	// https://tc39.github.io/ecma262/#sec-function.prototype.bind
	var functionBind = Function.bind || function bind(that /* , ...args */) {
	  var fn = aFunction$1(this);
	  var partArgs = slice.call(arguments, 1);
	  var boundFunction = function bound(/* args... */) {
	    var args = partArgs.concat(slice.call(arguments));
	    return this instanceof boundFunction ? construct$1(fn, args.length, args) : fn.apply(that, args);
	  };
	  if (isObject$3(fn.prototype)) boundFunction.prototype = fn.prototype;
	  return boundFunction;
	};

	// `Function.prototype.bind` method
	// https://tc39.github.io/ecma262/#sec-function.prototype.bind
	_export({ target: 'Function', proto: true }, {
	  bind: functionBind
	});

	var defineProperty$6 = objectDefineProperty.f;

	var FunctionPrototype = Function.prototype;
	var FunctionPrototypeToString = FunctionPrototype.toString;
	var nameRE = /^\s*function ([^ (]*)/;
	var NAME = 'name';

	// Function instances `.name` property
	// https://tc39.github.io/ecma262/#sec-function-instances-name
	if (descriptors && !(NAME in FunctionPrototype)) {
	  defineProperty$6(FunctionPrototype, NAME, {
	    configurable: true,
	    get: function () {
	      try {
	        return FunctionPrototypeToString.call(this).match(nameRE)[1];
	      } catch (error) {
	        return '';
	      }
	    }
	  });
	}

	var HAS_INSTANCE = wellKnownSymbol('hasInstance');
	var FunctionPrototype$1 = Function.prototype;

	// `Function.prototype[@@hasInstance]` method
	// https://tc39.github.io/ecma262/#sec-function.prototype-@@hasinstance
	if (!(HAS_INSTANCE in FunctionPrototype$1)) {
	  objectDefineProperty.f(FunctionPrototype$1, HAS_INSTANCE, { value: function (O) {
	    if (typeof this != 'function' || !isObject$3(O)) return false;
	    if (!isObject$3(this.prototype)) return O instanceof this;
	    // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	    while (O = objectGetPrototypeOf(O)) if (this.prototype === O) return true;
	    return false;
	  } });
	}

	// `globalThis` object
	// https://github.com/tc39/proposal-global
	_export({ global: true }, {
	  globalThis: global_1
	});

	// `Array.from` method implementation
	// https://tc39.github.io/ecma262/#sec-array.from
	var arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	  var O = toObject(arrayLike);
	  var C = typeof this == 'function' ? this : Array;
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  var iteratorMethod = getIteratorMethod(O);
	  var index = 0;
	  var length, result, step, iterator, next, value;
	  if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
	  // if the target is not iterable or it's an array with the default iterator - use a simple case
	  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
	    iterator = iteratorMethod.call(O);
	    next = iterator.next;
	    result = new C();
	    for (;!(step = next.call(iterator)).done; index++) {
	      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
	      createProperty(result, index, value);
	    }
	  } else {
	    length = toLength(O.length);
	    result = new C(length);
	    for (;length > index; index++) {
	      value = mapping ? mapfn(O[index], index) : O[index];
	      createProperty(result, index, value);
	    }
	  }
	  result.length = index;
	  return result;
	};

	var ITERATOR$2 = wellKnownSymbol('iterator');
	var SAFE_CLOSING = false;

	try {
	  var called = 0;
	  var iteratorWithReturn = {
	    next: function () {
	      return { done: !!called++ };
	    },
	    'return': function () {
	      SAFE_CLOSING = true;
	    }
	  };
	  iteratorWithReturn[ITERATOR$2] = function () {
	    return this;
	  };
	  // eslint-disable-next-line no-throw-literal
	  Array.from(iteratorWithReturn, function () { throw 2; });
	} catch (error) { /* empty */ }

	var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
	  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
	  var ITERATION_SUPPORT = false;
	  try {
	    var object = {};
	    object[ITERATOR$2] = function () {
	      return {
	        next: function () {
	          return { done: ITERATION_SUPPORT = true };
	        }
	      };
	    };
	    exec(object);
	  } catch (error) { /* empty */ }
	  return ITERATION_SUPPORT;
	};

	var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
	  Array.from(iterable);
	});

	// `Array.from` method
	// https://tc39.github.io/ecma262/#sec-array.from
	_export({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
	  from: arrayFrom
	});

	// `Array.isArray` method
	// https://tc39.github.io/ecma262/#sec-array.isarray
	_export({ target: 'Array', stat: true }, {
	  isArray: isArray$3
	});

	var ISNT_GENERIC = fails(function () {
	  function F() { /* empty */ }
	  return !(Array.of.call(F) instanceof F);
	});

	// `Array.of` method
	// https://tc39.github.io/ecma262/#sec-array.of
	// WebKit Array.of isn't generic
	_export({ target: 'Array', stat: true, forced: ISNT_GENERIC }, {
	  of: function of(/* ...args */) {
	    var index = 0;
	    var argumentsLength = arguments.length;
	    var result = new (typeof this == 'function' ? this : Array)(argumentsLength);
	    while (argumentsLength > index) createProperty(result, index, arguments[index++]);
	    result.length = argumentsLength;
	    return result;
	  }
	});

	var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

	var process$1 = global_1.process;
	var versions$1 = process$1 && process$1.versions;
	var v8 = versions$1 && versions$1.v8;
	var match, version$1;

	if (v8) {
	  match = v8.split('.');
	  version$1 = match[0] + match[1];
	} else if (engineUserAgent) {
	  match = engineUserAgent.match(/Edge\/(\d+)/);
	  if (!match || match[1] >= 74) {
	    match = engineUserAgent.match(/Chrome\/(\d+)/);
	    if (match) version$1 = match[1];
	  }
	}

	var engineV8Version = version$1 && +version$1;

	var SPECIES$1 = wellKnownSymbol('species');

	var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
	  // We can't use this feature detection in V8 since it causes
	  // deoptimization and serious performance degradation
	  // https://github.com/zloirock/core-js/issues/677
	  return engineV8Version >= 51 || !fails(function () {
	    var array = [];
	    var constructor = array.constructor = {};
	    constructor[SPECIES$1] = function () {
	      return { foo: 1 };
	    };
	    return array[METHOD_NAME](Boolean).foo !== 1;
	  });
	};

	var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
	var MAX_SAFE_INTEGER$2 = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

	// We can't use this feature detection in V8 since it causes
	// deoptimization and serious performance degradation
	// https://github.com/zloirock/core-js/issues/679
	var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
	  var array = [];
	  array[IS_CONCAT_SPREADABLE] = false;
	  return array.concat()[0] !== array;
	});

	var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

	var isConcatSpreadable = function (O) {
	  if (!isObject$3(O)) return false;
	  var spreadable = O[IS_CONCAT_SPREADABLE];
	  return spreadable !== undefined ? !!spreadable : isArray$3(O);
	};

	var FORCED$1 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

	// `Array.prototype.concat` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.concat
	// with adding support of @@isConcatSpreadable and @@species
	_export({ target: 'Array', proto: true, forced: FORCED$1 }, {
	  concat: function concat(arg) { // eslint-disable-line no-unused-vars
	    var O = toObject(this);
	    var A = arraySpeciesCreate(O, 0);
	    var n = 0;
	    var i, k, length, len, E;
	    for (i = -1, length = arguments.length; i < length; i++) {
	      E = i === -1 ? O : arguments[i];
	      if (isConcatSpreadable(E)) {
	        len = toLength(E.length);
	        if (n + len > MAX_SAFE_INTEGER$2) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
	        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
	      } else {
	        if (n >= MAX_SAFE_INTEGER$2) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
	        createProperty(A, n++, E);
	      }
	    }
	    A.length = n;
	    return A;
	  }
	});

	var min$2 = Math.min;

	// `Array.prototype.copyWithin` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
	var arrayCopyWithin = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
	  var O = toObject(this);
	  var len = toLength(O.length);
	  var to = toAbsoluteIndex(target, len);
	  var from = toAbsoluteIndex(start, len);
	  var end = arguments.length > 2 ? arguments[2] : undefined;
	  var count = min$2((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
	  var inc = 1;
	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }
	  while (count-- > 0) {
	    if (from in O) O[to] = O[from];
	    else delete O[to];
	    to += inc;
	    from += inc;
	  } return O;
	};

	var UNSCOPABLES = wellKnownSymbol('unscopables');
	var ArrayPrototype$1 = Array.prototype;

	// Array.prototype[@@unscopables]
	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	if (ArrayPrototype$1[UNSCOPABLES] == undefined) {
	  objectDefineProperty.f(ArrayPrototype$1, UNSCOPABLES, {
	    configurable: true,
	    value: objectCreate$1(null)
	  });
	}

	// add a key to Array.prototype[@@unscopables]
	var addToUnscopables = function (key) {
	  ArrayPrototype$1[UNSCOPABLES][key] = true;
	};

	// `Array.prototype.copyWithin` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
	_export({ target: 'Array', proto: true }, {
	  copyWithin: arrayCopyWithin
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('copyWithin');

	var arrayMethodIsStrict = function (METHOD_NAME, argument) {
	  var method = [][METHOD_NAME];
	  return !!method && fails(function () {
	    // eslint-disable-next-line no-useless-call,no-throw-literal
	    method.call(null, argument || function () { throw 1; }, 1);
	  });
	};

	var defineProperty$7 = Object.defineProperty;
	var cache = {};

	var thrower = function (it) { throw it; };

	var arrayMethodUsesToLength = function (METHOD_NAME, options) {
	  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
	  if (!options) options = {};
	  var method = [][METHOD_NAME];
	  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
	  var argument0 = has(options, 0) ? options[0] : thrower;
	  var argument1 = has(options, 1) ? options[1] : undefined;

	  return cache[METHOD_NAME] = !!method && !fails(function () {
	    if (ACCESSORS && !descriptors) return true;
	    var O = { length: -1 };

	    if (ACCESSORS) defineProperty$7(O, 1, { enumerable: true, get: thrower });
	    else O[1] = 1;

	    method.call(O, argument0, argument1);
	  });
	};

	var $every = arrayIteration.every;



	var STRICT_METHOD = arrayMethodIsStrict('every');
	var USES_TO_LENGTH = arrayMethodUsesToLength('every');

	// `Array.prototype.every` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.every
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
	  every: function every(callbackfn /* , thisArg */) {
	    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `Array.prototype.fill` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.fill
	var arrayFill = function fill(value /* , start = 0, end = @length */) {
	  var O = toObject(this);
	  var length = toLength(O.length);
	  var argumentsLength = arguments.length;
	  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
	  var end = argumentsLength > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
	  while (endPos > index) O[index++] = value;
	  return O;
	};

	// `Array.prototype.fill` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.fill
	_export({ target: 'Array', proto: true }, {
	  fill: arrayFill
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('fill');

	var $filter = arrayIteration.filter;



	var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');
	// Edge 14- issue
	var USES_TO_LENGTH$1 = arrayMethodUsesToLength('filter');

	// `Array.prototype.filter` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.filter
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH$1 }, {
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var $find = arrayIteration.find;



	var FIND = 'find';
	var SKIPS_HOLES = true;

	var USES_TO_LENGTH$2 = arrayMethodUsesToLength(FIND);

	// Shouldn't skip holes
	if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

	// `Array.prototype.find` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.find
	_export({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH$2 }, {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables(FIND);

	var $findIndex = arrayIteration.findIndex;



	var FIND_INDEX = 'findIndex';
	var SKIPS_HOLES$1 = true;

	var USES_TO_LENGTH$3 = arrayMethodUsesToLength(FIND_INDEX);

	// Shouldn't skip holes
	if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES$1 = false; });

	// `Array.prototype.findIndex` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.findindex
	_export({ target: 'Array', proto: true, forced: SKIPS_HOLES$1 || !USES_TO_LENGTH$3 }, {
	  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables(FIND_INDEX);

	// `FlattenIntoArray` abstract operation
	// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
	var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
	  var targetIndex = start;
	  var sourceIndex = 0;
	  var mapFn = mapper ? functionBindContext(mapper, thisArg, 3) : false;
	  var element;

	  while (sourceIndex < sourceLen) {
	    if (sourceIndex in source) {
	      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

	      if (depth > 0 && isArray$3(element)) {
	        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
	      } else {
	        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
	        target[targetIndex] = element;
	      }

	      targetIndex++;
	    }
	    sourceIndex++;
	  }
	  return targetIndex;
	};

	var flattenIntoArray_1 = flattenIntoArray;

	// `Array.prototype.flat` method
	// https://github.com/tc39/proposal-flatMap
	_export({ target: 'Array', proto: true }, {
	  flat: function flat(/* depthArg = 1 */) {
	    var depthArg = arguments.length ? arguments[0] : undefined;
	    var O = toObject(this);
	    var sourceLen = toLength(O.length);
	    var A = arraySpeciesCreate(O, 0);
	    A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
	    return A;
	  }
	});

	// `Array.prototype.flatMap` method
	// https://github.com/tc39/proposal-flatMap
	_export({ target: 'Array', proto: true }, {
	  flatMap: function flatMap(callbackfn /* , thisArg */) {
	    var O = toObject(this);
	    var sourceLen = toLength(O.length);
	    var A;
	    aFunction$1(callbackfn);
	    A = arraySpeciesCreate(O, 0);
	    A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    return A;
	  }
	});

	var $forEach$1 = arrayIteration.forEach;



	var STRICT_METHOD$1 = arrayMethodIsStrict('forEach');
	var USES_TO_LENGTH$4 = arrayMethodUsesToLength('forEach');

	// `Array.prototype.forEach` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	var arrayForEach = (!STRICT_METHOD$1 || !USES_TO_LENGTH$4) ? function forEach(callbackfn /* , thisArg */) {
	  return $forEach$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	} : [].forEach;

	// `Array.prototype.forEach` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	_export({ target: 'Array', proto: true, forced: [].forEach != arrayForEach }, {
	  forEach: arrayForEach
	});

	var $includes = arrayIncludes.includes;



	var USES_TO_LENGTH$5 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

	// `Array.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.includes
	_export({ target: 'Array', proto: true, forced: !USES_TO_LENGTH$5 }, {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('includes');

	var $indexOf = arrayIncludes.indexOf;



	var nativeIndexOf = [].indexOf;

	var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
	var STRICT_METHOD$2 = arrayMethodIsStrict('indexOf');
	var USES_TO_LENGTH$6 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

	// `Array.prototype.indexOf` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
	_export({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD$2 || !USES_TO_LENGTH$6 }, {
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? nativeIndexOf.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var nativeJoin = [].join;

	var ES3_STRINGS = indexedObject != Object;
	var STRICT_METHOD$3 = arrayMethodIsStrict('join', ',');

	// `Array.prototype.join` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.join
	_export({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD$3 }, {
	  join: function join(separator) {
	    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
	  }
	});

	var min$3 = Math.min;
	var nativeLastIndexOf = [].lastIndexOf;
	var NEGATIVE_ZERO$1 = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
	var STRICT_METHOD$4 = arrayMethodIsStrict('lastIndexOf');
	// For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
	var USES_TO_LENGTH$7 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });
	var FORCED$2 = NEGATIVE_ZERO$1 || !STRICT_METHOD$4 || !USES_TO_LENGTH$7;

	// `Array.prototype.lastIndexOf` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
	var arrayLastIndexOf = FORCED$2 ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
	  // convert -0 to +0
	  if (NEGATIVE_ZERO$1) return nativeLastIndexOf.apply(this, arguments) || 0;
	  var O = toIndexedObject(this);
	  var length = toLength(O.length);
	  var index = length - 1;
	  if (arguments.length > 1) index = min$3(index, toInteger(arguments[1]));
	  if (index < 0) index = length + index;
	  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
	  return -1;
	} : nativeLastIndexOf;

	// `Array.prototype.lastIndexOf` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
	_export({ target: 'Array', proto: true, forced: arrayLastIndexOf !== [].lastIndexOf }, {
	  lastIndexOf: arrayLastIndexOf
	});

	var $map = arrayIteration.map;



	var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('map');
	// FF49- issue
	var USES_TO_LENGTH$8 = arrayMethodUsesToLength('map');

	// `Array.prototype.map` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.map
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$1 || !USES_TO_LENGTH$8 }, {
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `Array.prototype.{ reduce, reduceRight }` methods implementation
	var createMethod$3 = function (IS_RIGHT) {
	  return function (that, callbackfn, argumentsLength, memo) {
	    aFunction$1(callbackfn);
	    var O = toObject(that);
	    var self = indexedObject(O);
	    var length = toLength(O.length);
	    var index = IS_RIGHT ? length - 1 : 0;
	    var i = IS_RIGHT ? -1 : 1;
	    if (argumentsLength < 2) while (true) {
	      if (index in self) {
	        memo = self[index];
	        index += i;
	        break;
	      }
	      index += i;
	      if (IS_RIGHT ? index < 0 : length <= index) {
	        throw TypeError('Reduce of empty array with no initial value');
	      }
	    }
	    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
	      memo = callbackfn(memo, self[index], index, O);
	    }
	    return memo;
	  };
	};

	var arrayReduce = {
	  // `Array.prototype.reduce` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
	  left: createMethod$3(false),
	  // `Array.prototype.reduceRight` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
	  right: createMethod$3(true)
	};

	var $reduce = arrayReduce.left;



	var STRICT_METHOD$5 = arrayMethodIsStrict('reduce');
	var USES_TO_LENGTH$9 = arrayMethodUsesToLength('reduce', { 1: 0 });

	// `Array.prototype.reduce` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$5 || !USES_TO_LENGTH$9 }, {
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var $reduceRight = arrayReduce.right;



	var STRICT_METHOD$6 = arrayMethodIsStrict('reduceRight');
	// For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
	var USES_TO_LENGTH$a = arrayMethodUsesToLength('reduce', { 1: 0 });

	// `Array.prototype.reduceRight` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$6 || !USES_TO_LENGTH$a }, {
	  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
	    return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var nativeReverse = [].reverse;
	var test$1 = [1, 2];

	// `Array.prototype.reverse` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.reverse
	// fix for Safari 12.0 bug
	// https://bugs.webkit.org/show_bug.cgi?id=188794
	_export({ target: 'Array', proto: true, forced: String(test$1) === String(test$1.reverse()) }, {
	  reverse: function reverse() {
	    // eslint-disable-next-line no-self-assign
	    if (isArray$3(this)) this.length = this.length;
	    return nativeReverse.call(this);
	  }
	});

	var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('slice');
	var USES_TO_LENGTH$b = arrayMethodUsesToLength('slice', { ACCESSORS: true, 0: 0, 1: 2 });

	var SPECIES$2 = wellKnownSymbol('species');
	var nativeSlice = [].slice;
	var max$1 = Math.max;

	// `Array.prototype.slice` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.slice
	// fallback for not array-like ES3 strings and DOM objects
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 || !USES_TO_LENGTH$b }, {
	  slice: function slice(start, end) {
	    var O = toIndexedObject(this);
	    var length = toLength(O.length);
	    var k = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
	    var Constructor, result, n;
	    if (isArray$3(O)) {
	      Constructor = O.constructor;
	      // cross-realm fallback
	      if (typeof Constructor == 'function' && (Constructor === Array || isArray$3(Constructor.prototype))) {
	        Constructor = undefined;
	      } else if (isObject$3(Constructor)) {
	        Constructor = Constructor[SPECIES$2];
	        if (Constructor === null) Constructor = undefined;
	      }
	      if (Constructor === Array || Constructor === undefined) {
	        return nativeSlice.call(O, k, fin);
	      }
	    }
	    result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));
	    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
	    result.length = n;
	    return result;
	  }
	});

	var $some = arrayIteration.some;



	var STRICT_METHOD$7 = arrayMethodIsStrict('some');
	var USES_TO_LENGTH$c = arrayMethodUsesToLength('some');

	// `Array.prototype.some` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.some
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$7 || !USES_TO_LENGTH$c }, {
	  some: function some(callbackfn /* , thisArg */) {
	    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var test$2 = [];
	var nativeSort = test$2.sort;

	// IE8-
	var FAILS_ON_UNDEFINED = fails(function () {
	  test$2.sort(undefined);
	});
	// V8 bug
	var FAILS_ON_NULL = fails(function () {
	  test$2.sort(null);
	});
	// Old WebKit
	var STRICT_METHOD$8 = arrayMethodIsStrict('sort');

	var FORCED$3 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$8;

	// `Array.prototype.sort` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.sort
	_export({ target: 'Array', proto: true, forced: FORCED$3 }, {
	  sort: function sort(comparefn) {
	    return comparefn === undefined
	      ? nativeSort.call(toObject(this))
	      : nativeSort.call(toObject(this), aFunction$1(comparefn));
	  }
	});

	var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('splice');
	var USES_TO_LENGTH$d = arrayMethodUsesToLength('splice', { ACCESSORS: true, 0: 0, 1: 2 });

	var max$2 = Math.max;
	var min$4 = Math.min;
	var MAX_SAFE_INTEGER$3 = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

	// `Array.prototype.splice` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.splice
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$3 || !USES_TO_LENGTH$d }, {
	  splice: function splice(start, deleteCount /* , ...items */) {
	    var O = toObject(this);
	    var len = toLength(O.length);
	    var actualStart = toAbsoluteIndex(start, len);
	    var argumentsLength = arguments.length;
	    var insertCount, actualDeleteCount, A, k, from, to;
	    if (argumentsLength === 0) {
	      insertCount = actualDeleteCount = 0;
	    } else if (argumentsLength === 1) {
	      insertCount = 0;
	      actualDeleteCount = len - actualStart;
	    } else {
	      insertCount = argumentsLength - 2;
	      actualDeleteCount = min$4(max$2(toInteger(deleteCount), 0), len - actualStart);
	    }
	    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$3) {
	      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
	    }
	    A = arraySpeciesCreate(O, actualDeleteCount);
	    for (k = 0; k < actualDeleteCount; k++) {
	      from = actualStart + k;
	      if (from in O) createProperty(A, k, O[from]);
	    }
	    A.length = actualDeleteCount;
	    if (insertCount < actualDeleteCount) {
	      for (k = actualStart; k < len - actualDeleteCount; k++) {
	        from = k + actualDeleteCount;
	        to = k + insertCount;
	        if (from in O) O[to] = O[from];
	        else delete O[to];
	      }
	      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
	    } else if (insertCount > actualDeleteCount) {
	      for (k = len - actualDeleteCount; k > actualStart; k--) {
	        from = k + actualDeleteCount - 1;
	        to = k + insertCount - 1;
	        if (from in O) O[to] = O[from];
	        else delete O[to];
	      }
	    }
	    for (k = 0; k < insertCount; k++) {
	      O[k + actualStart] = arguments[k + 2];
	    }
	    O.length = len - actualDeleteCount + insertCount;
	    return A;
	  }
	});

	var SPECIES$3 = wellKnownSymbol('species');

	var setSpecies = function (CONSTRUCTOR_NAME) {
	  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
	  var defineProperty = objectDefineProperty.f;

	  if (descriptors && Constructor && !Constructor[SPECIES$3]) {
	    defineProperty(Constructor, SPECIES$3, {
	      configurable: true,
	      get: function () { return this; }
	    });
	  }
	};

	// `Array[@@species]` getter
	// https://tc39.github.io/ecma262/#sec-get-array-@@species
	setSpecies('Array');

	// this method was added to unscopables after implementation
	// in popular engines, so it's moved to a separate module


	addToUnscopables('flat');

	// this method was added to unscopables after implementation
	// in popular engines, so it's moved to a separate module


	addToUnscopables('flatMap');

	var ITERATOR$3 = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS = false;

	var returnThis = function () { return this; };

	// `%IteratorPrototype%` object
	// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
	var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

	if ([].keys) {
	  arrayIterator = [].keys();
	  // Safari 8 has buggy iterators w/o `next`
	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
	  else {
	    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
	  }
	}

	if (IteratorPrototype == undefined) IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	if ( !has(IteratorPrototype, ITERATOR$3)) {
	  createNonEnumerableProperty(IteratorPrototype, ITERATOR$3, returnThis);
	}

	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
	};

	var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;





	var returnThis$1 = function () { return this; };

	var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = objectCreate$1(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });
	  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
	  iterators[TO_STRING_TAG] = returnThis$1;
	  return IteratorConstructor;
	};

	var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$4 = wellKnownSymbol('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';

	var returnThis$2 = function () { return this; };

	var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);

	  var getIterationMethod = function (KIND) {
	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
	    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];
	    switch (KIND) {
	      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
	      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
	      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
	    } return function () { return new IteratorConstructor(this); };
	  };

	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR$4]
	    || IterablePrototype['@@iterator']
	    || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY;

	  // fix native
	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
	    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
	      if ( objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
	        if (objectSetPrototypeOf) {
	          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
	        } else if (typeof CurrentIteratorPrototype[ITERATOR$4] != 'function') {
	          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$4, returnThis$2);
	        }
	      }
	      // Set @@toStringTag to native iterators
	      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
	    }
	  }

	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    INCORRECT_VALUES_NAME = true;
	    defaultIterator = function values() { return nativeIterator.call(this); };
	  }

	  // define iterator
	  if ( IterablePrototype[ITERATOR$4] !== defaultIterator) {
	    createNonEnumerableProperty(IterablePrototype, ITERATOR$4, defaultIterator);
	  }
	  iterators[NAME] = defaultIterator;

	  // export additional methods
	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        redefine(IterablePrototype, KEY, methods[KEY]);
	      }
	    } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME }, methods);
	  }

	  return methods;
	};

	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState$1 = internalState.set;
	var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR);

	// `Array.prototype.entries` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.entries
	// `Array.prototype.keys` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.keys
	// `Array.prototype.values` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.values
	// `Array.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
	// `CreateArrayIterator` internal method
	// https://tc39.github.io/ecma262/#sec-createarrayiterator
	var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
	  setInternalState$1(this, {
	    type: ARRAY_ITERATOR,
	    target: toIndexedObject(iterated), // target
	    index: 0,                          // next index
	    kind: kind                         // kind
	  });
	// `%ArrayIteratorPrototype%.next` method
	// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
	}, function () {
	  var state = getInternalState$1(this);
	  var target = state.target;
	  var kind = state.kind;
	  var index = state.index++;
	  if (!target || index >= target.length) {
	    state.target = undefined;
	    return { value: undefined, done: true };
	  }
	  if (kind == 'keys') return { value: index, done: false };
	  if (kind == 'values') return { value: target[index], done: false };
	  return { value: [index, target[index]], done: false };
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values%
	// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
	// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
	iterators.Arguments = iterators.Array;

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

	var fromCharCode = String.fromCharCode;
	var nativeFromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	var INCORRECT_LENGTH = !!nativeFromCodePoint && nativeFromCodePoint.length != 1;

	// `String.fromCodePoint` method
	// https://tc39.github.io/ecma262/#sec-string.fromcodepoint
	_export({ target: 'String', stat: true, forced: INCORRECT_LENGTH }, {
	  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
	    var elements = [];
	    var length = arguments.length;
	    var i = 0;
	    var code;
	    while (length > i) {
	      code = +arguments[i++];
	      if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw RangeError(code + ' is not a valid code point');
	      elements.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00)
	      );
	    } return elements.join('');
	  }
	});

	// `String.raw` method
	// https://tc39.github.io/ecma262/#sec-string.raw
	_export({ target: 'String', stat: true }, {
	  raw: function raw(template) {
	    var rawTemplate = toIndexedObject(template.raw);
	    var literalSegments = toLength(rawTemplate.length);
	    var argumentsLength = arguments.length;
	    var elements = [];
	    var i = 0;
	    while (literalSegments > i) {
	      elements.push(String(rawTemplate[i++]));
	      if (i < argumentsLength) elements.push(String(arguments[i]));
	    } return elements.join('');
	  }
	});

	// `String.prototype.{ codePointAt, at }` methods implementation
	var createMethod$4 = function (CONVERT_TO_STRING) {
	  return function ($this, pos) {
	    var S = String(requireObjectCoercible($this));
	    var position = toInteger(pos);
	    var size = S.length;
	    var first, second;
	    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
	    first = S.charCodeAt(position);
	    return first < 0xD800 || first > 0xDBFF || position + 1 === size
	      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
	        ? CONVERT_TO_STRING ? S.charAt(position) : first
	        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
	  };
	};

	var stringMultibyte = {
	  // `String.prototype.codePointAt` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
	  codeAt: createMethod$4(false),
	  // `String.prototype.at` method
	  // https://github.com/mathiasbynens/String.prototype.at
	  charAt: createMethod$4(true)
	};

	var codeAt = stringMultibyte.codeAt;

	// `String.prototype.codePointAt` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
	_export({ target: 'String', proto: true }, {
	  codePointAt: function codePointAt(pos) {
	    return codeAt(this, pos);
	  }
	});

	var MATCH = wellKnownSymbol('match');

	// `IsRegExp` abstract operation
	// https://tc39.github.io/ecma262/#sec-isregexp
	var isRegexp = function (it) {
	  var isRegExp;
	  return isObject$3(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
	};

	var notARegexp = function (it) {
	  if (isRegexp(it)) {
	    throw TypeError("The method doesn't accept regular expressions");
	  } return it;
	};

	var MATCH$1 = wellKnownSymbol('match');

	var correctIsRegexpLogic = function (METHOD_NAME) {
	  var regexp = /./;
	  try {
	    '/./'[METHOD_NAME](regexp);
	  } catch (e) {
	    try {
	      regexp[MATCH$1] = false;
	      return '/./'[METHOD_NAME](regexp);
	    } catch (f) { /* empty */ }
	  } return false;
	};

	var getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor.f;






	var nativeEndsWith = ''.endsWith;
	var min$5 = Math.min;

	var CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('endsWith');
	// https://github.com/zloirock/core-js/pull/702
	var MDN_POLYFILL_BUG =  !CORRECT_IS_REGEXP_LOGIC && !!function () {
	  var descriptor = getOwnPropertyDescriptor$4(String.prototype, 'endsWith');
	  return descriptor && !descriptor.writable;
	}();

	// `String.prototype.endsWith` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.endswith
	_export({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
	  endsWith: function endsWith(searchString /* , endPosition = @length */) {
	    var that = String(requireObjectCoercible(this));
	    notARegexp(searchString);
	    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	    var len = toLength(that.length);
	    var end = endPosition === undefined ? len : min$5(toLength(endPosition), len);
	    var search = String(searchString);
	    return nativeEndsWith
	      ? nativeEndsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

	// `String.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.includes
	_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~String(requireObjectCoercible(this))
	      .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `RegExp.prototype.flags` getter implementation
	// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
	var regexpFlags = function () {
	  var that = anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.dotAll) result += 's';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};

	// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
	// so we use an intermediate function.
	function RE(s, f) {
	  return RegExp(s, f);
	}

	var UNSUPPORTED_Y = fails(function () {
	  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
	  var re = RE('a', 'y');
	  re.lastIndex = 2;
	  return re.exec('abcd') != null;
	});

	var BROKEN_CARET = fails(function () {
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
	  var re = RE('^r', 'gy');
	  re.lastIndex = 2;
	  return re.exec('str') != null;
	});

	var regexpStickyHelpers = {
		UNSUPPORTED_Y: UNSUPPORTED_Y,
		BROKEN_CARET: BROKEN_CARET
	};

	var nativeExec = RegExp.prototype.exec;
	// This always refers to the native implementation, because the
	// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
	// which loads this file before patching the method.
	var nativeReplace = String.prototype.replace;

	var patchedExec = nativeExec;

	var UPDATES_LAST_INDEX_WRONG = (function () {
	  var re1 = /a/;
	  var re2 = /b*/g;
	  nativeExec.call(re1, 'a');
	  nativeExec.call(re2, 'a');
	  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
	})();

	var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y || regexpStickyHelpers.BROKEN_CARET;

	// nonparticipating capturing group, copied from es5-shim's String#split patch.
	var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

	var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1;

	if (PATCH) {
	  patchedExec = function exec(str) {
	    var re = this;
	    var lastIndex, reCopy, match, i;
	    var sticky = UNSUPPORTED_Y$1 && re.sticky;
	    var flags = regexpFlags.call(re);
	    var source = re.source;
	    var charsAdded = 0;
	    var strCopy = str;

	    if (sticky) {
	      flags = flags.replace('y', '');
	      if (flags.indexOf('g') === -1) {
	        flags += 'g';
	      }

	      strCopy = String(str).slice(re.lastIndex);
	      // Support anchored sticky behavior.
	      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
	        source = '(?: ' + source + ')';
	        strCopy = ' ' + strCopy;
	        charsAdded++;
	      }
	      // ^(? + rx + ) is needed, in combination with some str slicing, to
	      // simulate the 'y' flag.
	      reCopy = new RegExp('^(?:' + source + ')', flags);
	    }

	    if (NPCG_INCLUDED) {
	      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
	    }
	    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

	    match = nativeExec.call(sticky ? reCopy : re, strCopy);

	    if (sticky) {
	      if (match) {
	        match.input = match.input.slice(charsAdded);
	        match[0] = match[0].slice(charsAdded);
	        match.index = re.lastIndex;
	        re.lastIndex += match[0].length;
	      } else re.lastIndex = 0;
	    } else if (UPDATES_LAST_INDEX_WRONG && match) {
	      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
	    }
	    if (NPCG_INCLUDED && match && match.length > 1) {
	      // Fix browsers whose `exec` methods don't consistently return `undefined`
	      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
	      nativeReplace.call(match[0], reCopy, function () {
	        for (i = 1; i < arguments.length - 2; i++) {
	          if (arguments[i] === undefined) match[i] = undefined;
	        }
	      });
	    }

	    return match;
	  };
	}

	var regexpExec = patchedExec;

	_export({ target: 'RegExp', proto: true, forced: /./.exec !== regexpExec }, {
	  exec: regexpExec
	});

	// TODO: Remove from `core-js@4` since it's moved to entry points







	var SPECIES$4 = wellKnownSymbol('species');

	var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
	  // #replace needs built-in support for named groups.
	  // #match works fine because it just return the exec results, even if it has
	  // a "grops" property.
	  var re = /./;
	  re.exec = function () {
	    var result = [];
	    result.groups = { a: '7' };
	    return result;
	  };
	  return ''.replace(re, '$<a>') !== '7';
	});

	// IE <= 11 replaces $0 with the whole match, as if it was $&
	// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
	var REPLACE_KEEPS_$0 = (function () {
	  return 'a'.replace(/./, '$0') === '$0';
	})();

	var REPLACE = wellKnownSymbol('replace');
	// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
	var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
	  if (/./[REPLACE]) {
	    return /./[REPLACE]('a', '$0') === '';
	  }
	  return false;
	})();

	// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
	// Weex JS has frozen built-in prototypes, so use try / catch wrapper
	var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
	  var re = /(?:)/;
	  var originalExec = re.exec;
	  re.exec = function () { return originalExec.apply(this, arguments); };
	  var result = 'ab'.split(re);
	  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
	});

	var fixRegexpWellKnownSymbolLogic = function (KEY, length, exec, sham) {
	  var SYMBOL = wellKnownSymbol(KEY);

	  var DELEGATES_TO_SYMBOL = !fails(function () {
	    // String methods call symbol-named RegEp methods
	    var O = {};
	    O[SYMBOL] = function () { return 7; };
	    return ''[KEY](O) != 7;
	  });

	  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
	    // Symbol-named RegExp methods call .exec
	    var execCalled = false;
	    var re = /a/;

	    if (KEY === 'split') {
	      // We can't use real regex here since it causes deoptimization
	      // and serious performance degradation in V8
	      // https://github.com/zloirock/core-js/issues/306
	      re = {};
	      // RegExp[@@split] doesn't call the regex's exec method, but first creates
	      // a new one. We need to return the patched regex when creating the new one.
	      re.constructor = {};
	      re.constructor[SPECIES$4] = function () { return re; };
	      re.flags = '';
	      re[SYMBOL] = /./[SYMBOL];
	    }

	    re.exec = function () { execCalled = true; return null; };

	    re[SYMBOL]('');
	    return !execCalled;
	  });

	  if (
	    !DELEGATES_TO_SYMBOL ||
	    !DELEGATES_TO_EXEC ||
	    (KEY === 'replace' && !(
	      REPLACE_SUPPORTS_NAMED_GROUPS &&
	      REPLACE_KEEPS_$0 &&
	      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
	    )) ||
	    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
	  ) {
	    var nativeRegExpMethod = /./[SYMBOL];
	    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
	      if (regexp.exec === regexpExec) {
	        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
	          // The native String method already delegates to @@method (this
	          // polyfilled function), leasing to infinite recursion.
	          // We avoid it by directly calling the native @@method method.
	          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
	        }
	        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
	      }
	      return { done: false };
	    }, {
	      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
	      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
	    });
	    var stringMethod = methods[0];
	    var regexMethod = methods[1];

	    redefine(String.prototype, KEY, stringMethod);
	    redefine(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function (string, arg) { return regexMethod.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function (string) { return regexMethod.call(string, this); }
	    );
	  }

	  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
	};

	var charAt = stringMultibyte.charAt;

	// `AdvanceStringIndex` abstract operation
	// https://tc39.github.io/ecma262/#sec-advancestringindex
	var advanceStringIndex = function (S, index, unicode) {
	  return index + (unicode ? charAt(S, index).length : 1);
	};

	// `RegExpExec` abstract operation
	// https://tc39.github.io/ecma262/#sec-regexpexec
	var regexpExecAbstract = function (R, S) {
	  var exec = R.exec;
	  if (typeof exec === 'function') {
	    var result = exec.call(R, S);
	    if (typeof result !== 'object') {
	      throw TypeError('RegExp exec method returned something other than an Object or null');
	    }
	    return result;
	  }

	  if (classofRaw(R) !== 'RegExp') {
	    throw TypeError('RegExp#exec called on incompatible receiver');
	  }

	  return regexpExec.call(R, S);
	};

	// @@match logic
	fixRegexpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
	  return [
	    // `String.prototype.match` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.match
	    function match(regexp) {
	      var O = requireObjectCoercible(this);
	      var matcher = regexp == undefined ? undefined : regexp[MATCH];
	      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	    },
	    // `RegExp.prototype[@@match]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
	    function (regexp) {
	      var res = maybeCallNative(nativeMatch, regexp, this);
	      if (res.done) return res.value;

	      var rx = anObject(regexp);
	      var S = String(this);

	      if (!rx.global) return regexpExecAbstract(rx, S);

	      var fullUnicode = rx.unicode;
	      rx.lastIndex = 0;
	      var A = [];
	      var n = 0;
	      var result;
	      while ((result = regexpExecAbstract(rx, S)) !== null) {
	        var matchStr = String(result[0]);
	        A[n] = matchStr;
	        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	        n++;
	      }
	      return n === 0 ? null : A;
	    }
	  ];
	});

	var SPECIES$5 = wellKnownSymbol('species');

	// `SpeciesConstructor` abstract operation
	// https://tc39.github.io/ecma262/#sec-speciesconstructor
	var speciesConstructor = function (O, defaultConstructor) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES$5]) == undefined ? defaultConstructor : aFunction$1(S);
	};

	var MATCH_ALL = wellKnownSymbol('matchAll');
	var REGEXP_STRING = 'RegExp String';
	var REGEXP_STRING_ITERATOR = REGEXP_STRING + ' Iterator';
	var setInternalState$2 = internalState.set;
	var getInternalState$2 = internalState.getterFor(REGEXP_STRING_ITERATOR);
	var RegExpPrototype = RegExp.prototype;
	var regExpBuiltinExec = RegExpPrototype.exec;
	var nativeMatchAll = ''.matchAll;

	var WORKS_WITH_NON_GLOBAL_REGEX = !!nativeMatchAll && !fails(function () {
	  'a'.matchAll(/./);
	});

	var regExpExec = function (R, S) {
	  var exec = R.exec;
	  var result;
	  if (typeof exec == 'function') {
	    result = exec.call(R, S);
	    if (typeof result != 'object') throw TypeError('Incorrect exec result');
	    return result;
	  } return regExpBuiltinExec.call(R, S);
	};

	// eslint-disable-next-line max-len
	var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, global, fullUnicode) {
	  setInternalState$2(this, {
	    type: REGEXP_STRING_ITERATOR,
	    regexp: regexp,
	    string: string,
	    global: global,
	    unicode: fullUnicode,
	    done: false
	  });
	}, REGEXP_STRING, function next() {
	  var state = getInternalState$2(this);
	  if (state.done) return { value: undefined, done: true };
	  var R = state.regexp;
	  var S = state.string;
	  var match = regExpExec(R, S);
	  if (match === null) return { value: undefined, done: state.done = true };
	  if (state.global) {
	    if (String(match[0]) == '') R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);
	    return { value: match, done: false };
	  }
	  state.done = true;
	  return { value: match, done: false };
	});

	var $matchAll = function (string) {
	  var R = anObject(this);
	  var S = String(string);
	  var C, flagsValue, flags, matcher, global, fullUnicode;
	  C = speciesConstructor(R, RegExp);
	  flagsValue = R.flags;
	  if (flagsValue === undefined && R instanceof RegExp && !('flags' in RegExpPrototype)) {
	    flagsValue = regexpFlags.call(R);
	  }
	  flags = flagsValue === undefined ? '' : String(flagsValue);
	  matcher = new C(C === RegExp ? R.source : R, flags);
	  global = !!~flags.indexOf('g');
	  fullUnicode = !!~flags.indexOf('u');
	  matcher.lastIndex = toLength(R.lastIndex);
	  return new $RegExpStringIterator(matcher, S, global, fullUnicode);
	};

	// `String.prototype.matchAll` method
	// https://github.com/tc39/proposal-string-matchall
	_export({ target: 'String', proto: true, forced: WORKS_WITH_NON_GLOBAL_REGEX }, {
	  matchAll: function matchAll(regexp) {
	    var O = requireObjectCoercible(this);
	    var flags, S, matcher, rx;
	    if (regexp != null) {
	      if (isRegexp(regexp)) {
	        flags = String(requireObjectCoercible('flags' in RegExpPrototype
	          ? regexp.flags
	          : regexpFlags.call(regexp)
	        ));
	        if (!~flags.indexOf('g')) throw TypeError('`.matchAll` does not allow non-global regexes');
	      }
	      if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll.apply(O, arguments);
	      matcher = regexp[MATCH_ALL];
	      if (matcher === undefined && isPure && classofRaw(regexp) == 'RegExp') matcher = $matchAll;
	      if (matcher != null) return aFunction$1(matcher).call(regexp, O);
	    } else if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll.apply(O, arguments);
	    S = String(O);
	    rx = new RegExp(regexp, 'g');
	    return  rx[MATCH_ALL](S);
	  }
	});

	 MATCH_ALL in RegExpPrototype || createNonEnumerableProperty(RegExpPrototype, MATCH_ALL, $matchAll);

	// `String.prototype.repeat` method implementation
	// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
	var stringRepeat = ''.repeat || function repeat(count) {
	  var str = String(requireObjectCoercible(this));
	  var result = '';
	  var n = toInteger(count);
	  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
	  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
	  return result;
	};

	// https://github.com/tc39/proposal-string-pad-start-end




	var ceil$1 = Math.ceil;

	// `String.prototype.{ padStart, padEnd }` methods implementation
	var createMethod$5 = function (IS_END) {
	  return function ($this, maxLength, fillString) {
	    var S = String(requireObjectCoercible($this));
	    var stringLength = S.length;
	    var fillStr = fillString === undefined ? ' ' : String(fillString);
	    var intMaxLength = toLength(maxLength);
	    var fillLen, stringFiller;
	    if (intMaxLength <= stringLength || fillStr == '') return S;
	    fillLen = intMaxLength - stringLength;
	    stringFiller = stringRepeat.call(fillStr, ceil$1(fillLen / fillStr.length));
	    if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
	    return IS_END ? S + stringFiller : stringFiller + S;
	  };
	};

	var stringPad = {
	  // `String.prototype.padStart` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.padstart
	  start: createMethod$5(false),
	  // `String.prototype.padEnd` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.padend
	  end: createMethod$5(true)
	};

	// https://github.com/zloirock/core-js/issues/280


	// eslint-disable-next-line unicorn/no-unsafe-regex
	var stringPadWebkitBug = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(engineUserAgent);

	var $padEnd = stringPad.end;


	// `String.prototype.padEnd` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.padend
	_export({ target: 'String', proto: true, forced: stringPadWebkitBug }, {
	  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
	    return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var $padStart = stringPad.start;


	// `String.prototype.padStart` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.padstart
	_export({ target: 'String', proto: true, forced: stringPadWebkitBug }, {
	  padStart: function padStart(maxLength /* , fillString = ' ' */) {
	    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `String.prototype.repeat` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
	_export({ target: 'String', proto: true }, {
	  repeat: stringRepeat
	});

	var max$3 = Math.max;
	var min$6 = Math.min;
	var floor$1 = Math.floor;
	var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
	var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

	var maybeToString = function (it) {
	  return it === undefined ? it : String(it);
	};

	// @@replace logic
	fixRegexpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
	  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
	  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
	  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

	  return [
	    // `String.prototype.replace` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
	    function replace(searchValue, replaceValue) {
	      var O = requireObjectCoercible(this);
	      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
	      return replacer !== undefined
	        ? replacer.call(searchValue, O, replaceValue)
	        : nativeReplace.call(String(O), searchValue, replaceValue);
	    },
	    // `RegExp.prototype[@@replace]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
	    function (regexp, replaceValue) {
	      if (
	        (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||
	        (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
	      ) {
	        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
	        if (res.done) return res.value;
	      }

	      var rx = anObject(regexp);
	      var S = String(this);

	      var functionalReplace = typeof replaceValue === 'function';
	      if (!functionalReplace) replaceValue = String(replaceValue);

	      var global = rx.global;
	      if (global) {
	        var fullUnicode = rx.unicode;
	        rx.lastIndex = 0;
	      }
	      var results = [];
	      while (true) {
	        var result = regexpExecAbstract(rx, S);
	        if (result === null) break;

	        results.push(result);
	        if (!global) break;

	        var matchStr = String(result[0]);
	        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	      }

	      var accumulatedResult = '';
	      var nextSourcePosition = 0;
	      for (var i = 0; i < results.length; i++) {
	        result = results[i];

	        var matched = String(result[0]);
	        var position = max$3(min$6(toInteger(result.index), S.length), 0);
	        var captures = [];
	        // NOTE: This is equivalent to
	        //   captures = result.slice(1).map(maybeToString)
	        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
	        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
	        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
	        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
	        var namedCaptures = result.groups;
	        if (functionalReplace) {
	          var replacerArgs = [matched].concat(captures, position, S);
	          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
	          var replacement = String(replaceValue.apply(undefined, replacerArgs));
	        } else {
	          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
	        }
	        if (position >= nextSourcePosition) {
	          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
	          nextSourcePosition = position + matched.length;
	        }
	      }
	      return accumulatedResult + S.slice(nextSourcePosition);
	    }
	  ];

	  // https://tc39.github.io/ecma262/#sec-getsubstitution
	  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
	    var tailPos = position + matched.length;
	    var m = captures.length;
	    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
	    if (namedCaptures !== undefined) {
	      namedCaptures = toObject(namedCaptures);
	      symbols = SUBSTITUTION_SYMBOLS;
	    }
	    return nativeReplace.call(replacement, symbols, function (match, ch) {
	      var capture;
	      switch (ch.charAt(0)) {
	        case '$': return '$';
	        case '&': return matched;
	        case '`': return str.slice(0, position);
	        case "'": return str.slice(tailPos);
	        case '<':
	          capture = namedCaptures[ch.slice(1, -1)];
	          break;
	        default: // \d\d?
	          var n = +ch;
	          if (n === 0) return match;
	          if (n > m) {
	            var f = floor$1(n / 10);
	            if (f === 0) return match;
	            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
	            return match;
	          }
	          capture = captures[n - 1];
	      }
	      return capture === undefined ? '' : capture;
	    });
	  }
	});

	// @@search logic
	fixRegexpWellKnownSymbolLogic('search', 1, function (SEARCH, nativeSearch, maybeCallNative) {
	  return [
	    // `String.prototype.search` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.search
	    function search(regexp) {
	      var O = requireObjectCoercible(this);
	      var searcher = regexp == undefined ? undefined : regexp[SEARCH];
	      return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	    },
	    // `RegExp.prototype[@@search]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
	    function (regexp) {
	      var res = maybeCallNative(nativeSearch, regexp, this);
	      if (res.done) return res.value;

	      var rx = anObject(regexp);
	      var S = String(this);

	      var previousLastIndex = rx.lastIndex;
	      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
	      var result = regexpExecAbstract(rx, S);
	      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
	      return result === null ? -1 : result.index;
	    }
	  ];
	});

	var arrayPush$1 = [].push;
	var min$7 = Math.min;
	var MAX_UINT32 = 0xFFFFFFFF;

	// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
	var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });

	// @@split logic
	fixRegexpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
	  var internalSplit;
	  if (
	    'abbc'.split(/(b)*/)[1] == 'c' ||
	    'test'.split(/(?:)/, -1).length != 4 ||
	    'ab'.split(/(?:ab)*/).length != 2 ||
	    '.'.split(/(.?)(.?)/).length != 4 ||
	    '.'.split(/()()/).length > 1 ||
	    ''.split(/.?/).length
	  ) {
	    // based on es5-shim implementation, need to rework it
	    internalSplit = function (separator, limit) {
	      var string = String(requireObjectCoercible(this));
	      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      if (lim === 0) return [];
	      if (separator === undefined) return [string];
	      // If `separator` is not a regex, use native split
	      if (!isRegexp(separator)) {
	        return nativeSplit.call(string, separator, lim);
	      }
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var match, lastIndex, lastLength;
	      while (match = regexpExec.call(separatorCopy, string)) {
	        lastIndex = separatorCopy.lastIndex;
	        if (lastIndex > lastLastIndex) {
	          output.push(string.slice(lastLastIndex, match.index));
	          if (match.length > 1 && match.index < string.length) arrayPush$1.apply(output, match.slice(1));
	          lastLength = match[0].length;
	          lastLastIndex = lastIndex;
	          if (output.length >= lim) break;
	        }
	        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
	      }
	      if (lastLastIndex === string.length) {
	        if (lastLength || !separatorCopy.test('')) output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output.length > lim ? output.slice(0, lim) : output;
	    };
	  // Chakra, V8
	  } else if ('0'.split(undefined, 0).length) {
	    internalSplit = function (separator, limit) {
	      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
	    };
	  } else internalSplit = nativeSplit;

	  return [
	    // `String.prototype.split` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.split
	    function split(separator, limit) {
	      var O = requireObjectCoercible(this);
	      var splitter = separator == undefined ? undefined : separator[SPLIT];
	      return splitter !== undefined
	        ? splitter.call(separator, O, limit)
	        : internalSplit.call(String(O), separator, limit);
	    },
	    // `RegExp.prototype[@@split]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
	    //
	    // NOTE: This cannot be properly polyfilled in engines that don't support
	    // the 'y' flag.
	    function (regexp, limit) {
	      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
	      if (res.done) return res.value;

	      var rx = anObject(regexp);
	      var S = String(this);
	      var C = speciesConstructor(rx, RegExp);

	      var unicodeMatching = rx.unicode;
	      var flags = (rx.ignoreCase ? 'i' : '') +
	                  (rx.multiline ? 'm' : '') +
	                  (rx.unicode ? 'u' : '') +
	                  (SUPPORTS_Y ? 'y' : 'g');

	      // ^(? + rx + ) is needed, in combination with some S slicing, to
	      // simulate the 'y' flag.
	      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
	      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      if (lim === 0) return [];
	      if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
	      var p = 0;
	      var q = 0;
	      var A = [];
	      while (q < S.length) {
	        splitter.lastIndex = SUPPORTS_Y ? q : 0;
	        var z = regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
	        var e;
	        if (
	          z === null ||
	          (e = min$7(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
	        ) {
	          q = advanceStringIndex(S, q, unicodeMatching);
	        } else {
	          A.push(S.slice(p, q));
	          if (A.length === lim) return A;
	          for (var i = 1; i <= z.length - 1; i++) {
	            A.push(z[i]);
	            if (A.length === lim) return A;
	          }
	          q = p = e;
	        }
	      }
	      A.push(S.slice(p));
	      return A;
	    }
	  ];
	}, !SUPPORTS_Y);

	var getOwnPropertyDescriptor$5 = objectGetOwnPropertyDescriptor.f;






	var nativeStartsWith = ''.startsWith;
	var min$8 = Math.min;

	var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegexpLogic('startsWith');
	// https://github.com/zloirock/core-js/pull/702
	var MDN_POLYFILL_BUG$1 =  !CORRECT_IS_REGEXP_LOGIC$1 && !!function () {
	  var descriptor = getOwnPropertyDescriptor$5(String.prototype, 'startsWith');
	  return descriptor && !descriptor.writable;
	}();

	// `String.prototype.startsWith` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.startswith
	_export({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1 }, {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = String(requireObjectCoercible(this));
	    notARegexp(searchString);
	    var index = toLength(min$8(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return nativeStartsWith
	      ? nativeStartsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

	// a string of all valid unicode whitespaces
	// eslint-disable-next-line max-len
	var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var whitespace = '[' + whitespaces + ']';
	var ltrim = RegExp('^' + whitespace + whitespace + '*');
	var rtrim = RegExp(whitespace + whitespace + '*$');

	// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
	var createMethod$6 = function (TYPE) {
	  return function ($this) {
	    var string = String(requireObjectCoercible($this));
	    if (TYPE & 1) string = string.replace(ltrim, '');
	    if (TYPE & 2) string = string.replace(rtrim, '');
	    return string;
	  };
	};

	var stringTrim = {
	  // `String.prototype.{ trimLeft, trimStart }` methods
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
	  start: createMethod$6(1),
	  // `String.prototype.{ trimRight, trimEnd }` methods
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
	  end: createMethod$6(2),
	  // `String.prototype.trim` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
	  trim: createMethod$6(3)
	};

	var non = '\u200B\u0085\u180E';

	// check that a method works with the correct list
	// of whitespaces and has a correct name
	var stringTrimForced = function (METHOD_NAME) {
	  return fails(function () {
	    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
	  });
	};

	var $trim = stringTrim.trim;


	// `String.prototype.trim` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.trim
	_export({ target: 'String', proto: true, forced: stringTrimForced('trim') }, {
	  trim: function trim() {
	    return $trim(this);
	  }
	});

	var $trimStart = stringTrim.start;


	var FORCED$4 = stringTrimForced('trimStart');

	var trimStart = FORCED$4 ? function trimStart() {
	  return $trimStart(this);
	} : ''.trimStart;

	// `String.prototype.{ trimStart, trimLeft }` methods
	// https://github.com/tc39/ecmascript-string-left-right-trim
	_export({ target: 'String', proto: true, forced: FORCED$4 }, {
	  trimStart: trimStart,
	  trimLeft: trimStart
	});

	var $trimEnd = stringTrim.end;


	var FORCED$5 = stringTrimForced('trimEnd');

	var trimEnd = FORCED$5 ? function trimEnd() {
	  return $trimEnd(this);
	} : ''.trimEnd;

	// `String.prototype.{ trimEnd, trimRight }` methods
	// https://github.com/tc39/ecmascript-string-left-right-trim
	_export({ target: 'String', proto: true, forced: FORCED$5 }, {
	  trimEnd: trimEnd,
	  trimRight: trimEnd
	});

	var charAt$1 = stringMultibyte.charAt;



	var STRING_ITERATOR = 'String Iterator';
	var setInternalState$3 = internalState.set;
	var getInternalState$3 = internalState.getterFor(STRING_ITERATOR);

	// `String.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
	defineIterator(String, 'String', function (iterated) {
	  setInternalState$3(this, {
	    type: STRING_ITERATOR,
	    string: String(iterated),
	    index: 0
	  });
	// `%StringIteratorPrototype%.next` method
	// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
	}, function next() {
	  var state = getInternalState$3(this);
	  var string = state.string;
	  var index = state.index;
	  var point;
	  if (index >= string.length) return { value: undefined, done: true };
	  point = charAt$1(string, index);
	  state.index += point.length;
	  return { value: point, done: false };
	});

	var quot = /"/g;

	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	// https://tc39.github.io/ecma262/#sec-createhtml
	var createHtml = function (string, tag, attribute, value) {
	  var S = String(requireObjectCoercible(string));
	  var p1 = '<' + tag;
	  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};

	// check the existence of a method, lowercase
	// of a tag and escaping quotes in arguments
	var stringHtmlForced = function (METHOD_NAME) {
	  return fails(function () {
	    var test = ''[METHOD_NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  });
	};

	// `String.prototype.anchor` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.anchor
	_export({ target: 'String', proto: true, forced: stringHtmlForced('anchor') }, {
	  anchor: function anchor(name) {
	    return createHtml(this, 'a', 'name', name);
	  }
	});

	// `String.prototype.big` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.big
	_export({ target: 'String', proto: true, forced: stringHtmlForced('big') }, {
	  big: function big() {
	    return createHtml(this, 'big', '', '');
	  }
	});

	// `String.prototype.blink` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.blink
	_export({ target: 'String', proto: true, forced: stringHtmlForced('blink') }, {
	  blink: function blink() {
	    return createHtml(this, 'blink', '', '');
	  }
	});

	// `String.prototype.bold` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.bold
	_export({ target: 'String', proto: true, forced: stringHtmlForced('bold') }, {
	  bold: function bold() {
	    return createHtml(this, 'b', '', '');
	  }
	});

	// `String.prototype.fixed` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.fixed
	_export({ target: 'String', proto: true, forced: stringHtmlForced('fixed') }, {
	  fixed: function fixed() {
	    return createHtml(this, 'tt', '', '');
	  }
	});

	// `String.prototype.fontcolor` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.fontcolor
	_export({ target: 'String', proto: true, forced: stringHtmlForced('fontcolor') }, {
	  fontcolor: function fontcolor(color) {
	    return createHtml(this, 'font', 'color', color);
	  }
	});

	// `String.prototype.fontsize` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.fontsize
	_export({ target: 'String', proto: true, forced: stringHtmlForced('fontsize') }, {
	  fontsize: function fontsize(size) {
	    return createHtml(this, 'font', 'size', size);
	  }
	});

	// `String.prototype.italics` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.italics
	_export({ target: 'String', proto: true, forced: stringHtmlForced('italics') }, {
	  italics: function italics() {
	    return createHtml(this, 'i', '', '');
	  }
	});

	// `String.prototype.link` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.link
	_export({ target: 'String', proto: true, forced: stringHtmlForced('link') }, {
	  link: function link(url) {
	    return createHtml(this, 'a', 'href', url);
	  }
	});

	// `String.prototype.small` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.small
	_export({ target: 'String', proto: true, forced: stringHtmlForced('small') }, {
	  small: function small() {
	    return createHtml(this, 'small', '', '');
	  }
	});

	// `String.prototype.strike` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.strike
	_export({ target: 'String', proto: true, forced: stringHtmlForced('strike') }, {
	  strike: function strike() {
	    return createHtml(this, 'strike', '', '');
	  }
	});

	// `String.prototype.sub` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.sub
	_export({ target: 'String', proto: true, forced: stringHtmlForced('sub') }, {
	  sub: function sub() {
	    return createHtml(this, 'sub', '', '');
	  }
	});

	// `String.prototype.sup` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.sup
	_export({ target: 'String', proto: true, forced: stringHtmlForced('sup') }, {
	  sup: function sup() {
	    return createHtml(this, 'sup', '', '');
	  }
	});

	// makes subclassing work correct for wrapped built-ins
	var inheritIfRequired = function ($this, dummy, Wrapper) {
	  var NewTarget, NewTargetPrototype;
	  if (
	    // it can work only with native `setPrototypeOf`
	    objectSetPrototypeOf &&
	    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
	    typeof (NewTarget = dummy.constructor) == 'function' &&
	    NewTarget !== Wrapper &&
	    isObject$3(NewTargetPrototype = NewTarget.prototype) &&
	    NewTargetPrototype !== Wrapper.prototype
	  ) objectSetPrototypeOf($this, NewTargetPrototype);
	  return $this;
	};

	var defineProperty$8 = objectDefineProperty.f;
	var getOwnPropertyNames = objectGetOwnPropertyNames.f;





	var setInternalState$4 = internalState.set;



	var MATCH$2 = wellKnownSymbol('match');
	var NativeRegExp = global_1.RegExp;
	var RegExpPrototype$1 = NativeRegExp.prototype;
	var re1 = /a/g;
	var re2 = /a/g;

	// "new" should create a new object, old webkit bug
	var CORRECT_NEW = new NativeRegExp(re1) !== re1;

	var UNSUPPORTED_Y$2 = regexpStickyHelpers.UNSUPPORTED_Y;

	var FORCED$6 = descriptors && isForced_1('RegExp', (!CORRECT_NEW || UNSUPPORTED_Y$2 || fails(function () {
	  re2[MATCH$2] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
	})));

	// `RegExp` constructor
	// https://tc39.github.io/ecma262/#sec-regexp-constructor
	if (FORCED$6) {
	  var RegExpWrapper = function RegExp(pattern, flags) {
	    var thisIsRegExp = this instanceof RegExpWrapper;
	    var patternIsRegExp = isRegexp(pattern);
	    var flagsAreUndefined = flags === undefined;
	    var sticky;

	    if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
	      return pattern;
	    }

	    if (CORRECT_NEW) {
	      if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;
	    } else if (pattern instanceof RegExpWrapper) {
	      if (flagsAreUndefined) flags = regexpFlags.call(pattern);
	      pattern = pattern.source;
	    }

	    if (UNSUPPORTED_Y$2) {
	      sticky = !!flags && flags.indexOf('y') > -1;
	      if (sticky) flags = flags.replace(/y/g, '');
	    }

	    var result = inheritIfRequired(
	      CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags),
	      thisIsRegExp ? this : RegExpPrototype$1,
	      RegExpWrapper
	    );

	    if (UNSUPPORTED_Y$2 && sticky) setInternalState$4(result, { sticky: sticky });

	    return result;
	  };
	  var proxy = function (key) {
	    key in RegExpWrapper || defineProperty$8(RegExpWrapper, key, {
	      configurable: true,
	      get: function () { return NativeRegExp[key]; },
	      set: function (it) { NativeRegExp[key] = it; }
	    });
	  };
	  var keys$2 = getOwnPropertyNames(NativeRegExp);
	  var index = 0;
	  while (keys$2.length > index) proxy(keys$2[index++]);
	  RegExpPrototype$1.constructor = RegExpWrapper;
	  RegExpWrapper.prototype = RegExpPrototype$1;
	  redefine(global_1, 'RegExp', RegExpWrapper);
	}

	// https://tc39.github.io/ecma262/#sec-get-regexp-@@species
	setSpecies('RegExp');

	var UNSUPPORTED_Y$3 = regexpStickyHelpers.UNSUPPORTED_Y;

	// `RegExp.prototype.flags` getter
	// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
	if (descriptors && (/./g.flags != 'g' || UNSUPPORTED_Y$3)) {
	  objectDefineProperty.f(RegExp.prototype, 'flags', {
	    configurable: true,
	    get: regexpFlags
	  });
	}

	var UNSUPPORTED_Y$4 = regexpStickyHelpers.UNSUPPORTED_Y;
	var defineProperty$9 = objectDefineProperty.f;
	var getInternalState$4 = internalState.get;
	var RegExpPrototype$2 = RegExp.prototype;

	// `RegExp.prototype.sticky` getter
	if (descriptors && UNSUPPORTED_Y$4) {
	  defineProperty$9(RegExp.prototype, 'sticky', {
	    configurable: true,
	    get: function () {
	      if (this === RegExpPrototype$2) return undefined;
	      // We can't use InternalStateModule.getterFor because
	      // we don't add metadata for regexps created by a literal.
	      if (this instanceof RegExp) {
	        return !!getInternalState$4(this).sticky;
	      }
	      throw TypeError('Incompatible receiver, RegExp required');
	    }
	  });
	}

	// TODO: Remove from `core-js@4` since it's moved to entry points




	var DELEGATES_TO_EXEC = function () {
	  var execCalled = false;
	  var re = /[ac]/;
	  re.exec = function () {
	    execCalled = true;
	    return /./.exec.apply(this, arguments);
	  };
	  return re.test('abc') === true && execCalled;
	}();

	var nativeTest = /./.test;

	_export({ target: 'RegExp', proto: true, forced: !DELEGATES_TO_EXEC }, {
	  test: function (str) {
	    if (typeof this.exec !== 'function') {
	      return nativeTest.call(this, str);
	    }
	    var result = this.exec(str);
	    if (result !== null && !isObject$3(result)) {
	      throw new Error('RegExp exec method returned something other than an Object or null');
	    }
	    return !!result;
	  }
	});

	var TO_STRING = 'toString';
	var RegExpPrototype$3 = RegExp.prototype;
	var nativeToString = RegExpPrototype$3[TO_STRING];

	var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
	// FF44- RegExp#toString has a wrong name
	var INCORRECT_NAME = nativeToString.name != TO_STRING;

	// `RegExp.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
	if (NOT_GENERIC || INCORRECT_NAME) {
	  redefine(RegExp.prototype, TO_STRING, function toString() {
	    var R = anObject(this);
	    var p = String(R.source);
	    var rf = R.flags;
	    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype$3) ? regexpFlags.call(R) : rf);
	    return '/' + p + '/' + f;
	  }, { unsafe: true });
	}

	var trim$1 = stringTrim.trim;


	var $parseInt = global_1.parseInt;
	var hex = /^[+-]?0[Xx]/;
	var FORCED$7 = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22;

	// `parseInt` method
	// https://tc39.github.io/ecma262/#sec-parseint-string-radix
	var numberParseInt = FORCED$7 ? function parseInt(string, radix) {
	  var S = trim$1(String(string));
	  return $parseInt(S, (radix >>> 0) || (hex.test(S) ? 16 : 10));
	} : $parseInt;

	// `parseInt` method
	// https://tc39.github.io/ecma262/#sec-parseint-string-radix
	_export({ global: true, forced: parseInt != numberParseInt }, {
	  parseInt: numberParseInt
	});

	var trim$2 = stringTrim.trim;


	var $parseFloat = global_1.parseFloat;
	var FORCED$8 = 1 / $parseFloat(whitespaces + '-0') !== -Infinity;

	// `parseFloat` method
	// https://tc39.github.io/ecma262/#sec-parsefloat-string
	var numberParseFloat = FORCED$8 ? function parseFloat(string) {
	  var trimmedString = trim$2(String(string));
	  var result = $parseFloat(trimmedString);
	  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

	// `parseFloat` method
	// https://tc39.github.io/ecma262/#sec-parsefloat-string
	_export({ global: true, forced: parseFloat != numberParseFloat }, {
	  parseFloat: numberParseFloat
	});

	var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
	var getOwnPropertyDescriptor$6 = objectGetOwnPropertyDescriptor.f;
	var defineProperty$a = objectDefineProperty.f;
	var trim$3 = stringTrim.trim;

	var NUMBER = 'Number';
	var NativeNumber = global_1[NUMBER];
	var NumberPrototype = NativeNumber.prototype;

	// Opera ~12 has broken Object#toString
	var BROKEN_CLASSOF = classofRaw(objectCreate$1(NumberPrototype)) == NUMBER;

	// `ToNumber` abstract operation
	// https://tc39.github.io/ecma262/#sec-tonumber
	var toNumber = function (argument) {
	  var it = toPrimitive(argument, false);
	  var first, third, radix, maxCode, digits, length, index, code;
	  if (typeof it == 'string' && it.length > 2) {
	    it = trim$3(it);
	    first = it.charCodeAt(0);
	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
	        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
	        default: return +it;
	      }
	      digits = it.slice(2);
	      length = digits.length;
	      for (index = 0; index < length; index++) {
	        code = digits.charCodeAt(index);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if (code < 48 || code > maxCode) return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};

	// `Number` constructor
	// https://tc39.github.io/ecma262/#sec-number-constructor
	if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
	  var NumberWrapper = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value;
	    var dummy = this;
	    return dummy instanceof NumberWrapper
	      // check on 1..constructor(foo) case
	      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classofRaw(dummy) != NUMBER)
	        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
	  };
	  for (var keys$3 = descriptors ? getOwnPropertyNames$1(NativeNumber) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES2015 (in case, if modules with ES2015 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j = 0, key; keys$3.length > j; j++) {
	    if (has(NativeNumber, key = keys$3[j]) && !has(NumberWrapper, key)) {
	      defineProperty$a(NumberWrapper, key, getOwnPropertyDescriptor$6(NativeNumber, key));
	    }
	  }
	  NumberWrapper.prototype = NumberPrototype;
	  NumberPrototype.constructor = NumberWrapper;
	  redefine(global_1, NUMBER, NumberWrapper);
	}

	// `Number.EPSILON` constant
	// https://tc39.github.io/ecma262/#sec-number.epsilon
	_export({ target: 'Number', stat: true }, {
	  EPSILON: Math.pow(2, -52)
	});

	var globalIsFinite = global_1.isFinite;

	// `Number.isFinite` method
	// https://tc39.github.io/ecma262/#sec-number.isfinite
	var numberIsFinite = Number.isFinite || function isFinite(it) {
	  return typeof it == 'number' && globalIsFinite(it);
	};

	// `Number.isFinite` method
	// https://tc39.github.io/ecma262/#sec-number.isfinite
	_export({ target: 'Number', stat: true }, { isFinite: numberIsFinite });

	var floor$2 = Math.floor;

	// `Number.isInteger` method implementation
	// https://tc39.github.io/ecma262/#sec-number.isinteger
	var isInteger = function isInteger(it) {
	  return !isObject$3(it) && isFinite(it) && floor$2(it) === it;
	};

	// `Number.isInteger` method
	// https://tc39.github.io/ecma262/#sec-number.isinteger
	_export({ target: 'Number', stat: true }, {
	  isInteger: isInteger
	});

	// `Number.isNaN` method
	// https://tc39.github.io/ecma262/#sec-number.isnan
	_export({ target: 'Number', stat: true }, {
	  isNaN: function isNaN(number) {
	    // eslint-disable-next-line no-self-compare
	    return number != number;
	  }
	});

	var abs = Math.abs;

	// `Number.isSafeInteger` method
	// https://tc39.github.io/ecma262/#sec-number.issafeinteger
	_export({ target: 'Number', stat: true }, {
	  isSafeInteger: function isSafeInteger(number) {
	    return isInteger(number) && abs(number) <= 0x1FFFFFFFFFFFFF;
	  }
	});

	// `Number.MAX_SAFE_INTEGER` constant
	// https://tc39.github.io/ecma262/#sec-number.max_safe_integer
	_export({ target: 'Number', stat: true }, {
	  MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
	});

	// `Number.MIN_SAFE_INTEGER` constant
	// https://tc39.github.io/ecma262/#sec-number.min_safe_integer
	_export({ target: 'Number', stat: true }, {
	  MIN_SAFE_INTEGER: -0x1FFFFFFFFFFFFF
	});

	// `Number.parseFloat` method
	// https://tc39.github.io/ecma262/#sec-number.parseFloat
	_export({ target: 'Number', stat: true, forced: Number.parseFloat != numberParseFloat }, {
	  parseFloat: numberParseFloat
	});

	// `Number.parseInt` method
	// https://tc39.github.io/ecma262/#sec-number.parseint
	_export({ target: 'Number', stat: true, forced: Number.parseInt != numberParseInt }, {
	  parseInt: numberParseInt
	});

	// `thisNumberValue` abstract operation
	// https://tc39.github.io/ecma262/#sec-thisnumbervalue
	var thisNumberValue = function (value) {
	  if (typeof value != 'number' && classofRaw(value) != 'Number') {
	    throw TypeError('Incorrect invocation');
	  }
	  return +value;
	};

	var nativeToFixed = 1.0.toFixed;
	var floor$3 = Math.floor;

	var pow = function (x, n, acc) {
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};

	var log = function (x) {
	  var n = 0;
	  var x2 = x;
	  while (x2 >= 4096) {
	    n += 12;
	    x2 /= 4096;
	  }
	  while (x2 >= 2) {
	    n += 1;
	    x2 /= 2;
	  } return n;
	};

	var FORCED$9 = nativeToFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
	) || !fails(function () {
	  // V8 ~ Android 4.3-
	  nativeToFixed.call({});
	});

	// `Number.prototype.toFixed` method
	// https://tc39.github.io/ecma262/#sec-number.prototype.tofixed
	_export({ target: 'Number', proto: true, forced: FORCED$9 }, {
	  // eslint-disable-next-line max-statements
	  toFixed: function toFixed(fractionDigits) {
	    var number = thisNumberValue(this);
	    var fractDigits = toInteger(fractionDigits);
	    var data = [0, 0, 0, 0, 0, 0];
	    var sign = '';
	    var result = '0';
	    var e, z, j, k;

	    var multiply = function (n, c) {
	      var index = -1;
	      var c2 = c;
	      while (++index < 6) {
	        c2 += n * data[index];
	        data[index] = c2 % 1e7;
	        c2 = floor$3(c2 / 1e7);
	      }
	    };

	    var divide = function (n) {
	      var index = 6;
	      var c = 0;
	      while (--index >= 0) {
	        c += data[index];
	        data[index] = floor$3(c / n);
	        c = (c % n) * 1e7;
	      }
	    };

	    var dataToString = function () {
	      var index = 6;
	      var s = '';
	      while (--index >= 0) {
	        if (s !== '' || index === 0 || data[index] !== 0) {
	          var t = String(data[index]);
	          s = s === '' ? t : s + stringRepeat.call('0', 7 - t.length) + t;
	        }
	      } return s;
	    };

	    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
	    // eslint-disable-next-line no-self-compare
	    if (number != number) return 'NaN';
	    if (number <= -1e21 || number >= 1e21) return String(number);
	    if (number < 0) {
	      sign = '-';
	      number = -number;
	    }
	    if (number > 1e-21) {
	      e = log(number * pow(2, 69, 1)) - 69;
	      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if (e > 0) {
	        multiply(0, z);
	        j = fractDigits;
	        while (j >= 7) {
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while (j >= 23) {
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        result = dataToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        result = dataToString() + stringRepeat.call('0', fractDigits);
	      }
	    }
	    if (fractDigits > 0) {
	      k = result.length;
	      result = sign + (k <= fractDigits
	        ? '0.' + stringRepeat.call('0', fractDigits - k) + result
	        : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
	    } else {
	      result = sign + result;
	    } return result;
	  }
	});

	var nativeToPrecision = 1.0.toPrecision;

	var FORCED$a = fails(function () {
	  // IE7-
	  return nativeToPrecision.call(1, undefined) !== '1';
	}) || !fails(function () {
	  // V8 ~ Android 4.3-
	  nativeToPrecision.call({});
	});

	// `Number.prototype.toPrecision` method
	// https://tc39.github.io/ecma262/#sec-number.prototype.toprecision
	_export({ target: 'Number', proto: true, forced: FORCED$a }, {
	  toPrecision: function toPrecision(precision) {
	    return precision === undefined
	      ? nativeToPrecision.call(thisNumberValue(this))
	      : nativeToPrecision.call(thisNumberValue(this), precision);
	  }
	});

	var log$1 = Math.log;

	// `Math.log1p` method implementation
	// https://tc39.github.io/ecma262/#sec-math.log1p
	var mathLog1p = Math.log1p || function log1p(x) {
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log$1(1 + x);
	};

	var nativeAcosh = Math.acosh;
	var log$2 = Math.log;
	var sqrt = Math.sqrt;
	var LN2 = Math.LN2;

	var FORCED$b = !nativeAcosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  || Math.floor(nativeAcosh(Number.MAX_VALUE)) != 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN
	  || nativeAcosh(Infinity) != Infinity;

	// `Math.acosh` method
	// https://tc39.github.io/ecma262/#sec-math.acosh
	_export({ target: 'Math', stat: true, forced: FORCED$b }, {
	  acosh: function acosh(x) {
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? log$2(x) + LN2
	      : mathLog1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

	var nativeAsinh = Math.asinh;
	var log$3 = Math.log;
	var sqrt$1 = Math.sqrt;

	function asinh(x) {
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log$3(x + sqrt$1(x * x + 1));
	}

	// `Math.asinh` method
	// https://tc39.github.io/ecma262/#sec-math.asinh
	// Tor Browser bug: Math.asinh(0) -> -0
	_export({ target: 'Math', stat: true, forced: !(nativeAsinh && 1 / nativeAsinh(0) > 0) }, {
	  asinh: asinh
	});

	var nativeAtanh = Math.atanh;
	var log$4 = Math.log;

	// `Math.atanh` method
	// https://tc39.github.io/ecma262/#sec-math.atanh
	// Tor Browser bug: Math.atanh(-0) -> 0
	_export({ target: 'Math', stat: true, forced: !(nativeAtanh && 1 / nativeAtanh(-0) < 0) }, {
	  atanh: function atanh(x) {
	    return (x = +x) == 0 ? x : log$4((1 + x) / (1 - x)) / 2;
	  }
	});

	// `Math.sign` method implementation
	// https://tc39.github.io/ecma262/#sec-math.sign
	var mathSign = Math.sign || function sign(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

	var abs$1 = Math.abs;
	var pow$1 = Math.pow;

	// `Math.cbrt` method
	// https://tc39.github.io/ecma262/#sec-math.cbrt
	_export({ target: 'Math', stat: true }, {
	  cbrt: function cbrt(x) {
	    return mathSign(x = +x) * pow$1(abs$1(x), 1 / 3);
	  }
	});

	var floor$4 = Math.floor;
	var log$5 = Math.log;
	var LOG2E = Math.LOG2E;

	// `Math.clz32` method
	// https://tc39.github.io/ecma262/#sec-math.clz32
	_export({ target: 'Math', stat: true }, {
	  clz32: function clz32(x) {
	    return (x >>>= 0) ? 31 - floor$4(log$5(x + 0.5) * LOG2E) : 32;
	  }
	});

	var nativeExpm1 = Math.expm1;
	var exp = Math.exp;

	// `Math.expm1` method implementation
	// https://tc39.github.io/ecma262/#sec-math.expm1
	var mathExpm1 = (!nativeExpm1
	  // Old FF bug
	  || nativeExpm1(10) > 22025.465794806719 || nativeExpm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || nativeExpm1(-2e-17) != -2e-17
	) ? function expm1(x) {
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
	} : nativeExpm1;

	var nativeCosh = Math.cosh;
	var abs$2 = Math.abs;
	var E = Math.E;

	// `Math.cosh` method
	// https://tc39.github.io/ecma262/#sec-math.cosh
	_export({ target: 'Math', stat: true, forced: !nativeCosh || nativeCosh(710) === Infinity }, {
	  cosh: function cosh(x) {
	    var t = mathExpm1(abs$2(x) - 1) + 1;
	    return (t + 1 / (t * E * E)) * (E / 2);
	  }
	});

	// `Math.expm1` method
	// https://tc39.github.io/ecma262/#sec-math.expm1
	_export({ target: 'Math', stat: true, forced: mathExpm1 != Math.expm1 }, { expm1: mathExpm1 });

	var abs$3 = Math.abs;
	var pow$2 = Math.pow;
	var EPSILON = pow$2(2, -52);
	var EPSILON32 = pow$2(2, -23);
	var MAX32 = pow$2(2, 127) * (2 - EPSILON32);
	var MIN32 = pow$2(2, -126);

	var roundTiesToEven = function (n) {
	  return n + 1 / EPSILON - 1 / EPSILON;
	};

	// `Math.fround` method implementation
	// https://tc39.github.io/ecma262/#sec-math.fround
	var mathFround = Math.fround || function fround(x) {
	  var $abs = abs$3(x);
	  var $sign = mathSign(x);
	  var a, result;
	  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	  a = (1 + EPSILON32 / EPSILON) * $abs;
	  result = a - (a - $abs);
	  // eslint-disable-next-line no-self-compare
	  if (result > MAX32 || result != result) return $sign * Infinity;
	  return $sign * result;
	};

	// `Math.fround` method
	// https://tc39.github.io/ecma262/#sec-math.fround
	_export({ target: 'Math', stat: true }, { fround: mathFround });

	var $hypot = Math.hypot;
	var abs$4 = Math.abs;
	var sqrt$2 = Math.sqrt;

	// Chrome 77 bug
	// https://bugs.chromium.org/p/v8/issues/detail?id=9546
	var BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity;

	// `Math.hypot` method
	// https://tc39.github.io/ecma262/#sec-math.hypot
	_export({ target: 'Math', stat: true, forced: BUGGY }, {
	  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
	    var sum = 0;
	    var i = 0;
	    var aLen = arguments.length;
	    var larg = 0;
	    var arg, div;
	    while (i < aLen) {
	      arg = abs$4(arguments[i++]);
	      if (larg < arg) {
	        div = larg / arg;
	        sum = sum * div * div + 1;
	        larg = arg;
	      } else if (arg > 0) {
	        div = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * sqrt$2(sum);
	  }
	});

	var nativeImul = Math.imul;

	var FORCED$c = fails(function () {
	  return nativeImul(0xFFFFFFFF, 5) != -5 || nativeImul.length != 2;
	});

	// `Math.imul` method
	// https://tc39.github.io/ecma262/#sec-math.imul
	// some WebKit versions fails with big numbers, some has wrong arity
	_export({ target: 'Math', stat: true, forced: FORCED$c }, {
	  imul: function imul(x, y) {
	    var UINT16 = 0xFFFF;
	    var xn = +x;
	    var yn = +y;
	    var xl = UINT16 & xn;
	    var yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

	var log$6 = Math.log;
	var LOG10E = Math.LOG10E;

	// `Math.log10` method
	// https://tc39.github.io/ecma262/#sec-math.log10
	_export({ target: 'Math', stat: true }, {
	  log10: function log10(x) {
	    return log$6(x) * LOG10E;
	  }
	});

	// `Math.log1p` method
	// https://tc39.github.io/ecma262/#sec-math.log1p
	_export({ target: 'Math', stat: true }, { log1p: mathLog1p });

	var log$7 = Math.log;
	var LN2$1 = Math.LN2;

	// `Math.log2` method
	// https://tc39.github.io/ecma262/#sec-math.log2
	_export({ target: 'Math', stat: true }, {
	  log2: function log2(x) {
	    return log$7(x) / LN2$1;
	  }
	});

	// `Math.sign` method
	// https://tc39.github.io/ecma262/#sec-math.sign
	_export({ target: 'Math', stat: true }, {
	  sign: mathSign
	});

	var abs$5 = Math.abs;
	var exp$1 = Math.exp;
	var E$1 = Math.E;

	var FORCED$d = fails(function () {
	  return Math.sinh(-2e-17) != -2e-17;
	});

	// `Math.sinh` method
	// https://tc39.github.io/ecma262/#sec-math.sinh
	// V8 near Chromium 38 has a problem with very small numbers
	_export({ target: 'Math', stat: true, forced: FORCED$d }, {
	  sinh: function sinh(x) {
	    return abs$5(x = +x) < 1 ? (mathExpm1(x) - mathExpm1(-x)) / 2 : (exp$1(x - 1) - exp$1(-x - 1)) * (E$1 / 2);
	  }
	});

	var exp$2 = Math.exp;

	// `Math.tanh` method
	// https://tc39.github.io/ecma262/#sec-math.tanh
	_export({ target: 'Math', stat: true }, {
	  tanh: function tanh(x) {
	    var a = mathExpm1(x = +x);
	    var b = mathExpm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp$2(x) + exp$2(-x));
	  }
	});

	// Math[@@toStringTag] property
	// https://tc39.github.io/ecma262/#sec-math-@@tostringtag
	setToStringTag(Math, 'Math', true);

	var ceil$2 = Math.ceil;
	var floor$5 = Math.floor;

	// `Math.trunc` method
	// https://tc39.github.io/ecma262/#sec-math.trunc
	_export({ target: 'Math', stat: true }, {
	  trunc: function trunc(it) {
	    return (it > 0 ? floor$5 : ceil$2)(it);
	  }
	});

	// `Date.now` method
	// https://tc39.github.io/ecma262/#sec-date.now
	_export({ target: 'Date', stat: true }, {
	  now: function now() {
	    return new Date().getTime();
	  }
	});

	var FORCED$e = fails(function () {
	  return new Date(NaN).toJSON() !== null
	    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
	});

	// `Date.prototype.toJSON` method
	// https://tc39.github.io/ecma262/#sec-date.prototype.tojson
	_export({ target: 'Date', proto: true, forced: FORCED$e }, {
	  // eslint-disable-next-line no-unused-vars
	  toJSON: function toJSON(key) {
	    var O = toObject(this);
	    var pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

	var padStart = stringPad.start;

	var abs$6 = Math.abs;
	var DatePrototype = Date.prototype;
	var getTime = DatePrototype.getTime;
	var nativeDateToISOString = DatePrototype.toISOString;

	// `Date.prototype.toISOString` method implementation
	// https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
	// PhantomJS / old WebKit fails here:
	var dateToIsoString = (fails(function () {
	  return nativeDateToISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
	}) || !fails(function () {
	  nativeDateToISOString.call(new Date(NaN));
	})) ? function toISOString() {
	  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
	  var date = this;
	  var year = date.getUTCFullYear();
	  var milliseconds = date.getUTCMilliseconds();
	  var sign = year < 0 ? '-' : year > 9999 ? '+' : '';
	  return sign + padStart(abs$6(year), sign ? 6 : 4, 0) +
	    '-' + padStart(date.getUTCMonth() + 1, 2, 0) +
	    '-' + padStart(date.getUTCDate(), 2, 0) +
	    'T' + padStart(date.getUTCHours(), 2, 0) +
	    ':' + padStart(date.getUTCMinutes(), 2, 0) +
	    ':' + padStart(date.getUTCSeconds(), 2, 0) +
	    '.' + padStart(milliseconds, 3, 0) +
	    'Z';
	} : nativeDateToISOString;

	// `Date.prototype.toISOString` method
	// https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
	// PhantomJS / old WebKit has a broken implementations
	_export({ target: 'Date', proto: true, forced: Date.prototype.toISOString !== dateToIsoString }, {
	  toISOString: dateToIsoString
	});

	var DatePrototype$1 = Date.prototype;
	var INVALID_DATE = 'Invalid Date';
	var TO_STRING$1 = 'toString';
	var nativeDateToString = DatePrototype$1[TO_STRING$1];
	var getTime$1 = DatePrototype$1.getTime;

	// `Date.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-date.prototype.tostring
	if (new Date(NaN) + '' != INVALID_DATE) {
	  redefine(DatePrototype$1, TO_STRING$1, function toString() {
	    var value = getTime$1.call(this);
	    // eslint-disable-next-line no-self-compare
	    return value === value ? nativeDateToString.call(this) : INVALID_DATE;
	  });
	}

	var dateToPrimitive = function (hint) {
	  if (hint !== 'string' && hint !== 'number' && hint !== 'default') {
	    throw TypeError('Incorrect hint');
	  } return toPrimitive(anObject(this), hint !== 'number');
	};

	var TO_PRIMITIVE$1 = wellKnownSymbol('toPrimitive');
	var DatePrototype$2 = Date.prototype;

	// `Date.prototype[@@toPrimitive]` method
	// https://tc39.github.io/ecma262/#sec-date.prototype-@@toprimitive
	if (!(TO_PRIMITIVE$1 in DatePrototype$2)) {
	  createNonEnumerableProperty(DatePrototype$2, TO_PRIMITIVE$1, dateToPrimitive);
	}

	var $stringify$1 = getBuiltIn('JSON', 'stringify');
	var re = /[\uD800-\uDFFF]/g;
	var low = /^[\uD800-\uDBFF]$/;
	var hi = /^[\uDC00-\uDFFF]$/;

	var fix = function (match, offset, string) {
	  var prev = string.charAt(offset - 1);
	  var next = string.charAt(offset + 1);
	  if ((low.test(match) && !hi.test(next)) || (hi.test(match) && !low.test(prev))) {
	    return '\\u' + match.charCodeAt(0).toString(16);
	  } return match;
	};

	var FORCED$f = fails(function () {
	  return $stringify$1('\uDF06\uD834') !== '"\\udf06\\ud834"'
	    || $stringify$1('\uDEAD') !== '"\\udead"';
	});

	if ($stringify$1) {
	  // https://github.com/tc39/proposal-well-formed-stringify
	  _export({ target: 'JSON', stat: true, forced: FORCED$f }, {
	    // eslint-disable-next-line no-unused-vars
	    stringify: function stringify(it, replacer, space) {
	      var result = $stringify$1.apply(null, arguments);
	      return typeof result == 'string' ? result.replace(re, fix) : result;
	    }
	  });
	}

	// JSON[@@toStringTag] property
	// https://tc39.github.io/ecma262/#sec-json-@@tostringtag
	setToStringTag(global_1.JSON, 'JSON', true);

	var nativePromiseConstructor = global_1.Promise;

	var redefineAll = function (target, src, options) {
	  for (var key in src) redefine(target, key, src[key], options);
	  return target;
	};

	var anInstance = function (it, Constructor, name) {
	  if (!(it instanceof Constructor)) {
	    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
	  } return it;
	};

	var engineIsIos = /(iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent);

	var location = global_1.location;
	var set$3 = global_1.setImmediate;
	var clear = global_1.clearImmediate;
	var process$2 = global_1.process;
	var MessageChannel = global_1.MessageChannel;
	var Dispatch = global_1.Dispatch;
	var counter = 0;
	var queue$1 = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;

	var run = function (id) {
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue$1.hasOwnProperty(id)) {
	    var fn = queue$1[id];
	    delete queue$1[id];
	    fn();
	  }
	};

	var runner = function (id) {
	  return function () {
	    run(id);
	  };
	};

	var listener = function (event) {
	  run(event.data);
	};

	var post = function (id) {
	  // old engines have not location.origin
	  global_1.postMessage(id + '', location.protocol + '//' + location.host);
	};

	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!set$3 || !clear) {
	  set$3 = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue$1[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clear = function clearImmediate(id) {
	    delete queue$1[id];
	  };
	  // Node.js 0.8-
	  if (classofRaw(process$2) == 'process') {
	    defer = function (id) {
	      process$2.nextTick(runner(id));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(runner(id));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  // except iOS - https://github.com/zloirock/core-js/issues/624
	  } else if (MessageChannel && !engineIsIos) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = functionBindContext(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (
	    global_1.addEventListener &&
	    typeof postMessage == 'function' &&
	    !global_1.importScripts &&
	    !fails(post) &&
	    location.protocol !== 'file:'
	  ) {
	    defer = post;
	    global_1.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
	    defer = function (id) {
	      html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(runner(id), 0);
	    };
	  }
	}

	var task = {
	  set: set$3,
	  clear: clear
	};

	var getOwnPropertyDescriptor$7 = objectGetOwnPropertyDescriptor.f;

	var macrotask = task.set;


	var MutationObserver = global_1.MutationObserver || global_1.WebKitMutationObserver;
	var process$3 = global_1.process;
	var Promise$2 = global_1.Promise;
	var IS_NODE = classofRaw(process$3) == 'process';
	// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
	var queueMicrotaskDescriptor = getOwnPropertyDescriptor$7(global_1, 'queueMicrotask');
	var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

	var flush, head, last, notify, toggle, node, promise, then;

	// modern engines have queueMicrotask method
	if (!queueMicrotask) {
	  flush = function () {
	    var parent, fn;
	    if (IS_NODE && (parent = process$3.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (error) {
	        if (head) notify();
	        else last = undefined;
	        throw error;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };

	  // Node.js
	  if (IS_NODE) {
	    notify = function () {
	      process$3.nextTick(flush);
	    };
	  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
	  } else if (MutationObserver && !engineIsIos) {
	    toggle = true;
	    node = document.createTextNode('');
	    new MutationObserver(flush).observe(node, { characterData: true });
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise$2 && Promise$2.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    promise = Promise$2.resolve(undefined);
	    then = promise.then;
	    notify = function () {
	      then.call(promise, flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global_1, flush);
	    };
	  }
	}

	var microtask = queueMicrotask || function (fn) {
	  var task = { fn: fn, next: undefined };
	  if (last) last.next = task;
	  if (!head) {
	    head = task;
	    notify();
	  } last = task;
	};

	var PromiseCapability = function (C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction$1(resolve);
	  this.reject = aFunction$1(reject);
	};

	// 25.4.1.5 NewPromiseCapability(C)
	var f$7 = function (C) {
	  return new PromiseCapability(C);
	};

	var newPromiseCapability = {
		f: f$7
	};

	var promiseResolve = function (C, x) {
	  anObject(C);
	  if (isObject$3(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var hostReportErrors = function (a, b) {
	  var console = global_1.console;
	  if (console && console.error) {
	    arguments.length === 1 ? console.error(a) : console.error(a, b);
	  }
	};

	var perform = function (exec) {
	  try {
	    return { error: false, value: exec() };
	  } catch (error) {
	    return { error: true, value: error };
	  }
	};

	var task$1 = task.set;










	var SPECIES$6 = wellKnownSymbol('species');
	var PROMISE = 'Promise';
	var getInternalState$5 = internalState.get;
	var setInternalState$5 = internalState.set;
	var getInternalPromiseState = internalState.getterFor(PROMISE);
	var PromiseConstructor = nativePromiseConstructor;
	var TypeError$1 = global_1.TypeError;
	var document$2 = global_1.document;
	var process$4 = global_1.process;
	var $fetch = getBuiltIn('fetch');
	var newPromiseCapability$1 = newPromiseCapability.f;
	var newGenericPromiseCapability = newPromiseCapability$1;
	var IS_NODE$1 = classofRaw(process$4) == 'process';
	var DISPATCH_EVENT = !!(document$2 && document$2.createEvent && global_1.dispatchEvent);
	var UNHANDLED_REJECTION = 'unhandledrejection';
	var REJECTION_HANDLED = 'rejectionhandled';
	var PENDING = 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	var HANDLED = 1;
	var UNHANDLED = 2;
	var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

	var FORCED$g = isForced_1(PROMISE, function () {
	  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
	  if (!GLOBAL_CORE_JS_PROMISE) {
	    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	    // We can't detect it synchronously, so just check versions
	    if (engineV8Version === 66) return true;
	    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    if (!IS_NODE$1 && typeof PromiseRejectionEvent != 'function') return true;
	  }
	  // We can't use @@species feature detection in V8 since it causes
	  // deoptimization and performance degradation
	  // https://github.com/zloirock/core-js/issues/679
	  if (engineV8Version >= 51 && /native code/.test(PromiseConstructor)) return false;
	  // Detect correctness of subclassing with @@species support
	  var promise = PromiseConstructor.resolve(1);
	  var FakePromise = function (exec) {
	    exec(function () { /* empty */ }, function () { /* empty */ });
	  };
	  var constructor = promise.constructor = {};
	  constructor[SPECIES$6] = FakePromise;
	  return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
	});

	var INCORRECT_ITERATION$1 = FORCED$g || !checkCorrectnessOfIteration(function (iterable) {
	  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
	});

	// helpers
	var isThenable = function (it) {
	  var then;
	  return isObject$3(it) && typeof (then = it.then) == 'function' ? then : false;
	};

	var notify$1 = function (promise, state, isReject) {
	  if (state.notified) return;
	  state.notified = true;
	  var chain = state.reactions;
	  microtask(function () {
	    var value = state.value;
	    var ok = state.state == FULFILLED;
	    var index = 0;
	    // variable length - can't use forEach
	    while (chain.length > index) {
	      var reaction = chain[index++];
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
	            state.rejection = HANDLED;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value); // can throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (error) {
	        if (domain && !exited) domain.exit();
	        reject(error);
	      }
	    }
	    state.reactions = [];
	    state.notified = false;
	    if (isReject && !state.rejection) onUnhandled(promise, state);
	  });
	};

	var dispatchEvent = function (name, promise, reason) {
	  var event, handler;
	  if (DISPATCH_EVENT) {
	    event = document$2.createEvent('Event');
	    event.promise = promise;
	    event.reason = reason;
	    event.initEvent(name, false, true);
	    global_1.dispatchEvent(event);
	  } else event = { promise: promise, reason: reason };
	  if (handler = global_1['on' + name]) handler(event);
	  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
	};

	var onUnhandled = function (promise, state) {
	  task$1.call(global_1, function () {
	    var value = state.value;
	    var IS_UNHANDLED = isUnhandled(state);
	    var result;
	    if (IS_UNHANDLED) {
	      result = perform(function () {
	        if (IS_NODE$1) {
	          process$4.emit('unhandledRejection', value, promise);
	        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
	      if (result.error) throw result.value;
	    }
	  });
	};

	var isUnhandled = function (state) {
	  return state.rejection !== HANDLED && !state.parent;
	};

	var onHandleUnhandled = function (promise, state) {
	  task$1.call(global_1, function () {
	    if (IS_NODE$1) {
	      process$4.emit('rejectionHandled', promise);
	    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
	  });
	};

	var bind$1 = function (fn, promise, state, unwrap) {
	  return function (value) {
	    fn(promise, state, value, unwrap);
	  };
	};

	var internalReject = function (promise, state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  state.value = value;
	  state.state = REJECTED;
	  notify$1(promise, state, true);
	};

	var internalResolve = function (promise, state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  try {
	    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
	    var then = isThenable(value);
	    if (then) {
	      microtask(function () {
	        var wrapper = { done: false };
	        try {
	          then.call(value,
	            bind$1(internalResolve, promise, wrapper, state),
	            bind$1(internalReject, promise, wrapper, state)
	          );
	        } catch (error) {
	          internalReject(promise, wrapper, error, state);
	        }
	      });
	    } else {
	      state.value = value;
	      state.state = FULFILLED;
	      notify$1(promise, state, false);
	    }
	  } catch (error) {
	    internalReject(promise, { done: false }, error, state);
	  }
	};

	// constructor polyfill
	if (FORCED$g) {
	  // 25.4.3.1 Promise(executor)
	  PromiseConstructor = function Promise(executor) {
	    anInstance(this, PromiseConstructor, PROMISE);
	    aFunction$1(executor);
	    Internal.call(this);
	    var state = getInternalState$5(this);
	    try {
	      executor(bind$1(internalResolve, this, state), bind$1(internalReject, this, state));
	    } catch (error) {
	      internalReject(this, state, error);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    setInternalState$5(this, {
	      type: PROMISE,
	      done: false,
	      notified: false,
	      parent: false,
	      reactions: [],
	      rejection: false,
	      state: PENDING,
	      value: undefined
	    });
	  };
	  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
	    // `Promise.prototype.then` method
	    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
	    then: function then(onFulfilled, onRejected) {
	      var state = getInternalPromiseState(this);
	      var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = IS_NODE$1 ? process$4.domain : undefined;
	      state.parent = true;
	      state.reactions.push(reaction);
	      if (state.state != PENDING) notify$1(this, state, false);
	      return reaction.promise;
	    },
	    // `Promise.prototype.catch` method
	    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    var state = getInternalState$5(promise);
	    this.promise = promise;
	    this.resolve = bind$1(internalResolve, promise, state);
	    this.reject = bind$1(internalReject, promise, state);
	  };
	  newPromiseCapability.f = newPromiseCapability$1 = function (C) {
	    return C === PromiseConstructor || C === PromiseWrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };

	  if ( typeof nativePromiseConstructor == 'function') {
	    nativeThen = nativePromiseConstructor.prototype.then;

	    // wrap native Promise#then for native async functions
	    redefine(nativePromiseConstructor.prototype, 'then', function then(onFulfilled, onRejected) {
	      var that = this;
	      return new PromiseConstructor(function (resolve, reject) {
	        nativeThen.call(that, resolve, reject);
	      }).then(onFulfilled, onRejected);
	    // https://github.com/zloirock/core-js/issues/640
	    }, { unsafe: true });

	    // wrap fetch result
	    if (typeof $fetch == 'function') _export({ global: true, enumerable: true, forced: true }, {
	      // eslint-disable-next-line no-unused-vars
	      fetch: function fetch(input /* , init */) {
	        return promiseResolve(PromiseConstructor, $fetch.apply(global_1, arguments));
	      }
	    });
	  }
	}

	_export({ global: true, wrap: true, forced: FORCED$g }, {
	  Promise: PromiseConstructor
	});

	setToStringTag(PromiseConstructor, PROMISE, false);
	setSpecies(PROMISE);

	PromiseWrapper = getBuiltIn(PROMISE);

	// statics
	_export({ target: PROMISE, stat: true, forced: FORCED$g }, {
	  // `Promise.reject` method
	  // https://tc39.github.io/ecma262/#sec-promise.reject
	  reject: function reject(r) {
	    var capability = newPromiseCapability$1(this);
	    capability.reject.call(undefined, r);
	    return capability.promise;
	  }
	});

	_export({ target: PROMISE, stat: true, forced:  FORCED$g }, {
	  // `Promise.resolve` method
	  // https://tc39.github.io/ecma262/#sec-promise.resolve
	  resolve: function resolve(x) {
	    return promiseResolve( this, x);
	  }
	});

	_export({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION$1 }, {
	  // `Promise.all` method
	  // https://tc39.github.io/ecma262/#sec-promise.all
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction$1(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate_1(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        $promiseResolve.call(C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  },
	  // `Promise.race` method
	  // https://tc39.github.io/ecma262/#sec-promise.race
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction$1(C.resolve);
	      iterate_1(iterable, function (promise) {
	        $promiseResolve.call(C, promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	// `Promise.allSettled` method
	// https://github.com/tc39/proposal-promise-allSettled
	_export({ target: 'Promise', stat: true }, {
	  allSettled: function allSettled(iterable) {
	    var C = this;
	    var capability = newPromiseCapability.f(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var promiseResolve = aFunction$1(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate_1(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        promiseResolve.call(C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = { status: 'fulfilled', value: value };
	          --remaining || resolve(values);
	        }, function (e) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = { status: 'rejected', reason: e };
	          --remaining || resolve(values);
	        });
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
	var NON_GENERIC = !!nativePromiseConstructor && fails(function () {
	  nativePromiseConstructor.prototype['finally'].call({ then: function () { /* empty */ } }, function () { /* empty */ });
	});

	// `Promise.prototype.finally` method
	// https://tc39.github.io/ecma262/#sec-promise.prototype.finally
	_export({ target: 'Promise', proto: true, real: true, forced: NON_GENERIC }, {
	  'finally': function (onFinally) {
	    var C = speciesConstructor(this, getBuiltIn('Promise'));
	    var isFunction = typeof onFinally == 'function';
	    return this.then(
	      isFunction ? function (x) {
	        return promiseResolve(C, onFinally()).then(function () { return x; });
	      } : onFinally,
	      isFunction ? function (e) {
	        return promiseResolve(C, onFinally()).then(function () { throw e; });
	      } : onFinally
	    );
	  }
	});

	// patch native Promise.prototype for native async functions
	if ( typeof nativePromiseConstructor == 'function' && !nativePromiseConstructor.prototype['finally']) {
	  redefine(nativePromiseConstructor.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);
	}

	var collection = function (CONSTRUCTOR_NAME, wrapper, common) {
	  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
	  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var NativeConstructor = global_1[CONSTRUCTOR_NAME];
	  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
	  var Constructor = NativeConstructor;
	  var exported = {};

	  var fixMethod = function (KEY) {
	    var nativeMethod = NativePrototype[KEY];
	    redefine(NativePrototype, KEY,
	      KEY == 'add' ? function add(value) {
	        nativeMethod.call(this, value === 0 ? 0 : value);
	        return this;
	      } : KEY == 'delete' ? function (key) {
	        return IS_WEAK && !isObject$3(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
	      } : KEY == 'get' ? function get(key) {
	        return IS_WEAK && !isObject$3(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
	      } : KEY == 'has' ? function has(key) {
	        return IS_WEAK && !isObject$3(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
	      } : function set(key, value) {
	        nativeMethod.call(this, key === 0 ? 0 : key, value);
	        return this;
	      }
	    );
	  };

	  // eslint-disable-next-line max-len
	  if (isForced_1(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
	    new NativeConstructor().entries().next();
	  })))) {
	    // create collection constructor
	    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
	    internalMetadata.REQUIRED = true;
	  } else if (isForced_1(CONSTRUCTOR_NAME, true)) {
	    var instance = new Constructor();
	    // early implementations not supports chaining
	    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
	    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
	    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
	    // most early implementations doesn't supports iterables, most modern - not close it correctly
	    // eslint-disable-next-line no-new
	    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
	    // for early implementations -0 and +0 not the same
	    var BUGGY_ZERO = !IS_WEAK && fails(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new NativeConstructor();
	      var index = 5;
	      while (index--) $instance[ADDER](index, index);
	      return !$instance.has(-0);
	    });

	    if (!ACCEPT_ITERABLES) {
	      Constructor = wrapper(function (dummy, iterable) {
	        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
	        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
	        if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
	        return that;
	      });
	      Constructor.prototype = NativePrototype;
	      NativePrototype.constructor = Constructor;
	    }

	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }

	    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

	    // weak collections should not contains .clear method
	    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
	  }

	  exported[CONSTRUCTOR_NAME] = Constructor;
	  _export({ global: true, forced: Constructor != NativeConstructor }, exported);

	  setToStringTag(Constructor, CONSTRUCTOR_NAME);

	  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

	  return Constructor;
	};

	var defineProperty$b = objectDefineProperty.f;








	var fastKey = internalMetadata.fastKey;


	var setInternalState$6 = internalState.set;
	var internalStateGetterFor = internalState.getterFor;

	var collectionStrong = {
	  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, CONSTRUCTOR_NAME);
	      setInternalState$6(that, {
	        type: CONSTRUCTOR_NAME,
	        index: objectCreate$1(null),
	        first: undefined,
	        last: undefined,
	        size: 0
	      });
	      if (!descriptors) that.size = 0;
	      if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
	    });

	    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

	    var define = function (that, key, value) {
	      var state = getInternalState(that);
	      var entry = getEntry(that, key);
	      var previous, index;
	      // change existing entry
	      if (entry) {
	        entry.value = value;
	      // create new entry
	      } else {
	        state.last = entry = {
	          index: index = fastKey(key, true),
	          key: key,
	          value: value,
	          previous: previous = state.last,
	          next: undefined,
	          removed: false
	        };
	        if (!state.first) state.first = entry;
	        if (previous) previous.next = entry;
	        if (descriptors) state.size++;
	        else that.size++;
	        // add to index
	        if (index !== 'F') state.index[index] = entry;
	      } return that;
	    };

	    var getEntry = function (that, key) {
	      var state = getInternalState(that);
	      // fast case
	      var index = fastKey(key);
	      var entry;
	      if (index !== 'F') return state.index[index];
	      // frozen object case
	      for (entry = state.first; entry; entry = entry.next) {
	        if (entry.key == key) return entry;
	      }
	    };

	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear() {
	        var that = this;
	        var state = getInternalState(that);
	        var data = state.index;
	        var entry = state.first;
	        while (entry) {
	          entry.removed = true;
	          if (entry.previous) entry.previous = entry.previous.next = undefined;
	          delete data[entry.index];
	          entry = entry.next;
	        }
	        state.first = state.last = undefined;
	        if (descriptors) state.size = 0;
	        else that.size = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function (key) {
	        var that = this;
	        var state = getInternalState(that);
	        var entry = getEntry(that, key);
	        if (entry) {
	          var next = entry.next;
	          var prev = entry.previous;
	          delete state.index[entry.index];
	          entry.removed = true;
	          if (prev) prev.next = next;
	          if (next) next.previous = prev;
	          if (state.first == entry) state.first = next;
	          if (state.last == entry) state.last = prev;
	          if (descriptors) state.size--;
	          else that.size--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /* , that = undefined */) {
	        var state = getInternalState(this);
	        var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	        var entry;
	        while (entry = entry ? entry.next : state.first) {
	          boundFunction(entry.value, entry.key, this);
	          // revert to the last existing entry
	          while (entry && entry.removed) entry = entry.previous;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key) {
	        return !!getEntry(this, key);
	      }
	    });

	    redefineAll(C.prototype, IS_MAP ? {
	      // 23.1.3.6 Map.prototype.get(key)
	      get: function get(key) {
	        var entry = getEntry(this, key);
	        return entry && entry.value;
	      },
	      // 23.1.3.9 Map.prototype.set(key, value)
	      set: function set(key, value) {
	        return define(this, key === 0 ? 0 : key, value);
	      }
	    } : {
	      // 23.2.3.1 Set.prototype.add(value)
	      add: function add(value) {
	        return define(this, value = value === 0 ? 0 : value, value);
	      }
	    });
	    if (descriptors) defineProperty$b(C.prototype, 'size', {
	      get: function () {
	        return getInternalState(this).size;
	      }
	    });
	    return C;
	  },
	  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
	    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
	    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
	    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
	      setInternalState$6(this, {
	        type: ITERATOR_NAME,
	        target: iterated,
	        state: getInternalCollectionState(iterated),
	        kind: kind,
	        last: undefined
	      });
	    }, function () {
	      var state = getInternalIteratorState(this);
	      var kind = state.kind;
	      var entry = state.last;
	      // revert to the last existing entry
	      while (entry && entry.removed) entry = entry.previous;
	      // get next entry
	      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
	        // or finish the iteration
	        state.target = undefined;
	        return { value: undefined, done: true };
	      }
	      // return step by kind
	      if (kind == 'keys') return { value: entry.key, done: false };
	      if (kind == 'values') return { value: entry.value, done: false };
	      return { value: [entry.key, entry.value], done: false };
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(CONSTRUCTOR_NAME);
	  }
	};

	// `Map` constructor
	// https://tc39.github.io/ecma262/#sec-map-objects
	var es_map = collection('Map', function (init) {
	  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
	}, collectionStrong);

	// `Set` constructor
	// https://tc39.github.io/ecma262/#sec-set-objects
	var es_set = collection('Set', function (init) {
	  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
	}, collectionStrong);

	var getWeakData = internalMetadata.getWeakData;








	var setInternalState$7 = internalState.set;
	var internalStateGetterFor$1 = internalState.getterFor;
	var find = arrayIteration.find;
	var findIndex = arrayIteration.findIndex;
	var id$1 = 0;

	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function (store) {
	  return store.frozen || (store.frozen = new UncaughtFrozenStore());
	};

	var UncaughtFrozenStore = function () {
	  this.entries = [];
	};

	var findUncaughtFrozen = function (store, key) {
	  return find(store.entries, function (it) {
	    return it[0] === key;
	  });
	};

	UncaughtFrozenStore.prototype = {
	  get: function (key) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) return entry[1];
	  },
	  has: function (key) {
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function (key, value) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) entry[1] = value;
	    else this.entries.push([key, value]);
	  },
	  'delete': function (key) {
	    var index = findIndex(this.entries, function (it) {
	      return it[0] === key;
	    });
	    if (~index) this.entries.splice(index, 1);
	    return !!~index;
	  }
	};

	var collectionWeak = {
	  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, CONSTRUCTOR_NAME);
	      setInternalState$7(that, {
	        type: CONSTRUCTOR_NAME,
	        id: id$1++,
	        frozen: undefined
	      });
	      if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
	    });

	    var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);

	    var define = function (that, key, value) {
	      var state = getInternalState(that);
	      var data = getWeakData(anObject(key), true);
	      if (data === true) uncaughtFrozenStore(state).set(key, value);
	      else data[state.id] = value;
	      return that;
	    };

	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function (key) {
	        var state = getInternalState(this);
	        if (!isObject$3(key)) return false;
	        var data = getWeakData(key);
	        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
	        return data && has(data, state.id) && delete data[state.id];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has$1(key) {
	        var state = getInternalState(this);
	        if (!isObject$3(key)) return false;
	        var data = getWeakData(key);
	        if (data === true) return uncaughtFrozenStore(state).has(key);
	        return data && has(data, state.id);
	      }
	    });

	    redefineAll(C.prototype, IS_MAP ? {
	      // 23.3.3.3 WeakMap.prototype.get(key)
	      get: function get(key) {
	        var state = getInternalState(this);
	        if (isObject$3(key)) {
	          var data = getWeakData(key);
	          if (data === true) return uncaughtFrozenStore(state).get(key);
	          return data ? data[state.id] : undefined;
	        }
	      },
	      // 23.3.3.5 WeakMap.prototype.set(key, value)
	      set: function set(key, value) {
	        return define(this, key, value);
	      }
	    } : {
	      // 23.4.3.1 WeakSet.prototype.add(value)
	      add: function add(value) {
	        return define(this, value, true);
	      }
	    });

	    return C;
	  }
	};

	var es_weakMap = createCommonjsModule(function (module) {






	var enforceIternalState = internalState.enforce;


	var IS_IE11 = !global_1.ActiveXObject && 'ActiveXObject' in global_1;
	var isExtensible = Object.isExtensible;
	var InternalWeakMap;

	var wrapper = function (init) {
	  return function WeakMap() {
	    return init(this, arguments.length ? arguments[0] : undefined);
	  };
	};

	// `WeakMap` constructor
	// https://tc39.github.io/ecma262/#sec-weakmap-constructor
	var $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak);

	// IE11 WeakMap frozen keys fix
	// We can't use feature detection because it crash some old IE builds
	// https://github.com/zloirock/core-js/issues/485
	if (nativeWeakMap && IS_IE11) {
	  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
	  internalMetadata.REQUIRED = true;
	  var WeakMapPrototype = $WeakMap.prototype;
	  var nativeDelete = WeakMapPrototype['delete'];
	  var nativeHas = WeakMapPrototype.has;
	  var nativeGet = WeakMapPrototype.get;
	  var nativeSet = WeakMapPrototype.set;
	  redefineAll(WeakMapPrototype, {
	    'delete': function (key) {
	      if (isObject$3(key) && !isExtensible(key)) {
	        var state = enforceIternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        return nativeDelete.call(this, key) || state.frozen['delete'](key);
	      } return nativeDelete.call(this, key);
	    },
	    has: function has(key) {
	      if (isObject$3(key) && !isExtensible(key)) {
	        var state = enforceIternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        return nativeHas.call(this, key) || state.frozen.has(key);
	      } return nativeHas.call(this, key);
	    },
	    get: function get(key) {
	      if (isObject$3(key) && !isExtensible(key)) {
	        var state = enforceIternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);
	      } return nativeGet.call(this, key);
	    },
	    set: function set(key, value) {
	      if (isObject$3(key) && !isExtensible(key)) {
	        var state = enforceIternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);
	      } else nativeSet.call(this, key, value);
	      return this;
	    }
	  });
	}
	});

	// `WeakSet` constructor
	// https://tc39.github.io/ecma262/#sec-weakset-constructor
	collection('WeakSet', function (init) {
	  return function WeakSet() { return init(this, arguments.length ? arguments[0] : undefined); };
	}, collectionWeak);

	var arrayBufferNative = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';

	// `ToIndex` abstract operation
	// https://tc39.github.io/ecma262/#sec-toindex
	var toIndex = function (it) {
	  if (it === undefined) return 0;
	  var number = toInteger(it);
	  var length = toLength(number);
	  if (number !== length) throw RangeError('Wrong length or index');
	  return length;
	};

	// IEEE754 conversions based on https://github.com/feross/ieee754
	// eslint-disable-next-line no-shadow-restricted-names
	var Infinity$1 = 1 / 0;
	var abs$7 = Math.abs;
	var pow$3 = Math.pow;
	var floor$6 = Math.floor;
	var log$8 = Math.log;
	var LN2$2 = Math.LN2;

	var pack = function (number, mantissaLength, bytes) {
	  var buffer = new Array(bytes);
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var rt = mantissaLength === 23 ? pow$3(2, -24) - pow$3(2, -77) : 0;
	  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
	  var index = 0;
	  var exponent, mantissa, c;
	  number = abs$7(number);
	  // eslint-disable-next-line no-self-compare
	  if (number != number || number === Infinity$1) {
	    // eslint-disable-next-line no-self-compare
	    mantissa = number != number ? 1 : 0;
	    exponent = eMax;
	  } else {
	    exponent = floor$6(log$8(number) / LN2$2);
	    if (number * (c = pow$3(2, -exponent)) < 1) {
	      exponent--;
	      c *= 2;
	    }
	    if (exponent + eBias >= 1) {
	      number += rt / c;
	    } else {
	      number += rt * pow$3(2, 1 - eBias);
	    }
	    if (number * c >= 2) {
	      exponent++;
	      c /= 2;
	    }
	    if (exponent + eBias >= eMax) {
	      mantissa = 0;
	      exponent = eMax;
	    } else if (exponent + eBias >= 1) {
	      mantissa = (number * c - 1) * pow$3(2, mantissaLength);
	      exponent = exponent + eBias;
	    } else {
	      mantissa = number * pow$3(2, eBias - 1) * pow$3(2, mantissaLength);
	      exponent = 0;
	    }
	  }
	  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
	  exponent = exponent << mantissaLength | mantissa;
	  exponentLength += mantissaLength;
	  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
	  buffer[--index] |= sign * 128;
	  return buffer;
	};

	var unpack = function (buffer, mantissaLength) {
	  var bytes = buffer.length;
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var nBits = exponentLength - 7;
	  var index = bytes - 1;
	  var sign = buffer[index--];
	  var exponent = sign & 127;
	  var mantissa;
	  sign >>= 7;
	  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
	  mantissa = exponent & (1 << -nBits) - 1;
	  exponent >>= -nBits;
	  nBits += mantissaLength;
	  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
	  if (exponent === 0) {
	    exponent = 1 - eBias;
	  } else if (exponent === eMax) {
	    return mantissa ? NaN : sign ? -Infinity$1 : Infinity$1;
	  } else {
	    mantissa = mantissa + pow$3(2, mantissaLength);
	    exponent = exponent - eBias;
	  } return (sign ? -1 : 1) * mantissa * pow$3(2, exponent - mantissaLength);
	};

	var ieee754 = {
	  pack: pack,
	  unpack: unpack
	};

	var getOwnPropertyNames$2 = objectGetOwnPropertyNames.f;
	var defineProperty$c = objectDefineProperty.f;




	var getInternalState$6 = internalState.get;
	var setInternalState$8 = internalState.set;
	var ARRAY_BUFFER = 'ArrayBuffer';
	var DATA_VIEW = 'DataView';
	var PROTOTYPE$2 = 'prototype';
	var WRONG_LENGTH = 'Wrong length';
	var WRONG_INDEX = 'Wrong index';
	var NativeArrayBuffer = global_1[ARRAY_BUFFER];
	var $ArrayBuffer = NativeArrayBuffer;
	var $DataView = global_1[DATA_VIEW];
	var $DataViewPrototype = $DataView && $DataView[PROTOTYPE$2];
	var ObjectPrototype$2 = Object.prototype;
	var RangeError$1 = global_1.RangeError;

	var packIEEE754 = ieee754.pack;
	var unpackIEEE754 = ieee754.unpack;

	var packInt8 = function (number) {
	  return [number & 0xFF];
	};

	var packInt16 = function (number) {
	  return [number & 0xFF, number >> 8 & 0xFF];
	};

	var packInt32 = function (number) {
	  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
	};

	var unpackInt32 = function (buffer) {
	  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
	};

	var packFloat32 = function (number) {
	  return packIEEE754(number, 23, 4);
	};

	var packFloat64 = function (number) {
	  return packIEEE754(number, 52, 8);
	};

	var addGetter = function (Constructor, key) {
	  defineProperty$c(Constructor[PROTOTYPE$2], key, { get: function () { return getInternalState$6(this)[key]; } });
	};

	var get$3 = function (view, count, index, isLittleEndian) {
	  var intIndex = toIndex(index);
	  var store = getInternalState$6(view);
	  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
	  var bytes = getInternalState$6(store.buffer).bytes;
	  var start = intIndex + store.byteOffset;
	  var pack = bytes.slice(start, start + count);
	  return isLittleEndian ? pack : pack.reverse();
	};

	var set$4 = function (view, count, index, conversion, value, isLittleEndian) {
	  var intIndex = toIndex(index);
	  var store = getInternalState$6(view);
	  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
	  var bytes = getInternalState$6(store.buffer).bytes;
	  var start = intIndex + store.byteOffset;
	  var pack = conversion(+value);
	  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
	};

	if (!arrayBufferNative) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
	    var byteLength = toIndex(length);
	    setInternalState$8(this, {
	      bytes: arrayFill.call(new Array(byteLength), 0),
	      byteLength: byteLength
	    });
	    if (!descriptors) this.byteLength = byteLength;
	  };

	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = getInternalState$6(buffer).byteLength;
	    var offset = toInteger(byteOffset);
	    if (offset < 0 || offset > bufferLength) throw RangeError$1('Wrong offset');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if (offset + byteLength > bufferLength) throw RangeError$1(WRONG_LENGTH);
	    setInternalState$8(this, {
	      buffer: buffer,
	      byteLength: byteLength,
	      byteOffset: offset
	    });
	    if (!descriptors) {
	      this.buffer = buffer;
	      this.byteLength = byteLength;
	      this.byteOffset = offset;
	    }
	  };

	  if (descriptors) {
	    addGetter($ArrayBuffer, 'byteLength');
	    addGetter($DataView, 'buffer');
	    addGetter($DataView, 'byteLength');
	    addGetter($DataView, 'byteOffset');
	  }

	  redefineAll($DataView[PROTOTYPE$2], {
	    getInt8: function getInt8(byteOffset) {
	      return get$3(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get$3(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /* , littleEndian */) {
	      var bytes = get$3(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /* , littleEndian */) {
	      var bytes = get$3(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /* , littleEndian */) {
	      return unpackInt32(get$3(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
	    },
	    getUint32: function getUint32(byteOffset /* , littleEndian */) {
	      return unpackInt32(get$3(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get$3(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
	    },
	    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get$3(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set$4(this, 1, byteOffset, packInt8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set$4(this, 1, byteOffset, packInt8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
	      set$4(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
	      set$4(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
	      set$4(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
	      set$4(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
	      set$4(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
	      set$4(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
	    }
	  });
	} else {
	  if (!fails(function () {
	    NativeArrayBuffer(1);
	  }) || !fails(function () {
	    new NativeArrayBuffer(-1); // eslint-disable-line no-new
	  }) || fails(function () {
	    new NativeArrayBuffer(); // eslint-disable-line no-new
	    new NativeArrayBuffer(1.5); // eslint-disable-line no-new
	    new NativeArrayBuffer(NaN); // eslint-disable-line no-new
	    return NativeArrayBuffer.name != ARRAY_BUFFER;
	  })) {
	    $ArrayBuffer = function ArrayBuffer(length) {
	      anInstance(this, $ArrayBuffer);
	      return new NativeArrayBuffer(toIndex(length));
	    };
	    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE$2] = NativeArrayBuffer[PROTOTYPE$2];
	    for (var keys$4 = getOwnPropertyNames$2(NativeArrayBuffer), j$1 = 0, key$1; keys$4.length > j$1;) {
	      if (!((key$1 = keys$4[j$1++]) in $ArrayBuffer)) {
	        createNonEnumerableProperty($ArrayBuffer, key$1, NativeArrayBuffer[key$1]);
	      }
	    }
	    ArrayBufferPrototype.constructor = $ArrayBuffer;
	  }

	  // WebKit bug - the same parent prototype for typed arrays and data view
	  if (objectSetPrototypeOf && objectGetPrototypeOf($DataViewPrototype) !== ObjectPrototype$2) {
	    objectSetPrototypeOf($DataViewPrototype, ObjectPrototype$2);
	  }

	  // iOS Safari 7.x bug
	  var testView = new $DataView(new $ArrayBuffer(2));
	  var nativeSetInt8 = $DataViewPrototype.setInt8;
	  testView.setInt8(0, 2147483648);
	  testView.setInt8(1, 2147483649);
	  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
	    setInt8: function setInt8(byteOffset, value) {
	      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, { unsafe: true });
	}

	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);

	var arrayBuffer = {
	  ArrayBuffer: $ArrayBuffer,
	  DataView: $DataView
	};

	var ARRAY_BUFFER$1 = 'ArrayBuffer';
	var ArrayBuffer$1 = arrayBuffer[ARRAY_BUFFER$1];
	var NativeArrayBuffer$1 = global_1[ARRAY_BUFFER$1];

	// `ArrayBuffer` constructor
	// https://tc39.github.io/ecma262/#sec-arraybuffer-constructor
	_export({ global: true, forced: NativeArrayBuffer$1 !== ArrayBuffer$1 }, {
	  ArrayBuffer: ArrayBuffer$1
	});

	setSpecies(ARRAY_BUFFER$1);

	var defineProperty$d = objectDefineProperty.f;





	var Int8Array$1 = global_1.Int8Array;
	var Int8ArrayPrototype = Int8Array$1 && Int8Array$1.prototype;
	var Uint8ClampedArray = global_1.Uint8ClampedArray;
	var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
	var TypedArray = Int8Array$1 && objectGetPrototypeOf(Int8Array$1);
	var TypedArrayPrototype = Int8ArrayPrototype && objectGetPrototypeOf(Int8ArrayPrototype);
	var ObjectPrototype$3 = Object.prototype;
	var isPrototypeOf = ObjectPrototype$3.isPrototypeOf;

	var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
	var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
	// Fixing native typed arrays in Opera Presto crashes the browser, see #595
	var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferNative && !!objectSetPrototypeOf && classof(global_1.opera) !== 'Opera';
	var TYPED_ARRAY_TAG_REQIRED = false;
	var NAME$1;

	var TypedArrayConstructorsList = {
	  Int8Array: 1,
	  Uint8Array: 1,
	  Uint8ClampedArray: 1,
	  Int16Array: 2,
	  Uint16Array: 2,
	  Int32Array: 4,
	  Uint32Array: 4,
	  Float32Array: 4,
	  Float64Array: 8
	};

	var isView = function isView(it) {
	  var klass = classof(it);
	  return klass === 'DataView' || has(TypedArrayConstructorsList, klass);
	};

	var isTypedArray$1 = function (it) {
	  return isObject$3(it) && has(TypedArrayConstructorsList, classof(it));
	};

	var aTypedArray = function (it) {
	  if (isTypedArray$1(it)) return it;
	  throw TypeError('Target is not a typed array');
	};

	var aTypedArrayConstructor = function (C) {
	  if (objectSetPrototypeOf) {
	    if (isPrototypeOf.call(TypedArray, C)) return C;
	  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME$1)) {
	    var TypedArrayConstructor = global_1[ARRAY];
	    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
	      return C;
	    }
	  } throw TypeError('Target is not a typed array constructor');
	};

	var exportTypedArrayMethod = function (KEY, property, forced) {
	  if (!descriptors) return;
	  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
	    var TypedArrayConstructor = global_1[ARRAY];
	    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
	      delete TypedArrayConstructor.prototype[KEY];
	    }
	  }
	  if (!TypedArrayPrototype[KEY] || forced) {
	    redefine(TypedArrayPrototype, KEY, forced ? property
	      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
	  }
	};

	var exportTypedArrayStaticMethod = function (KEY, property, forced) {
	  var ARRAY, TypedArrayConstructor;
	  if (!descriptors) return;
	  if (objectSetPrototypeOf) {
	    if (forced) for (ARRAY in TypedArrayConstructorsList) {
	      TypedArrayConstructor = global_1[ARRAY];
	      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
	        delete TypedArrayConstructor[KEY];
	      }
	    }
	    if (!TypedArray[KEY] || forced) {
	      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
	      try {
	        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array$1[KEY] || property);
	      } catch (error) { /* empty */ }
	    } else return;
	  }
	  for (ARRAY in TypedArrayConstructorsList) {
	    TypedArrayConstructor = global_1[ARRAY];
	    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
	      redefine(TypedArrayConstructor, KEY, property);
	    }
	  }
	};

	for (NAME$1 in TypedArrayConstructorsList) {
	  if (!global_1[NAME$1]) NATIVE_ARRAY_BUFFER_VIEWS = false;
	}

	// WebKit bug - typed arrays constructors prototype is Object.prototype
	if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
	  // eslint-disable-next-line no-shadow
	  TypedArray = function TypedArray() {
	    throw TypeError('Incorrect invocation');
	  };
	  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME$1 in TypedArrayConstructorsList) {
	    if (global_1[NAME$1]) objectSetPrototypeOf(global_1[NAME$1], TypedArray);
	  }
	}

	if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype$3) {
	  TypedArrayPrototype = TypedArray.prototype;
	  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME$1 in TypedArrayConstructorsList) {
	    if (global_1[NAME$1]) objectSetPrototypeOf(global_1[NAME$1].prototype, TypedArrayPrototype);
	  }
	}

	// WebKit bug - one more object in Uint8ClampedArray prototype chain
	if (NATIVE_ARRAY_BUFFER_VIEWS && objectGetPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
	  objectSetPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
	}

	if (descriptors && !has(TypedArrayPrototype, TO_STRING_TAG$3)) {
	  TYPED_ARRAY_TAG_REQIRED = true;
	  defineProperty$d(TypedArrayPrototype, TO_STRING_TAG$3, { get: function () {
	    return isObject$3(this) ? this[TYPED_ARRAY_TAG] : undefined;
	  } });
	  for (NAME$1 in TypedArrayConstructorsList) if (global_1[NAME$1]) {
	    createNonEnumerableProperty(global_1[NAME$1], TYPED_ARRAY_TAG, NAME$1);
	  }
	}

	var arrayBufferViewCore = {
	  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
	  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
	  aTypedArray: aTypedArray,
	  aTypedArrayConstructor: aTypedArrayConstructor,
	  exportTypedArrayMethod: exportTypedArrayMethod,
	  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
	  isView: isView,
	  isTypedArray: isTypedArray$1,
	  TypedArray: TypedArray,
	  TypedArrayPrototype: TypedArrayPrototype
	};

	var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

	// `ArrayBuffer.isView` method
	// https://tc39.github.io/ecma262/#sec-arraybuffer.isview
	_export({ target: 'ArrayBuffer', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS$1 }, {
	  isView: arrayBufferViewCore.isView
	});

	var ArrayBuffer$2 = arrayBuffer.ArrayBuffer;
	var DataView$2 = arrayBuffer.DataView;
	var nativeArrayBufferSlice = ArrayBuffer$2.prototype.slice;

	var INCORRECT_SLICE = fails(function () {
	  return !new ArrayBuffer$2(2).slice(1, undefined).byteLength;
	});

	// `ArrayBuffer.prototype.slice` method
	// https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice
	_export({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
	  slice: function slice(start, end) {
	    if (nativeArrayBufferSlice !== undefined && end === undefined) {
	      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
	    }
	    var length = anObject(this).byteLength;
	    var first = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	    var result = new (speciesConstructor(this, ArrayBuffer$2))(toLength(fin - first));
	    var viewSource = new DataView$2(this);
	    var viewTarget = new DataView$2(result);
	    var index = 0;
	    while (first < fin) {
	      viewTarget.setUint8(index++, viewSource.getUint8(first++));
	    } return result;
	  }
	});

	// `DataView` constructor
	// https://tc39.github.io/ecma262/#sec-dataview-constructor
	_export({ global: true, forced: !arrayBufferNative }, {
	  DataView: arrayBuffer.DataView
	});

	/* eslint-disable no-new */



	var NATIVE_ARRAY_BUFFER_VIEWS$2 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

	var ArrayBuffer$3 = global_1.ArrayBuffer;
	var Int8Array$2 = global_1.Int8Array;

	var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$2 || !fails(function () {
	  Int8Array$2(1);
	}) || !fails(function () {
	  new Int8Array$2(-1);
	}) || !checkCorrectnessOfIteration(function (iterable) {
	  new Int8Array$2();
	  new Int8Array$2(null);
	  new Int8Array$2(1.5);
	  new Int8Array$2(iterable);
	}, true) || fails(function () {
	  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
	  return new Int8Array$2(new ArrayBuffer$3(2), 1, undefined).length !== 1;
	});

	var toPositiveInteger = function (it) {
	  var result = toInteger(it);
	  if (result < 0) throw RangeError("The argument can't be less than 0");
	  return result;
	};

	var toOffset = function (it, BYTES) {
	  var offset = toPositiveInteger(it);
	  if (offset % BYTES) throw RangeError('Wrong offset');
	  return offset;
	};

	var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;

	var typedArrayFrom = function from(source /* , mapfn, thisArg */) {
	  var O = toObject(source);
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  var iteratorMethod = getIteratorMethod(O);
	  var i, length, result, step, iterator, next;
	  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
	    iterator = iteratorMethod.call(O);
	    next = iterator.next;
	    O = [];
	    while (!(step = next.call(iterator)).done) {
	      O.push(step.value);
	    }
	  }
	  if (mapping && argumentsLength > 2) {
	    mapfn = functionBindContext(mapfn, arguments[2], 2);
	  }
	  length = toLength(O.length);
	  result = new (aTypedArrayConstructor$1(this))(length);
	  for (i = 0; length > i; i++) {
	    result[i] = mapping ? mapfn(O[i], i) : O[i];
	  }
	  return result;
	};

	var typedArrayConstructor = createCommonjsModule(function (module) {


















	var getOwnPropertyNames = objectGetOwnPropertyNames.f;

	var forEach = arrayIteration.forEach;






	var getInternalState = internalState.get;
	var setInternalState = internalState.set;
	var nativeDefineProperty = objectDefineProperty.f;
	var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	var round = Math.round;
	var RangeError = global_1.RangeError;
	var ArrayBuffer = arrayBuffer.ArrayBuffer;
	var DataView = arrayBuffer.DataView;
	var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
	var TYPED_ARRAY_TAG = arrayBufferViewCore.TYPED_ARRAY_TAG;
	var TypedArray = arrayBufferViewCore.TypedArray;
	var TypedArrayPrototype = arrayBufferViewCore.TypedArrayPrototype;
	var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
	var isTypedArray = arrayBufferViewCore.isTypedArray;
	var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	var WRONG_LENGTH = 'Wrong length';

	var fromList = function (C, list) {
	  var index = 0;
	  var length = list.length;
	  var result = new (aTypedArrayConstructor(C))(length);
	  while (length > index) result[index] = list[index++];
	  return result;
	};

	var addGetter = function (it, key) {
	  nativeDefineProperty(it, key, { get: function () {
	    return getInternalState(this)[key];
	  } });
	};

	var isArrayBuffer = function (it) {
	  var klass;
	  return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
	};

	var isTypedArrayIndex = function (target, key) {
	  return isTypedArray(target)
	    && typeof key != 'symbol'
	    && key in target
	    && String(+key) == String(key);
	};

	var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
	  return isTypedArrayIndex(target, key = toPrimitive(key, true))
	    ? createPropertyDescriptor(2, target[key])
	    : nativeGetOwnPropertyDescriptor(target, key);
	};

	var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
	  if (isTypedArrayIndex(target, key = toPrimitive(key, true))
	    && isObject$3(descriptor)
	    && has(descriptor, 'value')
	    && !has(descriptor, 'get')
	    && !has(descriptor, 'set')
	    // TODO: add validation descriptor w/o calling accessors
	    && !descriptor.configurable
	    && (!has(descriptor, 'writable') || descriptor.writable)
	    && (!has(descriptor, 'enumerable') || descriptor.enumerable)
	  ) {
	    target[key] = descriptor.value;
	    return target;
	  } return nativeDefineProperty(target, key, descriptor);
	};

	if (descriptors) {
	  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	    objectGetOwnPropertyDescriptor.f = wrappedGetOwnPropertyDescriptor;
	    objectDefineProperty.f = wrappedDefineProperty;
	    addGetter(TypedArrayPrototype, 'buffer');
	    addGetter(TypedArrayPrototype, 'byteOffset');
	    addGetter(TypedArrayPrototype, 'byteLength');
	    addGetter(TypedArrayPrototype, 'length');
	  }

	  _export({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
	    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
	    defineProperty: wrappedDefineProperty
	  });

	  module.exports = function (TYPE, wrapper, CLAMPED) {
	    var BYTES = TYPE.match(/\d+$/)[0] / 8;
	    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
	    var GETTER = 'get' + TYPE;
	    var SETTER = 'set' + TYPE;
	    var NativeTypedArrayConstructor = global_1[CONSTRUCTOR_NAME];
	    var TypedArrayConstructor = NativeTypedArrayConstructor;
	    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
	    var exported = {};

	    var getter = function (that, index) {
	      var data = getInternalState(that);
	      return data.view[GETTER](index * BYTES + data.byteOffset, true);
	    };

	    var setter = function (that, index, value) {
	      var data = getInternalState(that);
	      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
	      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
	    };

	    var addElement = function (that, index) {
	      nativeDefineProperty(that, index, {
	        get: function () {
	          return getter(this, index);
	        },
	        set: function (value) {
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };

	    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
	        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
	        var index = 0;
	        var byteOffset = 0;
	        var buffer, byteLength, length;
	        if (!isObject$3(data)) {
	          length = toIndex(data);
	          byteLength = length * BYTES;
	          buffer = new ArrayBuffer(byteLength);
	        } else if (isArrayBuffer(data)) {
	          buffer = data;
	          byteOffset = toOffset(offset, BYTES);
	          var $len = data.byteLength;
	          if ($length === undefined) {
	            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	            byteLength = $len - byteOffset;
	            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if (isTypedArray(data)) {
	          return fromList(TypedArrayConstructor, data);
	        } else {
	          return typedArrayFrom.call(TypedArrayConstructor, data);
	        }
	        setInternalState(that, {
	          buffer: buffer,
	          byteOffset: byteOffset,
	          byteLength: byteLength,
	          length: length,
	          view: new DataView(buffer)
	        });
	        while (index < length) addElement(that, index++);
	      });

	      if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
	      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = objectCreate$1(TypedArrayPrototype);
	    } else if (typedArrayConstructorsRequireWrappers) {
	      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
	        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
	        return inheritIfRequired(function () {
	          if (!isObject$3(data)) return new NativeTypedArrayConstructor(toIndex(data));
	          if (isArrayBuffer(data)) return $length !== undefined
	            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
	            : typedArrayOffset !== undefined
	              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
	              : new NativeTypedArrayConstructor(data);
	          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
	          return typedArrayFrom.call(TypedArrayConstructor, data);
	        }(), dummy, TypedArrayConstructor);
	      });

	      if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
	      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
	        if (!(key in TypedArrayConstructor)) {
	          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
	        }
	      });
	      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
	    }

	    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
	    }

	    if (TYPED_ARRAY_TAG) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
	    }

	    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

	    _export({
	      global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS
	    }, exported);

	    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
	      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
	    }

	    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
	    }

	    setSpecies(CONSTRUCTOR_NAME);
	  };
	} else module.exports = function () { /* empty */ };
	});

	// `Int8Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Int8', function (init) {
	  return function Int8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint8Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Uint8', function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint8ClampedArray` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Uint8', function (init) {
	  return function Uint8ClampedArray(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	}, true);

	// `Int16Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Int16', function (init) {
	  return function Int16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint16Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Uint16', function (init) {
	  return function Uint16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Int32Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Int32', function (init) {
	  return function Int32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint32Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Uint32', function (init) {
	  return function Uint32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Float32Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Float32', function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Float64Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Float64', function (init) {
	  return function Float64Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	var exportTypedArrayStaticMethod$1 = arrayBufferViewCore.exportTypedArrayStaticMethod;


	// `%TypedArray%.from` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.from
	exportTypedArrayStaticMethod$1('from', typedArrayFrom, typedArrayConstructorsRequireWrappers);

	var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayStaticMethod$2 = arrayBufferViewCore.exportTypedArrayStaticMethod;

	// `%TypedArray%.of` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.of
	exportTypedArrayStaticMethod$2('of', function of(/* ...items */) {
	  var index = 0;
	  var length = arguments.length;
	  var result = new (aTypedArrayConstructor$2(this))(length);
	  while (length > index) result[index] = arguments[index++];
	  return result;
	}, typedArrayConstructorsRequireWrappers);

	var aTypedArray$1 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$1 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.copyWithin` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin
	exportTypedArrayMethod$1('copyWithin', function copyWithin(target, start /* , end */) {
	  return arrayCopyWithin.call(aTypedArray$1(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	});

	var $every$1 = arrayIteration.every;

	var aTypedArray$2 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$2 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.every` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every
	exportTypedArrayMethod$2('every', function every(callbackfn /* , thisArg */) {
	  return $every$1(aTypedArray$2(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$3 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$3 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.fill` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
	// eslint-disable-next-line no-unused-vars
	exportTypedArrayMethod$3('fill', function fill(value /* , start, end */) {
	  return arrayFill.apply(aTypedArray$3(this), arguments);
	});

	var $filter$1 = arrayIteration.filter;


	var aTypedArray$4 = arrayBufferViewCore.aTypedArray;
	var aTypedArrayConstructor$3 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayMethod$4 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.filter` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter
	exportTypedArrayMethod$4('filter', function filter(callbackfn /* , thisArg */) {
	  var list = $filter$1(aTypedArray$4(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  var C = speciesConstructor(this, this.constructor);
	  var index = 0;
	  var length = list.length;
	  var result = new (aTypedArrayConstructor$3(C))(length);
	  while (length > index) result[index] = list[index++];
	  return result;
	});

	var $find$1 = arrayIteration.find;

	var aTypedArray$5 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$5 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.find` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find
	exportTypedArrayMethod$5('find', function find(predicate /* , thisArg */) {
	  return $find$1(aTypedArray$5(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $findIndex$1 = arrayIteration.findIndex;

	var aTypedArray$6 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$6 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.findIndex` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex
	exportTypedArrayMethod$6('findIndex', function findIndex(predicate /* , thisArg */) {
	  return $findIndex$1(aTypedArray$6(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $forEach$2 = arrayIteration.forEach;

	var aTypedArray$7 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$7 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.forEach` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach
	exportTypedArrayMethod$7('forEach', function forEach(callbackfn /* , thisArg */) {
	  $forEach$2(aTypedArray$7(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $includes$1 = arrayIncludes.includes;

	var aTypedArray$8 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$8 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes
	exportTypedArrayMethod$8('includes', function includes(searchElement /* , fromIndex */) {
	  return $includes$1(aTypedArray$8(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $indexOf$1 = arrayIncludes.indexOf;

	var aTypedArray$9 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$9 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.indexOf` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof
	exportTypedArrayMethod$9('indexOf', function indexOf(searchElement /* , fromIndex */) {
	  return $indexOf$1(aTypedArray$9(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	});

	var ITERATOR$5 = wellKnownSymbol('iterator');
	var Uint8Array$2 = global_1.Uint8Array;
	var arrayValues = es_array_iterator.values;
	var arrayKeys = es_array_iterator.keys;
	var arrayEntries = es_array_iterator.entries;
	var aTypedArray$a = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$a = arrayBufferViewCore.exportTypedArrayMethod;
	var nativeTypedArrayIterator = Uint8Array$2 && Uint8Array$2.prototype[ITERATOR$5];

	var CORRECT_ITER_NAME = !!nativeTypedArrayIterator
	  && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

	var typedArrayValues = function values() {
	  return arrayValues.call(aTypedArray$a(this));
	};

	// `%TypedArray%.prototype.entries` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries
	exportTypedArrayMethod$a('entries', function entries() {
	  return arrayEntries.call(aTypedArray$a(this));
	});
	// `%TypedArray%.prototype.keys` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys
	exportTypedArrayMethod$a('keys', function keys() {
	  return arrayKeys.call(aTypedArray$a(this));
	});
	// `%TypedArray%.prototype.values` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values
	exportTypedArrayMethod$a('values', typedArrayValues, !CORRECT_ITER_NAME);
	// `%TypedArray%.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator
	exportTypedArrayMethod$a(ITERATOR$5, typedArrayValues, !CORRECT_ITER_NAME);

	var aTypedArray$b = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$b = arrayBufferViewCore.exportTypedArrayMethod;
	var $join = [].join;

	// `%TypedArray%.prototype.join` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
	// eslint-disable-next-line no-unused-vars
	exportTypedArrayMethod$b('join', function join(separator) {
	  return $join.apply(aTypedArray$b(this), arguments);
	});

	var aTypedArray$c = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$c = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.lastIndexOf` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
	// eslint-disable-next-line no-unused-vars
	exportTypedArrayMethod$c('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
	  return arrayLastIndexOf.apply(aTypedArray$c(this), arguments);
	});

	var $map$1 = arrayIteration.map;


	var aTypedArray$d = arrayBufferViewCore.aTypedArray;
	var aTypedArrayConstructor$4 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayMethod$d = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.map` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map
	exportTypedArrayMethod$d('map', function map(mapfn /* , thisArg */) {
	  return $map$1(aTypedArray$d(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
	    return new (aTypedArrayConstructor$4(speciesConstructor(O, O.constructor)))(length);
	  });
	});

	var $reduce$1 = arrayReduce.left;

	var aTypedArray$e = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$e = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.reduce` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce
	exportTypedArrayMethod$e('reduce', function reduce(callbackfn /* , initialValue */) {
	  return $reduce$1(aTypedArray$e(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $reduceRight$1 = arrayReduce.right;

	var aTypedArray$f = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$f = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.reduceRicht` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright
	exportTypedArrayMethod$f('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
	  return $reduceRight$1(aTypedArray$f(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$g = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$g = arrayBufferViewCore.exportTypedArrayMethod;
	var floor$7 = Math.floor;

	// `%TypedArray%.prototype.reverse` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse
	exportTypedArrayMethod$g('reverse', function reverse() {
	  var that = this;
	  var length = aTypedArray$g(that).length;
	  var middle = floor$7(length / 2);
	  var index = 0;
	  var value;
	  while (index < middle) {
	    value = that[index];
	    that[index++] = that[--length];
	    that[length] = value;
	  } return that;
	});

	var aTypedArray$h = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$h = arrayBufferViewCore.exportTypedArrayMethod;

	var FORCED$h = fails(function () {
	  // eslint-disable-next-line no-undef
	  new Int8Array(1).set({});
	});

	// `%TypedArray%.prototype.set` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set
	exportTypedArrayMethod$h('set', function set(arrayLike /* , offset */) {
	  aTypedArray$h(this);
	  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
	  var length = this.length;
	  var src = toObject(arrayLike);
	  var len = toLength(src.length);
	  var index = 0;
	  if (len + offset > length) throw RangeError('Wrong length');
	  while (index < len) this[offset + index] = src[index++];
	}, FORCED$h);

	var aTypedArray$i = arrayBufferViewCore.aTypedArray;
	var aTypedArrayConstructor$5 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayMethod$i = arrayBufferViewCore.exportTypedArrayMethod;
	var $slice = [].slice;

	var FORCED$i = fails(function () {
	  // eslint-disable-next-line no-undef
	  new Int8Array(1).slice();
	});

	// `%TypedArray%.prototype.slice` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice
	exportTypedArrayMethod$i('slice', function slice(start, end) {
	  var list = $slice.call(aTypedArray$i(this), start, end);
	  var C = speciesConstructor(this, this.constructor);
	  var index = 0;
	  var length = list.length;
	  var result = new (aTypedArrayConstructor$5(C))(length);
	  while (length > index) result[index] = list[index++];
	  return result;
	}, FORCED$i);

	var $some$1 = arrayIteration.some;

	var aTypedArray$j = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$j = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.some` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some
	exportTypedArrayMethod$j('some', function some(callbackfn /* , thisArg */) {
	  return $some$1(aTypedArray$j(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$k = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$k = arrayBufferViewCore.exportTypedArrayMethod;
	var $sort = [].sort;

	// `%TypedArray%.prototype.sort` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort
	exportTypedArrayMethod$k('sort', function sort(comparefn) {
	  return $sort.call(aTypedArray$k(this), comparefn);
	});

	var aTypedArray$l = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$l = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.subarray` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray
	exportTypedArrayMethod$l('subarray', function subarray(begin, end) {
	  var O = aTypedArray$l(this);
	  var length = O.length;
	  var beginIndex = toAbsoluteIndex(begin, length);
	  return new (speciesConstructor(O, O.constructor))(
	    O.buffer,
	    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
	    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
	  );
	});

	var Int8Array$3 = global_1.Int8Array;
	var aTypedArray$m = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$m = arrayBufferViewCore.exportTypedArrayMethod;
	var $toLocaleString = [].toLocaleString;
	var $slice$1 = [].slice;

	// iOS Safari 6.x fails here
	var TO_LOCALE_STRING_BUG = !!Int8Array$3 && fails(function () {
	  $toLocaleString.call(new Int8Array$3(1));
	});

	var FORCED$j = fails(function () {
	  return [1, 2].toLocaleString() != new Int8Array$3([1, 2]).toLocaleString();
	}) || !fails(function () {
	  Int8Array$3.prototype.toLocaleString.call([1, 2]);
	});

	// `%TypedArray%.prototype.toLocaleString` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring
	exportTypedArrayMethod$m('toLocaleString', function toLocaleString() {
	  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice$1.call(aTypedArray$m(this)) : aTypedArray$m(this), arguments);
	}, FORCED$j);

	var exportTypedArrayMethod$n = arrayBufferViewCore.exportTypedArrayMethod;



	var Uint8Array$3 = global_1.Uint8Array;
	var Uint8ArrayPrototype = Uint8Array$3 && Uint8Array$3.prototype || {};
	var arrayToString = [].toString;
	var arrayJoin = [].join;

	if (fails(function () { arrayToString.call({}); })) {
	  arrayToString = function toString() {
	    return arrayJoin.call(this);
	  };
	}

	var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;

	// `%TypedArray%.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring
	exportTypedArrayMethod$n('toString', arrayToString, IS_NOT_ARRAY_METHOD);

	var nativeApply = getBuiltIn('Reflect', 'apply');
	var functionApply = Function.apply;

	// MS Edge argumentsList argument is optional
	var OPTIONAL_ARGUMENTS_LIST = !fails(function () {
	  nativeApply(function () { /* empty */ });
	});

	// `Reflect.apply` method
	// https://tc39.github.io/ecma262/#sec-reflect.apply
	_export({ target: 'Reflect', stat: true, forced: OPTIONAL_ARGUMENTS_LIST }, {
	  apply: function apply(target, thisArgument, argumentsList) {
	    aFunction$1(target);
	    anObject(argumentsList);
	    return nativeApply
	      ? nativeApply(target, thisArgument, argumentsList)
	      : functionApply.call(target, thisArgument, argumentsList);
	  }
	});

	var nativeConstruct = getBuiltIn('Reflect', 'construct');

	// `Reflect.construct` method
	// https://tc39.github.io/ecma262/#sec-reflect.construct
	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function () {
	  function F() { /* empty */ }
	  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function () {
	  nativeConstruct(function () { /* empty */ });
	});
	var FORCED$k = NEW_TARGET_BUG || ARGS_BUG;

	_export({ target: 'Reflect', stat: true, forced: FORCED$k, sham: FORCED$k }, {
	  construct: function construct(Target, args /* , newTarget */) {
	    aFunction$1(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction$1(arguments[2]);
	    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
	    if (Target == newTarget) {
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch (args.length) {
	        case 0: return new Target();
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (functionBind.apply(Target, $args))();
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto = newTarget.prototype;
	    var instance = objectCreate$1(isObject$3(proto) ? proto : Object.prototype);
	    var result = Function.apply.call(Target, instance, args);
	    return isObject$3(result) ? result : instance;
	  }
	});

	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	var ERROR_INSTEAD_OF_FALSE = fails(function () {
	  // eslint-disable-next-line no-undef
	  Reflect.defineProperty(objectDefineProperty.f({}, 1, { value: 1 }), 1, { value: 2 });
	});

	// `Reflect.defineProperty` method
	// https://tc39.github.io/ecma262/#sec-reflect.defineproperty
	_export({ target: 'Reflect', stat: true, forced: ERROR_INSTEAD_OF_FALSE, sham: !descriptors }, {
	  defineProperty: function defineProperty(target, propertyKey, attributes) {
	    anObject(target);
	    var key = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      objectDefineProperty.f(target, key, attributes);
	      return true;
	    } catch (error) {
	      return false;
	    }
	  }
	});

	var getOwnPropertyDescriptor$8 = objectGetOwnPropertyDescriptor.f;

	// `Reflect.deleteProperty` method
	// https://tc39.github.io/ecma262/#sec-reflect.deleteproperty
	_export({ target: 'Reflect', stat: true }, {
	  deleteProperty: function deleteProperty(target, propertyKey) {
	    var descriptor = getOwnPropertyDescriptor$8(anObject(target), propertyKey);
	    return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
	  }
	});

	// `Reflect.get` method
	// https://tc39.github.io/ecma262/#sec-reflect.get
	function get$4(target, propertyKey /* , receiver */) {
	  var receiver = arguments.length < 3 ? target : arguments[2];
	  var descriptor, prototype;
	  if (anObject(target) === receiver) return target[propertyKey];
	  if (descriptor = objectGetOwnPropertyDescriptor.f(target, propertyKey)) return has(descriptor, 'value')
	    ? descriptor.value
	    : descriptor.get === undefined
	      ? undefined
	      : descriptor.get.call(receiver);
	  if (isObject$3(prototype = objectGetPrototypeOf(target))) return get$4(prototype, propertyKey, receiver);
	}

	_export({ target: 'Reflect', stat: true }, {
	  get: get$4
	});

	// `Reflect.getOwnPropertyDescriptor` method
	// https://tc39.github.io/ecma262/#sec-reflect.getownpropertydescriptor
	_export({ target: 'Reflect', stat: true, sham: !descriptors }, {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	    return objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);
	  }
	});

	// `Reflect.getPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-reflect.getprototypeof
	_export({ target: 'Reflect', stat: true, sham: !correctPrototypeGetter }, {
	  getPrototypeOf: function getPrototypeOf(target) {
	    return objectGetPrototypeOf(anObject(target));
	  }
	});

	// `Reflect.has` method
	// https://tc39.github.io/ecma262/#sec-reflect.has
	_export({ target: 'Reflect', stat: true }, {
	  has: function has(target, propertyKey) {
	    return propertyKey in target;
	  }
	});

	var objectIsExtensible = Object.isExtensible;

	// `Reflect.isExtensible` method
	// https://tc39.github.io/ecma262/#sec-reflect.isextensible
	_export({ target: 'Reflect', stat: true }, {
	  isExtensible: function isExtensible(target) {
	    anObject(target);
	    return objectIsExtensible ? objectIsExtensible(target) : true;
	  }
	});

	// `Reflect.ownKeys` method
	// https://tc39.github.io/ecma262/#sec-reflect.ownkeys
	_export({ target: 'Reflect', stat: true }, {
	  ownKeys: ownKeys
	});

	// `Reflect.preventExtensions` method
	// https://tc39.github.io/ecma262/#sec-reflect.preventextensions
	_export({ target: 'Reflect', stat: true, sham: !freezing }, {
	  preventExtensions: function preventExtensions(target) {
	    anObject(target);
	    try {
	      var objectPreventExtensions = getBuiltIn('Object', 'preventExtensions');
	      if (objectPreventExtensions) objectPreventExtensions(target);
	      return true;
	    } catch (error) {
	      return false;
	    }
	  }
	});

	// `Reflect.set` method
	// https://tc39.github.io/ecma262/#sec-reflect.set
	function set$5(target, propertyKey, V /* , receiver */) {
	  var receiver = arguments.length < 4 ? target : arguments[3];
	  var ownDescriptor = objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);
	  var existingDescriptor, prototype;
	  if (!ownDescriptor) {
	    if (isObject$3(prototype = objectGetPrototypeOf(target))) {
	      return set$5(prototype, propertyKey, V, receiver);
	    }
	    ownDescriptor = createPropertyDescriptor(0);
	  }
	  if (has(ownDescriptor, 'value')) {
	    if (ownDescriptor.writable === false || !isObject$3(receiver)) return false;
	    if (existingDescriptor = objectGetOwnPropertyDescriptor.f(receiver, propertyKey)) {
	      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
	      existingDescriptor.value = V;
	      objectDefineProperty.f(receiver, propertyKey, existingDescriptor);
	    } else objectDefineProperty.f(receiver, propertyKey, createPropertyDescriptor(0, V));
	    return true;
	  }
	  return ownDescriptor.set === undefined ? false : (ownDescriptor.set.call(receiver, V), true);
	}

	// MS Edge 17-18 Reflect.set allows setting the property to object
	// with non-writable property on the prototype
	var MS_EDGE_BUG = fails(function () {
	  var object = objectDefineProperty.f({}, 'a', { configurable: true });
	  // eslint-disable-next-line no-undef
	  return Reflect.set(objectGetPrototypeOf(object), 'a', 1, object) !== false;
	});

	_export({ target: 'Reflect', stat: true, forced: MS_EDGE_BUG }, {
	  set: set$5
	});

	// `Reflect.setPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-reflect.setprototypeof
	if (objectSetPrototypeOf) _export({ target: 'Reflect', stat: true }, {
	  setPrototypeOf: function setPrototypeOf(target, proto) {
	    anObject(target);
	    aPossiblePrototype(proto);
	    try {
	      objectSetPrototypeOf(target, proto);
	      return true;
	    } catch (error) {
	      return false;
	    }
	  }
	});

	// iterable DOM collections
	// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
	var domIterables = {
	  CSSRuleList: 0,
	  CSSStyleDeclaration: 0,
	  CSSValueList: 0,
	  ClientRectList: 0,
	  DOMRectList: 0,
	  DOMStringList: 0,
	  DOMTokenList: 1,
	  DataTransferItemList: 0,
	  FileList: 0,
	  HTMLAllCollection: 0,
	  HTMLCollection: 0,
	  HTMLFormElement: 0,
	  HTMLSelectElement: 0,
	  MediaList: 0,
	  MimeTypeArray: 0,
	  NamedNodeMap: 0,
	  NodeList: 1,
	  PaintRequestList: 0,
	  Plugin: 0,
	  PluginArray: 0,
	  SVGLengthList: 0,
	  SVGNumberList: 0,
	  SVGPathSegList: 0,
	  SVGPointList: 0,
	  SVGStringList: 0,
	  SVGTransformList: 0,
	  SourceBufferList: 0,
	  StyleSheetList: 0,
	  TextTrackCueList: 0,
	  TextTrackList: 0,
	  TouchList: 0
	};

	for (var COLLECTION_NAME in domIterables) {
	  var Collection$2 = global_1[COLLECTION_NAME];
	  var CollectionPrototype = Collection$2 && Collection$2.prototype;
	  // some Chrome versions have non-configurable methods on DOMTokenList
	  if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {
	    createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach);
	  } catch (error) {
	    CollectionPrototype.forEach = arrayForEach;
	  }
	}

	var ITERATOR$6 = wellKnownSymbol('iterator');
	var TO_STRING_TAG$4 = wellKnownSymbol('toStringTag');
	var ArrayValues = es_array_iterator.values;

	for (var COLLECTION_NAME$1 in domIterables) {
	  var Collection$3 = global_1[COLLECTION_NAME$1];
	  var CollectionPrototype$1 = Collection$3 && Collection$3.prototype;
	  if (CollectionPrototype$1) {
	    // some Chrome versions have non-configurable methods on DOMTokenList
	    if (CollectionPrototype$1[ITERATOR$6] !== ArrayValues) try {
	      createNonEnumerableProperty(CollectionPrototype$1, ITERATOR$6, ArrayValues);
	    } catch (error) {
	      CollectionPrototype$1[ITERATOR$6] = ArrayValues;
	    }
	    if (!CollectionPrototype$1[TO_STRING_TAG$4]) {
	      createNonEnumerableProperty(CollectionPrototype$1, TO_STRING_TAG$4, COLLECTION_NAME$1);
	    }
	    if (domIterables[COLLECTION_NAME$1]) for (var METHOD_NAME in es_array_iterator) {
	      // some Chrome versions have non-configurable methods on DOMTokenList
	      if (CollectionPrototype$1[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
	        createNonEnumerableProperty(CollectionPrototype$1, METHOD_NAME, es_array_iterator[METHOD_NAME]);
	      } catch (error) {
	        CollectionPrototype$1[METHOD_NAME] = es_array_iterator[METHOD_NAME];
	      }
	    }
	  }
	}

	var FORCED$l = !global_1.setImmediate || !global_1.clearImmediate;

	// http://w3c.github.io/setImmediate/
	_export({ global: true, bind: true, enumerable: true, forced: FORCED$l }, {
	  // `setImmediate` method
	  // http://w3c.github.io/setImmediate/#si-setImmediate
	  setImmediate: task.set,
	  // `clearImmediate` method
	  // http://w3c.github.io/setImmediate/#si-clearImmediate
	  clearImmediate: task.clear
	});

	var process$5 = global_1.process;
	var isNode = classofRaw(process$5) == 'process';

	// `queueMicrotask` method
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-queuemicrotask
	_export({ global: true, enumerable: true, noTargetGet: true }, {
	  queueMicrotask: function queueMicrotask(fn) {
	    var domain = isNode && process$5.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});

	var slice$1 = [].slice;
	var MSIE = /MSIE .\./.test(engineUserAgent); // <- dirty ie9- check

	var wrap$2 = function (scheduler) {
	  return function (handler, timeout /* , ...arguments */) {
	    var boundArgs = arguments.length > 2;
	    var args = boundArgs ? slice$1.call(arguments, 2) : undefined;
	    return scheduler(boundArgs ? function () {
	      // eslint-disable-next-line no-new-func
	      (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);
	    } : handler, timeout);
	  };
	};

	// ie9- setTimeout & setInterval additional parameters fix
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
	_export({ global: true, bind: true, forced: MSIE }, {
	  // `setTimeout` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
	  setTimeout: wrap$2(global_1.setTimeout),
	  // `setInterval` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
	  setInterval: wrap$2(global_1.setInterval)
	});

	var ITERATOR$7 = wellKnownSymbol('iterator');

	var nativeUrl = !fails(function () {
	  var url = new URL('b?a=1&b=2&c=3', 'http://a');
	  var searchParams = url.searchParams;
	  var result = '';
	  url.pathname = 'c%20d';
	  searchParams.forEach(function (value, key) {
	    searchParams['delete']('b');
	    result += key + value;
	  });
	  return (isPure && !url.toJSON)
	    || !searchParams.sort
	    || url.href !== 'http://a/c%20d?a=1&c=3'
	    || searchParams.get('c') !== '3'
	    || String(new URLSearchParams('?a=1')) !== 'a=1'
	    || !searchParams[ITERATOR$7]
	    // throws in Edge
	    || new URL('https://a@b').username !== 'a'
	    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
	    // not punycoded in Edge
	    || new URL('http://тест').host !== 'xn--e1aybc'
	    // not escaped in Chrome 62-
	    || new URL('http://a#б').hash !== '#%D0%B1'
	    // fails in Chrome 66-
	    || result !== 'a1c3'
	    // throws in Safari
	    || new URL('http://x', undefined).host !== 'x';
	});

	// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
	var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
	var base = 36;
	var tMin = 1;
	var tMax = 26;
	var skew = 38;
	var damp = 700;
	var initialBias = 72;
	var initialN = 128; // 0x80
	var delimiter = '-'; // '\x2D'
	var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
	var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
	var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
	var baseMinusTMin = base - tMin;
	var floor$8 = Math.floor;
	var stringFromCharCode = String.fromCharCode;

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 */
	var ucs2decode = function (string) {
	  var output = [];
	  var counter = 0;
	  var length = string.length;
	  while (counter < length) {
	    var value = string.charCodeAt(counter++);
	    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
	      // It's a high surrogate, and there is a next character.
	      var extra = string.charCodeAt(counter++);
	      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
	        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
	      } else {
	        // It's an unmatched surrogate; only append this code unit, in case the
	        // next code unit is the high surrogate of a surrogate pair.
	        output.push(value);
	        counter--;
	      }
	    } else {
	      output.push(value);
	    }
	  }
	  return output;
	};

	/**
	 * Converts a digit/integer into a basic code point.
	 */
	var digitToBasic = function (digit) {
	  //  0..25 map to ASCII a..z or A..Z
	  // 26..35 map to ASCII 0..9
	  return digit + 22 + 75 * (digit < 26);
	};

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 */
	var adapt = function (delta, numPoints, firstTime) {
	  var k = 0;
	  delta = firstTime ? floor$8(delta / damp) : delta >> 1;
	  delta += floor$8(delta / numPoints);
	  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
	    delta = floor$8(delta / baseMinusTMin);
	  }
	  return floor$8(k + (baseMinusTMin + 1) * delta / (delta + skew));
	};

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 */
	// eslint-disable-next-line  max-statements
	var encode$1 = function (input) {
	  var output = [];

	  // Convert the input in UCS-2 to an array of Unicode code points.
	  input = ucs2decode(input);

	  // Cache the length.
	  var inputLength = input.length;

	  // Initialize the state.
	  var n = initialN;
	  var delta = 0;
	  var bias = initialBias;
	  var i, currentValue;

	  // Handle the basic code points.
	  for (i = 0; i < input.length; i++) {
	    currentValue = input[i];
	    if (currentValue < 0x80) {
	      output.push(stringFromCharCode(currentValue));
	    }
	  }

	  var basicLength = output.length; // number of basic code points.
	  var handledCPCount = basicLength; // number of code points that have been handled;

	  // Finish the basic string with a delimiter unless it's empty.
	  if (basicLength) {
	    output.push(delimiter);
	  }

	  // Main encoding loop:
	  while (handledCPCount < inputLength) {
	    // All non-basic code points < n have been handled already. Find the next larger one:
	    var m = maxInt;
	    for (i = 0; i < input.length; i++) {
	      currentValue = input[i];
	      if (currentValue >= n && currentValue < m) {
	        m = currentValue;
	      }
	    }

	    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
	    var handledCPCountPlusOne = handledCPCount + 1;
	    if (m - n > floor$8((maxInt - delta) / handledCPCountPlusOne)) {
	      throw RangeError(OVERFLOW_ERROR);
	    }

	    delta += (m - n) * handledCPCountPlusOne;
	    n = m;

	    for (i = 0; i < input.length; i++) {
	      currentValue = input[i];
	      if (currentValue < n && ++delta > maxInt) {
	        throw RangeError(OVERFLOW_ERROR);
	      }
	      if (currentValue == n) {
	        // Represent delta as a generalized variable-length integer.
	        var q = delta;
	        for (var k = base; /* no condition */; k += base) {
	          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	          if (q < t) break;
	          var qMinusT = q - t;
	          var baseMinusT = base - t;
	          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
	          q = floor$8(qMinusT / baseMinusT);
	        }

	        output.push(stringFromCharCode(digitToBasic(q)));
	        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
	        delta = 0;
	        ++handledCPCount;
	      }
	    }

	    ++delta;
	    ++n;
	  }
	  return output.join('');
	};

	var stringPunycodeToAscii = function (input) {
	  var encoded = [];
	  var labels = input.toLowerCase().replace(regexSeparators, '\u002E').split('.');
	  var i, label;
	  for (i = 0; i < labels.length; i++) {
	    label = labels[i];
	    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode$1(label) : label);
	  }
	  return encoded.join('.');
	};

	var getIterator = function (it) {
	  var iteratorMethod = getIteratorMethod(it);
	  if (typeof iteratorMethod != 'function') {
	    throw TypeError(String(it) + ' is not iterable');
	  } return anObject(iteratorMethod.call(it));
	};

	// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`





















	var $fetch$1 = getBuiltIn('fetch');
	var Headers = getBuiltIn('Headers');
	var ITERATOR$8 = wellKnownSymbol('iterator');
	var URL_SEARCH_PARAMS = 'URLSearchParams';
	var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
	var setInternalState$9 = internalState.set;
	var getInternalParamsState = internalState.getterFor(URL_SEARCH_PARAMS);
	var getInternalIteratorState = internalState.getterFor(URL_SEARCH_PARAMS_ITERATOR);

	var plus = /\+/g;
	var sequences = Array(4);

	var percentSequence = function (bytes) {
	  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
	};

	var percentDecode = function (sequence) {
	  try {
	    return decodeURIComponent(sequence);
	  } catch (error) {
	    return sequence;
	  }
	};

	var deserialize = function (it) {
	  var result = it.replace(plus, ' ');
	  var bytes = 4;
	  try {
	    return decodeURIComponent(result);
	  } catch (error) {
	    while (bytes) {
	      result = result.replace(percentSequence(bytes--), percentDecode);
	    }
	    return result;
	  }
	};

	var find$1 = /[!'()~]|%20/g;

	var replace = {
	  '!': '%21',
	  "'": '%27',
	  '(': '%28',
	  ')': '%29',
	  '~': '%7E',
	  '%20': '+'
	};

	var replacer = function (match) {
	  return replace[match];
	};

	var serialize = function (it) {
	  return encodeURIComponent(it).replace(find$1, replacer);
	};

	var parseSearchParams = function (result, query) {
	  if (query) {
	    var attributes = query.split('&');
	    var index = 0;
	    var attribute, entry;
	    while (index < attributes.length) {
	      attribute = attributes[index++];
	      if (attribute.length) {
	        entry = attribute.split('=');
	        result.push({
	          key: deserialize(entry.shift()),
	          value: deserialize(entry.join('='))
	        });
	      }
	    }
	  }
	};

	var updateSearchParams = function (query) {
	  this.entries.length = 0;
	  parseSearchParams(this.entries, query);
	};

	var validateArgumentsLength = function (passed, required) {
	  if (passed < required) throw TypeError('Not enough arguments');
	};

	var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
	  setInternalState$9(this, {
	    type: URL_SEARCH_PARAMS_ITERATOR,
	    iterator: getIterator(getInternalParamsState(params).entries),
	    kind: kind
	  });
	}, 'Iterator', function next() {
	  var state = getInternalIteratorState(this);
	  var kind = state.kind;
	  var step = state.iterator.next();
	  var entry = step.value;
	  if (!step.done) {
	    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
	  } return step;
	});

	// `URLSearchParams` constructor
	// https://url.spec.whatwg.org/#interface-urlsearchparams
	var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
	  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
	  var init = arguments.length > 0 ? arguments[0] : undefined;
	  var that = this;
	  var entries = [];
	  var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;

	  setInternalState$9(that, {
	    type: URL_SEARCH_PARAMS,
	    entries: entries,
	    updateURL: function () { /* empty */ },
	    updateSearchParams: updateSearchParams
	  });

	  if (init !== undefined) {
	    if (isObject$3(init)) {
	      iteratorMethod = getIteratorMethod(init);
	      if (typeof iteratorMethod === 'function') {
	        iterator = iteratorMethod.call(init);
	        next = iterator.next;
	        while (!(step = next.call(iterator)).done) {
	          entryIterator = getIterator(anObject(step.value));
	          entryNext = entryIterator.next;
	          if (
	            (first = entryNext.call(entryIterator)).done ||
	            (second = entryNext.call(entryIterator)).done ||
	            !entryNext.call(entryIterator).done
	          ) throw TypeError('Expected sequence with length 2');
	          entries.push({ key: first.value + '', value: second.value + '' });
	        }
	      } else for (key in init) if (has(init, key)) entries.push({ key: key, value: init[key] + '' });
	    } else {
	      parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');
	    }
	  }
	};

	var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;

	redefineAll(URLSearchParamsPrototype, {
	  // `URLSearchParams.prototype.appent` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
	  append: function append(name, value) {
	    validateArgumentsLength(arguments.length, 2);
	    var state = getInternalParamsState(this);
	    state.entries.push({ key: name + '', value: value + '' });
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.delete` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
	  'delete': function (name) {
	    validateArgumentsLength(arguments.length, 1);
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    var key = name + '';
	    var index = 0;
	    while (index < entries.length) {
	      if (entries[index].key === key) entries.splice(index, 1);
	      else index++;
	    }
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.get` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
	  get: function get(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = name + '';
	    var index = 0;
	    for (; index < entries.length; index++) {
	      if (entries[index].key === key) return entries[index].value;
	    }
	    return null;
	  },
	  // `URLSearchParams.prototype.getAll` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
	  getAll: function getAll(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = name + '';
	    var result = [];
	    var index = 0;
	    for (; index < entries.length; index++) {
	      if (entries[index].key === key) result.push(entries[index].value);
	    }
	    return result;
	  },
	  // `URLSearchParams.prototype.has` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
	  has: function has(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = name + '';
	    var index = 0;
	    while (index < entries.length) {
	      if (entries[index++].key === key) return true;
	    }
	    return false;
	  },
	  // `URLSearchParams.prototype.set` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
	  set: function set(name, value) {
	    validateArgumentsLength(arguments.length, 1);
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    var found = false;
	    var key = name + '';
	    var val = value + '';
	    var index = 0;
	    var entry;
	    for (; index < entries.length; index++) {
	      entry = entries[index];
	      if (entry.key === key) {
	        if (found) entries.splice(index--, 1);
	        else {
	          found = true;
	          entry.value = val;
	        }
	      }
	    }
	    if (!found) entries.push({ key: key, value: val });
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.sort` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
	  sort: function sort() {
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    // Array#sort is not stable in some engines
	    var slice = entries.slice();
	    var entry, entriesIndex, sliceIndex;
	    entries.length = 0;
	    for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
	      entry = slice[sliceIndex];
	      for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
	        if (entries[entriesIndex].key > entry.key) {
	          entries.splice(entriesIndex, 0, entry);
	          break;
	        }
	      }
	      if (entriesIndex === sliceIndex) entries.push(entry);
	    }
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.forEach` method
	  forEach: function forEach(callback /* , thisArg */) {
	    var entries = getInternalParamsState(this).entries;
	    var boundFunction = functionBindContext(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
	    var index = 0;
	    var entry;
	    while (index < entries.length) {
	      entry = entries[index++];
	      boundFunction(entry.value, entry.key, this);
	    }
	  },
	  // `URLSearchParams.prototype.keys` method
	  keys: function keys() {
	    return new URLSearchParamsIterator(this, 'keys');
	  },
	  // `URLSearchParams.prototype.values` method
	  values: function values() {
	    return new URLSearchParamsIterator(this, 'values');
	  },
	  // `URLSearchParams.prototype.entries` method
	  entries: function entries() {
	    return new URLSearchParamsIterator(this, 'entries');
	  }
	}, { enumerable: true });

	// `URLSearchParams.prototype[@@iterator]` method
	redefine(URLSearchParamsPrototype, ITERATOR$8, URLSearchParamsPrototype.entries);

	// `URLSearchParams.prototype.toString` method
	// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
	redefine(URLSearchParamsPrototype, 'toString', function toString() {
	  var entries = getInternalParamsState(this).entries;
	  var result = [];
	  var index = 0;
	  var entry;
	  while (index < entries.length) {
	    entry = entries[index++];
	    result.push(serialize(entry.key) + '=' + serialize(entry.value));
	  } return result.join('&');
	}, { enumerable: true });

	setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);

	_export({ global: true, forced: !nativeUrl }, {
	  URLSearchParams: URLSearchParamsConstructor
	});

	// Wrap `fetch` for correct work with polyfilled `URLSearchParams`
	// https://github.com/zloirock/core-js/issues/674
	if (!nativeUrl && typeof $fetch$1 == 'function' && typeof Headers == 'function') {
	  _export({ global: true, enumerable: true, forced: true }, {
	    fetch: function fetch(input /* , init */) {
	      var args = [input];
	      var init, body, headers;
	      if (arguments.length > 1) {
	        init = arguments[1];
	        if (isObject$3(init)) {
	          body = init.body;
	          if (classof(body) === URL_SEARCH_PARAMS) {
	            headers = init.headers ? new Headers(init.headers) : new Headers();
	            if (!headers.has('content-type')) {
	              headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	            }
	            init = objectCreate$1(init, {
	              body: createPropertyDescriptor(0, String(body)),
	              headers: createPropertyDescriptor(0, headers)
	            });
	          }
	        }
	        args.push(init);
	      } return $fetch$1.apply(this, args);
	    }
	  });
	}

	var web_urlSearchParams = {
	  URLSearchParams: URLSearchParamsConstructor,
	  getState: getInternalParamsState
	};

	// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`











	var codeAt$1 = stringMultibyte.codeAt;





	var NativeURL = global_1.URL;
	var URLSearchParams$1 = web_urlSearchParams.URLSearchParams;
	var getInternalSearchParamsState = web_urlSearchParams.getState;
	var setInternalState$a = internalState.set;
	var getInternalURLState = internalState.getterFor('URL');
	var floor$9 = Math.floor;
	var pow$4 = Math.pow;

	var INVALID_AUTHORITY = 'Invalid authority';
	var INVALID_SCHEME = 'Invalid scheme';
	var INVALID_HOST = 'Invalid host';
	var INVALID_PORT = 'Invalid port';

	var ALPHA = /[A-Za-z]/;
	var ALPHANUMERIC = /[\d+-.A-Za-z]/;
	var DIGIT = /\d/;
	var HEX_START = /^(0x|0X)/;
	var OCT = /^[0-7]+$/;
	var DEC = /^\d+$/;
	var HEX = /^[\dA-Fa-f]+$/;
	// eslint-disable-next-line no-control-regex
	var FORBIDDEN_HOST_CODE_POINT = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/;
	// eslint-disable-next-line no-control-regex
	var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/;
	// eslint-disable-next-line no-control-regex
	var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
	// eslint-disable-next-line no-control-regex
	var TAB_AND_NEW_LINE = /[\u0009\u000A\u000D]/g;
	var EOF;

	var parseHost = function (url, input) {
	  var result, codePoints, index;
	  if (input.charAt(0) == '[') {
	    if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
	    result = parseIPv6(input.slice(1, -1));
	    if (!result) return INVALID_HOST;
	    url.host = result;
	  // opaque host
	  } else if (!isSpecial(url)) {
	    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
	    result = '';
	    codePoints = arrayFrom(input);
	    for (index = 0; index < codePoints.length; index++) {
	      result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
	    }
	    url.host = result;
	  } else {
	    input = stringPunycodeToAscii(input);
	    if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
	    result = parseIPv4(input);
	    if (result === null) return INVALID_HOST;
	    url.host = result;
	  }
	};

	var parseIPv4 = function (input) {
	  var parts = input.split('.');
	  var partsLength, numbers, index, part, radix, number, ipv4;
	  if (parts.length && parts[parts.length - 1] == '') {
	    parts.pop();
	  }
	  partsLength = parts.length;
	  if (partsLength > 4) return input;
	  numbers = [];
	  for (index = 0; index < partsLength; index++) {
	    part = parts[index];
	    if (part == '') return input;
	    radix = 10;
	    if (part.length > 1 && part.charAt(0) == '0') {
	      radix = HEX_START.test(part) ? 16 : 8;
	      part = part.slice(radix == 8 ? 1 : 2);
	    }
	    if (part === '') {
	      number = 0;
	    } else {
	      if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;
	      number = parseInt(part, radix);
	    }
	    numbers.push(number);
	  }
	  for (index = 0; index < partsLength; index++) {
	    number = numbers[index];
	    if (index == partsLength - 1) {
	      if (number >= pow$4(256, 5 - partsLength)) return null;
	    } else if (number > 255) return null;
	  }
	  ipv4 = numbers.pop();
	  for (index = 0; index < numbers.length; index++) {
	    ipv4 += numbers[index] * pow$4(256, 3 - index);
	  }
	  return ipv4;
	};

	// eslint-disable-next-line max-statements
	var parseIPv6 = function (input) {
	  var address = [0, 0, 0, 0, 0, 0, 0, 0];
	  var pieceIndex = 0;
	  var compress = null;
	  var pointer = 0;
	  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

	  var char = function () {
	    return input.charAt(pointer);
	  };

	  if (char() == ':') {
	    if (input.charAt(1) != ':') return;
	    pointer += 2;
	    pieceIndex++;
	    compress = pieceIndex;
	  }
	  while (char()) {
	    if (pieceIndex == 8) return;
	    if (char() == ':') {
	      if (compress !== null) return;
	      pointer++;
	      pieceIndex++;
	      compress = pieceIndex;
	      continue;
	    }
	    value = length = 0;
	    while (length < 4 && HEX.test(char())) {
	      value = value * 16 + parseInt(char(), 16);
	      pointer++;
	      length++;
	    }
	    if (char() == '.') {
	      if (length == 0) return;
	      pointer -= length;
	      if (pieceIndex > 6) return;
	      numbersSeen = 0;
	      while (char()) {
	        ipv4Piece = null;
	        if (numbersSeen > 0) {
	          if (char() == '.' && numbersSeen < 4) pointer++;
	          else return;
	        }
	        if (!DIGIT.test(char())) return;
	        while (DIGIT.test(char())) {
	          number = parseInt(char(), 10);
	          if (ipv4Piece === null) ipv4Piece = number;
	          else if (ipv4Piece == 0) return;
	          else ipv4Piece = ipv4Piece * 10 + number;
	          if (ipv4Piece > 255) return;
	          pointer++;
	        }
	        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
	        numbersSeen++;
	        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
	      }
	      if (numbersSeen != 4) return;
	      break;
	    } else if (char() == ':') {
	      pointer++;
	      if (!char()) return;
	    } else if (char()) return;
	    address[pieceIndex++] = value;
	  }
	  if (compress !== null) {
	    swaps = pieceIndex - compress;
	    pieceIndex = 7;
	    while (pieceIndex != 0 && swaps > 0) {
	      swap = address[pieceIndex];
	      address[pieceIndex--] = address[compress + swaps - 1];
	      address[compress + --swaps] = swap;
	    }
	  } else if (pieceIndex != 8) return;
	  return address;
	};

	var findLongestZeroSequence = function (ipv6) {
	  var maxIndex = null;
	  var maxLength = 1;
	  var currStart = null;
	  var currLength = 0;
	  var index = 0;
	  for (; index < 8; index++) {
	    if (ipv6[index] !== 0) {
	      if (currLength > maxLength) {
	        maxIndex = currStart;
	        maxLength = currLength;
	      }
	      currStart = null;
	      currLength = 0;
	    } else {
	      if (currStart === null) currStart = index;
	      ++currLength;
	    }
	  }
	  if (currLength > maxLength) {
	    maxIndex = currStart;
	    maxLength = currLength;
	  }
	  return maxIndex;
	};

	var serializeHost = function (host) {
	  var result, index, compress, ignore0;
	  // ipv4
	  if (typeof host == 'number') {
	    result = [];
	    for (index = 0; index < 4; index++) {
	      result.unshift(host % 256);
	      host = floor$9(host / 256);
	    } return result.join('.');
	  // ipv6
	  } else if (typeof host == 'object') {
	    result = '';
	    compress = findLongestZeroSequence(host);
	    for (index = 0; index < 8; index++) {
	      if (ignore0 && host[index] === 0) continue;
	      if (ignore0) ignore0 = false;
	      if (compress === index) {
	        result += index ? ':' : '::';
	        ignore0 = true;
	      } else {
	        result += host[index].toString(16);
	        if (index < 7) result += ':';
	      }
	    }
	    return '[' + result + ']';
	  } return host;
	};

	var C0ControlPercentEncodeSet = {};
	var fragmentPercentEncodeSet = objectAssign({}, C0ControlPercentEncodeSet, {
	  ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1
	});
	var pathPercentEncodeSet = objectAssign({}, fragmentPercentEncodeSet, {
	  '#': 1, '?': 1, '{': 1, '}': 1
	});
	var userinfoPercentEncodeSet = objectAssign({}, pathPercentEncodeSet, {
	  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1
	});

	var percentEncode = function (char, set) {
	  var code = codeAt$1(char, 0);
	  return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);
	};

	var specialSchemes = {
	  ftp: 21,
	  file: null,
	  http: 80,
	  https: 443,
	  ws: 80,
	  wss: 443
	};

	var isSpecial = function (url) {
	  return has(specialSchemes, url.scheme);
	};

	var includesCredentials = function (url) {
	  return url.username != '' || url.password != '';
	};

	var cannotHaveUsernamePasswordPort = function (url) {
	  return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
	};

	var isWindowsDriveLetter = function (string, normalized) {
	  var second;
	  return string.length == 2 && ALPHA.test(string.charAt(0))
	    && ((second = string.charAt(1)) == ':' || (!normalized && second == '|'));
	};

	var startsWithWindowsDriveLetter = function (string) {
	  var third;
	  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (
	    string.length == 2 ||
	    ((third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#')
	  );
	};

	var shortenURLsPath = function (url) {
	  var path = url.path;
	  var pathSize = path.length;
	  if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
	    path.pop();
	  }
	};

	var isSingleDot = function (segment) {
	  return segment === '.' || segment.toLowerCase() === '%2e';
	};

	var isDoubleDot = function (segment) {
	  segment = segment.toLowerCase();
	  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
	};

	// States:
	var SCHEME_START = {};
	var SCHEME = {};
	var NO_SCHEME = {};
	var SPECIAL_RELATIVE_OR_AUTHORITY = {};
	var PATH_OR_AUTHORITY = {};
	var RELATIVE = {};
	var RELATIVE_SLASH = {};
	var SPECIAL_AUTHORITY_SLASHES = {};
	var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
	var AUTHORITY = {};
	var HOST = {};
	var HOSTNAME = {};
	var PORT = {};
	var FILE = {};
	var FILE_SLASH = {};
	var FILE_HOST = {};
	var PATH_START = {};
	var PATH = {};
	var CANNOT_BE_A_BASE_URL_PATH = {};
	var QUERY = {};
	var FRAGMENT = {};

	// eslint-disable-next-line max-statements
	var parseURL = function (url, input, stateOverride, base) {
	  var state = stateOverride || SCHEME_START;
	  var pointer = 0;
	  var buffer = '';
	  var seenAt = false;
	  var seenBracket = false;
	  var seenPasswordToken = false;
	  var codePoints, char, bufferCodePoints, failure;

	  if (!stateOverride) {
	    url.scheme = '';
	    url.username = '';
	    url.password = '';
	    url.host = null;
	    url.port = null;
	    url.path = [];
	    url.query = null;
	    url.fragment = null;
	    url.cannotBeABaseURL = false;
	    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
	  }

	  input = input.replace(TAB_AND_NEW_LINE, '');

	  codePoints = arrayFrom(input);

	  while (pointer <= codePoints.length) {
	    char = codePoints[pointer];
	    switch (state) {
	      case SCHEME_START:
	        if (char && ALPHA.test(char)) {
	          buffer += char.toLowerCase();
	          state = SCHEME;
	        } else if (!stateOverride) {
	          state = NO_SCHEME;
	          continue;
	        } else return INVALID_SCHEME;
	        break;

	      case SCHEME:
	        if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {
	          buffer += char.toLowerCase();
	        } else if (char == ':') {
	          if (stateOverride && (
	            (isSpecial(url) != has(specialSchemes, buffer)) ||
	            (buffer == 'file' && (includesCredentials(url) || url.port !== null)) ||
	            (url.scheme == 'file' && !url.host)
	          )) return;
	          url.scheme = buffer;
	          if (stateOverride) {
	            if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
	            return;
	          }
	          buffer = '';
	          if (url.scheme == 'file') {
	            state = FILE;
	          } else if (isSpecial(url) && base && base.scheme == url.scheme) {
	            state = SPECIAL_RELATIVE_OR_AUTHORITY;
	          } else if (isSpecial(url)) {
	            state = SPECIAL_AUTHORITY_SLASHES;
	          } else if (codePoints[pointer + 1] == '/') {
	            state = PATH_OR_AUTHORITY;
	            pointer++;
	          } else {
	            url.cannotBeABaseURL = true;
	            url.path.push('');
	            state = CANNOT_BE_A_BASE_URL_PATH;
	          }
	        } else if (!stateOverride) {
	          buffer = '';
	          state = NO_SCHEME;
	          pointer = 0;
	          continue;
	        } else return INVALID_SCHEME;
	        break;

	      case NO_SCHEME:
	        if (!base || (base.cannotBeABaseURL && char != '#')) return INVALID_SCHEME;
	        if (base.cannotBeABaseURL && char == '#') {
	          url.scheme = base.scheme;
	          url.path = base.path.slice();
	          url.query = base.query;
	          url.fragment = '';
	          url.cannotBeABaseURL = true;
	          state = FRAGMENT;
	          break;
	        }
	        state = base.scheme == 'file' ? FILE : RELATIVE;
	        continue;

	      case SPECIAL_RELATIVE_OR_AUTHORITY:
	        if (char == '/' && codePoints[pointer + 1] == '/') {
	          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	          pointer++;
	        } else {
	          state = RELATIVE;
	          continue;
	        } break;

	      case PATH_OR_AUTHORITY:
	        if (char == '/') {
	          state = AUTHORITY;
	          break;
	        } else {
	          state = PATH;
	          continue;
	        }

	      case RELATIVE:
	        url.scheme = base.scheme;
	        if (char == EOF) {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.query = base.query;
	        } else if (char == '/' || (char == '\\' && isSpecial(url))) {
	          state = RELATIVE_SLASH;
	        } else if (char == '?') {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.query = '';
	          state = QUERY;
	        } else if (char == '#') {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.query = base.query;
	          url.fragment = '';
	          state = FRAGMENT;
	        } else {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.path.pop();
	          state = PATH;
	          continue;
	        } break;

	      case RELATIVE_SLASH:
	        if (isSpecial(url) && (char == '/' || char == '\\')) {
	          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	        } else if (char == '/') {
	          state = AUTHORITY;
	        } else {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          state = PATH;
	          continue;
	        } break;

	      case SPECIAL_AUTHORITY_SLASHES:
	        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	        if (char != '/' || buffer.charAt(pointer + 1) != '/') continue;
	        pointer++;
	        break;

	      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
	        if (char != '/' && char != '\\') {
	          state = AUTHORITY;
	          continue;
	        } break;

	      case AUTHORITY:
	        if (char == '@') {
	          if (seenAt) buffer = '%40' + buffer;
	          seenAt = true;
	          bufferCodePoints = arrayFrom(buffer);
	          for (var i = 0; i < bufferCodePoints.length; i++) {
	            var codePoint = bufferCodePoints[i];
	            if (codePoint == ':' && !seenPasswordToken) {
	              seenPasswordToken = true;
	              continue;
	            }
	            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
	            if (seenPasswordToken) url.password += encodedCodePoints;
	            else url.username += encodedCodePoints;
	          }
	          buffer = '';
	        } else if (
	          char == EOF || char == '/' || char == '?' || char == '#' ||
	          (char == '\\' && isSpecial(url))
	        ) {
	          if (seenAt && buffer == '') return INVALID_AUTHORITY;
	          pointer -= arrayFrom(buffer).length + 1;
	          buffer = '';
	          state = HOST;
	        } else buffer += char;
	        break;

	      case HOST:
	      case HOSTNAME:
	        if (stateOverride && url.scheme == 'file') {
	          state = FILE_HOST;
	          continue;
	        } else if (char == ':' && !seenBracket) {
	          if (buffer == '') return INVALID_HOST;
	          failure = parseHost(url, buffer);
	          if (failure) return failure;
	          buffer = '';
	          state = PORT;
	          if (stateOverride == HOSTNAME) return;
	        } else if (
	          char == EOF || char == '/' || char == '?' || char == '#' ||
	          (char == '\\' && isSpecial(url))
	        ) {
	          if (isSpecial(url) && buffer == '') return INVALID_HOST;
	          if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
	          failure = parseHost(url, buffer);
	          if (failure) return failure;
	          buffer = '';
	          state = PATH_START;
	          if (stateOverride) return;
	          continue;
	        } else {
	          if (char == '[') seenBracket = true;
	          else if (char == ']') seenBracket = false;
	          buffer += char;
	        } break;

	      case PORT:
	        if (DIGIT.test(char)) {
	          buffer += char;
	        } else if (
	          char == EOF || char == '/' || char == '?' || char == '#' ||
	          (char == '\\' && isSpecial(url)) ||
	          stateOverride
	        ) {
	          if (buffer != '') {
	            var port = parseInt(buffer, 10);
	            if (port > 0xFFFF) return INVALID_PORT;
	            url.port = (isSpecial(url) && port === specialSchemes[url.scheme]) ? null : port;
	            buffer = '';
	          }
	          if (stateOverride) return;
	          state = PATH_START;
	          continue;
	        } else return INVALID_PORT;
	        break;

	      case FILE:
	        url.scheme = 'file';
	        if (char == '/' || char == '\\') state = FILE_SLASH;
	        else if (base && base.scheme == 'file') {
	          if (char == EOF) {
	            url.host = base.host;
	            url.path = base.path.slice();
	            url.query = base.query;
	          } else if (char == '?') {
	            url.host = base.host;
	            url.path = base.path.slice();
	            url.query = '';
	            state = QUERY;
	          } else if (char == '#') {
	            url.host = base.host;
	            url.path = base.path.slice();
	            url.query = base.query;
	            url.fragment = '';
	            state = FRAGMENT;
	          } else {
	            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
	              url.host = base.host;
	              url.path = base.path.slice();
	              shortenURLsPath(url);
	            }
	            state = PATH;
	            continue;
	          }
	        } else {
	          state = PATH;
	          continue;
	        } break;

	      case FILE_SLASH:
	        if (char == '/' || char == '\\') {
	          state = FILE_HOST;
	          break;
	        }
	        if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
	          if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);
	          else url.host = base.host;
	        }
	        state = PATH;
	        continue;

	      case FILE_HOST:
	        if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') {
	          if (!stateOverride && isWindowsDriveLetter(buffer)) {
	            state = PATH;
	          } else if (buffer == '') {
	            url.host = '';
	            if (stateOverride) return;
	            state = PATH_START;
	          } else {
	            failure = parseHost(url, buffer);
	            if (failure) return failure;
	            if (url.host == 'localhost') url.host = '';
	            if (stateOverride) return;
	            buffer = '';
	            state = PATH_START;
	          } continue;
	        } else buffer += char;
	        break;

	      case PATH_START:
	        if (isSpecial(url)) {
	          state = PATH;
	          if (char != '/' && char != '\\') continue;
	        } else if (!stateOverride && char == '?') {
	          url.query = '';
	          state = QUERY;
	        } else if (!stateOverride && char == '#') {
	          url.fragment = '';
	          state = FRAGMENT;
	        } else if (char != EOF) {
	          state = PATH;
	          if (char != '/') continue;
	        } break;

	      case PATH:
	        if (
	          char == EOF || char == '/' ||
	          (char == '\\' && isSpecial(url)) ||
	          (!stateOverride && (char == '?' || char == '#'))
	        ) {
	          if (isDoubleDot(buffer)) {
	            shortenURLsPath(url);
	            if (char != '/' && !(char == '\\' && isSpecial(url))) {
	              url.path.push('');
	            }
	          } else if (isSingleDot(buffer)) {
	            if (char != '/' && !(char == '\\' && isSpecial(url))) {
	              url.path.push('');
	            }
	          } else {
	            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
	              if (url.host) url.host = '';
	              buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
	            }
	            url.path.push(buffer);
	          }
	          buffer = '';
	          if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {
	            while (url.path.length > 1 && url.path[0] === '') {
	              url.path.shift();
	            }
	          }
	          if (char == '?') {
	            url.query = '';
	            state = QUERY;
	          } else if (char == '#') {
	            url.fragment = '';
	            state = FRAGMENT;
	          }
	        } else {
	          buffer += percentEncode(char, pathPercentEncodeSet);
	        } break;

	      case CANNOT_BE_A_BASE_URL_PATH:
	        if (char == '?') {
	          url.query = '';
	          state = QUERY;
	        } else if (char == '#') {
	          url.fragment = '';
	          state = FRAGMENT;
	        } else if (char != EOF) {
	          url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
	        } break;

	      case QUERY:
	        if (!stateOverride && char == '#') {
	          url.fragment = '';
	          state = FRAGMENT;
	        } else if (char != EOF) {
	          if (char == "'" && isSpecial(url)) url.query += '%27';
	          else if (char == '#') url.query += '%23';
	          else url.query += percentEncode(char, C0ControlPercentEncodeSet);
	        } break;

	      case FRAGMENT:
	        if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);
	        break;
	    }

	    pointer++;
	  }
	};

	// `URL` constructor
	// https://url.spec.whatwg.org/#url-class
	var URLConstructor = function URL(url /* , base */) {
	  var that = anInstance(this, URLConstructor, 'URL');
	  var base = arguments.length > 1 ? arguments[1] : undefined;
	  var urlString = String(url);
	  var state = setInternalState$a(that, { type: 'URL' });
	  var baseState, failure;
	  if (base !== undefined) {
	    if (base instanceof URLConstructor) baseState = getInternalURLState(base);
	    else {
	      failure = parseURL(baseState = {}, String(base));
	      if (failure) throw TypeError(failure);
	    }
	  }
	  failure = parseURL(state, urlString, null, baseState);
	  if (failure) throw TypeError(failure);
	  var searchParams = state.searchParams = new URLSearchParams$1();
	  var searchParamsState = getInternalSearchParamsState(searchParams);
	  searchParamsState.updateSearchParams(state.query);
	  searchParamsState.updateURL = function () {
	    state.query = String(searchParams) || null;
	  };
	  if (!descriptors) {
	    that.href = serializeURL.call(that);
	    that.origin = getOrigin.call(that);
	    that.protocol = getProtocol.call(that);
	    that.username = getUsername.call(that);
	    that.password = getPassword.call(that);
	    that.host = getHost.call(that);
	    that.hostname = getHostname.call(that);
	    that.port = getPort.call(that);
	    that.pathname = getPathname.call(that);
	    that.search = getSearch.call(that);
	    that.searchParams = getSearchParams.call(that);
	    that.hash = getHash.call(that);
	  }
	};

	var URLPrototype = URLConstructor.prototype;

	var serializeURL = function () {
	  var url = getInternalURLState(this);
	  var scheme = url.scheme;
	  var username = url.username;
	  var password = url.password;
	  var host = url.host;
	  var port = url.port;
	  var path = url.path;
	  var query = url.query;
	  var fragment = url.fragment;
	  var output = scheme + ':';
	  if (host !== null) {
	    output += '//';
	    if (includesCredentials(url)) {
	      output += username + (password ? ':' + password : '') + '@';
	    }
	    output += serializeHost(host);
	    if (port !== null) output += ':' + port;
	  } else if (scheme == 'file') output += '//';
	  output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
	  if (query !== null) output += '?' + query;
	  if (fragment !== null) output += '#' + fragment;
	  return output;
	};

	var getOrigin = function () {
	  var url = getInternalURLState(this);
	  var scheme = url.scheme;
	  var port = url.port;
	  if (scheme == 'blob') try {
	    return new URL(scheme.path[0]).origin;
	  } catch (error) {
	    return 'null';
	  }
	  if (scheme == 'file' || !isSpecial(url)) return 'null';
	  return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
	};

	var getProtocol = function () {
	  return getInternalURLState(this).scheme + ':';
	};

	var getUsername = function () {
	  return getInternalURLState(this).username;
	};

	var getPassword = function () {
	  return getInternalURLState(this).password;
	};

	var getHost = function () {
	  var url = getInternalURLState(this);
	  var host = url.host;
	  var port = url.port;
	  return host === null ? ''
	    : port === null ? serializeHost(host)
	    : serializeHost(host) + ':' + port;
	};

	var getHostname = function () {
	  var host = getInternalURLState(this).host;
	  return host === null ? '' : serializeHost(host);
	};

	var getPort = function () {
	  var port = getInternalURLState(this).port;
	  return port === null ? '' : String(port);
	};

	var getPathname = function () {
	  var url = getInternalURLState(this);
	  var path = url.path;
	  return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
	};

	var getSearch = function () {
	  var query = getInternalURLState(this).query;
	  return query ? '?' + query : '';
	};

	var getSearchParams = function () {
	  return getInternalURLState(this).searchParams;
	};

	var getHash = function () {
	  var fragment = getInternalURLState(this).fragment;
	  return fragment ? '#' + fragment : '';
	};

	var accessorDescriptor = function (getter, setter) {
	  return { get: getter, set: setter, configurable: true, enumerable: true };
	};

	if (descriptors) {
	  objectDefineProperties(URLPrototype, {
	    // `URL.prototype.href` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-href
	    href: accessorDescriptor(serializeURL, function (href) {
	      var url = getInternalURLState(this);
	      var urlString = String(href);
	      var failure = parseURL(url, urlString);
	      if (failure) throw TypeError(failure);
	      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
	    }),
	    // `URL.prototype.origin` getter
	    // https://url.spec.whatwg.org/#dom-url-origin
	    origin: accessorDescriptor(getOrigin),
	    // `URL.prototype.protocol` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-protocol
	    protocol: accessorDescriptor(getProtocol, function (protocol) {
	      var url = getInternalURLState(this);
	      parseURL(url, String(protocol) + ':', SCHEME_START);
	    }),
	    // `URL.prototype.username` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-username
	    username: accessorDescriptor(getUsername, function (username) {
	      var url = getInternalURLState(this);
	      var codePoints = arrayFrom(String(username));
	      if (cannotHaveUsernamePasswordPort(url)) return;
	      url.username = '';
	      for (var i = 0; i < codePoints.length; i++) {
	        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
	      }
	    }),
	    // `URL.prototype.password` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-password
	    password: accessorDescriptor(getPassword, function (password) {
	      var url = getInternalURLState(this);
	      var codePoints = arrayFrom(String(password));
	      if (cannotHaveUsernamePasswordPort(url)) return;
	      url.password = '';
	      for (var i = 0; i < codePoints.length; i++) {
	        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
	      }
	    }),
	    // `URL.prototype.host` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-host
	    host: accessorDescriptor(getHost, function (host) {
	      var url = getInternalURLState(this);
	      if (url.cannotBeABaseURL) return;
	      parseURL(url, String(host), HOST);
	    }),
	    // `URL.prototype.hostname` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-hostname
	    hostname: accessorDescriptor(getHostname, function (hostname) {
	      var url = getInternalURLState(this);
	      if (url.cannotBeABaseURL) return;
	      parseURL(url, String(hostname), HOSTNAME);
	    }),
	    // `URL.prototype.port` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-port
	    port: accessorDescriptor(getPort, function (port) {
	      var url = getInternalURLState(this);
	      if (cannotHaveUsernamePasswordPort(url)) return;
	      port = String(port);
	      if (port == '') url.port = null;
	      else parseURL(url, port, PORT);
	    }),
	    // `URL.prototype.pathname` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-pathname
	    pathname: accessorDescriptor(getPathname, function (pathname) {
	      var url = getInternalURLState(this);
	      if (url.cannotBeABaseURL) return;
	      url.path = [];
	      parseURL(url, pathname + '', PATH_START);
	    }),
	    // `URL.prototype.search` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-search
	    search: accessorDescriptor(getSearch, function (search) {
	      var url = getInternalURLState(this);
	      search = String(search);
	      if (search == '') {
	        url.query = null;
	      } else {
	        if ('?' == search.charAt(0)) search = search.slice(1);
	        url.query = '';
	        parseURL(url, search, QUERY);
	      }
	      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
	    }),
	    // `URL.prototype.searchParams` getter
	    // https://url.spec.whatwg.org/#dom-url-searchparams
	    searchParams: accessorDescriptor(getSearchParams),
	    // `URL.prototype.hash` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-hash
	    hash: accessorDescriptor(getHash, function (hash) {
	      var url = getInternalURLState(this);
	      hash = String(hash);
	      if (hash == '') {
	        url.fragment = null;
	        return;
	      }
	      if ('#' == hash.charAt(0)) hash = hash.slice(1);
	      url.fragment = '';
	      parseURL(url, hash, FRAGMENT);
	    })
	  });
	}

	// `URL.prototype.toJSON` method
	// https://url.spec.whatwg.org/#dom-url-tojson
	redefine(URLPrototype, 'toJSON', function toJSON() {
	  return serializeURL.call(this);
	}, { enumerable: true });

	// `URL.prototype.toString` method
	// https://url.spec.whatwg.org/#URL-stringification-behavior
	redefine(URLPrototype, 'toString', function toString() {
	  return serializeURL.call(this);
	}, { enumerable: true });

	if (NativeURL) {
	  var nativeCreateObjectURL = NativeURL.createObjectURL;
	  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
	  // `URL.createObjectURL` method
	  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
	  // eslint-disable-next-line no-unused-vars
	  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
	    return nativeCreateObjectURL.apply(NativeURL, arguments);
	  });
	  // `URL.revokeObjectURL` method
	  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
	  // eslint-disable-next-line no-unused-vars
	  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
	    return nativeRevokeObjectURL.apply(NativeURL, arguments);
	  });
	}

	setToStringTag(URLConstructor, 'URL');

	_export({ global: true, forced: !nativeUrl, sham: !descriptors }, {
	  URL: URLConstructor
	});

	// `URL.prototype.toJSON` method
	// https://url.spec.whatwg.org/#dom-url-tojson
	_export({ target: 'URL', proto: true, enumerable: true }, {
	  toJSON: function toJSON() {
	    return URL.prototype.toString.call(this);
	  }
	});

	var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global$1 !== 'undefined' ? global$1 : typeof self !== 'undefined' ? self : {};

	function commonjsRequire$1 () {
		throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
	}

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule$1(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var runtime_1$1 = createCommonjsModule$1(function (module) {
	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var runtime = (function (exports) {

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined$1; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  exports.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };

	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }

	  exports.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  exports.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  exports.awrap = function(arg) {
	    return { __await: arg };
	  };

	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration.
	          result.value = unwrapped;
	          resolve(result);
	        }, function(error) {
	          // If a rejected Promise was yielded, throw the rejection back
	          // into the async generator function so it can be handled there.
	          return invoke("throw", error, resolve, reject);
	        });
	      }
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	    return this;
	  };
	  exports.AsyncIterator = AsyncIterator;

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  exports.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );

	    return exports.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;

	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);

	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined$1) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;

	      if (context.method === "throw") {
	        // Note: ["return"] must be used for ES3 parsing compatibility.
	        if (delegate.iterator["return"]) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined$1;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;

	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;

	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined$1;
	      }

	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }

	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  Gp[toStringTagSymbol] = "Generator";

	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  exports.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined$1;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  exports.values = values;

	  function doneResult() {
	    return { value: undefined$1, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined$1;
	      this.done = false;
	      this.delegate = null;

	      this.method = "next";
	      this.arg = undefined$1;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined$1;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined$1;
	        }

	        return !! caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined$1;
	      }

	      return ContinueSentinel;
	    }
	  };

	  // Regardless of whether this script is executing as a CommonJS module
	  // or not, return the runtime object so that we can declare the variable
	  // regeneratorRuntime in the outer scope, which allows this module to be
	  // injected easily by `bin/regenerator --include-runtime script.js`.
	  return exports;

	}(
	  // If this script is executing as a CommonJS module, use module.exports
	  // as the regeneratorRuntime namespace. Otherwise create a new empty
	  // object. Either way, the resulting object will be used to initialize
	  // the regeneratorRuntime variable at the top of this file.
	   module.exports 
	));

	try {
	  regeneratorRuntime = runtime;
	} catch (accidentalStrictMode) {
	  // This module should not be running in strict mode, so the above
	  // assignment should always work unless something is misconfigured. Just
	  // in case runtime.js accidentally runs in strict mode, we can escape
	  // strict mode using a global Function call. This could conceivably fail
	  // if a Content Security Policy forbids using Function, but in that case
	  // the proper solution is to fix the accidental strict mode problem. If
	  // you've misconfigured your bundler to force strict mode and applied a
	  // CSP to forbid Function, and you're not willing to fix either of those
	  // problems, please detail your unique predicament in a GitHub issue.
	  Function("r", "regeneratorRuntime = r")(runtime);
	}
	});

	var regenerator$1 = runtime_1$1;

	function asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }

	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}

	function _asyncToGenerator$1(fn) {
	  return function () {
	    var self = this,
	        args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);

	      function _next(value) {
	        asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "next", value);
	      }

	      function _throw(err) {
	        asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "throw", err);
	      }

	      _next(undefined);
	    });
	  };
	}

	var asyncToGenerator$1 = _asyncToGenerator$1;

	function _classCallCheck$1(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	var classCallCheck$1 = _classCallCheck$1;

	function _defineProperties$1(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass$1(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties$1(Constructor, staticProps);
	  return Constructor;
	}

	var createClass$1 = _createClass$1;

	function _defineProperty$2(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	var defineProperty$e = _defineProperty$2;

	var bind$2 = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};

	/*!
	 * Determine if an object is a Buffer
	 *
	 * @author   Feross Aboukhadijeh <https://feross.org>
	 * @license  MIT
	 */

	var isBuffer$2 = function isBuffer (obj) {
	  return obj != null && obj.constructor != null &&
	    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	};

	/*global toString:true*/

	// utils is a library of generic helper functions non-specific to axios

	var toString$5 = Object.prototype.toString;

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray$4(val) {
	  return toString$5.call(val) === '[object Array]';
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	function isArrayBuffer$1(val) {
	  return toString$5.call(val) === '[object ArrayBuffer]';
	}

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData$1(val) {
	  return (typeof FormData !== 'undefined') && (val instanceof FormData);
	}

	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView$1(val) {
	  var result;
	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString$1(val) {
	  return typeof val === 'string';
	}

	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber$1(val) {
	  return typeof val === 'number';
	}

	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined$1(val) {
	  return typeof val === 'undefined';
	}

	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject$4(val) {
	  return val !== null && typeof val === 'object';
	}

	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	function isDate$1(val) {
	  return toString$5.call(val) === '[object Date]';
	}

	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	function isFile$1(val) {
	  return toString$5.call(val) === '[object File]';
	}

	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	function isBlob$1(val) {
	  return toString$5.call(val) === '[object Blob]';
	}

	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction$2(val) {
	  return toString$5.call(val) === '[object Function]';
	}

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream$1(val) {
	  return isObject$4(val) && isFunction$2(val.pipe);
	}

	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	function isURLSearchParams$1(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim$4(str) {
	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
	}

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  navigator.product -> 'ReactNative'
	 * nativescript
	 *  navigator.product -> 'NativeScript' or 'NS'
	 */
	function isStandardBrowserEnv$1() {
	  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
	                                           navigator.product === 'NativeScript' ||
	                                           navigator.product === 'NS')) {
	    return false;
	  }
	  return (
	    typeof window !== 'undefined' &&
	    typeof document !== 'undefined'
	  );
	}

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach$1(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }

	  // Force an array if not already something iterable
	  if (typeof obj !== 'object') {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }

	  if (isArray$4(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge$1(/* obj1, obj2, obj3, ... */) {
	  var result = {};
	  function assignValue(val, key) {
	    if (typeof result[key] === 'object' && typeof val === 'object') {
	      result[key] = merge$1(result[key], val);
	    } else {
	      result[key] = val;
	    }
	  }

	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach$1(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Function equal to merge with the difference being that no reference
	 * to original objects is kept.
	 *
	 * @see merge
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function deepMerge$1(/* obj1, obj2, obj3, ... */) {
	  var result = {};
	  function assignValue(val, key) {
	    if (typeof result[key] === 'object' && typeof val === 'object') {
	      result[key] = deepMerge$1(result[key], val);
	    } else if (typeof val === 'object') {
	      result[key] = deepMerge$1({}, val);
	    } else {
	      result[key] = val;
	    }
	  }

	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach$1(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend$1(a, b, thisArg) {
	  forEach$1(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind$2(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}

	var utils$1 = {
	  isArray: isArray$4,
	  isArrayBuffer: isArrayBuffer$1,
	  isBuffer: isBuffer$2,
	  isFormData: isFormData$1,
	  isArrayBufferView: isArrayBufferView$1,
	  isString: isString$1,
	  isNumber: isNumber$1,
	  isObject: isObject$4,
	  isUndefined: isUndefined$1,
	  isDate: isDate$1,
	  isFile: isFile$1,
	  isBlob: isBlob$1,
	  isFunction: isFunction$2,
	  isStream: isStream$1,
	  isURLSearchParams: isURLSearchParams$1,
	  isStandardBrowserEnv: isStandardBrowserEnv$1,
	  forEach: forEach$1,
	  merge: merge$1,
	  deepMerge: deepMerge$1,
	  extend: extend$1,
	  trim: trim$4
	};

	function encode$2(val) {
	  return encodeURIComponent(val).
	    replace(/%40/gi, '@').
	    replace(/%3A/gi, ':').
	    replace(/%24/g, '$').
	    replace(/%2C/gi, ',').
	    replace(/%20/g, '+').
	    replace(/%5B/gi, '[').
	    replace(/%5D/gi, ']');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	var buildURL$1 = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }

	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils$1.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];

	    utils$1.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }

	      if (utils$1.isArray(val)) {
	        key = key + '[]';
	      } else {
	        val = [val];
	      }

	      utils$1.forEach(val, function parseValue(v) {
	        if (utils$1.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils$1.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode$2(key) + '=' + encode$2(v));
	      });
	    });

	    serializedParams = parts.join('&');
	  }

	  if (serializedParams) {
	    var hashmarkIndex = url.indexOf('#');
	    if (hashmarkIndex !== -1) {
	      url = url.slice(0, hashmarkIndex);
	    }

	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }

	  return url;
	};

	function InterceptorManager$1() {
	  this.handlers = [];
	}

	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */
	InterceptorManager$1.prototype.use = function use(fulfilled, rejected) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected
	  });
	  return this.handlers.length - 1;
	};

	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */
	InterceptorManager$1.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};

	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */
	InterceptorManager$1.prototype.forEach = function forEach(fn) {
	  utils$1.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};

	var InterceptorManager_1$1 = InterceptorManager$1;

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */
	var transformData$1 = function transformData(data, headers, fns) {
	  /*eslint no-param-reassign:0*/
	  utils$1.forEach(fns, function transform(fn) {
	    data = fn(data, headers);
	  });

	  return data;
	};

	var isCancel$1 = function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	};

	var global$1$1 = (typeof global$1 !== "undefined" ? global$1 :
	            typeof self !== "undefined" ? self :
	            typeof window !== "undefined" ? window : {});

	// shim for using process in browser
	// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

	function defaultSetTimout$1() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout$1 () {
	    throw new Error('clearTimeout has not been defined');
	}
	var cachedSetTimeout$1 = defaultSetTimout$1;
	var cachedClearTimeout$1 = defaultClearTimeout$1;
	if (typeof global$1$1.setTimeout === 'function') {
	    cachedSetTimeout$1 = setTimeout;
	}
	if (typeof global$1$1.clearTimeout === 'function') {
	    cachedClearTimeout$1 = clearTimeout;
	}

	function runTimeout$1(fun) {
	    if (cachedSetTimeout$1 === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout$1 === defaultSetTimout$1 || !cachedSetTimeout$1) && setTimeout) {
	        cachedSetTimeout$1 = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout$1(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout$1.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout$1.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout$1(marker) {
	    if (cachedClearTimeout$1 === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout$1 === defaultClearTimeout$1 || !cachedClearTimeout$1) && clearTimeout) {
	        cachedClearTimeout$1 = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout$1(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout$1.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout$1.call(this, marker);
	        }
	    }



	}
	var queue$2 = [];
	var draining$1 = false;
	var currentQueue$1;
	var queueIndex$1 = -1;

	function cleanUpNextTick$1() {
	    if (!draining$1 || !currentQueue$1) {
	        return;
	    }
	    draining$1 = false;
	    if (currentQueue$1.length) {
	        queue$2 = currentQueue$1.concat(queue$2);
	    } else {
	        queueIndex$1 = -1;
	    }
	    if (queue$2.length) {
	        drainQueue$1();
	    }
	}

	function drainQueue$1() {
	    if (draining$1) {
	        return;
	    }
	    var timeout = runTimeout$1(cleanUpNextTick$1);
	    draining$1 = true;

	    var len = queue$2.length;
	    while(len) {
	        currentQueue$1 = queue$2;
	        queue$2 = [];
	        while (++queueIndex$1 < len) {
	            if (currentQueue$1) {
	                currentQueue$1[queueIndex$1].run();
	            }
	        }
	        queueIndex$1 = -1;
	        len = queue$2.length;
	    }
	    currentQueue$1 = null;
	    draining$1 = false;
	    runClearTimeout$1(timeout);
	}
	function nextTick$1(fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue$2.push(new Item$1(fun, args));
	    if (queue$2.length === 1 && !draining$1) {
	        runTimeout$1(drainQueue$1);
	    }
	}
	// v8 likes predictible objects
	function Item$1(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item$1.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	var title$1 = 'browser';
	var platform$1 = 'browser';
	var browser$1 = true;
	var env$1 = {};
	var argv$1 = [];
	var version$2 = ''; // empty string to avoid regexp issues
	var versions$2 = {};
	var release$1 = {};
	var config$1 = {};

	function noop$1() {}

	var on$1 = noop$1;
	var addListener$1 = noop$1;
	var once$1 = noop$1;
	var off$1 = noop$1;
	var removeListener$1 = noop$1;
	var removeAllListeners$1 = noop$1;
	var emit$1 = noop$1;

	function binding$1(name) {
	    throw new Error('process.binding is not supported');
	}

	function cwd$1 () { return '/' }
	function chdir$1 (dir) {
	    throw new Error('process.chdir is not supported');
	}function umask$1() { return 0; }

	// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
	var performance$1 = global$1$1.performance || {};
	var performanceNow$1 =
	  performance$1.now        ||
	  performance$1.mozNow     ||
	  performance$1.msNow      ||
	  performance$1.oNow       ||
	  performance$1.webkitNow  ||
	  function(){ return (new Date()).getTime() };

	// generate timestamp or delta
	// see http://nodejs.org/api/process.html#process_process_hrtime
	function hrtime$1(previousTimestamp){
	  var clocktime = performanceNow$1.call(performance$1)*1e-3;
	  var seconds = Math.floor(clocktime);
	  var nanoseconds = Math.floor((clocktime%1)*1e9);
	  if (previousTimestamp) {
	    seconds = seconds - previousTimestamp[0];
	    nanoseconds = nanoseconds - previousTimestamp[1];
	    if (nanoseconds<0) {
	      seconds--;
	      nanoseconds += 1e9;
	    }
	  }
	  return [seconds,nanoseconds]
	}

	var startTime$1 = new Date();
	function uptime$1() {
	  var currentTime = new Date();
	  var dif = currentTime - startTime$1;
	  return dif / 1000;
	}

	var process$6 = {
	  nextTick: nextTick$1,
	  title: title$1,
	  browser: browser$1,
	  env: env$1,
	  argv: argv$1,
	  version: version$2,
	  versions: versions$2,
	  on: on$1,
	  addListener: addListener$1,
	  once: once$1,
	  off: off$1,
	  removeListener: removeListener$1,
	  removeAllListeners: removeAllListeners$1,
	  emit: emit$1,
	  binding: binding$1,
	  cwd: cwd$1,
	  chdir: chdir$1,
	  umask: umask$1,
	  hrtime: hrtime$1,
	  platform: platform$1,
	  release: release$1,
	  config: config$1,
	  uptime: uptime$1
	};

	var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
	  utils$1.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};

	/**
	 * Update an Error with the specified config, error code, and response.
	 *
	 * @param {Error} error The error to update.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The error.
	 */
	var enhanceError$1 = function enhanceError(error, config, code, request, response) {
	  error.config = config;
	  if (code) {
	    error.code = code;
	  }

	  error.request = request;
	  error.response = response;
	  error.isAxiosError = true;

	  error.toJSON = function() {
	    return {
	      // Standard
	      message: this.message,
	      name: this.name,
	      // Microsoft
	      description: this.description,
	      number: this.number,
	      // Mozilla
	      fileName: this.fileName,
	      lineNumber: this.lineNumber,
	      columnNumber: this.columnNumber,
	      stack: this.stack,
	      // Axios
	      config: this.config,
	      code: this.code
	    };
	  };
	  return error;
	};

	/**
	 * Create an Error with the specified message, config, error code, request and response.
	 *
	 * @param {string} message The error message.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	var createError$1 = function createError(message, config, code, request, response) {
	  var error = new Error(message);
	  return enhanceError$1(error, config, code, request, response);
	};

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	var settle$1 = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  if (!validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(createError$1(
	      'Request failed with status code ' + response.status,
	      response.config,
	      null,
	      response.request,
	      response
	    ));
	  }
	};

	// Headers whose duplicates are ignored by node
	// c.f. https://nodejs.org/api/http.html#http_message_headers
	var ignoreDuplicateOf$1 = [
	  'age', 'authorization', 'content-length', 'content-type', 'etag',
	  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
	  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
	  'referer', 'retry-after', 'user-agent'
	];

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	var parseHeaders$1 = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;

	  if (!headers) { return parsed; }

	  utils$1.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils$1.trim(line.substr(0, i)).toLowerCase();
	    val = utils$1.trim(line.substr(i + 1));

	    if (key) {
	      if (parsed[key] && ignoreDuplicateOf$1.indexOf(key) >= 0) {
	        return;
	      }
	      if (key === 'set-cookie') {
	        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
	      } else {
	        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	      }
	    }
	  });

	  return parsed;
	};

	var isURLSameOrigin$1 = (
	  utils$1.isStandardBrowserEnv() ?

	  // Standard browser envs have full support of the APIs needed to test
	  // whether the request URL is of the same origin as current location.
	    (function standardBrowserEnv() {
	      var msie = /(msie|trident)/i.test(navigator.userAgent);
	      var urlParsingNode = document.createElement('a');
	      var originURL;

	      /**
	    * Parse a URL to discover it's components
	    *
	    * @param {String} url The URL to be parsed
	    * @returns {Object}
	    */
	      function resolveURL(url) {
	        var href = url;

	        if (msie) {
	        // IE needs attribute set twice to normalize properties
	          urlParsingNode.setAttribute('href', href);
	          href = urlParsingNode.href;
	        }

	        urlParsingNode.setAttribute('href', href);

	        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	        return {
	          href: urlParsingNode.href,
	          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	          host: urlParsingNode.host,
	          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	          hostname: urlParsingNode.hostname,
	          port: urlParsingNode.port,
	          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
	            urlParsingNode.pathname :
	            '/' + urlParsingNode.pathname
	        };
	      }

	      originURL = resolveURL(window.location.href);

	      /**
	    * Determine if a URL shares the same origin as the current location
	    *
	    * @param {String} requestURL The URL to test
	    * @returns {boolean} True if URL shares the same origin, otherwise false
	    */
	      return function isURLSameOrigin(requestURL) {
	        var parsed = (utils$1.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
	        return (parsed.protocol === originURL.protocol &&
	            parsed.host === originURL.host);
	      };
	    })() :

	  // Non standard browser envs (web workers, react-native) lack needed support.
	    (function nonStandardBrowserEnv() {
	      return function isURLSameOrigin() {
	        return true;
	      };
	    })()
	);

	var cookies$1 = (
	  utils$1.isStandardBrowserEnv() ?

	  // Standard browser envs support document.cookie
	    (function standardBrowserEnv() {
	      return {
	        write: function write(name, value, expires, path, domain, secure) {
	          var cookie = [];
	          cookie.push(name + '=' + encodeURIComponent(value));

	          if (utils$1.isNumber(expires)) {
	            cookie.push('expires=' + new Date(expires).toGMTString());
	          }

	          if (utils$1.isString(path)) {
	            cookie.push('path=' + path);
	          }

	          if (utils$1.isString(domain)) {
	            cookie.push('domain=' + domain);
	          }

	          if (secure === true) {
	            cookie.push('secure');
	          }

	          document.cookie = cookie.join('; ');
	        },

	        read: function read(name) {
	          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	          return (match ? decodeURIComponent(match[3]) : null);
	        },

	        remove: function remove(name) {
	          this.write(name, '', Date.now() - 86400000);
	        }
	      };
	    })() :

	  // Non standard browser env (web workers, react-native) lack needed support.
	    (function nonStandardBrowserEnv() {
	      return {
	        write: function write() {},
	        read: function read() { return null; },
	        remove: function remove() {}
	      };
	    })()
	);

	var xhr$1 = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;

	    if (utils$1.isFormData(requestData)) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }

	    var request = new XMLHttpRequest();

	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }

	    request.open(config.method.toUpperCase(), buildURL$1(config.url, config.params, config.paramsSerializer), true);

	    // Set the request timeout in MS
	    request.timeout = config.timeout;

	    // Listen for ready state
	    request.onreadystatechange = function handleLoad() {
	      if (!request || request.readyState !== 4) {
	        return;
	      }

	      // The request errored out and we didn't get a response, this will be
	      // handled by onerror instead
	      // With one exception: request that using file: protocol, most browsers
	      // will return status as 0 even though it's a successful request
	      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	        return;
	      }

	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders$1(request.getAllResponseHeaders()) : null;
	      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
	      var response = {
	        data: responseData,
	        status: request.status,
	        statusText: request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };

	      settle$1(resolve, reject, response);

	      // Clean up request
	      request = null;
	    };

	    // Handle browser request cancellation (as opposed to a manual cancellation)
	    request.onabort = function handleAbort() {
	      if (!request) {
	        return;
	      }

	      reject(createError$1('Request aborted', config, 'ECONNABORTED', request));

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(createError$1('Network Error', config, null, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      reject(createError$1('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
	        request));

	      // Clean up request
	      request = null;
	    };

	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils$1.isStandardBrowserEnv()) {
	      var cookies$1$1 = cookies$1;

	      // Add xsrf header
	      var xsrfValue = (config.withCredentials || isURLSameOrigin$1(config.url)) && config.xsrfCookieName ?
	        cookies$1$1.read(config.xsrfCookieName) :
	        undefined;

	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils$1.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }

	    // Add withCredentials to request if needed
	    if (config.withCredentials) {
	      request.withCredentials = true;
	    }

	    // Add responseType to request if needed
	    if (config.responseType) {
	      try {
	        request.responseType = config.responseType;
	      } catch (e) {
	        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
	        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
	        if (config.responseType !== 'json') {
	          throw e;
	        }
	      }
	    }

	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    }

	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }

	    if (config.cancelToken) {
	      // Handle cancellation
	      config.cancelToken.promise.then(function onCanceled(cancel) {
	        if (!request) {
	          return;
	        }

	        request.abort();
	        reject(cancel);
	        // Clean up request
	        request = null;
	      });
	    }

	    if (requestData === undefined) {
	      requestData = null;
	    }

	    // Send the request
	    request.send(requestData);
	  });
	};

	var DEFAULT_CONTENT_TYPE$1 = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};

	function setContentTypeIfUnset$1(headers, value) {
	  if (!utils$1.isUndefined(headers) && utils$1.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}

	function getDefaultAdapter$1() {
	  var adapter;
	  // Only Node.JS has a process variable that is of [[Class]] process
	  if (typeof process$6 !== 'undefined' && Object.prototype.toString.call(process$6) === '[object process]') {
	    // For node use HTTP adapter
	    adapter = xhr$1;
	  } else if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = xhr$1;
	  }
	  return adapter;
	}

	var defaults$1 = {
	  adapter: getDefaultAdapter$1(),

	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName$1(headers, 'Accept');
	    normalizeHeaderName$1(headers, 'Content-Type');
	    if (utils$1.isFormData(data) ||
	      utils$1.isArrayBuffer(data) ||
	      utils$1.isBuffer(data) ||
	      utils$1.isStream(data) ||
	      utils$1.isFile(data) ||
	      utils$1.isBlob(data)
	    ) {
	      return data;
	    }
	    if (utils$1.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils$1.isURLSearchParams(data)) {
	      setContentTypeIfUnset$1(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }
	    if (utils$1.isObject(data)) {
	      setContentTypeIfUnset$1(headers, 'application/json;charset=utf-8');
	      return JSON.stringify(data);
	    }
	    return data;
	  }],

	  transformResponse: [function transformResponse(data) {
	    /*eslint no-param-reassign:0*/
	    if (typeof data === 'string') {
	      try {
	        data = JSON.parse(data);
	      } catch (e) { /* Ignore */ }
	    }
	    return data;
	  }],

	  /**
	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
	   * timeout is not created.
	   */
	  timeout: 0,

	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',

	  maxContentLength: -1,

	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  }
	};

	defaults$1.headers = {
	  common: {
	    'Accept': 'application/json, text/plain, */*'
	  }
	};

	utils$1.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  defaults$1.headers[method] = {};
	});

	utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  defaults$1.headers[method] = utils$1.merge(DEFAULT_CONTENT_TYPE$1);
	});

	var defaults_1$1 = defaults$1;

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	var isAbsoluteURL$1 = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
	};

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */
	var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
	  return relativeURL
	    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
	    : baseURL;
	};

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	function throwIfCancellationRequested$1(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	}

	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */
	var dispatchRequest$1 = function dispatchRequest(config) {
	  throwIfCancellationRequested$1(config);

	  // Support baseURL config
	  if (config.baseURL && !isAbsoluteURL$1(config.url)) {
	    config.url = combineURLs$1(config.baseURL, config.url);
	  }

	  // Ensure headers exist
	  config.headers = config.headers || {};

	  // Transform request data
	  config.data = transformData$1(
	    config.data,
	    config.headers,
	    config.transformRequest
	  );

	  // Flatten headers
	  config.headers = utils$1.merge(
	    config.headers.common || {},
	    config.headers[config.method] || {},
	    config.headers || {}
	  );

	  utils$1.forEach(
	    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
	    function cleanHeaderConfig(method) {
	      delete config.headers[method];
	    }
	  );

	  var adapter = config.adapter || defaults_1$1.adapter;

	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested$1(config);

	    // Transform response data
	    response.data = transformData$1(
	      response.data,
	      response.headers,
	      config.transformResponse
	    );

	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel$1(reason)) {
	      throwIfCancellationRequested$1(config);

	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData$1(
	          reason.response.data,
	          reason.response.headers,
	          config.transformResponse
	        );
	      }
	    }

	    return Promise.reject(reason);
	  });
	};

	/**
	 * Config-specific merge-function which creates a new config-object
	 * by merging two configuration objects together.
	 *
	 * @param {Object} config1
	 * @param {Object} config2
	 * @returns {Object} New object resulting from merging config2 to config1
	 */
	var mergeConfig$1 = function mergeConfig(config1, config2) {
	  // eslint-disable-next-line no-param-reassign
	  config2 = config2 || {};
	  var config = {};

	  utils$1.forEach(['url', 'method', 'params', 'data'], function valueFromConfig2(prop) {
	    if (typeof config2[prop] !== 'undefined') {
	      config[prop] = config2[prop];
	    }
	  });

	  utils$1.forEach(['headers', 'auth', 'proxy'], function mergeDeepProperties(prop) {
	    if (utils$1.isObject(config2[prop])) {
	      config[prop] = utils$1.deepMerge(config1[prop], config2[prop]);
	    } else if (typeof config2[prop] !== 'undefined') {
	      config[prop] = config2[prop];
	    } else if (utils$1.isObject(config1[prop])) {
	      config[prop] = utils$1.deepMerge(config1[prop]);
	    } else if (typeof config1[prop] !== 'undefined') {
	      config[prop] = config1[prop];
	    }
	  });

	  utils$1.forEach([
	    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
	    'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
	    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength',
	    'validateStatus', 'maxRedirects', 'httpAgent', 'httpsAgent', 'cancelToken',
	    'socketPath'
	  ], function defaultToConfig2(prop) {
	    if (typeof config2[prop] !== 'undefined') {
	      config[prop] = config2[prop];
	    } else if (typeof config1[prop] !== 'undefined') {
	      config[prop] = config1[prop];
	    }
	  });

	  return config;
	};

	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 */
	function Axios$1(instanceConfig) {
	  this.defaults = instanceConfig;
	  this.interceptors = {
	    request: new InterceptorManager_1$1(),
	    response: new InterceptorManager_1$1()
	  };
	}

	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */
	Axios$1.prototype.request = function request(config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof config === 'string') {
	    config = arguments[1] || {};
	    config.url = arguments[0];
	  } else {
	    config = config || {};
	  }

	  config = mergeConfig$1(this.defaults, config);
	  config.method = config.method ? config.method.toLowerCase() : 'get';

	  // Hook up interceptors middleware
	  var chain = [dispatchRequest$1, undefined];
	  var promise = Promise.resolve(config);

	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    chain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });

	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    chain.push(interceptor.fulfilled, interceptor.rejected);
	  });

	  while (chain.length) {
	    promise = promise.then(chain.shift(), chain.shift());
	  }

	  return promise;
	};

	Axios$1.prototype.getUri = function getUri(config) {
	  config = mergeConfig$1(this.defaults, config);
	  return buildURL$1(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
	};

	// Provide aliases for supported request methods
	utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios$1.prototype[method] = function(url, config) {
	    return this.request(utils$1.merge(config || {}, {
	      method: method,
	      url: url
	    }));
	  };
	});

	utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/
	  Axios$1.prototype[method] = function(url, data, config) {
	    return this.request(utils$1.merge(config || {}, {
	      method: method,
	      url: url,
	      data: data
	    }));
	  };
	});

	var Axios_1$1 = Axios$1;

	/**
	 * A `Cancel` is an object that is thrown when an operation is canceled.
	 *
	 * @class
	 * @param {string=} message The message.
	 */
	function Cancel$1(message) {
	  this.message = message;
	}

	Cancel$1.prototype.toString = function toString() {
	  return 'Cancel' + (this.message ? ': ' + this.message : '');
	};

	Cancel$1.prototype.__CANCEL__ = true;

	var Cancel_1$1 = Cancel$1;

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @class
	 * @param {Function} executor The executor function.
	 */
	function CancelToken$1(executor) {
	  if (typeof executor !== 'function') {
	    throw new TypeError('executor must be a function.');
	  }

	  var resolvePromise;
	  this.promise = new Promise(function promiseExecutor(resolve) {
	    resolvePromise = resolve;
	  });

	  var token = this;
	  executor(function cancel(message) {
	    if (token.reason) {
	      // Cancellation has already been requested
	      return;
	    }

	    token.reason = new Cancel_1$1(message);
	    resolvePromise(token.reason);
	  });
	}

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	CancelToken$1.prototype.throwIfRequested = function throwIfRequested() {
	  if (this.reason) {
	    throw this.reason;
	  }
	};

	/**
	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	 * cancels the `CancelToken`.
	 */
	CancelToken$1.source = function source() {
	  var cancel;
	  var token = new CancelToken$1(function executor(c) {
	    cancel = c;
	  });
	  return {
	    token: token,
	    cancel: cancel
	  };
	};

	var CancelToken_1$1 = CancelToken$1;

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */
	var spread$1 = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};

	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */
	function createInstance$1(defaultConfig) {
	  var context = new Axios_1$1(defaultConfig);
	  var instance = bind$2(Axios_1$1.prototype.request, context);

	  // Copy axios.prototype to instance
	  utils$1.extend(instance, Axios_1$1.prototype, context);

	  // Copy context to instance
	  utils$1.extend(instance, context);

	  return instance;
	}

	// Create the default instance to be exported
	var axios$2 = createInstance$1(defaults_1$1);

	// Expose Axios class to allow class inheritance
	axios$2.Axios = Axios_1$1;

	// Factory for creating new instances
	axios$2.create = function create(instanceConfig) {
	  return createInstance$1(mergeConfig$1(axios$2.defaults, instanceConfig));
	};

	// Expose Cancel & CancelToken
	axios$2.Cancel = Cancel_1$1;
	axios$2.CancelToken = CancelToken_1$1;
	axios$2.isCancel = isCancel$1;

	// Expose all/spread
	axios$2.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios$2.spread = spread$1;

	var axios_1$1 = axios$2;

	// Allow use of default import syntax in TypeScript
	var default_1 = axios$2;
	axios_1$1.default = default_1;

	var axios$1$1 = axios_1$1;

	var interopRequireDefault = createCommonjsModule$1(function (module) {
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : {
	    "default": obj
	  };
	}

	module.exports = _interopRequireDefault;
	});

	unwrapExports(interopRequireDefault);

	var _typeof_1$1 = createCommonjsModule$1(function (module) {
	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    module.exports = _typeof = function _typeof(obj) {
	      return typeof obj;
	    };
	  } else {
	    module.exports = _typeof = function _typeof(obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	module.exports = _typeof;
	});

	function _assertThisInitialized$1(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	var assertThisInitialized$1 = _assertThisInitialized$1;

	function _possibleConstructorReturn$1(self, call) {
	  if (call && (_typeof_1$1(call) === "object" || typeof call === "function")) {
	    return call;
	  }

	  return assertThisInitialized$1(self);
	}

	var possibleConstructorReturn$1 = _possibleConstructorReturn$1;

	var getPrototypeOf$1 = createCommonjsModule$1(function (module) {
	function _getPrototypeOf(o) {
	  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	module.exports = _getPrototypeOf;
	});

	var setPrototypeOf$1 = createCommonjsModule$1(function (module) {
	function _setPrototypeOf(o, p) {
	  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	module.exports = _setPrototypeOf;
	});

	function _inherits$1(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) setPrototypeOf$1(subClass, superClass);
	}

	var inherits$1 = _inherits$1;

	function _superPropBase$1(object, property) {
	  while (!Object.prototype.hasOwnProperty.call(object, property)) {
	    object = getPrototypeOf$1(object);
	    if (object === null) break;
	  }

	  return object;
	}

	var superPropBase$1 = _superPropBase$1;

	var get$5 = createCommonjsModule$1(function (module) {
	function _get(target, property, receiver) {
	  if (typeof Reflect !== "undefined" && Reflect.get) {
	    module.exports = _get = Reflect.get;
	  } else {
	    module.exports = _get = function _get(target, property, receiver) {
	      var base = superPropBase$1(target, property);
	      if (!base) return;
	      var desc = Object.getOwnPropertyDescriptor(base, property);

	      if (desc.get) {
	        return desc.get.call(receiver);
	      }

	      return desc.value;
	    };
	  }

	  return _get(target, property, receiver || target);
	}

	module.exports = _get;
	});

	var constants = createCommonjsModule$1(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Type = exports.Char = void 0;
	var Char = {
	  ANCHOR: '&',
	  COMMENT: '#',
	  TAG: '!',
	  DIRECTIVES_END: '-',
	  DOCUMENT_END: '.'
	};
	exports.Char = Char;
	var Type = {
	  ALIAS: 'ALIAS',
	  BLANK_LINE: 'BLANK_LINE',
	  BLOCK_FOLDED: 'BLOCK_FOLDED',
	  BLOCK_LITERAL: 'BLOCK_LITERAL',
	  COMMENT: 'COMMENT',
	  DIRECTIVE: 'DIRECTIVE',
	  DOCUMENT: 'DOCUMENT',
	  FLOW_MAP: 'FLOW_MAP',
	  FLOW_SEQ: 'FLOW_SEQ',
	  MAP: 'MAP',
	  MAP_KEY: 'MAP_KEY',
	  MAP_VALUE: 'MAP_VALUE',
	  PLAIN: 'PLAIN',
	  QUOTE_DOUBLE: 'QUOTE_DOUBLE',
	  QUOTE_SINGLE: 'QUOTE_SINGLE',
	  SEQ: 'SEQ',
	  SEQ_ITEM: 'SEQ_ITEM'
	};
	exports.Type = Type;
	});

	unwrapExports(constants);
	var constants_1 = constants.Type;
	var constants_2 = constants.Char;

	function _isNativeFunction$1(fn) {
	  return Function.toString.call(fn).indexOf("[native code]") !== -1;
	}

	var isNativeFunction$1 = _isNativeFunction$1;

	var construct$2 = createCommonjsModule$1(function (module) {
	function isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;

	  try {
	    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function _construct(Parent, args, Class) {
	  if (isNativeReflectConstruct()) {
	    module.exports = _construct = Reflect.construct;
	  } else {
	    module.exports = _construct = function _construct(Parent, args, Class) {
	      var a = [null];
	      a.push.apply(a, args);
	      var Constructor = Function.bind.apply(Parent, a);
	      var instance = new Constructor();
	      if (Class) setPrototypeOf$1(instance, Class.prototype);
	      return instance;
	    };
	  }

	  return _construct.apply(null, arguments);
	}

	module.exports = _construct;
	});

	var wrapNativeSuper$1 = createCommonjsModule$1(function (module) {
	function _wrapNativeSuper(Class) {
	  var _cache = typeof Map === "function" ? new Map() : undefined;

	  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
	    if (Class === null || !isNativeFunction$1(Class)) return Class;

	    if (typeof Class !== "function") {
	      throw new TypeError("Super expression must either be null or a function");
	    }

	    if (typeof _cache !== "undefined") {
	      if (_cache.has(Class)) return _cache.get(Class);

	      _cache.set(Class, Wrapper);
	    }

	    function Wrapper() {
	      return construct$2(Class, arguments, getPrototypeOf$1(this).constructor);
	    }

	    Wrapper.prototype = Object.create(Class.prototype, {
	      constructor: {
	        value: Wrapper,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    return setPrototypeOf$1(Wrapper, Class);
	  };

	  return _wrapNativeSuper(Class);
	}

	module.exports = _wrapNativeSuper;
	});

	function _arrayWithHoles$1(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	var arrayWithHoles$1 = _arrayWithHoles$1;

	function _iterableToArrayLimit$1(arr, i) {
	  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
	    return;
	  }

	  var _arr = [];
	  var _n = true;
	  var _d = false;
	  var _e = undefined;

	  try {
	    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	var iterableToArrayLimit$1 = _iterableToArrayLimit$1;

	function _nonIterableRest$1() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance");
	}

	var nonIterableRest$1 = _nonIterableRest$1;

	function _slicedToArray$1(arr, i) {
	  return arrayWithHoles$1(arr) || iterableToArrayLimit$1(arr, i) || nonIterableRest$1();
	}

	var slicedToArray$1 = _slicedToArray$1;

	var sourceUtils = createCommonjsModule$1(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getLinePos = getLinePos;
	exports.getLine = getLine;
	exports.getPrettyContext = getPrettyContext;

	function findLineStarts(src) {
	  var ls = [0];
	  var offset = src.indexOf('\n');

	  while (offset !== -1) {
	    offset += 1;
	    ls.push(offset);
	    offset = src.indexOf('\n', offset);
	  }

	  return ls;
	}

	function getSrcInfo(cst) {
	  var lineStarts, src;

	  if (typeof cst === 'string') {
	    lineStarts = findLineStarts(cst);
	    src = cst;
	  } else {
	    if (Array.isArray(cst)) cst = cst[0];

	    if (cst && cst.context) {
	      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);
	      lineStarts = cst.lineStarts;
	      src = cst.context.src;
	    }
	  }

	  return {
	    lineStarts: lineStarts,
	    src: src
	  };
	}
	/**
	 * @typedef {Object} LinePos - One-indexed position in the source
	 * @property {number} line
	 * @property {number} col
	 */

	/**
	 * Determine the line/col position matching a character offset.
	 *
	 * Accepts a source string or a CST document as the second parameter. With
	 * the latter, starting indices for lines are cached in the document as
	 * `lineStarts: number[]`.
	 *
	 * Returns a one-indexed `{ line, col }` location if found, or
	 * `undefined` otherwise.
	 *
	 * @param {number} offset
	 * @param {string|Document|Document[]} cst
	 * @returns {?LinePos}
	 */


	function getLinePos(offset, cst) {
	  if (typeof offset !== 'number' || offset < 0) return null;

	  var _getSrcInfo = getSrcInfo(cst),
	      lineStarts = _getSrcInfo.lineStarts,
	      src = _getSrcInfo.src;

	  if (!lineStarts || !src || offset > src.length) return null;

	  for (var i = 0; i < lineStarts.length; ++i) {
	    var start = lineStarts[i];

	    if (offset < start) {
	      return {
	        line: i,
	        col: offset - lineStarts[i - 1] + 1
	      };
	    }

	    if (offset === start) return {
	      line: i + 1,
	      col: 1
	    };
	  }

	  var line = lineStarts.length;
	  return {
	    line: line,
	    col: offset - lineStarts[line - 1] + 1
	  };
	}
	/**
	 * Get a specified line from the source.
	 *
	 * Accepts a source string or a CST document as the second parameter. With
	 * the latter, starting indices for lines are cached in the document as
	 * `lineStarts: number[]`.
	 *
	 * Returns the line as a string if found, or `null` otherwise.
	 *
	 * @param {number} line One-indexed line number
	 * @param {string|Document|Document[]} cst
	 * @returns {?string}
	 */


	function getLine(line, cst) {
	  var _getSrcInfo2 = getSrcInfo(cst),
	      lineStarts = _getSrcInfo2.lineStarts,
	      src = _getSrcInfo2.src;

	  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;
	  var start = lineStarts[line - 1];
	  var end = lineStarts[line]; // undefined for last line; that's ok for slice()

	  while (end && end > start && src[end - 1] === '\n') {
	    --end;
	  }

	  return src.slice(start, end);
	}
	/**
	 * Pretty-print the starting line from the source indicated by the range `pos`
	 *
	 * Trims output to `maxWidth` chars while keeping the starting column visible,
	 * using `…` at either end to indicate dropped characters.
	 *
	 * Returns a two-line string (or `null`) with `\n` as separator; the second line
	 * will hold appropriately indented `^` marks indicating the column range.
	 *
	 * @param {Object} pos
	 * @param {LinePos} pos.start
	 * @param {LinePos} [pos.end]
	 * @param {string|Document|Document[]*} cst
	 * @param {number} [maxWidth=80]
	 * @returns {?string}
	 */


	function getPrettyContext(_ref, cst) {
	  var start = _ref.start,
	      end = _ref.end;
	  var maxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 80;
	  var src = getLine(start.line, cst);
	  if (!src) return null;
	  var col = start.col;

	  if (src.length > maxWidth) {
	    if (col <= maxWidth - 10) {
	      src = src.substr(0, maxWidth - 1) + '…';
	    } else {
	      var halfWidth = Math.round(maxWidth / 2);
	      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';
	      col -= src.length - maxWidth;
	      src = '…' + src.substr(1 - maxWidth);
	    }
	  }

	  var errLen = 1;
	  var errEnd = '';

	  if (end) {
	    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
	      errLen = end.col - start.col;
	    } else {
	      errLen = Math.min(src.length + 1, maxWidth) - col;
	      errEnd = '…';
	    }
	  }

	  var offset = col > 1 ? ' '.repeat(col - 1) : '';
	  var err = '^'.repeat(errLen);
	  return "".concat(src, "\n").concat(offset).concat(err).concat(errEnd);
	}
	});

	unwrapExports(sourceUtils);
	var sourceUtils_1 = sourceUtils.getLinePos;
	var sourceUtils_2 = sourceUtils.getLine;
	var sourceUtils_3 = sourceUtils.getPrettyContext;

	var Range_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var Range =
	/*#__PURE__*/
	function () {
	  (0, _createClass2.default)(Range, null, [{
	    key: "copy",
	    value: function copy(orig) {
	      return new Range(orig.start, orig.end);
	    }
	  }]);

	  function Range(start, end) {
	    (0, _classCallCheck2.default)(this, Range);
	    this.start = start;
	    this.end = end || start;
	  }

	  (0, _createClass2.default)(Range, [{
	    key: "isEmpty",
	    value: function isEmpty() {
	      return typeof this.start !== 'number' || !this.end || this.end <= this.start;
	    }
	    /**
	     * Set `origStart` and `origEnd` to point to the original source range for
	     * this node, which may differ due to dropped CR characters.
	     *
	     * @param {number[]} cr - Positions of dropped CR characters
	     * @param {number} offset - Starting index of `cr` from the last call
	     * @returns {number} - The next offset, matching the one found for `origStart`
	     */

	  }, {
	    key: "setOrigRange",
	    value: function setOrigRange(cr, offset) {
	      var start = this.start,
	          end = this.end;

	      if (cr.length === 0 || end <= cr[0]) {
	        this.origStart = start;
	        this.origEnd = end;
	        return offset;
	      }

	      var i = offset;

	      while (i < cr.length) {
	        if (cr[i] > start) break;else ++i;
	      }

	      this.origStart = start + i;
	      var nextOffset = i;

	      while (i < cr.length) {
	        // if end was at \n, it should now be at \r
	        if (cr[i] >= end) break;else ++i;
	      }

	      this.origEnd = end + i;
	      return nextOffset;
	    }
	  }]);
	  return Range;
	}();

	exports.default = Range;
	});

	unwrapExports(Range_1);

	var Node_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);





	var _Range = interopRequireDefault(Range_1);

	/** Root class of all nodes */
	var Node =
	/*#__PURE__*/
	function () {
	  (0, _createClass2.default)(Node, null, [{
	    key: "addStringTerminator",
	    value: function addStringTerminator(src, offset, str) {
	      if (str[str.length - 1] === '\n') return str;
	      var next = Node.endOfWhiteSpace(src, offset);
	      return next >= src.length || src[next] === '\n' ? str + '\n' : str;
	    } // ^(---|...)

	  }, {
	    key: "atDocumentBoundary",
	    value: function atDocumentBoundary(src, offset, sep) {
	      var ch0 = src[offset];
	      if (!ch0) return true;
	      var prev = src[offset - 1];
	      if (prev && prev !== '\n') return false;

	      if (sep) {
	        if (ch0 !== sep) return false;
	      } else {
	        if (ch0 !== constants.Char.DIRECTIVES_END && ch0 !== constants.Char.DOCUMENT_END) return false;
	      }

	      var ch1 = src[offset + 1];
	      var ch2 = src[offset + 2];
	      if (ch1 !== ch0 || ch2 !== ch0) return false;
	      var ch3 = src[offset + 3];
	      return !ch3 || ch3 === '\n' || ch3 === '\t' || ch3 === ' ';
	    }
	  }, {
	    key: "endOfIdentifier",
	    value: function endOfIdentifier(src, offset) {
	      var ch = src[offset];
	      var isVerbatim = ch === '<';
	      var notOk = isVerbatim ? ['\n', '\t', ' ', '>'] : ['\n', '\t', ' ', '[', ']', '{', '}', ','];

	      while (ch && notOk.indexOf(ch) === -1) {
	        ch = src[offset += 1];
	      }

	      if (isVerbatim && ch === '>') offset += 1;
	      return offset;
	    }
	  }, {
	    key: "endOfIndent",
	    value: function endOfIndent(src, offset) {
	      var ch = src[offset];

	      while (ch === ' ') {
	        ch = src[offset += 1];
	      }

	      return offset;
	    }
	  }, {
	    key: "endOfLine",
	    value: function endOfLine(src, offset) {
	      var ch = src[offset];

	      while (ch && ch !== '\n') {
	        ch = src[offset += 1];
	      }

	      return offset;
	    }
	  }, {
	    key: "endOfWhiteSpace",
	    value: function endOfWhiteSpace(src, offset) {
	      var ch = src[offset];

	      while (ch === '\t' || ch === ' ') {
	        ch = src[offset += 1];
	      }

	      return offset;
	    }
	  }, {
	    key: "startOfLine",
	    value: function startOfLine(src, offset) {
	      var ch = src[offset - 1];
	      if (ch === '\n') return offset;

	      while (ch && ch !== '\n') {
	        ch = src[offset -= 1];
	      }

	      return offset + 1;
	    }
	    /**
	     * End of indentation, or null if the line's indent level is not more
	     * than `indent`
	     *
	     * @param {string} src
	     * @param {number} indent
	     * @param {number} lineStart
	     * @returns {?number}
	     */

	  }, {
	    key: "endOfBlockIndent",
	    value: function endOfBlockIndent(src, indent, lineStart) {
	      var inEnd = Node.endOfIndent(src, lineStart);

	      if (inEnd > lineStart + indent) {
	        return inEnd;
	      } else {
	        var wsEnd = Node.endOfWhiteSpace(src, inEnd);
	        var ch = src[wsEnd];
	        if (!ch || ch === '\n') return wsEnd;
	      }

	      return null;
	    }
	  }, {
	    key: "atBlank",
	    value: function atBlank(src, offset, endAsBlank) {
	      var ch = src[offset];
	      return ch === '\n' || ch === '\t' || ch === ' ' || endAsBlank && !ch;
	    }
	  }, {
	    key: "atCollectionItem",
	    value: function atCollectionItem(src, offset) {
	      var ch = src[offset];
	      return (ch === '?' || ch === ':' || ch === '-') && Node.atBlank(src, offset + 1, true);
	    }
	  }, {
	    key: "nextNodeIsIndented",
	    value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
	      if (!ch || indentDiff < 0) return false;
	      if (indentDiff > 0) return true;
	      return indicatorAsIndent && ch === '-';
	    } // should be at line or string end, or at next non-whitespace char

	  }, {
	    key: "normalizeOffset",
	    value: function normalizeOffset(src, offset) {
	      var ch = src[offset];
	      return !ch ? offset : ch !== '\n' && src[offset - 1] === '\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);
	    } // fold single newline into space, multiple newlines to N - 1 newlines
	    // presumes src[offset] === '\n'

	  }, {
	    key: "foldNewline",
	    value: function foldNewline(src, offset, indent) {
	      var inCount = 0;
	      var error = false;
	      var fold = '';
	      var ch = src[offset + 1];

	      while (ch === ' ' || ch === '\t' || ch === '\n') {
	        switch (ch) {
	          case '\n':
	            inCount = 0;
	            offset += 1;
	            fold += '\n';
	            break;

	          case '\t':
	            if (inCount <= indent) error = true;
	            offset = Node.endOfWhiteSpace(src, offset + 2) - 1;
	            break;

	          case ' ':
	            inCount += 1;
	            offset += 1;
	            break;
	        }

	        ch = src[offset + 1];
	      }

	      if (!fold) fold = ' ';
	      if (ch && inCount <= indent) error = true;
	      return {
	        fold: fold,
	        offset: offset,
	        error: error
	      };
	    }
	  }]);

	  function Node(type, props, context) {
	    (0, _classCallCheck2.default)(this, Node);
	    Object.defineProperty(this, 'context', {
	      value: context || null,
	      writable: true
	    });
	    this.error = null;
	    this.range = null;
	    this.valueRange = null;
	    this.props = props || [];
	    this.type = type;
	    this.value = null;
	  }

	  (0, _createClass2.default)(Node, [{
	    key: "getPropValue",
	    value: function getPropValue(idx, key, skipKey) {
	      if (!this.context) return null;
	      var src = this.context.src;
	      var prop = this.props[idx];
	      return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
	    }
	  }, {
	    key: "commentHasRequiredWhitespace",
	    value: function commentHasRequiredWhitespace(start) {
	      var src = this.context.src;
	      if (this.header && start === this.header.end) return false;
	      if (!this.valueRange) return false;
	      var end = this.valueRange.end;
	      return start !== end || Node.atBlank(src, end - 1);
	    }
	  }, {
	    key: "parseComment",
	    value: function parseComment(start) {
	      var src = this.context.src;

	      if (src[start] === constants.Char.COMMENT) {
	        var end = Node.endOfLine(src, start + 1);
	        var commentRange = new _Range.default(start, end);
	        this.props.push(commentRange);
	        return end;
	      }

	      return start;
	    }
	    /**
	     * Populates the `origStart` and `origEnd` values of all ranges for this
	     * node. Extended by child classes to handle descendant nodes.
	     *
	     * @param {number[]} cr - Positions of dropped CR characters
	     * @param {number} offset - Starting index of `cr` from the last call
	     * @returns {number} - The next offset, matching the one found for `origStart`
	     */

	  }, {
	    key: "setOrigRanges",
	    value: function setOrigRanges(cr, offset) {
	      if (this.range) offset = this.range.setOrigRange(cr, offset);
	      if (this.valueRange) this.valueRange.setOrigRange(cr, offset);
	      this.props.forEach(function (prop) {
	        return prop.setOrigRange(cr, offset);
	      });
	      return offset;
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      var src = this.context.src,
	          range = this.range,
	          value = this.value;
	      if (value != null) return value;
	      var str = src.slice(range.start, range.end);
	      return Node.addStringTerminator(src, range.end, str);
	    }
	  }, {
	    key: "anchor",
	    get: function get() {
	      for (var i = 0; i < this.props.length; ++i) {
	        var anchor = this.getPropValue(i, constants.Char.ANCHOR, true);
	        if (anchor != null) return anchor;
	      }

	      return null;
	    }
	  }, {
	    key: "comment",
	    get: function get() {
	      var comments = [];

	      for (var i = 0; i < this.props.length; ++i) {
	        var comment = this.getPropValue(i, constants.Char.COMMENT, true);
	        if (comment != null) comments.push(comment);
	      }

	      return comments.length > 0 ? comments.join('\n') : null;
	    }
	  }, {
	    key: "hasComment",
	    get: function get() {
	      if (this.context) {
	        var src = this.context.src;

	        for (var i = 0; i < this.props.length; ++i) {
	          if (src[this.props[i].start] === constants.Char.COMMENT) return true;
	        }
	      }

	      return false;
	    }
	  }, {
	    key: "hasProps",
	    get: function get() {
	      if (this.context) {
	        var src = this.context.src;

	        for (var i = 0; i < this.props.length; ++i) {
	          if (src[this.props[i].start] !== constants.Char.COMMENT) return true;
	        }
	      }

	      return false;
	    }
	  }, {
	    key: "includesTrailingLines",
	    get: function get() {
	      return false;
	    }
	  }, {
	    key: "jsonLike",
	    get: function get() {
	      var jsonLikeTypes = [constants.Type.FLOW_MAP, constants.Type.FLOW_SEQ, constants.Type.QUOTE_DOUBLE, constants.Type.QUOTE_SINGLE];
	      return jsonLikeTypes.indexOf(this.type) !== -1;
	    }
	  }, {
	    key: "rangeAsLinePos",
	    get: function get() {
	      if (!this.range || !this.context) return undefined;
	      var start = (0, sourceUtils.getLinePos)(this.range.start, this.context.root);
	      if (!start) return undefined;
	      var end = (0, sourceUtils.getLinePos)(this.range.end, this.context.root);
	      return {
	        start: start,
	        end: end
	      };
	    }
	  }, {
	    key: "rawValue",
	    get: function get() {
	      if (!this.valueRange || !this.context) return null;
	      var _this$valueRange = this.valueRange,
	          start = _this$valueRange.start,
	          end = _this$valueRange.end;
	      return this.context.src.slice(start, end);
	    }
	  }, {
	    key: "tag",
	    get: function get() {
	      for (var i = 0; i < this.props.length; ++i) {
	        var tag = this.getPropValue(i, constants.Char.TAG, false);

	        if (tag != null) {
	          if (tag[1] === '<') {
	            return {
	              verbatim: tag.slice(2, -1)
	            };
	          } else {
	            // eslint-disable-next-line no-unused-vars
	            var _tag$match = tag.match(/^(.*!)([^!]*)$/),
	                _tag$match2 = (0, _slicedToArray2.default)(_tag$match, 3),
	                _ = _tag$match2[0],
	                handle = _tag$match2[1],
	                suffix = _tag$match2[2];

	            return {
	              handle: handle,
	              suffix: suffix
	            };
	          }
	        }
	      }

	      return null;
	    }
	  }, {
	    key: "valueRangeContainsNewline",
	    get: function get() {
	      if (!this.valueRange || !this.context) return false;
	      var _this$valueRange2 = this.valueRange,
	          start = _this$valueRange2.start,
	          end = _this$valueRange2.end;
	      var src = this.context.src;

	      for (var i = start; i < end; ++i) {
	        if (src[i] === '\n') return true;
	      }

	      return false;
	    }
	  }]);
	  return Node;
	}();

	exports.default = Node;
	});

	unwrapExports(Node_1);

	var errors = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.YAMLWarning = exports.YAMLSyntaxError = exports.YAMLSemanticError = exports.YAMLReferenceError = exports.YAMLError = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _inherits2 = interopRequireDefault(inherits$1);

	var _wrapNativeSuper2 = interopRequireDefault(wrapNativeSuper$1);

	var _Node = interopRequireDefault(Node_1);



	var _Range = interopRequireDefault(Range_1);

	var YAMLError =
	/*#__PURE__*/
	function (_Error) {
	  (0, _inherits2.default)(YAMLError, _Error);

	  function YAMLError(name, source, message) {
	    var _this;

	    (0, _classCallCheck2.default)(this, YAMLError);
	    if (!message || !(source instanceof _Node.default)) throw new Error("Invalid arguments for new ".concat(name));
	    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLError).call(this));
	    _this.name = name;
	    _this.message = message;
	    _this.source = source;
	    return _this;
	  }

	  (0, _createClass2.default)(YAMLError, [{
	    key: "makePretty",
	    value: function makePretty() {
	      if (!this.source) return;
	      this.nodeType = this.source.type;
	      var cst = this.source.context && this.source.context.root;

	      if (typeof this.offset === 'number') {
	        this.range = new _Range.default(this.offset, this.offset + 1);
	        var start = cst && (0, sourceUtils.getLinePos)(this.offset, cst);

	        if (start) {
	          var end = {
	            line: start.line,
	            col: start.col + 1
	          };
	          this.linePos = {
	            start: start,
	            end: end
	          };
	        }

	        delete this.offset;
	      } else {
	        this.range = this.source.range;
	        this.linePos = this.source.rangeAsLinePos;
	      }

	      if (this.linePos) {
	        var _this$linePos$start = this.linePos.start,
	            line = _this$linePos$start.line,
	            col = _this$linePos$start.col;
	        this.message += " at line ".concat(line, ", column ").concat(col);
	        var ctx = cst && (0, sourceUtils.getPrettyContext)(this.linePos, cst);
	        if (ctx) this.message += ":\n\n".concat(ctx, "\n");
	      }

	      delete this.source;
	    }
	  }]);
	  return YAMLError;
	}((0, _wrapNativeSuper2.default)(Error));

	exports.YAMLError = YAMLError;

	var YAMLReferenceError =
	/*#__PURE__*/
	function (_YAMLError) {
	  (0, _inherits2.default)(YAMLReferenceError, _YAMLError);

	  function YAMLReferenceError(source, message) {
	    (0, _classCallCheck2.default)(this, YAMLReferenceError);
	    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLReferenceError).call(this, 'YAMLReferenceError', source, message));
	  }

	  return YAMLReferenceError;
	}(YAMLError);

	exports.YAMLReferenceError = YAMLReferenceError;

	var YAMLSemanticError =
	/*#__PURE__*/
	function (_YAMLError2) {
	  (0, _inherits2.default)(YAMLSemanticError, _YAMLError2);

	  function YAMLSemanticError(source, message) {
	    (0, _classCallCheck2.default)(this, YAMLSemanticError);
	    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLSemanticError).call(this, 'YAMLSemanticError', source, message));
	  }

	  return YAMLSemanticError;
	}(YAMLError);

	exports.YAMLSemanticError = YAMLSemanticError;

	var YAMLSyntaxError =
	/*#__PURE__*/
	function (_YAMLError3) {
	  (0, _inherits2.default)(YAMLSyntaxError, _YAMLError3);

	  function YAMLSyntaxError(source, message) {
	    (0, _classCallCheck2.default)(this, YAMLSyntaxError);
	    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLSyntaxError).call(this, 'YAMLSyntaxError', source, message));
	  }

	  return YAMLSyntaxError;
	}(YAMLError);

	exports.YAMLSyntaxError = YAMLSyntaxError;

	var YAMLWarning =
	/*#__PURE__*/
	function (_YAMLError4) {
	  (0, _inherits2.default)(YAMLWarning, _YAMLError4);

	  function YAMLWarning(source, message) {
	    (0, _classCallCheck2.default)(this, YAMLWarning);
	    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLWarning).call(this, 'YAMLWarning', source, message));
	  }

	  return YAMLWarning;
	}(YAMLError);

	exports.YAMLWarning = YAMLWarning;
	});

	unwrapExports(errors);
	var errors_1 = errors.YAMLWarning;
	var errors_2 = errors.YAMLSyntaxError;
	var errors_3 = errors.YAMLSemanticError;
	var errors_4 = errors.YAMLReferenceError;
	var errors_5 = errors.YAMLError;

	var BlankLine_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _inherits2 = interopRequireDefault(inherits$1);



	var _Node2 = interopRequireDefault(Node_1);

	var _Range = interopRequireDefault(Range_1);

	var BlankLine =
	/*#__PURE__*/
	function (_Node) {
	  (0, _inherits2.default)(BlankLine, _Node);

	  function BlankLine() {
	    (0, _classCallCheck2.default)(this, BlankLine);
	    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(BlankLine).call(this, constants.Type.BLANK_LINE));
	  }

	  (0, _createClass2.default)(BlankLine, [{
	    key: "parse",

	    /**
	     * Parses blank lines from the source
	     *
	     * @param {ParseContext} context
	     * @param {number} start - Index of first \n character
	     * @returns {number} - Index of the character after this
	     */
	    value: function parse(context, start) {
	      this.context = context;
	      var src = context.src;
	      var offset = start + 1;

	      while (_Node2.default.atBlank(src, offset)) {
	        var lineEnd = _Node2.default.endOfWhiteSpace(src, offset);

	        if (lineEnd === '\n') offset = lineEnd + 1;else break;
	      }

	      this.range = new _Range.default(start, offset);
	      return offset;
	    }
	  }, {
	    key: "includesTrailingLines",
	    get: function get() {
	      return true;
	    }
	  }]);
	  return BlankLine;
	}(_Node2.default);

	exports.default = BlankLine;
	});

	unwrapExports(BlankLine_1);

	var CollectionItem_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _get2 = interopRequireDefault(get$5);

	var _inherits2 = interopRequireDefault(inherits$1);





	var _BlankLine = interopRequireDefault(BlankLine_1);

	var _Node2 = interopRequireDefault(Node_1);

	var _Range = interopRequireDefault(Range_1);

	var CollectionItem =
	/*#__PURE__*/
	function (_Node) {
	  (0, _inherits2.default)(CollectionItem, _Node);

	  function CollectionItem(type, props) {
	    var _this;

	    (0, _classCallCheck2.default)(this, CollectionItem);
	    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CollectionItem).call(this, type, props));
	    _this.node = null;
	    return _this;
	  }

	  (0, _createClass2.default)(CollectionItem, [{
	    key: "parse",

	    /**
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this
	     */
	    value: function parse(context, start) {
	      this.context = context;
	      var parseNode = context.parseNode,
	          src = context.src;
	      var atLineStart = context.atLineStart,
	          lineStart = context.lineStart;
	      if (!atLineStart && this.type === constants.Type.SEQ_ITEM) this.error = new errors.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');
	      var indent = atLineStart ? start - lineStart : context.indent;

	      var offset = _Node2.default.endOfWhiteSpace(src, start + 1);

	      var ch = src[offset];
	      var inlineComment = ch === '#';
	      var comments = [];
	      var blankLine = null;

	      while (ch === '\n' || ch === '#') {
	        if (ch === '#') {
	          var _end = _Node2.default.endOfLine(src, offset + 1);

	          comments.push(new _Range.default(offset, _end));
	          offset = _end;
	        } else {
	          atLineStart = true;
	          lineStart = offset + 1;

	          var wsEnd = _Node2.default.endOfWhiteSpace(src, lineStart);

	          if (src[wsEnd] === '\n' && comments.length === 0) {
	            blankLine = new _BlankLine.default();
	            lineStart = blankLine.parse({
	              src: src
	            }, lineStart);
	          }

	          offset = _Node2.default.endOfIndent(src, lineStart);
	        }

	        ch = src[offset];
	      }

	      if (_Node2.default.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== constants.Type.SEQ_ITEM)) {
	        this.node = parseNode({
	          atLineStart: atLineStart,
	          inCollection: false,
	          indent: indent,
	          lineStart: lineStart,
	          parent: this
	        }, offset);
	      } else if (ch && lineStart > start + 1) {
	        offset = lineStart - 1;
	      }

	      if (this.node) {
	        if (blankLine) {
	          // Only blank lines preceding non-empty nodes are captured. Note that
	          // this means that collection item range start indices do not always
	          // increase monotonically. -- eemeli/yaml#126
	          var items = context.parent.items || context.parent.contents;
	          if (items) items.push(blankLine);
	        }

	        if (comments.length) Array.prototype.push.apply(this.props, comments);
	        offset = this.node.range.end;
	      } else {
	        if (inlineComment) {
	          var c = comments[0];
	          this.props.push(c);
	          offset = c.end;
	        } else {
	          offset = _Node2.default.endOfLine(src, start + 1);
	        }
	      }

	      var end = this.node ? this.node.valueRange.end : offset;
	      this.valueRange = new _Range.default(start, end);
	      return offset;
	    }
	  }, {
	    key: "setOrigRanges",
	    value: function setOrigRanges(cr, offset) {
	      offset = (0, _get2.default)((0, _getPrototypeOf2.default)(CollectionItem.prototype), "setOrigRanges", this).call(this, cr, offset);
	      return this.node ? this.node.setOrigRanges(cr, offset) : offset;
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      var src = this.context.src,
	          node = this.node,
	          range = this.range,
	          value = this.value;
	      if (value != null) return value;
	      var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);
	      return _Node2.default.addStringTerminator(src, range.end, str);
	    }
	  }, {
	    key: "includesTrailingLines",
	    get: function get() {
	      return !!this.node && this.node.includesTrailingLines;
	    }
	  }]);
	  return CollectionItem;
	}(_Node2.default);

	exports.default = CollectionItem;
	});

	unwrapExports(CollectionItem_1);

	var Comment_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _inherits2 = interopRequireDefault(inherits$1);



	var _Node2 = interopRequireDefault(Node_1);

	var _Range = interopRequireDefault(Range_1);

	var Comment =
	/*#__PURE__*/
	function (_Node) {
	  (0, _inherits2.default)(Comment, _Node);

	  function Comment() {
	    (0, _classCallCheck2.default)(this, Comment);
	    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Comment).call(this, constants.Type.COMMENT));
	  }
	  /**
	   * Parses a comment line from the source
	   *
	   * @param {ParseContext} context
	   * @param {number} start - Index of first character
	   * @returns {number} - Index of the character after this scalar
	   */


	  (0, _createClass2.default)(Comment, [{
	    key: "parse",
	    value: function parse(context, start) {
	      this.context = context;
	      var offset = this.parseComment(start);
	      this.range = new _Range.default(start, offset);
	      return offset;
	    }
	  }]);
	  return Comment;
	}(_Node2.default);

	exports.default = Comment;
	});

	unwrapExports(Comment_1);

	var Collection_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.grabCollectionEndComments = grabCollectionEndComments;
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _get2 = interopRequireDefault(get$5);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _inherits2 = interopRequireDefault(inherits$1);



	var _BlankLine = interopRequireDefault(BlankLine_1);

	var _CollectionItem = interopRequireDefault(CollectionItem_1);

	var _Comment = interopRequireDefault(Comment_1);

	var _Node2 = interopRequireDefault(Node_1);

	var _Range = interopRequireDefault(Range_1);

	function grabCollectionEndComments(node) {
	  var cnode = node;

	  while (cnode instanceof _CollectionItem.default) {
	    cnode = cnode.node;
	  }

	  if (!(cnode instanceof Collection)) return null;
	  var len = cnode.items.length;
	  var ci = -1;

	  for (var i = len - 1; i >= 0; --i) {
	    var n = cnode.items[i];

	    if (n.type === constants.Type.COMMENT) {
	      // Keep sufficiently indented comments with preceding node
	      var _n$context = n.context,
	          indent = _n$context.indent,
	          lineStart = _n$context.lineStart;
	      if (indent > 0 && n.range.start >= lineStart + indent) break;
	      ci = i;
	    } else if (n.type === constants.Type.BLANK_LINE) ci = i;else break;
	  }

	  if (ci === -1) return null;
	  var ca = cnode.items.splice(ci, len - ci);
	  var prevEnd = ca[0].range.start;

	  while (true) {
	    cnode.range.end = prevEnd;
	    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;
	    if (cnode === node) break;
	    cnode = cnode.context.parent;
	  }

	  return ca;
	}

	var Collection =
	/*#__PURE__*/
	function (_Node) {
	  (0, _inherits2.default)(Collection, _Node);
	  (0, _createClass2.default)(Collection, null, [{
	    key: "nextContentHasIndent",
	    value: function nextContentHasIndent(src, offset, indent) {
	      var lineStart = _Node2.default.endOfLine(src, offset) + 1;
	      offset = _Node2.default.endOfWhiteSpace(src, lineStart);
	      var ch = src[offset];
	      if (!ch) return false;
	      if (offset >= lineStart + indent) return true;
	      if (ch !== '#' && ch !== '\n') return false;
	      return Collection.nextContentHasIndent(src, offset, indent);
	    }
	  }]);

	  function Collection(firstItem) {
	    var _this;

	    (0, _classCallCheck2.default)(this, Collection);
	    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Collection).call(this, firstItem.type === constants.Type.SEQ_ITEM ? constants.Type.SEQ : constants.Type.MAP));

	    for (var i = firstItem.props.length - 1; i >= 0; --i) {
	      if (firstItem.props[i].start < firstItem.context.lineStart) {
	        // props on previous line are assumed by the collection
	        _this.props = firstItem.props.slice(0, i + 1);
	        firstItem.props = firstItem.props.slice(i + 1);
	        var itemRange = firstItem.props[0] || firstItem.valueRange;
	        firstItem.range.start = itemRange.start;
	        break;
	      }
	    }

	    _this.items = [firstItem];
	    var ec = grabCollectionEndComments(firstItem);
	    if (ec) Array.prototype.push.apply(_this.items, ec);
	    return _this;
	  }

	  (0, _createClass2.default)(Collection, [{
	    key: "parse",

	    /**
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this
	     */
	    value: function parse(context, start) {
	      this.context = context;
	      var parseNode = context.parseNode,
	          src = context.src; // It's easier to recalculate lineStart here rather than tracking down the
	      // last context from which to read it -- eemeli/yaml#2

	      var lineStart = _Node2.default.startOfLine(src, start);

	      var firstItem = this.items[0]; // First-item context needs to be correct for later comment handling
	      // -- eemeli/yaml#17

	      firstItem.context.parent = this;
	      this.valueRange = _Range.default.copy(firstItem.valueRange);
	      var indent = firstItem.range.start - firstItem.context.lineStart;
	      var offset = start;
	      offset = _Node2.default.normalizeOffset(src, offset);
	      var ch = src[offset];
	      var atLineStart = _Node2.default.endOfWhiteSpace(src, lineStart) === offset;
	      var prevIncludesTrailingLines = false;

	      while (ch) {
	        while (ch === '\n' || ch === '#') {
	          if (atLineStart && ch === '\n' && !prevIncludesTrailingLines) {
	            var blankLine = new _BlankLine.default();
	            offset = blankLine.parse({
	              src: src
	            }, offset);
	            this.valueRange.end = offset;

	            if (offset >= src.length) {
	              ch = null;
	              break;
	            }

	            this.items.push(blankLine);
	            offset -= 1; // blankLine.parse() consumes terminal newline
	          } else if (ch === '#') {
	            if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {
	              return offset;
	            }

	            var comment = new _Comment.default();
	            offset = comment.parse({
	              indent: indent,
	              lineStart: lineStart,
	              src: src
	            }, offset);
	            this.items.push(comment);
	            this.valueRange.end = offset;

	            if (offset >= src.length) {
	              ch = null;
	              break;
	            }
	          }

	          lineStart = offset + 1;
	          offset = _Node2.default.endOfIndent(src, lineStart);

	          if (_Node2.default.atBlank(src, offset)) {
	            var wsEnd = _Node2.default.endOfWhiteSpace(src, offset);

	            var next = src[wsEnd];

	            if (!next || next === '\n' || next === '#') {
	              offset = wsEnd;
	            }
	          }

	          ch = src[offset];
	          atLineStart = true;
	        }

	        if (!ch) {
	          break;
	        }

	        if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {
	          if (lineStart > start) offset = lineStart;
	          break;
	        }

	        if (firstItem.type === constants.Type.SEQ_ITEM !== (ch === '-')) {
	          var typeswitch = true;

	          if (ch === '-') {
	            // map key may start with -, as long as it's followed by a non-whitespace char
	            var _next = src[offset + 1];
	            typeswitch = !_next || _next === '\n' || _next === '\t' || _next === ' ';
	          }

	          if (typeswitch) {
	            if (lineStart > start) offset = lineStart;
	            break;
	          }
	        }

	        var node = parseNode({
	          atLineStart: atLineStart,
	          inCollection: true,
	          indent: indent,
	          lineStart: lineStart,
	          parent: this
	        }, offset);
	        if (!node) return offset; // at next document start

	        this.items.push(node);
	        this.valueRange.end = node.valueRange.end;
	        offset = _Node2.default.normalizeOffset(src, node.range.end);
	        ch = src[offset];
	        atLineStart = false;
	        prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range
	        // has advanced to check the current line's indentation level
	        // -- eemeli/yaml#10 & eemeli/yaml#38

	        if (ch) {
	          var ls = offset - 1;
	          var prev = src[ls];

	          while (prev === ' ' || prev === '\t') {
	            prev = src[--ls];
	          }

	          if (prev === '\n') {
	            lineStart = ls + 1;
	            atLineStart = true;
	          }
	        }

	        var ec = grabCollectionEndComments(node);
	        if (ec) Array.prototype.push.apply(this.items, ec);
	      }

	      return offset;
	    }
	  }, {
	    key: "setOrigRanges",
	    value: function setOrigRanges(cr, offset) {
	      offset = (0, _get2.default)((0, _getPrototypeOf2.default)(Collection.prototype), "setOrigRanges", this).call(this, cr, offset);
	      this.items.forEach(function (node) {
	        offset = node.setOrigRanges(cr, offset);
	      });
	      return offset;
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      var src = this.context.src,
	          items = this.items,
	          range = this.range,
	          value = this.value;
	      if (value != null) return value;
	      var str = src.slice(range.start, items[0].range.start) + String(items[0]);

	      for (var i = 1; i < items.length; ++i) {
	        var item = items[i];
	        var _item$context = item.context,
	            atLineStart = _item$context.atLineStart,
	            indent = _item$context.indent;
	        if (atLineStart) for (var _i = 0; _i < indent; ++_i) {
	          str += ' ';
	        }
	        str += String(item);
	      }

	      return _Node2.default.addStringTerminator(src, range.end, str);
	    }
	  }, {
	    key: "includesTrailingLines",
	    get: function get() {
	      return this.items.length > 0;
	    }
	  }]);
	  return Collection;
	}(_Node2.default);

	exports.default = Collection;
	});

	unwrapExports(Collection_1);
	var Collection_2 = Collection_1.grabCollectionEndComments;

	var Directive_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _inherits2 = interopRequireDefault(inherits$1);



	var _Node2 = interopRequireDefault(Node_1);

	var _Range = interopRequireDefault(Range_1);

	var Directive =
	/*#__PURE__*/
	function (_Node) {
	  (0, _inherits2.default)(Directive, _Node);
	  (0, _createClass2.default)(Directive, null, [{
	    key: "endOfDirective",
	    value: function endOfDirective(src, offset) {
	      var ch = src[offset];

	      while (ch && ch !== '\n' && ch !== '#') {
	        ch = src[offset += 1];
	      } // last char can't be whitespace


	      ch = src[offset - 1];

	      while (ch === ' ' || ch === '\t') {
	        offset -= 1;
	        ch = src[offset - 1];
	      }

	      return offset;
	    }
	  }]);

	  function Directive() {
	    var _this;

	    (0, _classCallCheck2.default)(this, Directive);
	    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Directive).call(this, constants.Type.DIRECTIVE));
	    _this.name = null;
	    return _this;
	  }

	  (0, _createClass2.default)(Directive, [{
	    key: "parseName",
	    value: function parseName(start) {
	      var src = this.context.src;
	      var offset = start;
	      var ch = src[offset];

	      while (ch && ch !== '\n' && ch !== '\t' && ch !== ' ') {
	        ch = src[offset += 1];
	      }

	      this.name = src.slice(start, offset);
	      return offset;
	    }
	  }, {
	    key: "parseParameters",
	    value: function parseParameters(start) {
	      var src = this.context.src;
	      var offset = start;
	      var ch = src[offset];

	      while (ch && ch !== '\n' && ch !== '#') {
	        ch = src[offset += 1];
	      }

	      this.valueRange = new _Range.default(start, offset);
	      return offset;
	    }
	  }, {
	    key: "parse",
	    value: function parse(context, start) {
	      this.context = context;
	      var offset = this.parseName(start + 1);
	      offset = this.parseParameters(offset);
	      offset = this.parseComment(offset);
	      this.range = new _Range.default(start, offset);
	      return offset;
	    }
	  }, {
	    key: "parameters",
	    get: function get() {
	      var raw = this.rawValue;
	      return raw ? raw.trim().split(/[ \t]+/) : [];
	    }
	  }]);
	  return Directive;
	}(_Node2.default);

	exports.default = Directive;
	});

	unwrapExports(Directive_1);

	var Document_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _get2 = interopRequireDefault(get$5);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _inherits2 = interopRequireDefault(inherits$1);





	var _BlankLine = interopRequireDefault(BlankLine_1);



	var _Comment = interopRequireDefault(Comment_1);

	var _Directive = interopRequireDefault(Directive_1);

	var _Node2 = interopRequireDefault(Node_1);

	var _Range = interopRequireDefault(Range_1);

	var Document =
	/*#__PURE__*/
	function (_Node) {
	  (0, _inherits2.default)(Document, _Node);
	  (0, _createClass2.default)(Document, null, [{
	    key: "startCommentOrEndBlankLine",
	    value: function startCommentOrEndBlankLine(src, start) {
	      var offset = _Node2.default.endOfWhiteSpace(src, start);

	      var ch = src[offset];
	      return ch === '#' || ch === '\n' ? offset : start;
	    }
	  }]);

	  function Document() {
	    var _this;

	    (0, _classCallCheck2.default)(this, Document);
	    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Document).call(this, constants.Type.DOCUMENT));
	    _this.directives = null;
	    _this.contents = null;
	    _this.directivesEndMarker = null;
	    _this.documentEndMarker = null;
	    return _this;
	  }

	  (0, _createClass2.default)(Document, [{
	    key: "parseDirectives",
	    value: function parseDirectives(start) {
	      var src = this.context.src;
	      this.directives = [];
	      var atLineStart = true;
	      var hasDirectives = false;
	      var offset = start;

	      while (!_Node2.default.atDocumentBoundary(src, offset, constants.Char.DIRECTIVES_END)) {
	        offset = Document.startCommentOrEndBlankLine(src, offset);

	        switch (src[offset]) {
	          case '\n':
	            if (atLineStart) {
	              var blankLine = new _BlankLine.default();
	              offset = blankLine.parse({
	                src: src
	              }, offset);

	              if (offset < src.length) {
	                this.directives.push(blankLine);
	              }
	            } else {
	              offset += 1;
	              atLineStart = true;
	            }

	            break;

	          case '#':
	            {
	              var comment = new _Comment.default();
	              offset = comment.parse({
	                src: src
	              }, offset);
	              this.directives.push(comment);
	              atLineStart = false;
	            }
	            break;

	          case '%':
	            {
	              var directive = new _Directive.default();
	              offset = directive.parse({
	                parent: this,
	                src: src
	              }, offset);
	              this.directives.push(directive);
	              hasDirectives = true;
	              atLineStart = false;
	            }
	            break;

	          default:
	            if (hasDirectives) {
	              this.error = new errors.YAMLSemanticError(this, 'Missing directives-end indicator line');
	            } else if (this.directives.length > 0) {
	              this.contents = this.directives;
	              this.directives = [];
	            }

	            return offset;
	        }
	      }

	      if (src[offset]) {
	        this.directivesEndMarker = new _Range.default(offset, offset + 3);
	        return offset + 3;
	      }

	      if (hasDirectives) {
	        this.error = new errors.YAMLSemanticError(this, 'Missing directives-end indicator line');
	      } else if (this.directives.length > 0) {
	        this.contents = this.directives;
	        this.directives = [];
	      }

	      return offset;
	    }
	  }, {
	    key: "parseContents",
	    value: function parseContents(start) {
	      var _this$context = this.context,
	          parseNode = _this$context.parseNode,
	          src = _this$context.src;
	      if (!this.contents) this.contents = [];
	      var lineStart = start;

	      while (src[lineStart - 1] === '-') {
	        lineStart -= 1;
	      }

	      var offset = _Node2.default.endOfWhiteSpace(src, start);

	      var atLineStart = lineStart === start;
	      this.valueRange = new _Range.default(offset);

	      while (!_Node2.default.atDocumentBoundary(src, offset, constants.Char.DOCUMENT_END)) {
	        switch (src[offset]) {
	          case '\n':
	            if (atLineStart) {
	              var blankLine = new _BlankLine.default();
	              offset = blankLine.parse({
	                src: src
	              }, offset);

	              if (offset < src.length) {
	                this.contents.push(blankLine);
	              }
	            } else {
	              offset += 1;
	              atLineStart = true;
	            }

	            lineStart = offset;
	            break;

	          case '#':
	            {
	              var comment = new _Comment.default();
	              offset = comment.parse({
	                src: src
	              }, offset);
	              this.contents.push(comment);
	              atLineStart = false;
	            }
	            break;

	          default:
	            {
	              var iEnd = _Node2.default.endOfIndent(src, offset);

	              var context = {
	                atLineStart: atLineStart,
	                indent: -1,
	                inFlow: false,
	                inCollection: false,
	                lineStart: lineStart,
	                parent: this
	              };
	              var node = parseNode(context, iEnd);
	              if (!node) return this.valueRange.end = iEnd; // at next document start

	              this.contents.push(node);
	              offset = node.range.end;
	              atLineStart = false;
	              var ec = (0, Collection_1.grabCollectionEndComments)(node);
	              if (ec) Array.prototype.push.apply(this.contents, ec);
	            }
	        }

	        offset = Document.startCommentOrEndBlankLine(src, offset);
	      }

	      this.valueRange.end = offset;

	      if (src[offset]) {
	        this.documentEndMarker = new _Range.default(offset, offset + 3);
	        offset += 3;

	        if (src[offset]) {
	          offset = _Node2.default.endOfWhiteSpace(src, offset);

	          if (src[offset] === '#') {
	            var _comment = new _Comment.default();

	            offset = _comment.parse({
	              src: src
	            }, offset);
	            this.contents.push(_comment);
	          }

	          switch (src[offset]) {
	            case '\n':
	              offset += 1;
	              break;

	            case undefined:
	              break;

	            default:
	              this.error = new errors.YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');
	          }
	        }
	      }

	      return offset;
	    }
	    /**
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this
	     */

	  }, {
	    key: "parse",
	    value: function parse(context, start) {
	      context.root = this;
	      this.context = context;
	      var src = context.src;
	      var offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM

	      offset = this.parseDirectives(offset);
	      offset = this.parseContents(offset);
	      return offset;
	    }
	  }, {
	    key: "setOrigRanges",
	    value: function setOrigRanges(cr, offset) {
	      offset = (0, _get2.default)((0, _getPrototypeOf2.default)(Document.prototype), "setOrigRanges", this).call(this, cr, offset);
	      this.directives.forEach(function (node) {
	        offset = node.setOrigRanges(cr, offset);
	      });
	      if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);
	      this.contents.forEach(function (node) {
	        offset = node.setOrigRanges(cr, offset);
	      });
	      if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);
	      return offset;
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      var contents = this.contents,
	          directives = this.directives,
	          value = this.value;
	      if (value != null) return value;
	      var str = directives.join('');

	      if (contents.length > 0) {
	        if (directives.length > 0 || contents[0].type === constants.Type.COMMENT) str += '---\n';
	        str += contents.join('');
	      }

	      if (str[str.length - 1] !== '\n') str += '\n';
	      return str;
	    }
	  }]);
	  return Document;
	}(_Node2.default);

	exports.default = Document;
	});

	unwrapExports(Document_1);

	var Alias_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _inherits2 = interopRequireDefault(inherits$1);

	var _Node2 = interopRequireDefault(Node_1);

	var _Range = interopRequireDefault(Range_1);

	var Alias =
	/*#__PURE__*/
	function (_Node) {
	  (0, _inherits2.default)(Alias, _Node);

	  function Alias() {
	    (0, _classCallCheck2.default)(this, Alias);
	    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Alias).apply(this, arguments));
	  }

	  (0, _createClass2.default)(Alias, [{
	    key: "parse",

	    /**
	     * Parses an *alias from the source
	     *
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this scalar
	     */
	    value: function parse(context, start) {
	      this.context = context;
	      var src = context.src;

	      var offset = _Node2.default.endOfIdentifier(src, start + 1);

	      this.valueRange = new _Range.default(start + 1, offset);
	      offset = _Node2.default.endOfWhiteSpace(src, offset);
	      offset = this.parseComment(offset);
	      return offset;
	    }
	  }]);
	  return Alias;
	}(_Node2.default);

	exports.default = Alias;
	});

	unwrapExports(Alias_1);

	var BlockValue_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = exports.Chomp = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _get2 = interopRequireDefault(get$5);

	var _inherits2 = interopRequireDefault(inherits$1);



	var _Node2 = interopRequireDefault(Node_1);

	var _Range = interopRequireDefault(Range_1);

	var Chomp = {
	  CLIP: 'CLIP',
	  KEEP: 'KEEP',
	  STRIP: 'STRIP'
	};
	exports.Chomp = Chomp;

	var BlockValue =
	/*#__PURE__*/
	function (_Node) {
	  (0, _inherits2.default)(BlockValue, _Node);

	  function BlockValue(type, props) {
	    var _this;

	    (0, _classCallCheck2.default)(this, BlockValue);
	    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(BlockValue).call(this, type, props));
	    _this.blockIndent = null;
	    _this.chomping = Chomp.CLIP;
	    _this.header = null;
	    return _this;
	  }

	  (0, _createClass2.default)(BlockValue, [{
	    key: "parseBlockHeader",
	    value: function parseBlockHeader(start) {
	      var src = this.context.src;
	      var offset = start + 1;
	      var bi = '';

	      while (true) {
	        var ch = src[offset];

	        switch (ch) {
	          case '-':
	            this.chomping = Chomp.STRIP;
	            break;

	          case '+':
	            this.chomping = Chomp.KEEP;
	            break;

	          case '0':
	          case '1':
	          case '2':
	          case '3':
	          case '4':
	          case '5':
	          case '6':
	          case '7':
	          case '8':
	          case '9':
	            bi += ch;
	            break;

	          default:
	            this.blockIndent = Number(bi) || null;
	            this.header = new _Range.default(start, offset);
	            return offset;
	        }

	        offset += 1;
	      }
	    }
	  }, {
	    key: "parseBlockValue",
	    value: function parseBlockValue(start) {
	      var _this$context = this.context,
	          indent = _this$context.indent,
	          src = _this$context.src;
	      var offset = start;
	      var valueEnd = start;
	      var bi = this.blockIndent ? indent + this.blockIndent - 1 : indent;
	      var minBlockIndent = 1;

	      for (var ch = src[offset]; ch === '\n'; ch = src[offset]) {
	        offset += 1;
	        if (_Node2.default.atDocumentBoundary(src, offset)) break;

	        var end = _Node2.default.endOfBlockIndent(src, bi, offset); // should not include tab?


	        if (end === null) break;

	        if (!this.blockIndent) {
	          // no explicit block indent, none yet detected
	          var lineIndent = end - (offset + indent);

	          if (src[end] !== '\n') {
	            // first line with non-whitespace content
	            if (lineIndent < minBlockIndent) {
	              offset -= 1;
	              break;
	            }

	            this.blockIndent = lineIndent;
	            bi = indent + this.blockIndent - 1;
	          } else if (lineIndent > minBlockIndent) {
	            // empty line with more whitespace
	            minBlockIndent = lineIndent;
	          }
	        }

	        if (src[end] === '\n') {
	          offset = end;
	        } else {
	          offset = valueEnd = _Node2.default.endOfLine(src, end);
	        }
	      }

	      if (this.chomping !== Chomp.KEEP) {
	        offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
	      }

	      this.valueRange = new _Range.default(start + 1, offset);
	      return offset;
	    }
	    /**
	     * Parses a block value from the source
	     *
	     * Accepted forms are:
	     * ```
	     * BS
	     * block
	     * lines
	     *
	     * BS #comment
	     * block
	     * lines
	     * ```
	     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
	     * are empty or have an indent level greater than `indent`.
	     *
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this block
	     */

	  }, {
	    key: "parse",
	    value: function parse(context, start) {
	      this.context = context;
	      var src = context.src;
	      var offset = this.parseBlockHeader(start);
	      offset = _Node2.default.endOfWhiteSpace(src, offset);
	      offset = this.parseComment(offset);
	      offset = this.parseBlockValue(offset);
	      return offset;
	    }
	  }, {
	    key: "setOrigRanges",
	    value: function setOrigRanges(cr, offset) {
	      offset = (0, _get2.default)((0, _getPrototypeOf2.default)(BlockValue.prototype), "setOrigRanges", this).call(this, cr, offset);
	      return this.header ? this.header.setOrigRange(cr, offset) : offset;
	    }
	  }, {
	    key: "includesTrailingLines",
	    get: function get() {
	      return this.chomping === Chomp.KEEP;
	    }
	  }, {
	    key: "strValue",
	    get: function get() {
	      if (!this.valueRange || !this.context) return null;
	      var _this$valueRange = this.valueRange,
	          start = _this$valueRange.start,
	          end = _this$valueRange.end;
	      var _this$context2 = this.context,
	          indent = _this$context2.indent,
	          src = _this$context2.src;
	      if (this.valueRange.isEmpty()) return '';
	      var lastNewLine = null;
	      var ch = src[end - 1];

	      while (ch === '\n' || ch === '\t' || ch === ' ') {
	        end -= 1;

	        if (end <= start) {
	          if (this.chomping === Chomp.KEEP) break;else return '';
	        }

	        if (ch === '\n') lastNewLine = end;
	        ch = src[end - 1];
	      }

	      var keepStart = end + 1;

	      if (lastNewLine) {
	        if (this.chomping === Chomp.KEEP) {
	          keepStart = lastNewLine;
	          end = this.valueRange.end;
	        } else {
	          end = lastNewLine;
	        }
	      }

	      var bi = indent + this.blockIndent;
	      var folded = this.type === constants.Type.BLOCK_FOLDED;
	      var atStart = true;
	      var str = '';
	      var sep = '';
	      var prevMoreIndented = false;

	      for (var i = start; i < end; ++i) {
	        for (var j = 0; j < bi; ++j) {
	          if (src[i] !== ' ') break;
	          i += 1;
	        }

	        var _ch = src[i];

	        if (_ch === '\n') {
	          if (sep === '\n') str += '\n';else sep = '\n';
	        } else {
	          var lineEnd = _Node2.default.endOfLine(src, i);

	          var line = src.slice(i, lineEnd);
	          i = lineEnd;

	          if (folded && (_ch === ' ' || _ch === '\t') && i < keepStart) {
	            if (sep === ' ') sep = '\n';else if (!prevMoreIndented && !atStart && sep === '\n') sep = '\n\n';
	            str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')

	            sep = lineEnd < end && src[lineEnd] || '';
	            prevMoreIndented = true;
	          } else {
	            str += sep + line;
	            sep = folded && i < keepStart ? ' ' : '\n';
	            prevMoreIndented = false;
	          }

	          if (atStart && line !== '') atStart = false;
	        }
	      }

	      return this.chomping === Chomp.STRIP ? str : str + '\n';
	    }
	  }]);
	  return BlockValue;
	}(_Node2.default);

	exports.default = BlockValue;
	});

	unwrapExports(BlockValue_1);
	var BlockValue_2 = BlockValue_1.Chomp;

	var FlowCollection_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _get2 = interopRequireDefault(get$5);

	var _inherits2 = interopRequireDefault(inherits$1);





	var _BlankLine = interopRequireDefault(BlankLine_1);

	var _Comment = interopRequireDefault(Comment_1);

	var _Node2 = interopRequireDefault(Node_1);

	var _Range = interopRequireDefault(Range_1);

	var FlowCollection =
	/*#__PURE__*/
	function (_Node) {
	  (0, _inherits2.default)(FlowCollection, _Node);

	  function FlowCollection(type, props) {
	    var _this;

	    (0, _classCallCheck2.default)(this, FlowCollection);
	    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FlowCollection).call(this, type, props));
	    _this.items = null;
	    return _this;
	  }

	  (0, _createClass2.default)(FlowCollection, [{
	    key: "prevNodeIsJsonLike",
	    value: function prevNodeIsJsonLike() {
	      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;
	      var node = this.items[idx - 1];
	      return !!node && (node.jsonLike || node.type === constants.Type.COMMENT && this.nodeIsJsonLike(idx - 1));
	    }
	    /**
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this
	     */

	  }, {
	    key: "parse",
	    value: function parse(context, start) {
	      this.context = context;
	      var parseNode = context.parseNode,
	          src = context.src;
	      var indent = context.indent,
	          lineStart = context.lineStart;
	      var char = src[start]; // { or [

	      this.items = [{
	        char: char,
	        offset: start
	      }];

	      var offset = _Node2.default.endOfWhiteSpace(src, start + 1);

	      char = src[offset];

	      while (char && char !== ']' && char !== '}') {
	        switch (char) {
	          case '\n':
	            {
	              lineStart = offset + 1;

	              var wsEnd = _Node2.default.endOfWhiteSpace(src, lineStart);

	              if (src[wsEnd] === '\n') {
	                var blankLine = new _BlankLine.default();
	                lineStart = blankLine.parse({
	                  src: src
	                }, lineStart);
	                this.items.push(blankLine);
	              }

	              offset = _Node2.default.endOfIndent(src, lineStart);

	              if (offset <= lineStart + indent) {
	                char = src[offset];

	                if (offset < lineStart + indent || char !== ']' && char !== '}') {
	                  var msg = 'Insufficient indentation in flow collection';
	                  this.error = new errors.YAMLSemanticError(this, msg);
	                }
	              }
	            }
	            break;

	          case ',':
	            {
	              this.items.push({
	                char: char,
	                offset: offset
	              });
	              offset += 1;
	            }
	            break;

	          case '#':
	            {
	              var comment = new _Comment.default();
	              offset = comment.parse({
	                src: src
	              }, offset);
	              this.items.push(comment);
	            }
	            break;

	          case '?':
	          case ':':
	            {
	              var next = src[offset + 1];

	              if (next === '\n' || next === '\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace
	              char === ':' && this.prevNodeIsJsonLike()) {
	                this.items.push({
	                  char: char,
	                  offset: offset
	                });
	                offset += 1;
	                break;
	              }
	            }
	          // fallthrough

	          default:
	            {
	              var node = parseNode({
	                atLineStart: false,
	                inCollection: false,
	                inFlow: true,
	                indent: -1,
	                lineStart: lineStart,
	                parent: this
	              }, offset);

	              if (!node) {
	                // at next document start
	                this.valueRange = new _Range.default(start, offset);
	                return offset;
	              }

	              this.items.push(node);
	              offset = _Node2.default.normalizeOffset(src, node.range.end);
	            }
	        }

	        offset = _Node2.default.endOfWhiteSpace(src, offset);
	        char = src[offset];
	      }

	      this.valueRange = new _Range.default(start, offset + 1);

	      if (char) {
	        this.items.push({
	          char: char,
	          offset: offset
	        });
	        offset = _Node2.default.endOfWhiteSpace(src, offset + 1);
	        offset = this.parseComment(offset);
	      }

	      return offset;
	    }
	  }, {
	    key: "setOrigRanges",
	    value: function setOrigRanges(cr, offset) {
	      offset = (0, _get2.default)((0, _getPrototypeOf2.default)(FlowCollection.prototype), "setOrigRanges", this).call(this, cr, offset);
	      this.items.forEach(function (node) {
	        if (node instanceof _Node2.default) {
	          offset = node.setOrigRanges(cr, offset);
	        } else if (cr.length === 0) {
	          node.origOffset = node.offset;
	        } else {
	          var i = offset;

	          while (i < cr.length) {
	            if (cr[i] > node.offset) break;else ++i;
	          }

	          node.origOffset = node.offset + i;
	          offset = i;
	        }
	      });
	      return offset;
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      var src = this.context.src,
	          items = this.items,
	          range = this.range,
	          value = this.value;
	      if (value != null) return value;
	      var nodes = items.filter(function (item) {
	        return item instanceof _Node2.default;
	      });
	      var str = '';
	      var prevEnd = range.start;
	      nodes.forEach(function (node) {
	        var prefix = src.slice(prevEnd, node.range.start);
	        prevEnd = node.range.end;
	        str += prefix + String(node);

	        if (str[str.length - 1] === '\n' && src[prevEnd - 1] !== '\n' && src[prevEnd] === '\n') {
	          // Comment range does not include the terminal newline, but its
	          // stringified value does. Without this fix, newlines at comment ends
	          // get duplicated.
	          prevEnd += 1;
	        }
	      });
	      str += src.slice(prevEnd, range.end);
	      return _Node2.default.addStringTerminator(src, range.end, str);
	    }
	  }]);
	  return FlowCollection;
	}(_Node2.default);

	exports.default = FlowCollection;
	});

	unwrapExports(FlowCollection_1);

	var PlainValue_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _inherits2 = interopRequireDefault(inherits$1);

	var _Node2 = interopRequireDefault(Node_1);

	var _Range = interopRequireDefault(Range_1);

	var PlainValue =
	/*#__PURE__*/
	function (_Node) {
	  (0, _inherits2.default)(PlainValue, _Node);

	  function PlainValue() {
	    (0, _classCallCheck2.default)(this, PlainValue);
	    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PlainValue).apply(this, arguments));
	  }

	  (0, _createClass2.default)(PlainValue, [{
	    key: "parseBlockValue",
	    value: function parseBlockValue(start) {
	      var _this$context = this.context,
	          indent = _this$context.indent,
	          inFlow = _this$context.inFlow,
	          src = _this$context.src;
	      var offset = start;
	      var valueEnd = start;

	      for (var ch = src[offset]; ch === '\n'; ch = src[offset]) {
	        if (_Node2.default.atDocumentBoundary(src, offset + 1)) break;

	        var end = _Node2.default.endOfBlockIndent(src, indent, offset + 1);

	        if (end === null || src[end] === '#') break;

	        if (src[end] === '\n') {
	          offset = end;
	        } else {
	          valueEnd = PlainValue.endOfLine(src, end, inFlow);
	          offset = valueEnd;
	        }
	      }

	      if (this.valueRange.isEmpty()) this.valueRange.start = start;
	      this.valueRange.end = valueEnd;
	      return valueEnd;
	    }
	    /**
	     * Parses a plain value from the source
	     *
	     * Accepted forms are:
	     * ```
	     * #comment
	     *
	     * first line
	     *
	     * first line #comment
	     *
	     * first line
	     * block
	     * lines
	     *
	     * #comment
	     * block
	     * lines
	     * ```
	     * where block lines are empty or have an indent level greater than `indent`.
	     *
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this scalar, may be `\n`
	     */

	  }, {
	    key: "parse",
	    value: function parse(context, start) {
	      this.context = context;
	      var inFlow = context.inFlow,
	          src = context.src;
	      var offset = start;
	      var ch = src[offset];

	      if (ch && ch !== '#' && ch !== '\n') {
	        offset = PlainValue.endOfLine(src, start, inFlow);
	      }

	      this.valueRange = new _Range.default(start, offset);
	      offset = _Node2.default.endOfWhiteSpace(src, offset);
	      offset = this.parseComment(offset);

	      if (!this.hasComment || this.valueRange.isEmpty()) {
	        offset = this.parseBlockValue(offset);
	      }

	      return offset;
	    }
	  }, {
	    key: "strValue",
	    get: function get() {
	      if (!this.valueRange || !this.context) return null;
	      var _this$valueRange = this.valueRange,
	          start = _this$valueRange.start,
	          end = _this$valueRange.end;
	      var src = this.context.src;
	      var ch = src[end - 1];

	      while (start < end && (ch === '\n' || ch === '\t' || ch === ' ')) {
	        ch = src[--end - 1];
	      }

	      ch = src[start];

	      while (start < end && (ch === '\n' || ch === '\t' || ch === ' ')) {
	        ch = src[++start];
	      }

	      var str = '';

	      for (var i = start; i < end; ++i) {
	        var _ch = src[i];

	        if (_ch === '\n') {
	          var _Node$foldNewline = _Node2.default.foldNewline(src, i, -1),
	              fold = _Node$foldNewline.fold,
	              offset = _Node$foldNewline.offset;

	          str += fold;
	          i = offset;
	        } else if (_ch === ' ' || _ch === '\t') {
	          // trim trailing whitespace
	          var wsStart = i;
	          var next = src[i + 1];

	          while (i < end && (next === ' ' || next === '\t')) {
	            i += 1;
	            next = src[i + 1];
	          }

	          if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;
	        } else {
	          str += _ch;
	        }
	      }

	      return str;
	    }
	  }], [{
	    key: "endOfLine",
	    value: function endOfLine(src, start, inFlow) {
	      var ch = src[start];
	      var offset = start;

	      while (ch && ch !== '\n') {
	        if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;
	        var next = src[offset + 1];
	        if (ch === ':' && (!next || next === '\n' || next === '\t' || next === ' ' || inFlow && next === ',')) break;
	        if ((ch === ' ' || ch === '\t') && next === '#') break;
	        offset += 1;
	        ch = next;
	      }

	      return offset;
	    }
	  }]);
	  return PlainValue;
	}(_Node2.default);

	exports.default = PlainValue;
	});

	unwrapExports(PlainValue_1);

	var QuoteDouble_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _inherits2 = interopRequireDefault(inherits$1);



	var _Node2 = interopRequireDefault(Node_1);

	var _Range = interopRequireDefault(Range_1);

	var QuoteDouble =
	/*#__PURE__*/
	function (_Node) {
	  (0, _inherits2.default)(QuoteDouble, _Node);

	  function QuoteDouble() {
	    (0, _classCallCheck2.default)(this, QuoteDouble);
	    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(QuoteDouble).apply(this, arguments));
	  }

	  (0, _createClass2.default)(QuoteDouble, [{
	    key: "parseCharCode",
	    value: function parseCharCode(offset, length, errors$1) {
	      var src = this.context.src;
	      var cc = src.substr(offset, length);
	      var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
	      var code = ok ? parseInt(cc, 16) : NaN;

	      if (isNaN(code)) {
	        errors$1.push(new errors.YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(offset - 2, length + 2))));
	        return src.substr(offset - 2, length + 2);
	      }

	      return String.fromCodePoint(code);
	    }
	    /**
	     * Parses a "double quoted" value from the source
	     *
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this scalar
	     */

	  }, {
	    key: "parse",
	    value: function parse(context, start) {
	      this.context = context;
	      var src = context.src;
	      var offset = QuoteDouble.endOfQuote(src, start + 1);
	      this.valueRange = new _Range.default(start, offset);
	      offset = _Node2.default.endOfWhiteSpace(src, offset);
	      offset = this.parseComment(offset);
	      return offset;
	    }
	  }, {
	    key: "strValue",

	    /**
	     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
	     */
	    get: function get() {
	      if (!this.valueRange || !this.context) return null;
	      var errors$1 = [];
	      var _this$valueRange = this.valueRange,
	          start = _this$valueRange.start,
	          end = _this$valueRange.end;
	      var _this$context = this.context,
	          indent = _this$context.indent,
	          src = _this$context.src;
	      if (src[end - 1] !== '"') errors$1.push(new errors.YAMLSyntaxError(this, 'Missing closing "quote')); // Using String#replace is too painful with escaped newlines preceded by
	      // escaped backslashes; also, this should be faster.

	      var str = '';

	      for (var i = start + 1; i < end - 1; ++i) {
	        var ch = src[i];

	        if (ch === '\n') {
	          if (_Node2.default.atDocumentBoundary(src, i + 1)) errors$1.push(new errors.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));

	          var _Node$foldNewline = _Node2.default.foldNewline(src, i, indent),
	              fold = _Node$foldNewline.fold,
	              offset = _Node$foldNewline.offset,
	              error = _Node$foldNewline.error;

	          str += fold;
	          i = offset;
	          if (error) errors$1.push(new errors.YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));
	        } else if (ch === '\\') {
	          i += 1;

	          switch (src[i]) {
	            case '0':
	              str += '\0';
	              break;
	            // null character

	            case 'a':
	              str += '\x07';
	              break;
	            // bell character

	            case 'b':
	              str += '\b';
	              break;
	            // backspace

	            case 'e':
	              str += '\x1b';
	              break;
	            // escape character

	            case 'f':
	              str += '\f';
	              break;
	            // form feed

	            case 'n':
	              str += '\n';
	              break;
	            // line feed

	            case 'r':
	              str += '\r';
	              break;
	            // carriage return

	            case 't':
	              str += '\t';
	              break;
	            // horizontal tab

	            case 'v':
	              str += '\v';
	              break;
	            // vertical tab

	            case 'N':
	              str += "\x85";
	              break;
	            // Unicode next line

	            case '_':
	              str += "\xA0";
	              break;
	            // Unicode non-breaking space

	            case 'L':
	              str += "\u2028";
	              break;
	            // Unicode line separator

	            case 'P':
	              str += "\u2029";
	              break;
	            // Unicode paragraph separator

	            case ' ':
	              str += ' ';
	              break;

	            case '"':
	              str += '"';
	              break;

	            case '/':
	              str += '/';
	              break;

	            case '\\':
	              str += '\\';
	              break;

	            case '\t':
	              str += '\t';
	              break;

	            case 'x':
	              str += this.parseCharCode(i + 1, 2, errors$1);
	              i += 2;
	              break;

	            case 'u':
	              str += this.parseCharCode(i + 1, 4, errors$1);
	              i += 4;
	              break;

	            case 'U':
	              str += this.parseCharCode(i + 1, 8, errors$1);
	              i += 8;
	              break;

	            case '\n':
	              // skip escaped newlines, but still trim the following line
	              while (src[i + 1] === ' ' || src[i + 1] === '\t') {
	                i += 1;
	              }

	              break;

	            default:
	              errors$1.push(new errors.YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(i - 1, 2))));
	              str += '\\' + src[i];
	          }
	        } else if (ch === ' ' || ch === '\t') {
	          // trim trailing whitespace
	          var wsStart = i;
	          var next = src[i + 1];

	          while (next === ' ' || next === '\t') {
	            i += 1;
	            next = src[i + 1];
	          }

	          if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
	        } else {
	          str += ch;
	        }
	      }

	      return errors$1.length > 0 ? {
	        errors: errors$1,
	        str: str
	      } : str;
	    }
	  }], [{
	    key: "endOfQuote",
	    value: function endOfQuote(src, offset) {
	      var ch = src[offset];

	      while (ch && ch !== '"') {
	        offset += ch === '\\' ? 2 : 1;
	        ch = src[offset];
	      }

	      return offset + 1;
	    }
	  }]);
	  return QuoteDouble;
	}(_Node2.default);

	exports.default = QuoteDouble;
	});

	unwrapExports(QuoteDouble_1);

	var QuoteSingle_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _inherits2 = interopRequireDefault(inherits$1);



	var _Node2 = interopRequireDefault(Node_1);

	var _Range = interopRequireDefault(Range_1);

	var QuoteSingle =
	/*#__PURE__*/
	function (_Node) {
	  (0, _inherits2.default)(QuoteSingle, _Node);

	  function QuoteSingle() {
	    (0, _classCallCheck2.default)(this, QuoteSingle);
	    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(QuoteSingle).apply(this, arguments));
	  }

	  (0, _createClass2.default)(QuoteSingle, [{
	    key: "parse",

	    /**
	     * Parses a 'single quoted' value from the source
	     *
	     * @param {ParseContext} context
	     * @param {number} start - Index of first character
	     * @returns {number} - Index of the character after this scalar
	     */
	    value: function parse(context, start) {
	      this.context = context;
	      var src = context.src;
	      var offset = QuoteSingle.endOfQuote(src, start + 1);
	      this.valueRange = new _Range.default(start, offset);
	      offset = _Node2.default.endOfWhiteSpace(src, offset);
	      offset = this.parseComment(offset);
	      return offset;
	    }
	  }, {
	    key: "strValue",

	    /**
	     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
	     */
	    get: function get() {
	      if (!this.valueRange || !this.context) return null;
	      var errors$1 = [];
	      var _this$valueRange = this.valueRange,
	          start = _this$valueRange.start,
	          end = _this$valueRange.end;
	      var _this$context = this.context,
	          indent = _this$context.indent,
	          src = _this$context.src;
	      if (src[end - 1] !== "'") errors$1.push(new errors.YAMLSyntaxError(this, "Missing closing 'quote"));
	      var str = '';

	      for (var i = start + 1; i < end - 1; ++i) {
	        var ch = src[i];

	        if (ch === '\n') {
	          if (_Node2.default.atDocumentBoundary(src, i + 1)) errors$1.push(new errors.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));

	          var _Node$foldNewline = _Node2.default.foldNewline(src, i, indent),
	              fold = _Node$foldNewline.fold,
	              offset = _Node$foldNewline.offset,
	              error = _Node$foldNewline.error;

	          str += fold;
	          i = offset;
	          if (error) errors$1.push(new errors.YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));
	        } else if (ch === "'") {
	          str += ch;
	          i += 1;
	          if (src[i] !== "'") errors$1.push(new errors.YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));
	        } else if (ch === ' ' || ch === '\t') {
	          // trim trailing whitespace
	          var wsStart = i;
	          var next = src[i + 1];

	          while (next === ' ' || next === '\t') {
	            i += 1;
	            next = src[i + 1];
	          }

	          if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
	        } else {
	          str += ch;
	        }
	      }

	      return errors$1.length > 0 ? {
	        errors: errors$1,
	        str: str
	      } : str;
	    }
	  }], [{
	    key: "endOfQuote",
	    value: function endOfQuote(src, offset) {
	      var ch = src[offset];

	      while (ch) {
	        if (ch === "'") {
	          if (src[offset + 1] !== "'") break;
	          ch = src[offset += 2];
	        } else {
	          ch = src[offset += 1];
	        }
	      }

	      return offset + 1;
	    }
	  }]);
	  return QuoteSingle;
	}(_Node2.default);

	exports.default = QuoteSingle;
	});

	unwrapExports(QuoteSingle_1);

	var ParseContext_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _defineProperty2 = interopRequireDefault(defineProperty$e);





	var _Alias = interopRequireDefault(Alias_1);

	var _BlockValue = interopRequireDefault(BlockValue_1);

	var _Collection = interopRequireDefault(Collection_1);

	var _CollectionItem = interopRequireDefault(CollectionItem_1);

	var _FlowCollection = interopRequireDefault(FlowCollection_1);

	var _Node = interopRequireDefault(Node_1);

	var _PlainValue = interopRequireDefault(PlainValue_1);

	var _QuoteDouble = interopRequireDefault(QuoteDouble_1);

	var _QuoteSingle = interopRequireDefault(QuoteSingle_1);

	var _Range = interopRequireDefault(Range_1);

	/**
	 * @param {boolean} atLineStart - Node starts at beginning of line
	 * @param {boolean} inFlow - true if currently in a flow context
	 * @param {boolean} inCollection - true if currently in a collection context
	 * @param {number} indent - Current level of indentation
	 * @param {number} lineStart - Start of the current line
	 * @param {Node} parent - The parent of the node
	 * @param {string} src - Source of the YAML document
	 */
	var ParseContext =
	/*#__PURE__*/
	function () {
	  (0, _createClass2.default)(ParseContext, null, [{
	    key: "parseType",
	    value: function parseType(src, offset, inFlow) {
	      switch (src[offset]) {
	        case '*':
	          return constants.Type.ALIAS;

	        case '>':
	          return constants.Type.BLOCK_FOLDED;

	        case '|':
	          return constants.Type.BLOCK_LITERAL;

	        case '{':
	          return constants.Type.FLOW_MAP;

	        case '[':
	          return constants.Type.FLOW_SEQ;

	        case '?':
	          return !inFlow && _Node.default.atBlank(src, offset + 1, true) ? constants.Type.MAP_KEY : constants.Type.PLAIN;

	        case ':':
	          return !inFlow && _Node.default.atBlank(src, offset + 1, true) ? constants.Type.MAP_VALUE : constants.Type.PLAIN;

	        case '-':
	          return !inFlow && _Node.default.atBlank(src, offset + 1, true) ? constants.Type.SEQ_ITEM : constants.Type.PLAIN;

	        case '"':
	          return constants.Type.QUOTE_DOUBLE;

	        case "'":
	          return constants.Type.QUOTE_SINGLE;

	        default:
	          return constants.Type.PLAIN;
	      }
	    }
	  }]);

	  function ParseContext() {
	    var _this = this;

	    var orig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	        atLineStart = _ref.atLineStart,
	        inCollection = _ref.inCollection,
	        inFlow = _ref.inFlow,
	        indent = _ref.indent,
	        lineStart = _ref.lineStart,
	        parent = _ref.parent;

	    (0, _classCallCheck2.default)(this, ParseContext);
	    (0, _defineProperty2.default)(this, "parseNode", function (overlay, start) {
	      if (_Node.default.atDocumentBoundary(_this.src, start)) return null;
	      var context = new ParseContext(_this, overlay);

	      var _context$parseProps = context.parseProps(start),
	          props = _context$parseProps.props,
	          type = _context$parseProps.type,
	          valueStart = _context$parseProps.valueStart;

	      var node;

	      switch (type) {
	        case constants.Type.ALIAS:
	          node = new _Alias.default(type, props);
	          break;

	        case constants.Type.BLOCK_FOLDED:
	        case constants.Type.BLOCK_LITERAL:
	          node = new _BlockValue.default(type, props);
	          break;

	        case constants.Type.FLOW_MAP:
	        case constants.Type.FLOW_SEQ:
	          node = new _FlowCollection.default(type, props);
	          break;

	        case constants.Type.MAP_KEY:
	        case constants.Type.MAP_VALUE:
	        case constants.Type.SEQ_ITEM:
	          node = new _CollectionItem.default(type, props);
	          break;

	        case constants.Type.COMMENT:
	        case constants.Type.PLAIN:
	          node = new _PlainValue.default(type, props);
	          break;

	        case constants.Type.QUOTE_DOUBLE:
	          node = new _QuoteDouble.default(type, props);
	          break;

	        case constants.Type.QUOTE_SINGLE:
	          node = new _QuoteSingle.default(type, props);
	          break;

	        default:
	          node.error = new errors.YAMLSyntaxError(node, "Unknown node type: ".concat(JSON.stringify(type)));
	          node.range = new _Range.default(start, start + 1);
	          return node;
	      }

	      var offset = node.parse(context, valueStart);
	      node.range = new _Range.default(start, offset);

	      if (offset <= start) {
	        node.error = new Error("Node#parse consumed no characters");
	        node.error.parseEnd = offset;
	        node.error.source = node;
	        node.range.end = start + 1;
	      }

	      if (context.nodeStartsCollection(node)) {
	        if (!node.error && !context.atLineStart && context.parent.type === constants.Type.DOCUMENT) {
	          node.error = new errors.YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');
	        }

	        var collection = new _Collection.default(node);
	        offset = collection.parse(new ParseContext(context), offset);
	        collection.range = new _Range.default(start, offset);
	        return collection;
	      }

	      return node;
	    });
	    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
	    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
	    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
	    this.indent = indent != null ? indent : orig.indent;
	    this.lineStart = lineStart != null ? lineStart : orig.lineStart;
	    this.parent = parent != null ? parent : orig.parent || {};
	    this.root = orig.root;
	    this.src = orig.src;
	  } // for logging


	  (0, _createClass2.default)(ParseContext, [{
	    key: "nodeStartsCollection",
	    value: function nodeStartsCollection(node) {
	      var inCollection = this.inCollection,
	          inFlow = this.inFlow,
	          src = this.src;
	      if (inCollection || inFlow) return false;
	      if (node instanceof _CollectionItem.default) return true; // check for implicit key

	      var offset = node.range.end;
	      if (src[offset] === '\n' || src[offset - 1] === '\n') return false;
	      offset = _Node.default.endOfWhiteSpace(src, offset);
	      return src[offset] === ':';
	    } // Anchor and tag are before type, which determines the node implementation
	    // class; hence this intermediate step.

	  }, {
	    key: "parseProps",
	    value: function parseProps(offset) {
	      var inFlow = this.inFlow,
	          parent = this.parent,
	          src = this.src;
	      var props = [];
	      var lineHasProps = false;
	      offset = _Node.default.endOfWhiteSpace(src, offset);
	      var ch = src[offset];

	      while (ch === constants.Char.ANCHOR || ch === constants.Char.COMMENT || ch === constants.Char.TAG || ch === '\n') {
	        if (ch === '\n') {
	          var lineStart = offset + 1;

	          var inEnd = _Node.default.endOfIndent(src, lineStart);

	          var indentDiff = inEnd - (lineStart + this.indent);
	          var noIndicatorAsIndent = parent.type === constants.Type.SEQ_ITEM && parent.context.atLineStart;
	          if (!_Node.default.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;
	          this.atLineStart = true;
	          this.lineStart = lineStart;
	          lineHasProps = false;
	          offset = inEnd;
	        } else if (ch === constants.Char.COMMENT) {
	          var end = _Node.default.endOfLine(src, offset + 1);

	          props.push(new _Range.default(offset, end));
	          offset = end;
	        } else {
	          var _end = _Node.default.endOfIdentifier(src, offset + 1);

	          if (ch === constants.Char.TAG && src[_end] === ',' && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset + 1, _end + 13))) {
	            // Let's presume we're dealing with a YAML 1.0 domain tag here, rather
	            // than an empty but 'foo.bar' private-tagged node in a flow collection
	            // followed without whitespace by a plain string starting with a year
	            // or date divided by something.
	            _end = _Node.default.endOfIdentifier(src, _end + 5);
	          }

	          props.push(new _Range.default(offset, _end));
	          lineHasProps = true;
	          offset = _Node.default.endOfWhiteSpace(src, _end);
	        }

	        ch = src[offset];
	      } // '- &a : b' has an anchor on an empty node


	      if (lineHasProps && ch === ':' && _Node.default.atBlank(src, offset + 1, true)) offset -= 1;
	      var type = ParseContext.parseType(src, offset, inFlow);
	      return {
	        props: props,
	        type: type,
	        valueStart: offset
	      };
	    }
	    /**
	     * Parses a node from the source
	     * @param {ParseContext} overlay
	     * @param {number} start - Index of first non-whitespace character for the node
	     * @returns {?Node} - null if at a document boundary
	     */

	  }, {
	    key: "pretty",
	    get: function get() {
	      var obj = {
	        start: "".concat(this.lineStart, " + ").concat(this.indent),
	        in: [],
	        parent: this.parent.type
	      };
	      if (!this.atLineStart) obj.start += ' + N';
	      if (this.inCollection) obj.in.push('collection');
	      if (this.inFlow) obj.in.push('flow');
	      return obj;
	    }
	  }]);
	  return ParseContext;
	}();

	exports.default = ParseContext;
	});

	unwrapExports(ParseContext_1);

	var parse_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = parse;

	var _Document = interopRequireDefault(Document_1);

	var _ParseContext = interopRequireDefault(ParseContext_1);

	// Published as 'yaml/parse-cst'
	function parse(src) {
	  var cr = [];

	  if (src.indexOf('\r') !== -1) {
	    src = src.replace(/\r\n?/g, function (match, offset) {
	      if (match.length > 1) cr.push(offset);
	      return '\n';
	    });
	  }

	  var documents = [];
	  var offset = 0;

	  do {
	    var doc = new _Document.default();
	    var context = new _ParseContext.default({
	      src: src
	    });
	    offset = doc.parse(context, offset);
	    documents.push(doc);
	  } while (offset < src.length);

	  documents.setOrigRanges = function () {
	    if (cr.length === 0) return false;

	    for (var i = 1; i < cr.length; ++i) {
	      cr[i] -= i;
	    }

	    var crOffset = 0;

	    for (var _i = 0; _i < documents.length; ++_i) {
	      crOffset = documents[_i].setOrigRanges(cr, crOffset);
	    }

	    cr.splice(0, cr.length);
	    return true;
	  };

	  documents.toString = function () {
	    return documents.join('...\n');
	  };

	  return documents;
	}
	});

	unwrapExports(parse_1);

	var interopRequireWildcard = createCommonjsModule$1(function (module) {
	function _getRequireWildcardCache() {
	  if (typeof WeakMap !== "function") return null;
	  var cache = new WeakMap();

	  _getRequireWildcardCache = function _getRequireWildcardCache() {
	    return cache;
	  };

	  return cache;
	}

	function _interopRequireWildcard(obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  }

	  if (obj === null || _typeof_1$1(obj) !== "object" && typeof obj !== "function") {
	    return {
	      "default": obj
	    };
	  }

	  var cache = _getRequireWildcardCache();

	  if (cache && cache.has(obj)) {
	    return cache.get(obj);
	  }

	  var newObj = {};
	  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

	  for (var key in obj) {
	    if (Object.prototype.hasOwnProperty.call(obj, key)) {
	      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

	      if (desc && (desc.get || desc.set)) {
	        Object.defineProperty(newObj, key, desc);
	      } else {
	        newObj[key] = obj[key];
	      }
	    }
	  }

	  newObj["default"] = obj;

	  if (cache) {
	    cache.set(obj, newObj);
	  }

	  return newObj;
	}

	module.exports = _interopRequireWildcard;
	});

	unwrapExports(interopRequireWildcard);

	var addComment_1 = createCommonjsModule$1(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.addCommentBefore = addCommentBefore;
	exports.default = addComment;

	function addCommentBefore(str, indent, comment) {
	  if (!comment) return str;
	  var cc = comment.replace(/[\s\S]^/gm, "$&".concat(indent, "#"));
	  return "#".concat(cc, "\n").concat(indent).concat(str);
	}

	function addComment(str, indent, comment) {
	  return !comment ? str : comment.indexOf('\n') === -1 ? "".concat(str, " #").concat(comment) : "".concat(str, "\n") + comment.replace(/^/gm, "".concat(indent || '', "#"));
	}
	});

	unwrapExports(addComment_1);
	var addComment_2 = addComment_1.addCommentBefore;

	var toJSON_1 = createCommonjsModule$1(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = toJSON;

	function toJSON(value, arg, ctx) {
	  if (Array.isArray(value)) return value.map(function (v, i) {
	    return toJSON(v, String(i), ctx);
	  });

	  if (value && typeof value.toJSON === 'function') {
	    var anchor = ctx && ctx.anchors && ctx.anchors.find(function (a) {
	      return a.node === value;
	    });
	    if (anchor) ctx.onCreate = function (res) {
	      anchor.res = res;
	      delete ctx.onCreate;
	    };
	    var res = value.toJSON(arg, ctx);
	    if (anchor && ctx.onCreate) ctx.onCreate(res);
	    return res;
	  }

	  return value;
	}
	});

	unwrapExports(toJSON_1);

	function _iterableToArray$1(iter) {
	  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
	}

	var iterableToArray$1 = _iterableToArray$1;

	function _toArray$1(arr) {
	  return arrayWithHoles$1(arr) || iterableToArray$1(arr) || nonIterableRest$1();
	}

	var toArray$1 = _toArray$1;

	var Node_1$1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var Node = function Node() {
	  (0, _classCallCheck2.default)(this, Node);
	};

	exports.default = Node;
	});

	unwrapExports(Node_1$1);

	var Scalar_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _inherits2 = interopRequireDefault(inherits$1);

	var _toJSON2 = interopRequireDefault(toJSON_1);

	var _Node2 = interopRequireDefault(Node_1$1);

	// Published as 'yaml/scalar'
	var Scalar =
	/*#__PURE__*/
	function (_Node) {
	  (0, _inherits2.default)(Scalar, _Node);

	  function Scalar(value) {
	    var _this;

	    (0, _classCallCheck2.default)(this, Scalar);
	    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Scalar).call(this));
	    _this.value = value;
	    return _this;
	  }

	  (0, _createClass2.default)(Scalar, [{
	    key: "toJSON",
	    value: function toJSON(arg, ctx) {
	      return ctx && ctx.keep ? this.value : (0, _toJSON2.default)(this.value, arg, ctx);
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      return String(this.value);
	    }
	  }]);
	  return Scalar;
	}(_Node2.default);

	exports.default = Scalar;
	});

	unwrapExports(Scalar_1);

	var Pair_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _inherits2 = interopRequireDefault(inherits$1);

	var _typeof2 = interopRequireDefault(_typeof_1$1);

	var _addComment = interopRequireDefault(addComment_1);



	var _toJSON = interopRequireDefault(toJSON_1);

	var _Collection = interopRequireDefault(Collection_1$1);

	var _Node2 = interopRequireDefault(Node_1$1);

	var _Scalar = interopRequireDefault(Scalar_1);

	// Published as 'yaml/pair'
	var stringifyKey = function stringifyKey(key, jsKey, ctx) {
	  if (jsKey === null) return '';
	  if ((0, _typeof2.default)(jsKey) !== 'object') return String(jsKey);
	  if (key instanceof _Node2.default && ctx && ctx.doc) return key.toString({
	    anchors: {},
	    doc: ctx.doc,
	    indent: '',
	    inFlow: true,
	    inStringifyKey: true
	  });
	  return JSON.stringify(jsKey);
	};

	var Pair =
	/*#__PURE__*/
	function (_Node) {
	  (0, _inherits2.default)(Pair, _Node);

	  function Pair(key) {
	    var _this;

	    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    (0, _classCallCheck2.default)(this, Pair);
	    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Pair).call(this));
	    _this.key = key;
	    _this.value = value;
	    _this.type = 'PAIR';
	    return _this;
	  }

	  (0, _createClass2.default)(Pair, [{
	    key: "addToJSMap",
	    value: function addToJSMap(ctx, map) {
	      var key = (0, _toJSON.default)(this.key, '', ctx);

	      if (map instanceof Map) {
	        var value = (0, _toJSON.default)(this.value, key, ctx);
	        map.set(key, value);
	      } else if (map instanceof Set) {
	        map.add(key);
	      } else {
	        var stringKey = stringifyKey(this.key, key, ctx);
	        map[stringKey] = (0, _toJSON.default)(this.value, stringKey, ctx);
	      }

	      return map;
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON(_, ctx) {
	      var pair = ctx && ctx.mapAsMap ? new Map() : {};
	      return this.addToJSMap(ctx, pair);
	    }
	  }, {
	    key: "toString",
	    value: function toString(ctx, onComment, onChompKeep) {
	      if (!ctx || !ctx.doc) return JSON.stringify(this);
	      var simpleKeys = ctx.doc.options.simpleKeys;
	      var key = this.key,
	          value = this.value;
	      var keyComment = key instanceof _Node2.default && key.comment;

	      if (simpleKeys) {
	        if (keyComment) {
	          throw new Error('With simple keys, key nodes cannot have comments');
	        }

	        if (key instanceof _Collection.default) {
	          var msg = 'With simple keys, collection cannot be used as a key value';
	          throw new Error(msg);
	        }
	      }

	      var explicitKey = !simpleKeys && (!key || keyComment || key instanceof _Collection.default || key.type === constants.Type.BLOCK_FOLDED || key.type === constants.Type.BLOCK_LITERAL);
	      var _ctx = ctx,
	          doc = _ctx.doc,
	          indent = _ctx.indent;
	      ctx = Object.assign({}, ctx, {
	        implicitKey: !explicitKey,
	        indent: indent + '  '
	      });
	      var chompKeep = false;
	      var str = doc.schema.stringify(key, ctx, function () {
	        return keyComment = null;
	      }, function () {
	        return chompKeep = true;
	      });
	      str = (0, _addComment.default)(str, ctx.indent, keyComment);

	      if (ctx.allNullValues && !simpleKeys) {
	        if (this.comment) {
	          str = (0, _addComment.default)(str, ctx.indent, this.comment);
	          if (onComment) onComment();
	        } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();

	        return ctx.inFlow ? str : "? ".concat(str);
	      }

	      str = explicitKey ? "? ".concat(str, "\n").concat(indent, ":") : "".concat(str, ":");

	      if (this.comment) {
	        // expected (but not strictly required) to be a single-line comment
	        str = (0, _addComment.default)(str, ctx.indent, this.comment);
	        if (onComment) onComment();
	      }

	      var vcb = '';
	      var valueComment = null;

	      if (value instanceof _Node2.default) {
	        if (value.spaceBefore) vcb = '\n';

	        if (value.commentBefore) {
	          var cs = value.commentBefore.replace(/^/gm, "".concat(ctx.indent, "#"));
	          vcb += "\n".concat(cs);
	        }

	        valueComment = value.comment;
	      } else if (value && (0, _typeof2.default)(value) === 'object') {
	        value = doc.schema.createNode(value, true);
	      }

	      ctx.implicitKey = false;
	      chompKeep = false;
	      var valueStr = doc.schema.stringify(value, ctx, function () {
	        return valueComment = null;
	      }, function () {
	        return chompKeep = true;
	      });
	      var ws = ' ';

	      if (vcb || this.comment) {
	        ws = "".concat(vcb, "\n").concat(ctx.indent);
	      } else if (!explicitKey && value instanceof _Collection.default) {
	        var flow = valueStr[0] === '[' || valueStr[0] === '{';
	        if (!flow || valueStr.includes('\n')) ws = "\n".concat(ctx.indent);
	      }

	      if (chompKeep && !valueComment && onChompKeep) onChompKeep();
	      return (0, _addComment.default)(str + ws + valueStr, ctx.indent, valueComment);
	    }
	  }, {
	    key: "commentBefore",
	    get: function get() {
	      return this.key && this.key.commentBefore;
	    },
	    set: function set(cb) {
	      if (this.key == null) this.key = new _Scalar.default(null);
	      this.key.commentBefore = cb;
	    }
	  }]);
	  return Pair;
	}(_Node2.default);

	exports.default = Pair;
	});

	unwrapExports(Pair_1);

	var Collection_1$1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = exports.isEmptyPath = void 0;

	var _toArray2 = interopRequireDefault(toArray$1);

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf3 = interopRequireDefault(getPrototypeOf$1);

	var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

	var _inherits2 = interopRequireDefault(inherits$1);

	var _defineProperty2 = interopRequireDefault(defineProperty$e);

	var _typeof2 = interopRequireDefault(_typeof_1$1);

	var _addComment = interopRequireDefault(addComment_1);

	var _Node2 = interopRequireDefault(Node_1$1);

	var _Pair = interopRequireDefault(Pair_1);

	var _Scalar = interopRequireDefault(Scalar_1);

	// null, undefined, or an empty non-string iterable (e.g. [])
	var isEmptyPath = function isEmptyPath(path) {
	  return path == null || (0, _typeof2.default)(path) === 'object' && path[Symbol.iterator]().next().done;
	};

	exports.isEmptyPath = isEmptyPath;

	var Collection =
	/*#__PURE__*/
	function (_Node) {
	  (0, _inherits2.default)(Collection, _Node);

	  function Collection() {
	    var _getPrototypeOf2;

	    var _this;

	    (0, _classCallCheck2.default)(this, Collection);

	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(Collection)).call.apply(_getPrototypeOf2, [this].concat(args)));
	    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "items", []);
	    return _this;
	  }

	  (0, _createClass2.default)(Collection, [{
	    key: "addIn",
	    value: function addIn(path, value) {
	      if (isEmptyPath(path)) this.add(value);else {
	        var _path = (0, _toArray2.default)(path),
	            key = _path[0],
	            rest = _path.slice(1);

	        var node = this.get(key, true);
	        if (node instanceof Collection) node.addIn(rest, value);else throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
	      }
	    }
	  }, {
	    key: "deleteIn",
	    value: function deleteIn(_ref) {
	      var _ref2 = (0, _toArray2.default)(_ref),
	          key = _ref2[0],
	          rest = _ref2.slice(1);

	      if (rest.length === 0) return this.delete(key);
	      var node = this.get(key, true);
	      if (node instanceof Collection) return node.deleteIn(rest);else throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
	    }
	  }, {
	    key: "getIn",
	    value: function getIn(_ref3, keepScalar) {
	      var _ref4 = (0, _toArray2.default)(_ref3),
	          key = _ref4[0],
	          rest = _ref4.slice(1);

	      var node = this.get(key, true);
	      if (rest.length === 0) return !keepScalar && node instanceof _Scalar.default ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;
	    }
	  }, {
	    key: "hasAllNullValues",
	    value: function hasAllNullValues() {
	      return this.items.every(function (node) {
	        if (!(node instanceof _Pair.default)) return false;
	        var n = node.value;
	        return n == null || n instanceof _Scalar.default && n.value == null && !n.commentBefore && !n.comment && !n.tag;
	      });
	    }
	  }, {
	    key: "hasIn",
	    value: function hasIn(_ref5) {
	      var _ref6 = (0, _toArray2.default)(_ref5),
	          key = _ref6[0],
	          rest = _ref6.slice(1);

	      if (rest.length === 0) return this.has(key);
	      var node = this.get(key, true);
	      return node instanceof Collection ? node.hasIn(rest) : false;
	    }
	  }, {
	    key: "setIn",
	    value: function setIn(_ref7, value) {
	      var _ref8 = (0, _toArray2.default)(_ref7),
	          key = _ref8[0],
	          rest = _ref8.slice(1);

	      if (rest.length === 0) {
	        this.set(key, value);
	      } else {
	        var node = this.get(key, true);
	        if (node instanceof Collection) node.setIn(rest, value);else throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
	      }
	    } // overridden in implementations

	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      return null;
	    }
	  }, {
	    key: "toString",
	    value: function toString(ctx, _ref9, onComment, onChompKeep) {
	      var _this2 = this;

	      var blockItem = _ref9.blockItem,
	          flowChars = _ref9.flowChars,
	          isMap = _ref9.isMap,
	          itemIndent = _ref9.itemIndent;
	      var _ctx = ctx,
	          doc = _ctx.doc,
	          indent = _ctx.indent;
	      var inFlow = this.type && this.type.substr(0, 4) === 'FLOW' || ctx.inFlow;
	      if (inFlow) itemIndent += '  ';
	      var allNullValues = isMap && this.hasAllNullValues();
	      ctx = Object.assign({}, ctx, {
	        allNullValues: allNullValues,
	        indent: itemIndent,
	        inFlow: inFlow,
	        type: null
	      });
	      var chompKeep = false;
	      var hasItemWithNewLine = false;
	      var nodes = this.items.reduce(function (nodes, item, i) {
	        var comment;

	        if (item) {
	          if (!chompKeep && item.spaceBefore) nodes.push({
	            type: 'comment',
	            str: ''
	          });
	          if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(function (line) {
	            nodes.push({
	              type: 'comment',
	              str: "#".concat(line)
	            });
	          });
	          if (item.comment) comment = item.comment;
	          if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;
	        }

	        chompKeep = false;
	        var str = doc.schema.stringify(item, ctx, function () {
	          return comment = null;
	        }, function () {
	          return chompKeep = true;
	        });
	        if (inFlow && !hasItemWithNewLine && str.includes('\n')) hasItemWithNewLine = true;
	        if (inFlow && i < _this2.items.length - 1) str += ',';
	        str = (0, _addComment.default)(str, itemIndent, comment);
	        if (chompKeep && (comment || inFlow)) chompKeep = false;
	        nodes.push({
	          type: 'item',
	          str: str
	        });
	        return nodes;
	      }, []);
	      var str;

	      if (nodes.length === 0) {
	        str = flowChars.start + flowChars.end;
	      } else if (inFlow) {
	        var start = flowChars.start,
	            end = flowChars.end;
	        var strings = nodes.map(function (n) {
	          return n.str;
	        });

	        if (hasItemWithNewLine || strings.reduce(function (sum, str) {
	          return sum + str.length + 2;
	        }, 2) > Collection.maxFlowStringSingleLineLength) {
	          str = start;
	          var _iteratorNormalCompletion = true;
	          var _didIteratorError = false;
	          var _iteratorError = undefined;

	          try {
	            for (var _iterator = strings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	              var s = _step.value;
	              str += s ? "\n  ".concat(indent).concat(s) : '\n';
	            }
	          } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion && _iterator.return != null) {
	                _iterator.return();
	              }
	            } finally {
	              if (_didIteratorError) {
	                throw _iteratorError;
	              }
	            }
	          }

	          str += "\n".concat(indent).concat(end);
	        } else {
	          str = "".concat(start, " ").concat(strings.join(' '), " ").concat(end);
	        }
	      } else {
	        var _strings = nodes.map(blockItem);

	        str = _strings.shift();
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;

	        try {
	          for (var _iterator2 = _strings[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var _s = _step2.value;
	            str += _s ? "\n".concat(indent).concat(_s) : '\n';
	          }
	        } catch (err) {
	          _didIteratorError2 = true;
	          _iteratorError2 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
	              _iterator2.return();
	            }
	          } finally {
	            if (_didIteratorError2) {
	              throw _iteratorError2;
	            }
	          }
	        }
	      }

	      if (this.comment) {
	        str += '\n' + this.comment.replace(/^/gm, "".concat(indent, "#"));
	        if (onComment) onComment();
	      } else if (chompKeep && onChompKeep) onChompKeep();

	      return str;
	    }
	  }]);
	  return Collection;
	}(_Node2.default);

	exports.default = Collection;
	(0, _defineProperty2.default)(Collection, "maxFlowStringSingleLineLength", 60);
	});

	unwrapExports(Collection_1$1);
	var Collection_2$1 = Collection_1$1.isEmptyPath;

	var Alias_1$1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _inherits2 = interopRequireDefault(inherits$1);

	var _defineProperty2 = interopRequireDefault(defineProperty$e);





	var _toJSON2 = interopRequireDefault(toJSON_1);

	var _Collection = interopRequireDefault(Collection_1$1);

	var _Node2 = interopRequireDefault(Node_1$1);

	var _Pair = interopRequireDefault(Pair_1);

	var getAliasCount = function getAliasCount(node, anchors) {
	  if (node instanceof Alias) {
	    var anchor = anchors.find(function (a) {
	      return a.node === node.source;
	    });
	    return anchor.count * anchor.aliasCount;
	  } else if (node instanceof _Collection.default) {
	    var count = 0;
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = node.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var item = _step.value;
	        var c = getAliasCount(item, anchors);
	        if (c > count) count = c;
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return != null) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }

	    return count;
	  } else if (node instanceof _Pair.default) {
	    var kc = getAliasCount(node.key, anchors);
	    var vc = getAliasCount(node.value, anchors);
	    return Math.max(kc, vc);
	  }

	  return 1;
	};

	var Alias =
	/*#__PURE__*/
	function (_Node) {
	  (0, _inherits2.default)(Alias, _Node);
	  (0, _createClass2.default)(Alias, null, [{
	    key: "stringify",
	    value: function stringify(_ref, _ref2) {
	      var range = _ref.range,
	          source = _ref.source;
	      var anchors = _ref2.anchors,
	          doc = _ref2.doc,
	          implicitKey = _ref2.implicitKey,
	          inStringifyKey = _ref2.inStringifyKey;
	      var anchor = Object.keys(anchors).find(function (a) {
	        return anchors[a] === source;
	      });
	      if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();
	      if (anchor) return "*".concat(anchor).concat(implicitKey ? ' ' : '');
	      var msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';
	      throw new Error("".concat(msg, " [").concat(range, "]"));
	    }
	  }]);

	  function Alias(source) {
	    var _this;

	    (0, _classCallCheck2.default)(this, Alias);
	    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Alias).call(this));
	    _this.source = source;
	    _this.type = constants.Type.ALIAS;
	    return _this;
	  }

	  (0, _createClass2.default)(Alias, [{
	    key: "toJSON",
	    value: function toJSON(arg, ctx) {
	      var _this2 = this;

	      if (!ctx) return (0, _toJSON2.default)(this.source, arg, ctx);
	      var anchors = ctx.anchors,
	          maxAliasCount = ctx.maxAliasCount;
	      var anchor = anchors.find(function (a) {
	        return a.node === _this2.source;
	      });

	      if (!anchor || anchor.res === undefined) {
	        var msg = 'This should not happen: Alias anchor was not resolved?';
	        if (this.cstNode) throw new errors.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);
	      }

	      if (maxAliasCount >= 0) {
	        anchor.count += 1;
	        if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);

	        if (anchor.count * anchor.aliasCount > maxAliasCount) {
	          var _msg = 'Excessive alias count indicates a resource exhaustion attack';
	          if (this.cstNode) throw new errors.YAMLReferenceError(this.cstNode, _msg);else throw new ReferenceError(_msg);
	        }
	      }

	      return anchor.res;
	    } // Only called when stringifying an alias mapping key while constructing
	    // Object output.

	  }, {
	    key: "toString",
	    value: function toString(ctx) {
	      return Alias.stringify(this, ctx);
	    }
	  }, {
	    key: "tag",
	    set: function set(t) {
	      throw new Error('Alias nodes cannot have tags');
	    }
	  }]);
	  return Alias;
	}(_Node2.default);

	exports.default = Alias;
	(0, _defineProperty2.default)(Alias, "default", true);
	});

	unwrapExports(Alias_1$1);

	var _Map$1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.findPair = findPair;
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _get2 = interopRequireDefault(get$5);

	var _inherits2 = interopRequireDefault(inherits$1);

	var _Collection2 = interopRequireDefault(Collection_1$1);

	var _Pair = interopRequireDefault(Pair_1);

	var _Scalar = interopRequireDefault(Scalar_1);

	function findPair(items, key) {
	  var k = key instanceof _Scalar.default ? key.value : key;
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var it = _step.value;

	      if (it instanceof _Pair.default) {
	        if (it.key === key || it.key === k) return it;
	        if (it.key && it.key.value === k) return it;
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return != null) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  return undefined;
	}

	var YAMLMap =
	/*#__PURE__*/
	function (_Collection) {
	  (0, _inherits2.default)(YAMLMap, _Collection);

	  function YAMLMap() {
	    (0, _classCallCheck2.default)(this, YAMLMap);
	    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLMap).apply(this, arguments));
	  }

	  (0, _createClass2.default)(YAMLMap, [{
	    key: "add",
	    value: function add(pair) {
	      if (!pair) pair = new _Pair.default(pair);else if (!(pair instanceof _Pair.default)) pair = new _Pair.default(pair.key || pair, pair.value);
	      var prev = findPair(this.items, pair.key);
	      if (prev) throw new Error("Key ".concat(pair.key, " already set"));
	      this.items.push(pair);
	    }
	  }, {
	    key: "delete",
	    value: function _delete(key) {
	      var it = findPair(this.items, key);
	      if (!it) return false;
	      var del = this.items.splice(this.items.indexOf(it), 1);
	      return del.length > 0;
	    }
	  }, {
	    key: "get",
	    value: function get(key, keepScalar) {
	      var it = findPair(this.items, key);
	      var node = it && it.value;
	      return !keepScalar && node instanceof _Scalar.default ? node.value : node;
	    }
	  }, {
	    key: "has",
	    value: function has(key) {
	      return !!findPair(this.items, key);
	    }
	  }, {
	    key: "set",
	    value: function set(key, value) {
	      var prev = findPair(this.items, key);
	      if (prev) prev.value = value;else this.items.push(new _Pair.default(key, value));
	    }
	    /**
	     * @param {*} arg ignored
	     * @param {*} ctx Conversion context, originally set in Document#toJSON()
	     * @param {Class} Type If set, forces the returned collection type
	     * @returns {*} Instance of Type, Map, or Object
	     */

	  }, {
	    key: "toJSON",
	    value: function toJSON(_, ctx, Type) {
	      var map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};
	      if (ctx && ctx.onCreate) ctx.onCreate(map);
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;

	      try {
	        for (var _iterator2 = this.items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var item = _step2.value;
	          item.addToJSMap(ctx, map);
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }

	      return map;
	    }
	  }, {
	    key: "toString",
	    value: function toString(ctx, onComment, onChompKeep) {
	      if (!ctx) return JSON.stringify(this);
	      var _iteratorNormalCompletion3 = true;
	      var _didIteratorError3 = false;
	      var _iteratorError3 = undefined;

	      try {
	        for (var _iterator3 = this.items[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	          var item = _step3.value;
	          if (!(item instanceof _Pair.default)) throw new Error("Map items must all be pairs; found ".concat(JSON.stringify(item), " instead"));
	        }
	      } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
	            _iterator3.return();
	          }
	        } finally {
	          if (_didIteratorError3) {
	            throw _iteratorError3;
	          }
	        }
	      }

	      return (0, _get2.default)((0, _getPrototypeOf2.default)(YAMLMap.prototype), "toString", this).call(this, ctx, {
	        blockItem: function blockItem(n) {
	          return n.str;
	        },
	        flowChars: {
	          start: '{',
	          end: '}'
	        },
	        isMap: true,
	        itemIndent: ctx.indent || ''
	      }, onComment, onChompKeep);
	    }
	  }]);
	  return YAMLMap;
	}(_Collection2.default);

	exports.default = YAMLMap;
	});

	unwrapExports(_Map$1);
	var _Map_1 = _Map$1.findPair;

	var Seq = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _get2 = interopRequireDefault(get$5);

	var _inherits2 = interopRequireDefault(inherits$1);

	var _toJSON2 = interopRequireDefault(toJSON_1);

	var _Collection2 = interopRequireDefault(Collection_1$1);

	var _Scalar = interopRequireDefault(Scalar_1);

	// Published as 'yaml/seq'
	function asItemIndex(key) {
	  var idx = key instanceof _Scalar.default ? key.value : key;
	  if (idx && typeof idx === 'string') idx = Number(idx);
	  return Number.isInteger(idx) && idx >= 0 ? idx : null;
	}

	var YAMLSeq =
	/*#__PURE__*/
	function (_Collection) {
	  (0, _inherits2.default)(YAMLSeq, _Collection);

	  function YAMLSeq() {
	    (0, _classCallCheck2.default)(this, YAMLSeq);
	    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLSeq).apply(this, arguments));
	  }

	  (0, _createClass2.default)(YAMLSeq, [{
	    key: "add",
	    value: function add(value) {
	      this.items.push(value);
	    }
	  }, {
	    key: "delete",
	    value: function _delete(key) {
	      var idx = asItemIndex(key);
	      if (typeof idx !== 'number') return false;
	      var del = this.items.splice(idx, 1);
	      return del.length > 0;
	    }
	  }, {
	    key: "get",
	    value: function get(key, keepScalar) {
	      var idx = asItemIndex(key);
	      if (typeof idx !== 'number') return undefined;
	      var it = this.items[idx];
	      return !keepScalar && it instanceof _Scalar.default ? it.value : it;
	    }
	  }, {
	    key: "has",
	    value: function has(key) {
	      var idx = asItemIndex(key);
	      return typeof idx === 'number' && idx < this.items.length;
	    }
	  }, {
	    key: "set",
	    value: function set(key, value) {
	      var idx = asItemIndex(key);
	      if (typeof idx !== 'number') throw new Error("Expected a valid index, not ".concat(key, "."));
	      this.items[idx] = value;
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON(_, ctx) {
	      var seq = [];
	      if (ctx && ctx.onCreate) ctx.onCreate(seq);
	      var i = 0;
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var item = _step.value;
	          seq.push((0, _toJSON2.default)(item, String(i++), ctx));
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      return seq;
	    }
	  }, {
	    key: "toString",
	    value: function toString(ctx, onComment, onChompKeep) {
	      if (!ctx) return JSON.stringify(this);
	      return (0, _get2.default)((0, _getPrototypeOf2.default)(YAMLSeq.prototype), "toString", this).call(this, ctx, {
	        blockItem: function blockItem(n) {
	          return n.type === 'comment' ? n.str : "- ".concat(n.str);
	        },
	        flowChars: {
	          start: '[',
	          end: ']'
	        },
	        isMap: false,
	        itemIndent: (ctx.indent || '') + '  '
	      }, onComment, onChompKeep);
	    }
	  }]);
	  return YAMLSeq;
	}(_Collection2.default);

	exports.default = YAMLSeq;
	});

	unwrapExports(Seq);

	var Merge_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = exports.MERGE_KEY = void 0;

	var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _get2 = interopRequireDefault(get$5);

	var _inherits2 = interopRequireDefault(inherits$1);

	var _Map$1$1 = interopRequireDefault(_Map$1);

	var _Pair2 = interopRequireDefault(Pair_1);

	var _Scalar = interopRequireDefault(Scalar_1);

	var _Seq = interopRequireDefault(Seq);

	var MERGE_KEY = '<<';
	exports.MERGE_KEY = MERGE_KEY;

	var Merge =
	/*#__PURE__*/
	function (_Pair) {
	  (0, _inherits2.default)(Merge, _Pair);

	  function Merge(pair) {
	    var _this;

	    (0, _classCallCheck2.default)(this, Merge);

	    if (pair instanceof _Pair2.default) {
	      var seq = pair.value;

	      if (!(seq instanceof _Seq.default)) {
	        seq = new _Seq.default();
	        seq.items.push(pair.value);
	        seq.range = pair.value.range;
	      }

	      _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Merge).call(this, pair.key, seq));
	      _this.range = pair.range;
	    } else {
	      _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Merge).call(this, new _Scalar.default(MERGE_KEY), new _Seq.default()));
	    }

	    _this.type = 'MERGE_PAIR';
	    return (0, _possibleConstructorReturn2.default)(_this);
	  } // If the value associated with a merge key is a single mapping node, each of
	  // its key/value pairs is inserted into the current mapping, unless the key
	  // already exists in it. If the value associated with the merge key is a
	  // sequence, then this sequence is expected to contain mapping nodes and each
	  // of these nodes is merged in turn according to its order in the sequence.
	  // Keys in mapping nodes earlier in the sequence override keys specified in
	  // later mapping nodes. -- http://yaml.org/type/merge.html


	  (0, _createClass2.default)(Merge, [{
	    key: "addToJSMap",
	    value: function addToJSMap(ctx, map) {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = this.value.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var source = _step.value.source;
	          if (!(source instanceof _Map$1$1.default)) throw new Error('Merge sources must be maps');
	          var srcMap = source.toJSON(null, ctx, Map);
	          var _iteratorNormalCompletion2 = true;
	          var _didIteratorError2 = false;
	          var _iteratorError2 = undefined;

	          try {
	            for (var _iterator2 = srcMap[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	              var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),
	                  key = _step2$value[0],
	                  value = _step2$value[1];

	              if (map instanceof Map) {
	                if (!map.has(key)) map.set(key, value);
	              } else if (map instanceof Set) {
	                map.add(key);
	              } else {
	                if (!Object.prototype.hasOwnProperty.call(map, key)) map[key] = value;
	              }
	            }
	          } catch (err) {
	            _didIteratorError2 = true;
	            _iteratorError2 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
	                _iterator2.return();
	              }
	            } finally {
	              if (_didIteratorError2) {
	                throw _iteratorError2;
	              }
	            }
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      return map;
	    }
	  }, {
	    key: "toString",
	    value: function toString(ctx, onComment) {
	      var seq = this.value;
	      if (seq.items.length > 1) return (0, _get2.default)((0, _getPrototypeOf2.default)(Merge.prototype), "toString", this).call(this, ctx, onComment);
	      this.value = seq.items[0];
	      var str = (0, _get2.default)((0, _getPrototypeOf2.default)(Merge.prototype), "toString", this).call(this, ctx, onComment);
	      this.value = seq;
	      return str;
	    }
	  }]);
	  return Merge;
	}(_Pair2.default);

	exports.default = Merge;
	});

	unwrapExports(Merge_1);
	var Merge_2 = Merge_1.MERGE_KEY;

	var Anchors_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _defineProperty2 = interopRequireDefault(defineProperty$e);

	var _Alias = interopRequireDefault(Alias_1$1);

	var _Map$1$1 = interopRequireDefault(_Map$1);

	var _Merge = interopRequireDefault(Merge_1);

	var _Scalar = interopRequireDefault(Scalar_1);

	var _Seq = interopRequireDefault(Seq);

	var Anchors =
	/*#__PURE__*/
	function () {
	  (0, _createClass2.default)(Anchors, null, [{
	    key: "validAnchorNode",
	    value: function validAnchorNode(node) {
	      return node instanceof _Scalar.default || node instanceof _Seq.default || node instanceof _Map$1$1.default;
	    }
	  }]);

	  function Anchors(prefix) {
	    (0, _classCallCheck2.default)(this, Anchors);
	    (0, _defineProperty2.default)(this, "map", {});
	    this.prefix = prefix;
	  }

	  (0, _createClass2.default)(Anchors, [{
	    key: "createAlias",
	    value: function createAlias(node, name) {
	      this.setAnchor(node, name);
	      return new _Alias.default(node);
	    }
	  }, {
	    key: "createMergePair",
	    value: function createMergePair() {
	      var _this = this;

	      var merge = new _Merge.default();

	      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
	        sources[_key] = arguments[_key];
	      }

	      merge.value.items = sources.map(function (s) {
	        if (s instanceof _Alias.default) {
	          if (s.source instanceof _Map$1$1.default) return s;
	        } else if (s instanceof _Map$1$1.default) {
	          return _this.createAlias(s);
	        }

	        throw new Error('Merge sources must be Map nodes or their Aliases');
	      });
	      return merge;
	    }
	  }, {
	    key: "getName",
	    value: function getName(node) {
	      var map = this.map;
	      return Object.keys(map).find(function (a) {
	        return map[a] === node;
	      });
	    }
	  }, {
	    key: "getNode",
	    value: function getNode(name) {
	      return this.map[name];
	    }
	  }, {
	    key: "newName",
	    value: function newName(prefix) {
	      if (!prefix) prefix = this.prefix;
	      var names = Object.keys(this.map);

	      for (var i = 1; true; ++i) {
	        var name = "".concat(prefix).concat(i);
	        if (!names.includes(name)) return name;
	      }
	    } // During parsing, map & aliases contain CST nodes

	  }, {
	    key: "resolveNodes",
	    value: function resolveNodes() {
	      var map = this.map,
	          _cstAliases = this._cstAliases;
	      Object.keys(map).forEach(function (a) {
	        map[a] = map[a].resolved;
	      });

	      _cstAliases.forEach(function (a) {
	        a.source = a.source.resolved;
	      });

	      delete this._cstAliases;
	    }
	  }, {
	    key: "setAnchor",
	    value: function setAnchor(node, name) {
	      if (node != null && !Anchors.validAnchorNode(node)) {
	        throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');
	      }

	      if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
	        throw new Error('Anchor names must not contain whitespace or control characters');
	      }

	      var map = this.map;
	      var prev = node && Object.keys(map).find(function (a) {
	        return map[a] === node;
	      });

	      if (prev) {
	        if (!name) {
	          return prev;
	        } else if (prev !== name) {
	          delete map[prev];
	          map[name] = node;
	        }
	      } else {
	        if (!name) {
	          if (!node) return null;
	          name = this.newName();
	        }

	        map[name] = node;
	      }

	      return name;
	    }
	  }]);
	  return Anchors;
	}();

	exports.default = Anchors;
	});

	unwrapExports(Anchors_1);

	var listTagNames$1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _typeof2 = interopRequireDefault(_typeof_1$1);

	var _Collection = interopRequireDefault(Collection_1$1);

	var _Pair = interopRequireDefault(Pair_1);

	var _Scalar = interopRequireDefault(Scalar_1);

	var visit = function visit(node, tags) {
	  if (node && (0, _typeof2.default)(node) === 'object') {
	    var tag = node.tag;

	    if (node instanceof _Collection.default) {
	      if (tag) tags[tag] = true;
	      node.items.forEach(function (n) {
	        return visit(n, tags);
	      });
	    } else if (node instanceof _Pair.default) {
	      visit(node.key, tags);
	      visit(node.value, tags);
	    } else if (node instanceof _Scalar.default) {
	      if (tag) tags[tag] = true;
	    }
	  }

	  return tags;
	};

	var _default = function _default(node) {
	  return Object.keys(visit(node, {}));
	};

	exports.default = _default;
	});

	unwrapExports(listTagNames$1);

	var warnings = createCommonjsModule$1(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.warn = warn;
	exports.warnFileDeprecation = warnFileDeprecation;
	exports.warnOptionDeprecation = warnOptionDeprecation;

	/* global global, console */
	function warn(warning, type) {
	  if (commonjsGlobal$1 && commonjsGlobal$1._YAML_SILENCE_WARNINGS) return;

	  var _ref = commonjsGlobal$1 && commonjsGlobal$1.process,
	      emitWarning = _ref.emitWarning; // This will throw in Jest if `warning` is an Error instance due to
	  // https://github.com/facebook/jest/issues/2549


	  if (emitWarning) emitWarning(warning, type);else {
	    // eslint-disable-next-line no-console
	    console.warn(type ? "".concat(type, ": ").concat(warning) : warning);
	  }
	}

	function warnFileDeprecation(filename) {
	  if (commonjsGlobal$1 && commonjsGlobal$1._YAML_SILENCE_DEPRECATION_WARNINGS) return;
	  var path = filename.replace(/.*yaml[/\\]/i, '').replace(/\.js$/, '').replace(/\\/g, '/');
	  warn("The endpoint 'yaml/".concat(path, "' will be removed in a future release."), 'DeprecationWarning');
	}

	var warned = {};

	function warnOptionDeprecation(name, alternative) {
	  if (commonjsGlobal$1 && commonjsGlobal$1._YAML_SILENCE_DEPRECATION_WARNINGS) return;
	  if (warned[name]) return;
	  warned[name] = true;
	  var msg = "The option '".concat(name, "' will be removed in a future release");
	  msg += alternative ? ", use '".concat(alternative, "' instead.") : '.';
	  warn(msg, 'DeprecationWarning');
	}
	});

	unwrapExports(warnings);
	var warnings_1 = warnings.warn;
	var warnings_2 = warnings.warnFileDeprecation;
	var warnings_3 = warnings.warnOptionDeprecation;

	var foldFlowLines_1 = createCommonjsModule$1(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = foldFlowLines;
	exports.FOLD_QUOTED = exports.FOLD_BLOCK = exports.FOLD_FLOW = void 0;
	var FOLD_FLOW = 'flow';
	exports.FOLD_FLOW = FOLD_FLOW;
	var FOLD_BLOCK = 'block';
	exports.FOLD_BLOCK = FOLD_BLOCK;
	var FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line
	// returns index of last newline in more-indented block

	exports.FOLD_QUOTED = FOLD_QUOTED;

	var consumeMoreIndentedLines = function consumeMoreIndentedLines(text, i) {
	  var ch = text[i + 1];

	  while (ch === ' ' || ch === '\t') {
	    do {
	      ch = text[i += 1];
	    } while (ch && ch !== '\n');

	    ch = text[i + 1];
	  }

	  return i;
	};
	/**
	 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
	 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
	 * terminated with `\n` and started with `indent`.
	 *
	 * @param {string} text
	 * @param {string} indent
	 * @param {string} [mode='flow'] `'block'` prevents more-indented lines
	 *   from being folded; `'quoted'` allows for `\` escapes, including escaped
	 *   newlines
	 * @param {Object} options
	 * @param {number} [options.indentAtStart] Accounts for leading contents on
	 *   the first line, defaulting to `indent.length`
	 * @param {number} [options.lineWidth=80]
	 * @param {number} [options.minContentWidth=20] Allow highly indented lines to
	 *   stretch the line width
	 * @param {function} options.onFold Called once if the text is folded
	 * @param {function} options.onFold Called once if any line of text exceeds
	 *   lineWidth characters
	 */


	function foldFlowLines(text, indent, mode, _ref) {
	  var indentAtStart = _ref.indentAtStart,
	      _ref$lineWidth = _ref.lineWidth,
	      lineWidth = _ref$lineWidth === void 0 ? 80 : _ref$lineWidth,
	      _ref$minContentWidth = _ref.minContentWidth,
	      minContentWidth = _ref$minContentWidth === void 0 ? 20 : _ref$minContentWidth,
	      onFold = _ref.onFold,
	      onOverflow = _ref.onOverflow;
	  if (!lineWidth || lineWidth < 0) return text;
	  var endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
	  if (text.length <= endStep) return text;
	  var folds = [];
	  var escapedFolds = {};
	  var end = lineWidth - (typeof indentAtStart === 'number' ? indentAtStart : indent.length);
	  var split = undefined;
	  var prev = undefined;
	  var overflow = false;
	  var i = -1;

	  if (mode === FOLD_BLOCK) {
	    i = consumeMoreIndentedLines(text, i);
	    if (i !== -1) end = i + endStep;
	  }

	  for (var ch; ch = text[i += 1];) {
	    if (mode === FOLD_QUOTED && ch === '\\') {
	      switch (text[i + 1]) {
	        case 'x':
	          i += 3;
	          break;

	        case 'u':
	          i += 5;
	          break;

	        case 'U':
	          i += 9;
	          break;

	        default:
	          i += 1;
	      }
	    }

	    if (ch === '\n') {
	      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);
	      end = i + endStep;
	      split = undefined;
	    } else {
	      if (ch === ' ' && prev && prev !== ' ' && prev !== '\n' && prev !== '\t') {
	        // space surrounded by non-space can be replaced with newline + indent
	        var next = text[i + 1];
	        if (next && next !== ' ' && next !== '\n' && next !== '\t') split = i;
	      }

	      if (i >= end) {
	        if (split) {
	          folds.push(split);
	          end = split + endStep;
	          split = undefined;
	        } else if (mode === FOLD_QUOTED) {
	          // white-space collected at end may stretch past lineWidth
	          while (prev === ' ' || prev === '\t') {
	            prev = ch;
	            ch = text[i += 1];
	            overflow = true;
	          } // i - 2 accounts for not-dropped last char + newline-escaping \


	          folds.push(i - 2);
	          escapedFolds[i - 2] = true;
	          end = i - 2 + endStep;
	          split = undefined;
	        } else {
	          overflow = true;
	        }
	      }
	    }

	    prev = ch;
	  }

	  if (overflow && onOverflow) onOverflow();
	  if (folds.length === 0) return text;
	  if (onFold) onFold();
	  var res = text.slice(0, folds[0]);

	  for (var _i = 0; _i < folds.length; ++_i) {
	    var fold = folds[_i];

	    var _end = folds[_i + 1] || text.length;

	    if (mode === FOLD_QUOTED && escapedFolds[fold]) res += "".concat(text[fold], "\\");
	    res += "\n".concat(indent).concat(text.slice(fold + 1, _end));
	  }

	  return res;
	}
	});

	unwrapExports(foldFlowLines_1);
	var foldFlowLines_2 = foldFlowLines_1.FOLD_QUOTED;
	var foldFlowLines_3 = foldFlowLines_1.FOLD_BLOCK;
	var foldFlowLines_4 = foldFlowLines_1.FOLD_FLOW;

	var options = createCommonjsModule$1(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.strOptions = exports.nullOptions = exports.boolOptions = exports.binaryOptions = void 0;



	var binaryOptions = {
	  defaultType: constants.Type.BLOCK_LITERAL,
	  lineWidth: 76
	};
	exports.binaryOptions = binaryOptions;
	var boolOptions = {
	  trueStr: 'true',
	  falseStr: 'false'
	};
	exports.boolOptions = boolOptions;
	var nullOptions = {
	  nullStr: 'null'
	};
	exports.nullOptions = nullOptions;
	var strOptions = {
	  defaultType: constants.Type.PLAIN,
	  doubleQuoted: {
	    jsonEncoding: false,
	    minMultiLineLength: 40
	  },
	  fold: {
	    lineWidth: 80,
	    minContentWidth: 20
	  }
	};
	exports.strOptions = strOptions;
	});

	unwrapExports(options);
	var options_1 = options.strOptions;
	var options_2 = options.nullOptions;
	var options_3 = options.boolOptions;
	var options_4 = options.binaryOptions;

	var stringify$1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.stringifyNumber = stringifyNumber;
	exports.stringifyString = stringifyString;





	var _foldFlowLines = interopRequireWildcard(foldFlowLines_1);



	function stringifyNumber(_ref) {
	  var format = _ref.format,
	      minFractionDigits = _ref.minFractionDigits,
	      tag = _ref.tag,
	      value = _ref.value;
	  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';
	  var n = JSON.stringify(value);

	  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\d/.test(n)) {
	    var i = n.indexOf('.');

	    if (i < 0) {
	      i = n.length;
	      n += '.';
	    }

	    var d = minFractionDigits - (n.length - i - 1);

	    while (d-- > 0) {
	      n += '0';
	    }
	  }

	  return n;
	}

	function lineLengthOverLimit(str, limit) {
	  var strLen = str.length;
	  if (strLen <= limit) return false;

	  for (var i = 0, start = 0; i < strLen; ++i) {
	    if (str[i] === '\n') {
	      if (i - start > limit) return true;
	      start = i + 1;
	      if (strLen - start <= limit) return false;
	    }
	  }

	  return true;
	}

	function doubleQuotedString(value, _ref2) {
	  var implicitKey = _ref2.implicitKey,
	      indent = _ref2.indent;
	  var _strOptions$doubleQuo = options.strOptions.doubleQuoted,
	      jsonEncoding = _strOptions$doubleQuo.jsonEncoding,
	      minMultiLineLength = _strOptions$doubleQuo.minMultiLineLength;
	  var json = JSON.stringify(value);
	  if (jsonEncoding) return json;
	  var str = '';
	  var start = 0;

	  for (var i = 0, ch = json[i]; ch; ch = json[++i]) {
	    if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
	      // space before newline needs to be escaped to not be folded
	      str += json.slice(start, i) + '\\ ';
	      i += 1;
	      start = i;
	      ch = '\\';
	    }

	    if (ch === '\\') switch (json[i + 1]) {
	      case 'u':
	        {
	          str += json.slice(start, i);
	          var code = json.substr(i + 2, 4);

	          switch (code) {
	            case '0000':
	              str += '\\0';
	              break;

	            case '0007':
	              str += '\\a';
	              break;

	            case '000b':
	              str += '\\v';
	              break;

	            case '001b':
	              str += '\\e';
	              break;

	            case '0085':
	              str += '\\N';
	              break;

	            case '00a0':
	              str += '\\_';
	              break;

	            case '2028':
	              str += '\\L';
	              break;

	            case '2029':
	              str += '\\P';
	              break;

	            default:
	              if (code.substr(0, 2) === '00') str += '\\x' + code.substr(2);else str += json.substr(i, 6);
	          }

	          i += 5;
	          start = i + 1;
	        }
	        break;

	      case 'n':
	        if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
	          i += 1;
	        } else {
	          // folding will eat first newline
	          str += json.slice(start, i) + '\n\n';

	          while (json[i + 2] === '\\' && json[i + 3] === 'n' && json[i + 4] !== '"') {
	            str += '\n';
	            i += 2;
	          }

	          str += indent; // space after newline needs to be escaped to not be folded

	          if (json[i + 2] === ' ') str += '\\';
	          i += 1;
	          start = i + 1;
	        }

	        break;

	      default:
	        i += 1;
	    }
	  }

	  str = start ? str + json.slice(start) : json;
	  return implicitKey ? str : (0, _foldFlowLines.default)(str, indent, _foldFlowLines.FOLD_QUOTED, options.strOptions.fold);
	}

	function singleQuotedString(value, ctx) {
	  var indent = ctx.indent,
	      implicitKey = ctx.implicitKey;

	  if (implicitKey) {
	    if (/\n/.test(value)) return doubleQuotedString(value, ctx);
	  } else {
	    // single quoted string can't have leading or trailing whitespace around newline
	    if (/[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
	  }

	  var res = "'" + value.replace(/'/g, "''").replace(/\n+/g, "$&\n".concat(indent)) + "'";
	  return implicitKey ? res : (0, _foldFlowLines.default)(res, indent, _foldFlowLines.FOLD_FLOW, options.strOptions.fold);
	}

	function blockString(_ref3, ctx, onComment, onChompKeep) {
	  var comment = _ref3.comment,
	      type = _ref3.type,
	      value = _ref3.value;

	  // 1. Block can't end in whitespace unless the last line is non-empty.
	  // 2. Strings consisting of only whitespace are best rendered explicitly.
	  if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
	    return doubleQuotedString(value, ctx);
	  }

	  var indent = ctx.indent || (ctx.forceBlockIndent ? ' ' : '');
	  var indentSize = indent ? '2' : '1'; // root is at -1

	  var literal = type === constants.Type.BLOCK_FOLDED ? false : type === constants.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, options.strOptions.fold.lineWidth - indent.length);
	  var header = literal ? '|' : '>';
	  if (!value) return header + '\n';
	  var wsStart = '';
	  var wsEnd = '';
	  value = value.replace(/[\n\t ]*$/, function (ws) {
	    var n = ws.indexOf('\n');

	    if (n === -1) {
	      header += '-'; // strip
	    } else if (value === ws || n !== ws.length - 1) {
	      header += '+'; // keep

	      if (onChompKeep) onChompKeep();
	    }

	    wsEnd = ws.replace(/\n$/, '');
	    return '';
	  }).replace(/^[\n ]*/, function (ws) {
	    if (ws.indexOf(' ') !== -1) header += indentSize;
	    var m = ws.match(/ +$/);

	    if (m) {
	      wsStart = ws.slice(0, -m[0].length);
	      return m[0];
	    } else {
	      wsStart = ws;
	      return '';
	    }
	  });
	  if (wsEnd) wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, "$&".concat(indent));
	  if (wsStart) wsStart = wsStart.replace(/\n+/g, "$&".concat(indent));

	  if (comment) {
	    header += ' #' + comment.replace(/ ?[\r\n]+/g, ' ');
	    if (onComment) onComment();
	  }

	  if (!value) return "".concat(header).concat(indentSize, "\n").concat(indent).concat(wsEnd);

	  if (literal) {
	    value = value.replace(/\n+/g, "$&".concat(indent));
	    return "".concat(header, "\n").concat(indent).concat(wsStart).concat(value).concat(wsEnd);
	  }

	  value = value.replace(/\n+/g, '\n$&').replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
	  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent
	  .replace(/\n+/g, "$&".concat(indent));
	  var body = (0, _foldFlowLines.default)("".concat(wsStart).concat(value).concat(wsEnd), indent, _foldFlowLines.FOLD_BLOCK, options.strOptions.fold);
	  return "".concat(header, "\n").concat(indent).concat(body);
	}

	function plainString(item, ctx, onComment, onChompKeep) {
	  var comment = item.comment,
	      type = item.type,
	      value = item.value;
	  var actualString = ctx.actualString,
	      implicitKey = ctx.implicitKey,
	      indent = ctx.indent,
	      inFlow = ctx.inFlow,
	      tags = ctx.tags;

	  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
	    return doubleQuotedString(value, ctx);
	  }

	  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
	    // not allowed:
	    // - empty string, '-' or '?'
	    // - start with an indicator character (except [?:-]) or /[?-] /
	    // - '\n ', ': ' or ' \n' anywhere
	    // - '#' not preceded by a non-space char
	    // - end with ' ' or ':'
	    return implicitKey || inFlow || value.indexOf('\n') === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
	  }

	  if (!implicitKey && !inFlow && type !== constants.Type.PLAIN && value.indexOf('\n') !== -1) {
	    // Where allowed & type not set explicitly, prefer block style for multiline strings
	    return blockString(item, ctx, onComment, onChompKeep);
	  }

	  var str = value.replace(/\n+/g, "$&\n".concat(indent)); // Verify that output will be parsed as a string, as e.g. plain numbers and
	  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
	  // and others in v1.1.

	  if (actualString && typeof tags.resolveScalar(str).value !== 'string') {
	    return doubleQuotedString(value, ctx);
	  }

	  var body = implicitKey ? str : (0, _foldFlowLines.default)(str, indent, _foldFlowLines.FOLD_FLOW, options.strOptions.fold);

	  if (comment && !inFlow && (body.indexOf('\n') !== -1 || comment.indexOf('\n') !== -1)) {
	    if (onComment) onComment();
	    return (0, addComment_1.addCommentBefore)(body, indent, comment);
	  }

	  return body;
	}

	function stringifyString(item, ctx, onComment, onChompKeep) {
	  var defaultType = options.strOptions.defaultType;
	  var implicitKey = ctx.implicitKey,
	      inFlow = ctx.inFlow;
	  var _item = item,
	      type = _item.type,
	      value = _item.value;

	  if (typeof value !== 'string') {
	    value = String(value);
	    item = Object.assign({}, item, {
	      value: value
	    });
	  }

	  var _stringify = function _stringify(_type) {
	    switch (_type) {
	      case constants.Type.BLOCK_FOLDED:
	      case constants.Type.BLOCK_LITERAL:
	        return blockString(item, ctx, onComment, onChompKeep);

	      case constants.Type.QUOTE_DOUBLE:
	        return doubleQuotedString(value, ctx);

	      case constants.Type.QUOTE_SINGLE:
	        return singleQuotedString(value, ctx);

	      case constants.Type.PLAIN:
	        return plainString(item, ctx, onComment, onChompKeep);

	      default:
	        return null;
	    }
	  };

	  if (type !== constants.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
	    // force double quotes on control characters
	    type = constants.Type.QUOTE_DOUBLE;
	  } else if ((implicitKey || inFlow) && (type === constants.Type.BLOCK_FOLDED || type === constants.Type.BLOCK_LITERAL)) {
	    // should not happen; blocks are not valid inside flow containers
	    type = constants.Type.QUOTE_DOUBLE;
	  }

	  var res = _stringify(type);

	  if (res === null) {
	    res = _stringify(defaultType);
	    if (res === null) throw new Error("Unsupported default string type ".concat(defaultType));
	  }

	  return res;
	}
	});

	unwrapExports(stringify$1);
	var stringify_1 = stringify$1.stringifyNumber;
	var stringify_2 = stringify$1.stringifyString;

	var parseUtils = createCommonjsModule$1(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.checkFlowCollectionEnd = checkFlowCollectionEnd;
	exports.checkKeyLength = checkKeyLength;
	exports.resolveComments = resolveComments;





	function checkFlowCollectionEnd(errors$1, cst) {
	  var char, name;

	  switch (cst.type) {
	    case constants.Type.FLOW_MAP:
	      char = '}';
	      name = 'flow map';
	      break;

	    case constants.Type.FLOW_SEQ:
	      char = ']';
	      name = 'flow sequence';
	      break;

	    default:
	      errors$1.push(new errors.YAMLSemanticError(cst, 'Not a flow collection!?'));
	      return;
	  }

	  var lastItem;

	  for (var i = cst.items.length - 1; i >= 0; --i) {
	    var item = cst.items[i];

	    if (!item || item.type !== constants.Type.COMMENT) {
	      lastItem = item;
	      break;
	    }
	  }

	  if (lastItem && lastItem.char !== char) {
	    var msg = "Expected ".concat(name, " to end with ").concat(char);
	    var err;

	    if (typeof lastItem.offset === 'number') {
	      err = new errors.YAMLSemanticError(cst, msg);
	      err.offset = lastItem.offset + 1;
	    } else {
	      err = new errors.YAMLSemanticError(lastItem, msg);
	      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;
	    }

	    errors$1.push(err);
	  }
	}

	function checkKeyLength(errors$1, node, itemIdx, key, keyStart) {
	  if (!key || typeof keyStart !== 'number') return;
	  var item = node.items[itemIdx];
	  var keyEnd = item && item.range && item.range.start;

	  if (!keyEnd) {
	    for (var i = itemIdx - 1; i >= 0; --i) {
	      var it = node.items[i];

	      if (it && it.range) {
	        keyEnd = it.range.end + 2 * (itemIdx - i);
	        break;
	      }
	    }
	  }

	  if (keyEnd > keyStart + 1024) {
	    var k = String(key).substr(0, 8) + '...' + String(key).substr(-8);
	    errors$1.push(new errors.YAMLSemanticError(node, "The \"".concat(k, "\" key is too long")));
	  }
	}

	function resolveComments(collection, comments) {
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = comments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var _step$value = _step.value,
	          afterKey = _step$value.afterKey,
	          before = _step$value.before,
	          comment = _step$value.comment;
	      var item = collection.items[before];

	      if (!item) {
	        if (comment !== undefined) {
	          if (collection.comment) collection.comment += '\n' + comment;else collection.comment = comment;
	        }
	      } else {
	        if (afterKey && item.value) item = item.value;

	        if (comment === undefined) {
	          if (afterKey || !item.commentBefore) item.spaceBefore = true;
	        } else {
	          if (item.commentBefore) item.commentBefore += '\n' + comment;else item.commentBefore = comment;
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return != null) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	}
	});

	unwrapExports(parseUtils);
	var parseUtils_1 = parseUtils.checkFlowCollectionEnd;
	var parseUtils_2 = parseUtils.checkKeyLength;
	var parseUtils_3 = parseUtils.resolveComments;

	var parseMap_1 = createCommonjsModule$1(function (module, exports) {





	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = parseMap;



	var _PlainValue = interopRequireDefault(PlainValue_1);



	var _Map$1$1 = interopRequireDefault(_Map$1);

	var _Merge = interopRequireWildcard(Merge_1);

	var _Pair = interopRequireDefault(Pair_1);



	var _Alias = interopRequireDefault(Alias_1$1);

	var _Collection = interopRequireDefault(Collection_1$1);

	function parseMap(doc, cst) {
	  if (cst.type !== constants.Type.MAP && cst.type !== constants.Type.FLOW_MAP) {
	    var msg = "A ".concat(cst.type, " node cannot be resolved as a mapping");
	    doc.errors.push(new errors.YAMLSyntaxError(cst, msg));
	    return null;
	  }

	  var _ref = cst.type === constants.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst),
	      comments = _ref.comments,
	      items = _ref.items;

	  var map = new _Map$1$1.default();
	  map.items = items;
	  (0, parseUtils.resolveComments)(map, comments);
	  var hasCollectionKey = false;

	  for (var i = 0; i < items.length; ++i) {
	    var iKey = items[i].key;
	    if (iKey instanceof _Collection.default) hasCollectionKey = true;

	    if (doc.schema.merge && iKey && iKey.value === _Merge.MERGE_KEY) {
	      items[i] = new _Merge.default(items[i]);
	      var sources = items[i].value.items;
	      var error = null;
	      sources.some(function (node) {
	        if (node instanceof _Alias.default) {
	          // During parsing, alias sources are CST nodes; to account for
	          // circular references their resolved values can't be used here.
	          var type = node.source.type;
	          if (type === constants.Type.MAP || type === constants.Type.FLOW_MAP) return false;
	          return error = 'Merge nodes aliases can only point to maps';
	        }

	        return error = 'Merge nodes can only have Alias nodes as values';
	      });
	      if (error) doc.errors.push(new errors.YAMLSemanticError(cst, error));
	    } else {
	      for (var j = i + 1; j < items.length; ++j) {
	        var jKey = items[j].key;

	        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {
	          var _msg = "Map keys must be unique; \"".concat(iKey, "\" is repeated");

	          doc.errors.push(new errors.YAMLSemanticError(cst, _msg));
	          break;
	        }
	      }
	    }
	  }

	  if (hasCollectionKey && !doc.options.mapAsMap) {
	    var warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
	    doc.warnings.push(new errors.YAMLWarning(cst, warn));
	  }

	  cst.resolved = map;
	  return map;
	}

	var valueHasPairComment = function valueHasPairComment(_ref2) {
	  var _ref2$context = _ref2.context,
	      lineStart = _ref2$context.lineStart,
	      node = _ref2$context.node,
	      src = _ref2$context.src,
	      props = _ref2.props;
	  if (props.length === 0) return false;
	  var start = props[0].start;
	  if (node && start > node.valueRange.start) return false;
	  if (src[start] !== constants.Char.COMMENT) return false;

	  for (var i = lineStart; i < start; ++i) {
	    if (src[i] === '\n') return false;
	  }

	  return true;
	};

	function resolvePairComment(item, pair) {
	  if (!valueHasPairComment(item)) return;
	  var comment = item.getPropValue(0, constants.Char.COMMENT, true);
	  var found = false;
	  var cb = pair.value.commentBefore;

	  if (cb && cb.startsWith(comment)) {
	    pair.value.commentBefore = cb.substr(comment.length + 1);
	    found = true;
	  } else {
	    var cc = pair.value.comment;

	    if (!item.node && cc && cc.startsWith(comment)) {
	      pair.value.comment = cc.substr(comment.length + 1);
	      found = true;
	    }
	  }

	  if (found) pair.comment = comment;
	}

	function resolveBlockMapItems(doc, cst) {
	  var comments = [];
	  var items = [];
	  var key = undefined;
	  var keyStart = null;

	  for (var i = 0; i < cst.items.length; ++i) {
	    var item = cst.items[i];

	    switch (item.type) {
	      case constants.Type.BLANK_LINE:
	        comments.push({
	          afterKey: !!key,
	          before: items.length
	        });
	        break;

	      case constants.Type.COMMENT:
	        comments.push({
	          afterKey: !!key,
	          before: items.length,
	          comment: item.comment
	        });
	        break;

	      case constants.Type.MAP_KEY:
	        if (key !== undefined) items.push(new _Pair.default(key));
	        if (item.error) doc.errors.push(item.error);
	        key = doc.resolveNode(item.node);
	        keyStart = null;
	        break;

	      case constants.Type.MAP_VALUE:
	        {
	          if (key === undefined) key = null;
	          if (item.error) doc.errors.push(item.error);

	          if (!item.context.atLineStart && item.node && item.node.type === constants.Type.MAP && !item.node.context.atLineStart) {
	            var msg = 'Nested mappings are not allowed in compact mappings';
	            doc.errors.push(new errors.YAMLSemanticError(item.node, msg));
	          }

	          var valueNode = item.node;

	          if (!valueNode && item.props.length > 0) {
	            // Comments on an empty mapping value need to be preserved, so we
	            // need to construct a minimal empty node here to use instead of the
	            // missing `item.node`. -- eemeli/yaml#19
	            valueNode = new _PlainValue.default(constants.Type.PLAIN, []);
	            valueNode.context = {
	              parent: item,
	              src: item.context.src
	            };
	            var pos = item.range.start + 1;
	            valueNode.range = {
	              start: pos,
	              end: pos
	            };
	            valueNode.valueRange = {
	              start: pos,
	              end: pos
	            };

	            if (typeof item.range.origStart === 'number') {
	              var origPos = item.range.origStart + 1;
	              valueNode.range.origStart = valueNode.range.origEnd = origPos;
	              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
	            }
	          }

	          var pair = new _Pair.default(key, doc.resolveNode(valueNode));
	          resolvePairComment(item, pair);
	          items.push(pair);
	          (0, parseUtils.checkKeyLength)(doc.errors, cst, i, key, keyStart);
	          key = undefined;
	          keyStart = null;
	        }
	        break;

	      default:
	        if (key !== undefined) items.push(new _Pair.default(key));
	        key = doc.resolveNode(item);
	        keyStart = item.range.start;
	        if (item.error) doc.errors.push(item.error);

	        next: for (var j = i + 1;; ++j) {
	          var nextItem = cst.items[j];

	          switch (nextItem && nextItem.type) {
	            case constants.Type.BLANK_LINE:
	            case constants.Type.COMMENT:
	              continue next;

	            case constants.Type.MAP_VALUE:
	              break next;

	            default:
	              doc.errors.push(new errors.YAMLSemanticError(item, 'Implicit map keys need to be followed by map values'));
	              break next;
	          }
	        }

	        if (item.valueRangeContainsNewline) {
	          var _msg2 = 'Implicit map keys need to be on a single line';
	          doc.errors.push(new errors.YAMLSemanticError(item, _msg2));
	        }

	    }
	  }

	  if (key !== undefined) items.push(new _Pair.default(key));
	  return {
	    comments: comments,
	    items: items
	  };
	}

	function resolveFlowMapItems(doc, cst) {
	  var comments = [];
	  var items = [];
	  var key = undefined;
	  var keyStart = null;
	  var explicitKey = false;
	  var next = '{';

	  for (var i = 0; i < cst.items.length; ++i) {
	    (0, parseUtils.checkKeyLength)(doc.errors, cst, i, key, keyStart);
	    var item = cst.items[i];

	    if (typeof item.char === 'string') {
	      var char = item.char,
	          offset = item.offset;

	      if (char === '?' && key === undefined && !explicitKey) {
	        explicitKey = true;
	        next = ':';
	        continue;
	      }

	      if (char === ':') {
	        if (key === undefined) key = null;

	        if (next === ':') {
	          next = ',';
	          continue;
	        }
	      } else {
	        if (explicitKey) {
	          if (key === undefined && char !== ',') key = null;
	          explicitKey = false;
	        }

	        if (key !== undefined) {
	          items.push(new _Pair.default(key));
	          key = undefined;
	          keyStart = null;

	          if (char === ',') {
	            next = ':';
	            continue;
	          }
	        }
	      }

	      if (char === '}') {
	        if (i === cst.items.length - 1) continue;
	      } else if (char === next) {
	        next = ':';
	        continue;
	      }

	      var msg = "Flow map contains an unexpected ".concat(char);
	      var err = new errors.YAMLSyntaxError(cst, msg);
	      err.offset = offset;
	      doc.errors.push(err);
	    } else if (item.type === constants.Type.BLANK_LINE) {
	      comments.push({
	        afterKey: !!key,
	        before: items.length
	      });
	    } else if (item.type === constants.Type.COMMENT) {
	      comments.push({
	        afterKey: !!key,
	        before: items.length,
	        comment: item.comment
	      });
	    } else if (key === undefined) {
	      if (next === ',') doc.errors.push(new errors.YAMLSemanticError(item, 'Separator , missing in flow map'));
	      key = doc.resolveNode(item);
	      keyStart = explicitKey ? null : item.range.start; // TODO: add error for non-explicit multiline plain key
	    } else {
	      if (next !== ',') doc.errors.push(new errors.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));
	      items.push(new _Pair.default(key, doc.resolveNode(item)));
	      key = undefined;
	      explicitKey = false;
	    }
	  }

	  (0, parseUtils.checkFlowCollectionEnd)(doc.errors, cst);
	  if (key !== undefined) items.push(new _Pair.default(key));
	  return {
	    comments: comments,
	    items: items
	  };
	}
	});

	unwrapExports(parseMap_1);

	var map$1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _typeof2 = interopRequireDefault(_typeof_1$1);

	var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

	var _Map$1$1 = interopRequireDefault(_Map$1);

	var _parseMap = interopRequireDefault(parseMap_1);

	function createMap(schema, obj, ctx) {
	  var map = new _Map$1$1.default();

	  if (obj instanceof Map) {
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = obj[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var _step$value = (0, _slicedToArray2.default)(_step.value, 2),
	            key = _step$value[0],
	            value = _step$value[1];

	        map.items.push(schema.createPair(key, value, ctx));
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return != null) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  } else if (obj && (0, _typeof2.default)(obj) === 'object') {
	    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
	      var _key = _Object$keys[_i];
	      map.items.push(schema.createPair(_key, obj[_key], ctx));
	    }
	  }

	  return map;
	}

	var _default = {
	  createNode: createMap,
	  default: true,
	  nodeClass: _Map$1$1.default,
	  tag: 'tag:yaml.org,2002:map',
	  resolve: _parseMap.default
	};
	exports.default = _default;
	});

	unwrapExports(map$1);

	var parseSeq_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = parseSeq;





	var _Pair = interopRequireDefault(Pair_1);



	var _Seq = interopRequireDefault(Seq);

	var _Collection = interopRequireDefault(Collection_1$1);

	function parseSeq(doc, cst) {
	  if (cst.type !== constants.Type.SEQ && cst.type !== constants.Type.FLOW_SEQ) {
	    var msg = "A ".concat(cst.type, " node cannot be resolved as a sequence");
	    doc.errors.push(new errors.YAMLSyntaxError(cst, msg));
	    return null;
	  }

	  var _ref = cst.type === constants.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst),
	      comments = _ref.comments,
	      items = _ref.items;

	  var seq = new _Seq.default();
	  seq.items = items;
	  (0, parseUtils.resolveComments)(seq, comments);

	  if (!doc.options.mapAsMap && items.some(function (it) {
	    return it instanceof _Pair.default && it.key instanceof _Collection.default;
	  })) {
	    var warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
	    doc.warnings.push(new errors.YAMLWarning(cst, warn));
	  }

	  cst.resolved = seq;
	  return seq;
	}

	function resolveBlockSeqItems(doc, cst) {
	  var comments = [];
	  var items = [];

	  for (var i = 0; i < cst.items.length; ++i) {
	    var item = cst.items[i];

	    switch (item.type) {
	      case constants.Type.BLANK_LINE:
	        comments.push({
	          before: items.length
	        });
	        break;

	      case constants.Type.COMMENT:
	        comments.push({
	          comment: item.comment,
	          before: items.length
	        });
	        break;

	      case constants.Type.SEQ_ITEM:
	        if (item.error) doc.errors.push(item.error);
	        items.push(doc.resolveNode(item.node));

	        if (item.hasProps) {
	          var msg = 'Sequence items cannot have tags or anchors before the - indicator';
	          doc.errors.push(new errors.YAMLSemanticError(item, msg));
	        }

	        break;

	      default:
	        if (item.error) doc.errors.push(item.error);
	        doc.errors.push(new errors.YAMLSyntaxError(item, "Unexpected ".concat(item.type, " node in sequence")));
	    }
	  }

	  return {
	    comments: comments,
	    items: items
	  };
	}

	function resolveFlowSeqItems(doc, cst) {
	  var comments = [];
	  var items = [];
	  var explicitKey = false;
	  var key = undefined;
	  var keyStart = null;
	  var next = '[';

	  for (var i = 0; i < cst.items.length; ++i) {
	    var item = cst.items[i];

	    if (typeof item.char === 'string') {
	      var char = item.char,
	          offset = item.offset;

	      if (char !== ':' && (explicitKey || key !== undefined)) {
	        if (explicitKey && key === undefined) key = next ? items.pop() : null;
	        items.push(new _Pair.default(key));
	        explicitKey = false;
	        key = undefined;
	        keyStart = null;
	      }

	      if (char === next) {
	        next = null;
	      } else if (!next && char === '?') {
	        explicitKey = true;
	      } else if (next !== '[' && char === ':' && key === undefined) {
	        if (next === ',') {
	          key = items.pop();

	          if (key instanceof _Pair.default) {
	            var msg = 'Chaining flow sequence pairs is invalid';
	            var err = new errors.YAMLSemanticError(cst, msg);
	            err.offset = offset;
	            doc.errors.push(err);
	          }

	          if (!explicitKey) (0, parseUtils.checkKeyLength)(doc.errors, cst, i, key, keyStart);
	        } else {
	          key = null;
	        }

	        keyStart = null;
	        explicitKey = false; // TODO: add error for non-explicit multiline plain key

	        next = null;
	      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {
	        var _msg = "Flow sequence contains an unexpected ".concat(char);

	        var _err = new errors.YAMLSyntaxError(cst, _msg);

	        _err.offset = offset;
	        doc.errors.push(_err);
	      }
	    } else if (item.type === constants.Type.BLANK_LINE) {
	      comments.push({
	        before: items.length
	      });
	    } else if (item.type === constants.Type.COMMENT) {
	      comments.push({
	        comment: item.comment,
	        before: items.length
	      });
	    } else {
	      if (next) {
	        var _msg2 = "Expected a ".concat(next, " in flow sequence");

	        doc.errors.push(new errors.YAMLSemanticError(item, _msg2));
	      }

	      var value = doc.resolveNode(item);

	      if (key === undefined) {
	        items.push(value);
	      } else {
	        items.push(new _Pair.default(key, value));
	        key = undefined;
	      }

	      keyStart = item.range.start;
	      next = ',';
	    }
	  }

	  (0, parseUtils.checkFlowCollectionEnd)(doc.errors, cst);
	  if (key !== undefined) items.push(new _Pair.default(key));
	  return {
	    comments: comments,
	    items: items
	  };
	}
	});

	unwrapExports(parseSeq_1);

	var seq$1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _parseSeq = interopRequireDefault(parseSeq_1);

	var _Seq = interopRequireDefault(Seq);

	function createSeq(schema, obj, ctx) {
	  var seq = new _Seq.default();

	  if (obj && obj[Symbol.iterator]) {
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = obj[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var it = _step.value;
	        var v = schema.createNode(it, ctx.wrapScalars, null, ctx);
	        seq.items.push(v);
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return != null) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  }

	  return seq;
	}

	var _default = {
	  createNode: createSeq,
	  default: true,
	  nodeClass: _Seq.default,
	  tag: 'tag:yaml.org,2002:seq',
	  resolve: _parseSeq.default
	};
	exports.default = _default;
	});

	unwrapExports(seq$1);

	var string$1 = createCommonjsModule$1(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = exports.resolveString = void 0;





	var resolveString = function resolveString(doc, node) {
	  // on error, will return { str: string, errors: Error[] }
	  var res = node.strValue;
	  if (!res) return '';
	  if (typeof res === 'string') return res;
	  res.errors.forEach(function (error) {
	    if (!error.source) error.source = node;
	    doc.errors.push(error);
	  });
	  return res.str;
	};

	exports.resolveString = resolveString;
	var _default = {
	  identify: function identify(value) {
	    return typeof value === 'string';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:str',
	  resolve: resolveString,
	  stringify: function stringify$1$1(item, ctx, onComment, onChompKeep) {
	    ctx = Object.assign({
	      actualString: true
	    }, ctx);
	    return (0, stringify$1.stringifyString)(item, ctx, onComment, onChompKeep);
	  },
	  options: options.strOptions
	};
	exports.default = _default;
	});

	unwrapExports(string$1);
	var string_1 = string$1.resolveString;

	var failsafe$1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _map = interopRequireDefault(map$1);

	var _seq = interopRequireDefault(seq$1);

	var _string = interopRequireDefault(string$1);

	var _default = [_map.default, _seq.default, _string.default];
	exports.default = _default;
	});

	unwrapExports(failsafe$1);

	var core$1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _Scalar = interopRequireDefault(Scalar_1);



	var _failsafe = interopRequireDefault(failsafe$1);



	var _default = _failsafe.default.concat([{
	  identify: function identify(value) {
	    return value == null;
	  },
	  createNode: function createNode(schema, value, ctx) {
	    return ctx.wrapScalars ? new _Scalar.default(null) : null;
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:null',
	  test: /^(?:~|[Nn]ull|NULL)?$/,
	  resolve: function resolve() {
	    return null;
	  },
	  options: options.nullOptions,
	  stringify: function stringify() {
	    return options.nullOptions.nullStr;
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'boolean';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:bool',
	  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
	  resolve: function resolve(str) {
	    return str[0] === 't' || str[0] === 'T';
	  },
	  options: options.boolOptions,
	  stringify: function stringify(_ref) {
	    var value = _ref.value;
	    return value ? options.boolOptions.trueStr : options.boolOptions.falseStr;
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'OCT',
	  test: /^0o([0-7]+)$/,
	  resolve: function resolve(str, oct) {
	    return parseInt(oct, 8);
	  },
	  stringify: function stringify(_ref2) {
	    var value = _ref2.value;
	    return '0o' + value.toString(8);
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  test: /^[-+]?[0-9]+$/,
	  resolve: function resolve(str) {
	    return parseInt(str, 10);
	  },
	  stringify: stringify$1.stringifyNumber
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'HEX',
	  test: /^0x([0-9a-fA-F]+)$/,
	  resolve: function resolve(str, hex) {
	    return parseInt(hex, 16);
	  },
	  stringify: function stringify(_ref3) {
	    var value = _ref3.value;
	    return '0x' + value.toString(16);
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  test: /^(?:[-+]?\.inf|(\.nan))$/i,
	  resolve: function resolve(str, nan) {
	    return nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
	  },
	  stringify: stringify$1.stringifyNumber
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  format: 'EXP',
	  test: /^[-+]?(?:0|[1-9][0-9]*)(\.[0-9]*)?[eE][-+]?[0-9]+$/,
	  resolve: function resolve(str) {
	    return parseFloat(str);
	  },
	  stringify: function stringify(_ref4) {
	    var value = _ref4.value;
	    return Number(value).toExponential();
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  test: /^[-+]?(?:0|[1-9][0-9]*)\.([0-9]*)$/,
	  resolve: function resolve(str, frac) {
	    var node = new _Scalar.default(parseFloat(str));
	    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;
	    return node;
	  },
	  stringify: stringify$1.stringifyNumber
	}]);

	exports.default = _default;
	});

	unwrapExports(core$1);

	var json$1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _map = interopRequireDefault(map$1);

	var _seq = interopRequireDefault(seq$1);

	var _Scalar = interopRequireDefault(Scalar_1);



	var schema = [_map.default, _seq.default, {
	  identify: function identify(value) {
	    return typeof value === 'string';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:str',
	  resolve: string$1.resolveString,
	  stringify: function stringify(value) {
	    return JSON.stringify(value);
	  }
	}, {
	  identify: function identify(value) {
	    return value == null;
	  },
	  createNode: function createNode(schema, value, ctx) {
	    return ctx.wrapScalars ? new _Scalar.default(null) : null;
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:null',
	  test: /^null$/,
	  resolve: function resolve() {
	    return null;
	  },
	  stringify: function stringify(value) {
	    return JSON.stringify(value);
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'boolean';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:bool',
	  test: /^true$/,
	  resolve: function resolve() {
	    return true;
	  },
	  stringify: function stringify(value) {
	    return JSON.stringify(value);
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'boolean';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:bool',
	  test: /^false$/,
	  resolve: function resolve() {
	    return false;
	  },
	  stringify: function stringify(value) {
	    return JSON.stringify(value);
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  test: /^-?(?:0|[1-9][0-9]*)$/,
	  resolve: function resolve(str) {
	    return parseInt(str, 10);
	  },
	  stringify: function stringify(value) {
	    return JSON.stringify(value);
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
	  resolve: function resolve(str) {
	    return parseFloat(str);
	  },
	  stringify: function stringify(value) {
	    return JSON.stringify(value);
	  }
	}];

	schema.scalarFallback = function (str) {
	  throw new SyntaxError("Unresolved plain scalar ".concat(JSON.stringify(str)));
	};

	var _default = schema;
	exports.default = _default;
	});

	unwrapExports(json$1);

	var lookup$1 = [];
	var revLookup$1 = [];
	var Arr$1 = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	var inited$1 = false;
	function init$1 () {
	  inited$1 = true;
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	  for (var i = 0, len = code.length; i < len; ++i) {
	    lookup$1[i] = code[i];
	    revLookup$1[code.charCodeAt(i)] = i;
	  }

	  revLookup$1['-'.charCodeAt(0)] = 62;
	  revLookup$1['_'.charCodeAt(0)] = 63;
	}

	function toByteArray$1 (b64) {
	  if (!inited$1) {
	    init$1();
	  }
	  var i, j, l, tmp, placeHolders, arr;
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

	  // base64 is 4/3 + up to two characters of the original data
	  arr = new Arr$1(len * 3 / 4 - placeHolders);

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len;

	  var L = 0;

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup$1[b64.charCodeAt(i)] << 18) | (revLookup$1[b64.charCodeAt(i + 1)] << 12) | (revLookup$1[b64.charCodeAt(i + 2)] << 6) | revLookup$1[b64.charCodeAt(i + 3)];
	    arr[L++] = (tmp >> 16) & 0xFF;
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup$1[b64.charCodeAt(i)] << 2) | (revLookup$1[b64.charCodeAt(i + 1)] >> 4);
	    arr[L++] = tmp & 0xFF;
	  } else if (placeHolders === 1) {
	    tmp = (revLookup$1[b64.charCodeAt(i)] << 10) | (revLookup$1[b64.charCodeAt(i + 1)] << 4) | (revLookup$1[b64.charCodeAt(i + 2)] >> 2);
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64$1 (num) {
	  return lookup$1[num >> 18 & 0x3F] + lookup$1[num >> 12 & 0x3F] + lookup$1[num >> 6 & 0x3F] + lookup$1[num & 0x3F]
	}

	function encodeChunk$1 (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
	    output.push(tripletToBase64$1(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray$1 (uint8) {
	  if (!inited$1) {
	    init$1();
	  }
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var output = '';
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk$1(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    output += lookup$1[tmp >> 2];
	    output += lookup$1[(tmp << 4) & 0x3F];
	    output += '==';
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
	    output += lookup$1[tmp >> 10];
	    output += lookup$1[(tmp >> 4) & 0x3F];
	    output += lookup$1[(tmp << 2) & 0x3F];
	    output += '=';
	  }

	  parts.push(output);

	  return parts.join('')
	}

	function read$1 (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	function write$1 (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	}

	var toString$1$1 = {}.toString;

	var isArray$1$1 = Array.isArray || function (arr) {
	  return toString$1$1.call(arr) == '[object Array]';
	};

	var INSPECT_MAX_BYTES$1 = 50;

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer$1.TYPED_ARRAY_SUPPORT = global$1$1.TYPED_ARRAY_SUPPORT !== undefined
	  ? global$1$1.TYPED_ARRAY_SUPPORT
	  : true;

	function kMaxLength$1 () {
	  return Buffer$1.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer$1 (that, length) {
	  if (kMaxLength$1() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length);
	    that.__proto__ = Buffer$1.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer$1(length);
	    }
	    that.length = length;
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer$1 (arg, encodingOrOffset, length) {
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
	    return new Buffer$1(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe$1(this, arg)
	  }
	  return from$1(this, arg, encodingOrOffset, length)
	}

	Buffer$1.poolSize = 8192; // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer$1._augment = function (arr) {
	  arr.__proto__ = Buffer$1.prototype;
	  return arr
	};

	function from$1 (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer$1(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString$1(that, value, encodingOrOffset)
	  }

	  return fromObject$1(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer$1.from = function (value, encodingOrOffset, length) {
	  return from$1(null, value, encodingOrOffset, length)
	};

	if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
	  Buffer$1.__proto__ = Uint8Array;
	}

	function assertSize$1 (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc$1 (that, size, fill, encoding) {
	  assertSize$1(size);
	  if (size <= 0) {
	    return createBuffer$1(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer$1(that, size).fill(fill, encoding)
	      : createBuffer$1(that, size).fill(fill)
	  }
	  return createBuffer$1(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer$1.alloc = function (size, fill, encoding) {
	  return alloc$1(null, size, fill, encoding)
	};

	function allocUnsafe$1 (that, size) {
	  assertSize$1(size);
	  that = createBuffer$1(that, size < 0 ? 0 : checked$1(size) | 0);
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0;
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer$1.allocUnsafe = function (size) {
	  return allocUnsafe$1(null, size)
	};
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer$1.allocUnsafeSlow = function (size) {
	  return allocUnsafe$1(null, size)
	};

	function fromString$1 (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8';
	  }

	  if (!Buffer$1.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength$1(string, encoding) | 0;
	  that = createBuffer$1(that, length);

	  var actual = that.write(string, encoding);

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual);
	  }

	  return that
	}

	function fromArrayLike$1 (that, array) {
	  var length = array.length < 0 ? 0 : checked$1(array.length) | 0;
	  that = createBuffer$1(that, length);
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that
	}

	function fromArrayBuffer$1 (that, array, byteOffset, length) {
	  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array);
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset);
	  } else {
	    array = new Uint8Array(array, byteOffset, length);
	  }

	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array;
	    that.__proto__ = Buffer$1.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike$1(that, array);
	  }
	  return that
	}

	function fromObject$1 (that, obj) {
	  if (internalIsBuffer$1(obj)) {
	    var len = checked$1(obj.length) | 0;
	    that = createBuffer$1(that, len);

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len);
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan$1(obj.length)) {
	        return createBuffer$1(that, 0)
	      }
	      return fromArrayLike$1(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray$1$1(obj.data)) {
	      return fromArrayLike$1(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked$1 (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength$1()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength$1().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	Buffer$1.isBuffer = isBuffer$1$1;
	function internalIsBuffer$1 (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer$1.compare = function compare (a, b) {
	  if (!internalIsBuffer$1(a) || !internalIsBuffer$1(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	Buffer$1.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	};

	Buffer$1.concat = function concat (list, length) {
	  if (!isArray$1$1(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer$1.alloc(0)
	  }

	  var i;
	  if (length === undefined) {
	    length = 0;
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length;
	    }
	  }

	  var buffer = Buffer$1.allocUnsafe(length);
	  var pos = 0;
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i];
	    if (!internalIsBuffer$1(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos);
	    pos += buf.length;
	  }
	  return buffer
	};

	function byteLength$1 (string, encoding) {
	  if (internalIsBuffer$1(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string;
	  }

	  var len = string.length;
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes$1(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes$1(string).length
	      default:
	        if (loweredCase) return utf8ToBytes$1(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	}
	Buffer$1.byteLength = byteLength$1;

	function slowToString$1 (encoding, start, end) {
	  var loweredCase = false;

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0;
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length;
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0;
	  start >>>= 0;

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8';

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice$1(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice$1(this, start, end)

	      case 'ascii':
	        return asciiSlice$1(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice$1(this, start, end)

	      case 'base64':
	        return base64Slice$1(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice$1(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase();
	        loweredCase = true;
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer$1.prototype._isBuffer = true;

	function swap$1 (b, n, m) {
	  var i = b[n];
	  b[n] = b[m];
	  b[m] = i;
	}

	Buffer$1.prototype.swap16 = function swap16 () {
	  var len = this.length;
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap$1(this, i, i + 1);
	  }
	  return this
	};

	Buffer$1.prototype.swap32 = function swap32 () {
	  var len = this.length;
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap$1(this, i, i + 3);
	    swap$1(this, i + 1, i + 2);
	  }
	  return this
	};

	Buffer$1.prototype.swap64 = function swap64 () {
	  var len = this.length;
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap$1(this, i, i + 7);
	    swap$1(this, i + 1, i + 6);
	    swap$1(this, i + 2, i + 5);
	    swap$1(this, i + 3, i + 4);
	  }
	  return this
	};

	Buffer$1.prototype.toString = function toString () {
	  var length = this.length | 0;
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice$1(this, 0, length)
	  return slowToString$1.apply(this, arguments)
	};

	Buffer$1.prototype.equals = function equals (b) {
	  if (!internalIsBuffer$1(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer$1.compare(this, b) === 0
	};

	Buffer$1.prototype.inspect = function inspect () {
	  var str = '';
	  var max = INSPECT_MAX_BYTES$1;
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
	    if (this.length > max) str += ' ... ';
	  }
	  return '<Buffer ' + str + '>'
	};

	Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!internalIsBuffer$1(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0;
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0;
	  }
	  if (thisStart === undefined) {
	    thisStart = 0;
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length;
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0;
	  end >>>= 0;
	  thisStart >>>= 0;
	  thisEnd >>>= 0;

	  if (this === target) return 0

	  var x = thisEnd - thisStart;
	  var y = end - start;
	  var len = Math.min(x, y);

	  var thisCopy = this.slice(thisStart, thisEnd);
	  var targetCopy = target.slice(start, end);

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i];
	      y = targetCopy[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf$1 (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset;
	    byteOffset = 0;
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff;
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000;
	  }
	  byteOffset = +byteOffset;  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1);
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1;
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0;
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer$1.from(val, encoding);
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (internalIsBuffer$1(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf$1(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF; // Search for a byte value [0-255]
	    if (Buffer$1.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf$1(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf$1 (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1;
	  var arrLength = arr.length;
	  var valLength = val.length;

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase();
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2;
	      arrLength /= 2;
	      valLength /= 2;
	      byteOffset /= 2;
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i;
	  if (dir) {
	    var foundIndex = -1;
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i;
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex;
	        foundIndex = -1;
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true;
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false;
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	};

	Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf$1(this, val, byteOffset, encoding, true)
	};

	Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf$1(this, val, byteOffset, encoding, false)
	};

	function hexWrite$1 (buf, string, offset, length) {
	  offset = Number(offset) || 0;
	  var remaining = buf.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = Number(length);
	    if (length > remaining) {
	      length = remaining;
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length;
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2;
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16);
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed;
	  }
	  return i
	}

	function utf8Write$1 (buf, string, offset, length) {
	  return blitBuffer$1(utf8ToBytes$1(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite$1 (buf, string, offset, length) {
	  return blitBuffer$1(asciiToBytes$1(string), buf, offset, length)
	}

	function latin1Write$1 (buf, string, offset, length) {
	  return asciiWrite$1(buf, string, offset, length)
	}

	function base64Write$1 (buf, string, offset, length) {
	  return blitBuffer$1(base64ToBytes$1(string), buf, offset, length)
	}

	function ucs2Write$1 (buf, string, offset, length) {
	  return blitBuffer$1(utf16leToBytes$1(string, buf.length - offset), buf, offset, length)
	}

	Buffer$1.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8';
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset;
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0;
	    if (isFinite(length)) {
	      length = length | 0;
	      if (encoding === undefined) encoding = 'utf8';
	    } else {
	      encoding = length;
	      length = undefined;
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset;
	  if (length === undefined || length > remaining) length = remaining;

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8';

	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite$1(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write$1(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite$1(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write$1(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write$1(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write$1(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	};

	Buffer$1.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	};

	function base64Slice$1 (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return fromByteArray$1(buf)
	  } else {
	    return fromByteArray$1(buf.slice(start, end))
	  }
	}

	function utf8Slice$1 (buf, start, end) {
	  end = Math.min(buf.length, end);
	  var res = [];

	  var i = start;
	  while (i < end) {
	    var firstByte = buf[i];
	    var codePoint = null;
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1;

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint;

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte;
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1];
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          fourthByte = buf[i + 3];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint;
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD;
	      bytesPerSequence = 1;
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000;
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	      codePoint = 0xDC00 | codePoint & 0x3FF;
	    }

	    res.push(codePoint);
	    i += bytesPerSequence;
	  }

	  return decodeCodePointsArray$1(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH$1 = 0x1000;

	function decodeCodePointsArray$1 (codePoints) {
	  var len = codePoints.length;
	  if (len <= MAX_ARGUMENTS_LENGTH$1) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = '';
	  var i = 0;
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH$1)
	    );
	  }
	  return res
	}

	function asciiSlice$1 (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F);
	  }
	  return ret
	}

	function latin1Slice$1 (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i]);
	  }
	  return ret
	}

	function hexSlice$1 (buf, start, end) {
	  var len = buf.length;

	  if (!start || start < 0) start = 0;
	  if (!end || end < 0 || end > len) end = len;

	  var out = '';
	  for (var i = start; i < end; ++i) {
	    out += toHex$1(buf[i]);
	  }
	  return out
	}

	function utf16leSlice$1 (buf, start, end) {
	  var bytes = buf.slice(start, end);
	  var res = '';
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	  }
	  return res
	}

	Buffer$1.prototype.slice = function slice (start, end) {
	  var len = this.length;
	  start = ~~start;
	  end = end === undefined ? len : ~~end;

	  if (start < 0) {
	    start += len;
	    if (start < 0) start = 0;
	  } else if (start > len) {
	    start = len;
	  }

	  if (end < 0) {
	    end += len;
	    if (end < 0) end = 0;
	  } else if (end > len) {
	    end = len;
	  }

	  if (end < start) end = start;

	  var newBuf;
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end);
	    newBuf.__proto__ = Buffer$1.prototype;
	  } else {
	    var sliceLen = end - start;
	    newBuf = new Buffer$1(sliceLen, undefined);
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start];
	    }
	  }

	  return newBuf
	};

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset$1 (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset$1(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }

	  return val
	};

	Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    checkOffset$1(offset, byteLength, this.length);
	  }

	  var val = this[offset + --byteLength];
	  var mul = 1;
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul;
	  }

	  return val
	};

	Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset$1(offset, 1, this.length);
	  return this[offset]
	};

	Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset$1(offset, 2, this.length);
	  return this[offset] | (this[offset + 1] << 8)
	};

	Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset$1(offset, 2, this.length);
	  return (this[offset] << 8) | this[offset + 1]
	};

	Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset$1(offset, 4, this.length);

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	};

	Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset$1(offset, 4, this.length);

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	};

	Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset$1(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset$1(offset, byteLength, this.length);

	  var i = byteLength;
	  var mul = 1;
	  var val = this[offset + --i];
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset$1(offset, 1, this.length);
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	};

	Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset$1(offset, 2, this.length);
	  var val = this[offset] | (this[offset + 1] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset$1(offset, 2, this.length);
	  var val = this[offset + 1] | (this[offset] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset$1(offset, 4, this.length);

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	};

	Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset$1(offset, 4, this.length);

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	};

	Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset$1(offset, 4, this.length);
	  return read$1(this, offset, true, 23, 4)
	};

	Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset$1(offset, 4, this.length);
	  return read$1(this, offset, false, 23, 4)
	};

	Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset$1(offset, 8, this.length);
	  return read$1(this, offset, true, 52, 8)
	};

	Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset$1(offset, 8, this.length);
	  return read$1(this, offset, false, 52, 8)
	};

	function checkInt$1 (buf, value, offset, ext, max, min) {
	  if (!internalIsBuffer$1(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt$1(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var mul = 1;
	  var i = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt$1(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt$1(this, value, offset, 1, 0xff, 0);
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	function objectWriteUInt16$1 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8;
	  }
	}

	Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt$1(this, value, offset, 2, 0xffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16$1(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt$1(this, value, offset, 2, 0xffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16$1(this, value, offset, false);
	  }
	  return offset + 2
	};

	function objectWriteUInt32$1 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
	  }
	}

	Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt$1(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 1] = (value >>> 8);
	    this[offset] = (value & 0xff);
	  } else {
	    objectWriteUInt32$1(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt$1(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32$1(this, value, offset, false);
	  }
	  return offset + 4
	};

	Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt$1(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = 0;
	  var mul = 1;
	  var sub = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt$1(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  var sub = 0;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt$1(this, value, offset, 1, 0x7f, -0x80);
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  if (value < 0) value = 0xff + value + 1;
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt$1(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16$1(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt$1(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16$1(this, value, offset, false);
	  }
	  return offset + 2
	};

	Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt$1(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 3] = (value >>> 24);
	  } else {
	    objectWriteUInt32$1(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt$1(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (value < 0) value = 0xffffffff + value + 1;
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32$1(this, value, offset, false);
	  }
	  return offset + 4
	};

	function checkIEEE754$1 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat$1 (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754$1(buf, value, offset, 4);
	  }
	  write$1(buf, value, offset, littleEndian, 23, 4);
	  return offset + 4
	}

	Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat$1(this, value, offset, true, noAssert)
	};

	Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat$1(this, value, offset, false, noAssert)
	};

	function writeDouble$1 (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754$1(buf, value, offset, 8);
	  }
	  write$1(buf, value, offset, littleEndian, 52, 8);
	  return offset + 8
	}

	Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble$1(this, value, offset, true, noAssert)
	};

	Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble$1(this, value, offset, false, noAssert)
	};

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0;
	  if (!end && end !== 0) end = this.length;
	  if (targetStart >= target.length) targetStart = target.length;
	  if (!targetStart) targetStart = 0;
	  if (end > 0 && end < start) end = start;

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length;
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start;
	  }

	  var len = end - start;
	  var i;

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    );
	  }

	  return len
	};

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start;
	      start = 0;
	      end = this.length;
	    } else if (typeof end === 'string') {
	      encoding = end;
	      end = this.length;
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0);
	      if (code < 256) {
	        val = code;
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255;
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0;
	  end = end === undefined ? this.length : end >>> 0;

	  if (!val) val = 0;

	  var i;
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val;
	    }
	  } else {
	    var bytes = internalIsBuffer$1(val)
	      ? val
	      : utf8ToBytes$1(new Buffer$1(val, encoding).toString());
	    var len = bytes.length;
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len];
	    }
	  }

	  return this
	};

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE$1 = /[^+\/0-9A-Za-z-_]/g;

	function base64clean$1 (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim$1(str).replace(INVALID_BASE64_RE$1, '');
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '=';
	  }
	  return str
	}

	function stringtrim$1 (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex$1 (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes$1 (string, units) {
	  units = units || Infinity;
	  var codePoint;
	  var length = string.length;
	  var leadSurrogate = null;
	  var bytes = [];

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i);

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint;

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	        leadSurrogate = codePoint;
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	    }

	    leadSurrogate = null;

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint);
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes$1 (str) {
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF);
	  }
	  return byteArray
	}

	function utf16leToBytes$1 (str, units) {
	  var c, hi, lo;
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i);
	    hi = c >> 8;
	    lo = c % 256;
	    byteArray.push(lo);
	    byteArray.push(hi);
	  }

	  return byteArray
	}


	function base64ToBytes$1 (str) {
	  return toByteArray$1(base64clean$1(str))
	}

	function blitBuffer$1 (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i];
	  }
	  return i
	}

	function isnan$1 (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}


	// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	function isBuffer$1$1(obj) {
	  return obj != null && (!!obj._isBuffer || isFastBuffer$1(obj) || isSlowBuffer$1(obj))
	}

	function isFastBuffer$1 (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer$1 (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer$1(obj.slice(0, 0))
	}

	var binary$1 = createCommonjsModule$1(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;











	/* global atob, btoa, Buffer */
	var _default = {
	  identify: function identify(value) {
	    return value instanceof Uint8Array;
	  },
	  // Buffer inherits from Uint8Array
	  default: false,
	  tag: 'tag:yaml.org,2002:binary',

	  /**
	   * Returns a Buffer in node and an Uint8Array in browsers
	   *
	   * To use the resulting buffer as an image, you'll want to do something like:
	   *
	   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
	   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
	   */
	  resolve: function resolve(doc, node) {
	    if (typeof Buffer$1 === 'function') {
	      var src = (0, string$1.resolveString)(doc, node);
	      return Buffer$1.from(src, 'base64');
	    } else if (typeof atob === 'function') {
	      var _src = atob((0, string$1.resolveString)(doc, node));

	      var buffer = new Uint8Array(_src.length);

	      for (var i = 0; i < _src.length; ++i) {
	        buffer[i] = _src.charCodeAt(i);
	      }

	      return buffer;
	    } else {
	      doc.errors.push(new errors.YAMLReferenceError(node, 'This environment does not support reading binary tags; either Buffer or atob is required'));
	      return null;
	    }
	  },
	  options: options.binaryOptions,
	  stringify: function stringify$1$1(_ref, ctx, onComment, onChompKeep) {
	    var comment = _ref.comment,
	        type = _ref.type,
	        value = _ref.value;
	    var src;

	    if (typeof Buffer$1 === 'function') {
	      src = value instanceof Buffer$1 ? value.toString('base64') : Buffer$1.from(value.buffer).toString('base64');
	    } else if (typeof btoa === 'function') {
	      var s = '';

	      for (var i = 0; i < value.length; ++i) {
	        s += String.fromCharCode(value[i]);
	      }

	      src = btoa(s);
	    } else {
	      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
	    }

	    if (!type) type = options.binaryOptions.defaultType;

	    if (type === constants.Type.QUOTE_DOUBLE) {
	      value = src;
	    } else {
	      var lineWidth = options.binaryOptions.lineWidth;
	      var n = Math.ceil(src.length / lineWidth);
	      var lines = new Array(n);

	      for (var _i = 0, o = 0; _i < n; ++_i, o += lineWidth) {
	        lines[_i] = src.substr(o, lineWidth);
	      }

	      value = lines.join(type === constants.Type.BLOCK_LITERAL ? '\n' : ' ');
	    }

	    return (0, stringify$1.stringifyString)({
	      comment: comment,
	      type: type,
	      value: value
	    }, ctx, onComment, onChompKeep);
	  }
	};
	exports.default = _default;
	});

	unwrapExports(binary$1);

	var pairs$1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.parsePairs = parsePairs;
	exports.createPairs = createPairs;
	exports.default = void 0;



	var _Map$1$1 = interopRequireDefault(_Map$1);

	var _Pair = interopRequireDefault(Pair_1);

	var _parseSeq = interopRequireDefault(parseSeq_1);

	var _Seq = interopRequireDefault(Seq);

	function parsePairs(doc, cst) {
	  var seq = (0, _parseSeq.default)(doc, cst);

	  for (var i = 0; i < seq.items.length; ++i) {
	    var item = seq.items[i];
	    if (item instanceof _Pair.default) continue;else if (item instanceof _Map$1$1.default) {
	      if (item.items.length > 1) {
	        var msg = 'Each pair must have its own sequence indicator';
	        throw new errors.YAMLSemanticError(cst, msg);
	      }

	      var pair = item.items[0] || new _Pair.default();
	      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? "".concat(item.commentBefore, "\n").concat(pair.commentBefore) : item.commentBefore;
	      if (item.comment) pair.comment = pair.comment ? "".concat(item.comment, "\n").concat(pair.comment) : item.comment;
	      item = pair;
	    }
	    seq.items[i] = item instanceof _Pair.default ? item : new _Pair.default(item);
	  }

	  return seq;
	}

	function createPairs(schema, iterable, ctx) {
	  var pairs = new _Seq.default();
	  pairs.tag = 'tag:yaml.org,2002:pairs';
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var it = _step.value;
	      var key = void 0,
	          value = void 0;

	      if (Array.isArray(it)) {
	        if (it.length === 2) {
	          key = it[0];
	          value = it[1];
	        } else throw new TypeError("Expected [key, value] tuple: ".concat(it));
	      } else if (it && it instanceof Object) {
	        var keys = Object.keys(it);

	        if (keys.length === 1) {
	          key = keys[0];
	          value = it[key];
	        } else throw new TypeError("Expected { key: value } tuple: ".concat(it));
	      } else {
	        key = it;
	      }

	      var pair = schema.createPair(key, value, ctx);
	      pairs.items.push(pair);
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return != null) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  return pairs;
	}

	var _default = {
	  default: false,
	  tag: 'tag:yaml.org,2002:pairs',
	  resolve: parsePairs,
	  createNode: createPairs
	};
	exports.default = _default;
	});

	unwrapExports(pairs$1);
	var pairs_1 = pairs$1.parsePairs;
	var pairs_2 = pairs$1.createPairs;

	var omap$1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = exports.YAMLOMap = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

	var _inherits2 = interopRequireDefault(inherits$1);

	var _defineProperty2 = interopRequireDefault(defineProperty$e);



	var _toJSON2 = interopRequireDefault(toJSON_1);

	var _Map$1$1 = interopRequireDefault(_Map$1);

	var _Pair = interopRequireDefault(Pair_1);

	var _Scalar = interopRequireDefault(Scalar_1);

	var _Seq = interopRequireDefault(Seq);



	var YAMLOMap =
	/*#__PURE__*/
	function (_YAMLSeq) {
	  (0, _inherits2.default)(YAMLOMap, _YAMLSeq);

	  function YAMLOMap() {
	    var _this;

	    (0, _classCallCheck2.default)(this, YAMLOMap);
	    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLOMap).call(this));
	    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "add", _Map$1$1.default.prototype.add.bind((0, _assertThisInitialized2.default)(_this)));
	    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "delete", _Map$1$1.default.prototype.delete.bind((0, _assertThisInitialized2.default)(_this)));
	    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "get", _Map$1$1.default.prototype.get.bind((0, _assertThisInitialized2.default)(_this)));
	    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "has", _Map$1$1.default.prototype.has.bind((0, _assertThisInitialized2.default)(_this)));
	    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "set", _Map$1$1.default.prototype.set.bind((0, _assertThisInitialized2.default)(_this)));
	    _this.tag = YAMLOMap.tag;
	    return _this;
	  }

	  (0, _createClass2.default)(YAMLOMap, [{
	    key: "toJSON",
	    value: function toJSON(_, ctx) {
	      var map = new Map();
	      if (ctx && ctx.onCreate) ctx.onCreate(map);
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var pair = _step.value;
	          var key = void 0,
	              value = void 0;

	          if (pair instanceof _Pair.default) {
	            key = (0, _toJSON2.default)(pair.key, '', ctx);
	            value = (0, _toJSON2.default)(pair.value, key, ctx);
	          } else {
	            key = (0, _toJSON2.default)(pair, '', ctx);
	          }

	          if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');
	          map.set(key, value);
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      return map;
	    }
	  }]);
	  return YAMLOMap;
	}(_Seq.default);

	exports.YAMLOMap = YAMLOMap;
	(0, _defineProperty2.default)(YAMLOMap, "tag", 'tag:yaml.org,2002:omap');

	function parseOMap(doc, cst) {
	  var pairs$1$1 = (0, pairs$1.parsePairs)(doc, cst);
	  var seenKeys = [];
	  var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;

	  try {
	    for (var _iterator2 = pairs$1$1.items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var key = _step2.value.key;

	      if (key instanceof _Scalar.default) {
	        if (seenKeys.includes(key.value)) {
	          var msg = 'Ordered maps must not include duplicate keys';
	          throw new errors.YAMLSemanticError(cst, msg);
	        } else {
	          seenKeys.push(key.value);
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
	        _iterator2.return();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }

	  return Object.assign(new YAMLOMap(), pairs$1$1);
	}

	function createOMap(schema, iterable, ctx) {
	  var pairs$1$1 = (0, pairs$1.createPairs)(schema, iterable, ctx);
	  var omap = new YAMLOMap();
	  omap.items = pairs$1$1.items;
	  return omap;
	}

	var _default = {
	  identify: function identify(value) {
	    return value instanceof Map;
	  },
	  nodeClass: YAMLOMap,
	  default: false,
	  tag: 'tag:yaml.org,2002:omap',
	  resolve: parseOMap,
	  createNode: createOMap
	};
	exports.default = _default;
	});

	unwrapExports(omap$1);
	var omap_1 = omap$1.YAMLOMap;

	var set$6 = createCommonjsModule$1(function (module, exports) {





	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = exports.YAMLSet = void 0;

	var _typeof2 = interopRequireDefault(_typeof_1$1);

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _get2 = interopRequireDefault(get$5);

	var _inherits2 = interopRequireDefault(inherits$1);

	var _defineProperty2 = interopRequireDefault(defineProperty$e);



	var _Map$1$1 = interopRequireWildcard(_Map$1);

	var _Pair = interopRequireDefault(Pair_1);

	var _parseMap = interopRequireDefault(parseMap_1);

	var _Scalar = interopRequireDefault(Scalar_1);

	var YAMLSet =
	/*#__PURE__*/
	function (_YAMLMap) {
	  (0, _inherits2.default)(YAMLSet, _YAMLMap);

	  function YAMLSet() {
	    var _this;

	    (0, _classCallCheck2.default)(this, YAMLSet);
	    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(YAMLSet).call(this));
	    _this.tag = YAMLSet.tag;
	    return _this;
	  }

	  (0, _createClass2.default)(YAMLSet, [{
	    key: "add",
	    value: function add(key) {
	      var pair = key instanceof _Pair.default ? key : new _Pair.default(key);
	      var prev = (0, _Map$1$1.findPair)(this.items, pair.key);
	      if (!prev) this.items.push(pair);
	    }
	  }, {
	    key: "get",
	    value: function get(key, keepPair) {
	      var pair = (0, _Map$1$1.findPair)(this.items, key);
	      return !keepPair && pair instanceof _Pair.default ? pair.key instanceof _Scalar.default ? pair.key.value : pair.key : pair;
	    }
	  }, {
	    key: "set",
	    value: function set(key, value) {
	      if (typeof value !== 'boolean') throw new Error("Expected boolean value for set(key, value) in a YAML set, not ".concat((0, _typeof2.default)(value)));
	      var prev = (0, _Map$1$1.findPair)(this.items, key);

	      if (prev && !value) {
	        this.items.splice(this.items.indexOf(prev), 1);
	      } else if (!prev && value) {
	        this.items.push(new _Pair.default(key));
	      }
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON(_, ctx) {
	      return (0, _get2.default)((0, _getPrototypeOf2.default)(YAMLSet.prototype), "toJSON", this).call(this, _, ctx, Set);
	    }
	  }, {
	    key: "toString",
	    value: function toString(ctx, onComment, onChompKeep) {
	      if (!ctx) return JSON.stringify(this);
	      if (this.hasAllNullValues()) return (0, _get2.default)((0, _getPrototypeOf2.default)(YAMLSet.prototype), "toString", this).call(this, ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');
	    }
	  }]);
	  return YAMLSet;
	}(_Map$1$1.default);

	exports.YAMLSet = YAMLSet;
	(0, _defineProperty2.default)(YAMLSet, "tag", 'tag:yaml.org,2002:set');

	function parseSet(doc, cst) {
	  var map = (0, _parseMap.default)(doc, cst);
	  if (!map.hasAllNullValues()) throw new errors.YAMLSemanticError(cst, 'Set items must all have null values');
	  return Object.assign(new YAMLSet(), map);
	}

	function createSet(schema, iterable, ctx) {
	  var set = new YAMLSet();
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var value = _step.value;
	      set.items.push(schema.createPair(value, null, ctx));
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return != null) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  return set;
	}

	var _default = {
	  identify: function identify(value) {
	    return value instanceof Set;
	  },
	  nodeClass: YAMLSet,
	  default: false,
	  tag: 'tag:yaml.org,2002:set',
	  resolve: parseSet,
	  createNode: createSet
	};
	exports.default = _default;
	});

	unwrapExports(set$6);
	var set_1$1 = set$6.YAMLSet;

	var timestamp_1 = createCommonjsModule$1(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.timestamp = exports.floatTime = exports.intTime = void 0;



	var parseSexagesimal = function parseSexagesimal(sign, parts) {
	  var n = parts.split(':').reduce(function (n, p) {
	    return n * 60 + Number(p);
	  }, 0);
	  return sign === '-' ? -n : n;
	}; // hhhh:mm:ss.sss


	var stringifySexagesimal = function stringifySexagesimal(_ref) {
	  var value = _ref.value;
	  if (isNaN(value) || !isFinite(value)) return (0, stringify$1.stringifyNumber)(value);
	  var sign = '';

	  if (value < 0) {
	    sign = '-';
	    value = Math.abs(value);
	  }

	  var parts = [value % 60]; // seconds, including ms

	  if (value < 60) {
	    parts.unshift(0); // at least one : is required
	  } else {
	    value = Math.round((value - parts[0]) / 60);
	    parts.unshift(value % 60); // minutes

	    if (value >= 60) {
	      value = Math.round((value - parts[0]) / 60);
	      parts.unshift(value); // hours
	    }
	  }

	  return sign + parts.map(function (n) {
	    return n < 10 ? '0' + String(n) : String(n);
	  }).join(':').replace(/000000\d*$/, '') // % 60 may introduce error
	  ;
	};

	var intTime = {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'TIME',
	  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
	  resolve: function resolve(str, sign, parts) {
	    return parseSexagesimal(sign, parts.replace(/_/g, ''));
	  },
	  stringify: stringifySexagesimal
	};
	exports.intTime = intTime;
	var floatTime = {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  format: 'TIME',
	  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
	  resolve: function resolve(str, sign, parts) {
	    return parseSexagesimal(sign, parts.replace(/_/g, ''));
	  },
	  stringify: stringifySexagesimal
	};
	exports.floatTime = floatTime;
	var timestamp = {
	  identify: function identify(value) {
	    return value instanceof Date;
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:timestamp',
	  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
	  // may be omitted altogether, resulting in a date format. In such a case, the time part is
	  // assumed to be 00:00:00Z (start of day, UTC).
	  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
	  '(?:(?:t|T|[ \\t]+)' + // t | T | whitespace
	  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
	  '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
	  ')?' + ')$'),
	  resolve: function resolve(str, year, month, day, hour, minute, second, millisec, tz) {
	    if (millisec) millisec = (millisec + '00').substr(1, 3);
	    var date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);

	    if (tz && tz !== 'Z') {
	      var d = parseSexagesimal(tz[0], tz.slice(1));
	      if (Math.abs(d) < 30) d *= 60;
	      date -= 60000 * d;
	    }

	    return new Date(date);
	  },
	  stringify: function stringify(_ref2) {
	    var value = _ref2.value;
	    return value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '');
	  }
	};
	exports.timestamp = timestamp;
	});

	unwrapExports(timestamp_1);
	var timestamp_2 = timestamp_1.timestamp;
	var timestamp_3 = timestamp_1.floatTime;
	var timestamp_4 = timestamp_1.intTime;

	var yaml1_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _Scalar = interopRequireDefault(Scalar_1);



	var _failsafe = interopRequireDefault(failsafe$1);



	var _binary = interopRequireDefault(binary$1);

	var _omap = interopRequireDefault(omap$1);

	var _pairs = interopRequireDefault(pairs$1);

	var _set = interopRequireDefault(set$6);



	var _default = _failsafe.default.concat([{
	  identify: function identify(value) {
	    return value == null;
	  },
	  createNode: function createNode(schema, value, ctx) {
	    return ctx.wrapScalars ? new _Scalar.default(null) : null;
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:null',
	  test: /^(?:~|[Nn]ull|NULL)?$/,
	  resolve: function resolve() {
	    return null;
	  },
	  options: options.nullOptions,
	  stringify: function stringify() {
	    return options.nullOptions.nullStr;
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'boolean';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:bool',
	  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
	  resolve: function resolve() {
	    return true;
	  },
	  options: options.boolOptions,
	  stringify: function stringify(_ref) {
	    var value = _ref.value;
	    return value ? options.boolOptions.trueStr : options.boolOptions.falseStr;
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'boolean';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:bool',
	  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
	  resolve: function resolve() {
	    return false;
	  },
	  options: options.boolOptions,
	  stringify: function stringify(_ref2) {
	    var value = _ref2.value;
	    return value ? options.boolOptions.trueStr : options.boolOptions.falseStr;
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'BIN',
	  test: /^0b([0-1_]+)$/,
	  resolve: function resolve(str, bin) {
	    return parseInt(bin.replace(/_/g, ''), 2);
	  },
	  stringify: function stringify(_ref3) {
	    var value = _ref3.value;
	    return '0b' + value.toString(2);
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'OCT',
	  test: /^[-+]?0([0-7_]+)$/,
	  resolve: function resolve(str, oct) {
	    return parseInt(oct.replace(/_/g, ''), 8);
	  },
	  stringify: function stringify(_ref4) {
	    var value = _ref4.value;
	    return (value < 0 ? '-0' : '0') + value.toString(8);
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  test: /^[-+]?[0-9][0-9_]*$/,
	  resolve: function resolve(str) {
	    return parseInt(str.replace(/_/g, ''), 10);
	  },
	  stringify: stringify$1.stringifyNumber
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'HEX',
	  test: /^0x([0-9a-fA-F_]+)$/,
	  resolve: function resolve(str, hex) {
	    return parseInt(hex.replace(/_/g, ''), 16);
	  },
	  stringify: function stringify(_ref5) {
	    var value = _ref5.value;
	    return (value < 0 ? '-0x' : '0x') + value.toString(16);
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  test: /^(?:[-+]?\.inf|(\.nan))$/i,
	  resolve: function resolve(str, nan) {
	    return nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
	  },
	  stringify: stringify$1.stringifyNumber
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  format: 'EXP',
	  test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
	  resolve: function resolve(str) {
	    return parseFloat(str.replace(/_/g, ''));
	  },
	  stringify: function stringify(_ref6) {
	    var value = _ref6.value;
	    return Number(value).toExponential();
	  }
	}, {
	  identify: function identify(value) {
	    return typeof value === 'number';
	  },
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
	  resolve: function resolve(str, frac) {
	    var node = new _Scalar.default(parseFloat(str.replace(/_/g, '')));

	    if (frac) {
	      var f = frac.replace(/_/g, '');
	      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;
	    }

	    return node;
	  },
	  stringify: stringify$1.stringifyNumber
	}], _binary.default, _omap.default, _pairs.default, _set.default, timestamp_1.intTime, timestamp_1.floatTime, timestamp_1.timestamp);

	exports.default = _default;
	});

	unwrapExports(yaml1_1);

	var tags_1 = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.tags = exports.schemas = void 0;

	var _core = interopRequireDefault(core$1);

	var _failsafe = interopRequireDefault(failsafe$1);

	var _json = interopRequireDefault(json$1);

	var _yaml = interopRequireDefault(yaml1_1);

	var _map = interopRequireDefault(map$1);

	var _seq = interopRequireDefault(seq$1);

	var _binary = interopRequireDefault(binary$1);

	var _omap = interopRequireDefault(omap$1);

	var _pairs = interopRequireDefault(pairs$1);

	var _set = interopRequireDefault(set$6);



	var schemas = {
	  core: _core.default,
	  failsafe: _failsafe.default,
	  json: _json.default,
	  yaml11: _yaml.default
	};
	exports.schemas = schemas;
	var tags = {
	  binary: _binary.default,
	  floatTime: timestamp_1.floatTime,
	  intTime: timestamp_1.intTime,
	  map: _map.default,
	  omap: _omap.default,
	  pairs: _pairs.default,
	  seq: _seq.default,
	  set: _set.default,
	  timestamp: timestamp_1.timestamp
	};
	exports.tags = tags;
	});

	unwrapExports(tags_1);
	var tags_2 = tags_1.tags;
	var tags_3 = tags_1.schemas;

	var schema = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _typeof2 = interopRequireDefault(_typeof_1$1);

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _defineProperty2 = interopRequireDefault(defineProperty$e);













	var _Alias = interopRequireDefault(Alias_1$1);

	var _Collection = interopRequireDefault(Collection_1$1);

	var _Node = interopRequireDefault(Node_1$1);

	var _Pair = interopRequireDefault(Pair_1);

	var _Scalar = interopRequireDefault(Scalar_1);

	var isMap = function isMap(_ref) {
	  var type = _ref.type;
	  return type === constants.Type.FLOW_MAP || type === constants.Type.MAP;
	};

	var isSeq = function isSeq(_ref2) {
	  var type = _ref2.type;
	  return type === constants.Type.FLOW_SEQ || type === constants.Type.SEQ;
	};

	var Schema =
	/*#__PURE__*/
	function () {
	  function Schema(_ref3) {
	    var customTags = _ref3.customTags,
	        merge = _ref3.merge,
	        schema = _ref3.schema,
	        deprecatedCustomTags = _ref3.tags;
	    (0, _classCallCheck2.default)(this, Schema);
	    this.merge = !!merge;
	    this.name = schema;
	    this.tags = tags_1.schemas[schema.replace(/\W/g, '')]; // 'yaml-1.1' -> 'yaml11'

	    if (!this.tags) {
	      var keys = Object.keys(tags_1.schemas).map(function (key) {
	        return JSON.stringify(key);
	      }).join(', ');
	      throw new Error("Unknown schema \"".concat(schema, "\"; use one of ").concat(keys));
	    }

	    if (!customTags && deprecatedCustomTags) {
	      customTags = deprecatedCustomTags;
	      (0, warnings.warnOptionDeprecation)('tags', 'customTags');
	    }

	    if (Array.isArray(customTags)) {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = customTags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var tag = _step.value;
	          this.tags = this.tags.concat(tag);
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    } else if (typeof customTags === 'function') {
	      this.tags = customTags(this.tags.slice());
	    }

	    for (var i = 0; i < this.tags.length; ++i) {
	      var _tag = this.tags[i];

	      if (typeof _tag === 'string') {
	        var tagObj = tags_1.tags[_tag];

	        if (!tagObj) {
	          var _keys = Object.keys(tags_1.tags).map(function (key) {
	            return JSON.stringify(key);
	          }).join(', ');

	          throw new Error("Unknown custom tag \"".concat(_tag, "\"; use one of ").concat(_keys));
	        }

	        this.tags[i] = tagObj;
	      }
	    }
	  }

	  (0, _createClass2.default)(Schema, [{
	    key: "createNode",
	    value: function createNode(value, wrapScalars, tag, ctx) {
	      if (value instanceof _Node.default) return value;
	      var tagObj;

	      if (tag) {
	        if (tag.startsWith('!!')) tag = Schema.defaultPrefix + tag.slice(2);
	        var match = this.tags.filter(function (t) {
	          return t.tag === tag;
	        });
	        tagObj = match.find(function (t) {
	          return !t.format;
	        }) || match[0];
	        if (!tagObj) throw new Error("Tag ".concat(tag, " not found"));
	      } else {
	        // TODO: deprecate/remove class check
	        tagObj = this.tags.find(function (t) {
	          return (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format;
	        });

	        if (!tagObj) {
	          if (typeof value.toJSON === 'function') value = value.toJSON();
	          if ((0, _typeof2.default)(value) !== 'object') return wrapScalars ? new _Scalar.default(value) : value;
	          tagObj = value instanceof Map ? tags_1.tags.map : value[Symbol.iterator] ? tags_1.tags.seq : tags_1.tags.map;
	        }
	      }

	      if (!ctx) ctx = {
	        wrapScalars: wrapScalars
	      };else ctx.wrapScalars = wrapScalars;

	      if (ctx.onTagObj) {
	        ctx.onTagObj(tagObj);
	        delete ctx.onTagObj;
	      }

	      var obj = {};

	      if (value && (0, _typeof2.default)(value) === 'object' && ctx.prevObjects) {
	        var prev = ctx.prevObjects.find(function (o) {
	          return o.value === value;
	        });

	        if (prev) {
	          var alias = new _Alias.default(prev); // leaves source dirty; must be cleaned by caller

	          ctx.aliasNodes.push(alias);
	          return alias;
	        }

	        obj.value = value;
	        ctx.prevObjects.push(obj);
	      }

	      obj.node = tagObj.createNode ? tagObj.createNode(this, value, ctx) : wrapScalars ? new _Scalar.default(value) : value;
	      return obj.node;
	    }
	  }, {
	    key: "createPair",
	    value: function createPair(key, value, ctx) {
	      var k = this.createNode(key, ctx.wrapScalars, null, ctx);
	      var v = this.createNode(value, ctx.wrapScalars, null, ctx);
	      return new _Pair.default(k, v);
	    } // falls back to string on no match

	  }, {
	    key: "resolveScalar",
	    value: function resolveScalar(str, tags) {
	      if (!tags) tags = this.tags;

	      for (var i = 0; i < tags.length; ++i) {
	        var _tags$i = tags[i],
	            format = _tags$i.format,
	            test = _tags$i.test,
	            resolve = _tags$i.resolve;

	        if (test) {
	          var match = str.match(test);

	          if (match) {
	            var res = resolve.apply(null, match);
	            if (!(res instanceof _Scalar.default)) res = new _Scalar.default(res);
	            if (format) res.format = format;
	            return res;
	          }
	        }
	      }

	      if (this.tags.scalarFallback) str = this.tags.scalarFallback(str);
	      return new _Scalar.default(str);
	    } // sets node.resolved on success

	  }, {
	    key: "resolveNode",
	    value: function resolveNode(doc, node, tagName) {
	      var tags = this.tags.filter(function (_ref4) {
	        var tag = _ref4.tag;
	        return tag === tagName;
	      });
	      var generic = tags.find(function (_ref5) {
	        var test = _ref5.test;
	        return !test;
	      });
	      if (node.error) doc.errors.push(node.error);

	      try {
	        if (generic) {
	          var res = generic.resolve(doc, node);
	          if (!(res instanceof _Collection.default)) res = new _Scalar.default(res);
	          node.resolved = res;
	        } else {
	          var str = (0, string$1.resolveString)(doc, node);

	          if (typeof str === 'string' && tags.length > 0) {
	            node.resolved = this.resolveScalar(str, tags);
	          }
	        }
	      } catch (error) {
	        if (!error.source) error.source = node;
	        doc.errors.push(error);
	        node.resolved = null;
	      }

	      if (!node.resolved) return null;
	      if (tagName && node.tag) node.resolved.tag = tagName;
	      return node.resolved;
	    }
	  }, {
	    key: "resolveNodeWithFallback",
	    value: function resolveNodeWithFallback(doc, node, tagName) {
	      var res = this.resolveNode(doc, node, tagName);
	      if (Object.prototype.hasOwnProperty.call(node, 'resolved')) return res;
	      var fallback = isMap(node) ? Schema.defaultTags.MAP : isSeq(node) ? Schema.defaultTags.SEQ : Schema.defaultTags.STR;

	      if (fallback) {
	        doc.warnings.push(new errors.YAMLWarning(node, "The tag ".concat(tagName, " is unavailable, falling back to ").concat(fallback)));

	        var _res = this.resolveNode(doc, node, fallback);

	        _res.tag = tagName;
	        return _res;
	      } else {
	        doc.errors.push(new errors.YAMLReferenceError(node, "The tag ".concat(tagName, " is unavailable")));
	      }

	      return null;
	    }
	  }, {
	    key: "getTagObject",
	    value: function getTagObject(item) {
	      if (item instanceof _Alias.default) return _Alias.default;

	      if (item.tag) {
	        var match = this.tags.filter(function (t) {
	          return t.tag === item.tag;
	        });
	        if (match.length > 0) return match.find(function (t) {
	          return t.format === item.format;
	        }) || match[0];
	      }

	      var tagObj, obj;

	      if (item instanceof _Scalar.default) {
	        obj = item.value; // TODO: deprecate/remove class check

	        var _match = this.tags.filter(function (t) {
	          return t.identify && t.identify(obj) || t.class && obj instanceof t.class;
	        });

	        tagObj = _match.find(function (t) {
	          return t.format === item.format;
	        }) || _match.find(function (t) {
	          return !t.format;
	        });
	      } else {
	        obj = item;
	        tagObj = this.tags.find(function (t) {
	          return t.nodeClass && obj instanceof t.nodeClass;
	        });
	      }

	      if (!tagObj) {
	        var name = obj && obj.constructor ? obj.constructor.name : (0, _typeof2.default)(obj);
	        throw new Error("Tag not resolved for ".concat(name, " value"));
	      }

	      return tagObj;
	    } // needs to be called before stringifier to allow for circular anchor refs

	  }, {
	    key: "stringifyProps",
	    value: function stringifyProps(node, tagObj, _ref6) {
	      var anchors = _ref6.anchors,
	          doc = _ref6.doc;
	      var props = [];
	      var anchor = doc.anchors.getName(node);

	      if (anchor) {
	        anchors[anchor] = node;
	        props.push("&".concat(anchor));
	      }

	      if (node.tag) {
	        props.push(doc.stringifyTag(node.tag));
	      } else if (!tagObj.default) {
	        props.push(doc.stringifyTag(tagObj.tag));
	      }

	      return props.join(' ');
	    }
	  }, {
	    key: "stringify",
	    value: function stringify$1$1(item, ctx, onComment, onChompKeep) {
	      var tagObj;

	      if (!(item instanceof _Node.default)) {
	        var createCtx = {
	          aliasNodes: [],
	          onTagObj: function onTagObj(o) {
	            return tagObj = o;
	          },
	          prevObjects: []
	        };
	        item = this.createNode(item, true, null, createCtx);
	        var anchors = ctx.doc.anchors;
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;

	        try {
	          for (var _iterator2 = createCtx.aliasNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var alias = _step2.value;
	            alias.source = alias.source.node;
	            var name = anchors.getName(alias.source);

	            if (!name) {
	              name = anchors.newName();
	              anchors.map[name] = alias.source;
	            }
	          }
	        } catch (err) {
	          _didIteratorError2 = true;
	          _iteratorError2 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
	              _iterator2.return();
	            }
	          } finally {
	            if (_didIteratorError2) {
	              throw _iteratorError2;
	            }
	          }
	        }
	      }

	      ctx.tags = this;
	      if (item instanceof _Pair.default) return item.toString(ctx, onComment, onChompKeep);
	      if (!tagObj) tagObj = this.getTagObject(item);
	      var props = this.stringifyProps(item, tagObj, ctx);
	      var str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof _Collection.default ? item.toString(ctx, onComment, onChompKeep) : (0, stringify$1.stringifyString)(item, ctx, onComment, onChompKeep);
	      return props ? item instanceof _Collection.default && str[0] !== '{' && str[0] !== '[' ? "".concat(props, "\n").concat(ctx.indent).concat(str) : "".concat(props, " ").concat(str) : str;
	    }
	  }]);
	  return Schema;
	}();

	exports.default = Schema;
	(0, _defineProperty2.default)(Schema, "defaultPrefix", 'tag:yaml.org,2002:');
	(0, _defineProperty2.default)(Schema, "defaultTags", {
	  MAP: 'tag:yaml.org,2002:map',
	  SEQ: 'tag:yaml.org,2002:seq',
	  STR: 'tag:yaml.org,2002:str'
	});
	});

	unwrapExports(schema);

	var Document_1$1 = createCommonjsModule$1(function (module, exports) {





	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _slicedToArray2 = interopRequireDefault(slicedToArray$1);

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _createClass2 = interopRequireDefault(createClass$1);

	var _defineProperty2 = interopRequireDefault(defineProperty$e);

	var _addComment = interopRequireDefault(addComment_1);

	var _Anchors = interopRequireDefault(Anchors_1);





	var _listTagNames = interopRequireDefault(listTagNames$1);

	var _schema = interopRequireDefault(schema);

	var _Alias = interopRequireDefault(Alias_1$1);

	var _Collection = interopRequireWildcard(Collection_1$1);

	var _Node = interopRequireDefault(Node_1$1);

	var _Scalar = interopRequireDefault(Scalar_1);

	var _toJSON2 = interopRequireDefault(toJSON_1);

	var isCollectionItem = function isCollectionItem(node) {
	  return node && [constants.Type.MAP_KEY, constants.Type.MAP_VALUE, constants.Type.SEQ_ITEM].includes(node.type);
	};

	var Document =
	/*#__PURE__*/
	function () {
	  function Document(options) {
	    (0, _classCallCheck2.default)(this, Document);
	    this.anchors = new _Anchors.default(options.anchorPrefix);
	    this.commentBefore = null;
	    this.comment = null;
	    this.contents = null;
	    this.directivesEndMarker = null;
	    this.errors = [];
	    this.options = options;
	    this.schema = null;
	    this.tagPrefixes = [];
	    this.version = null;
	    this.warnings = [];
	  }

	  (0, _createClass2.default)(Document, [{
	    key: "assertCollectionContents",
	    value: function assertCollectionContents() {
	      if (this.contents instanceof _Collection.default) return true;
	      throw new Error('Expected a YAML collection as document contents');
	    }
	  }, {
	    key: "add",
	    value: function add(value) {
	      this.assertCollectionContents();
	      return this.contents.add(value);
	    }
	  }, {
	    key: "addIn",
	    value: function addIn(path, value) {
	      this.assertCollectionContents();
	      this.contents.addIn(path, value);
	    }
	  }, {
	    key: "delete",
	    value: function _delete(key) {
	      this.assertCollectionContents();
	      return this.contents.delete(key);
	    }
	  }, {
	    key: "deleteIn",
	    value: function deleteIn(path) {
	      if ((0, _Collection.isEmptyPath)(path)) {
	        if (this.contents == null) return false;
	        this.contents = null;
	        return true;
	      }

	      this.assertCollectionContents();
	      return this.contents.deleteIn(path);
	    }
	  }, {
	    key: "getDefaults",
	    value: function getDefaults() {
	      return Document.defaults[this.version] || Document.defaults[this.options.version] || {};
	    }
	  }, {
	    key: "get",
	    value: function get(key, keepScalar) {
	      return this.contents instanceof _Collection.default ? this.contents.get(key, keepScalar) : undefined;
	    }
	  }, {
	    key: "getIn",
	    value: function getIn(path, keepScalar) {
	      if ((0, _Collection.isEmptyPath)(path)) return !keepScalar && this.contents instanceof _Scalar.default ? this.contents.value : this.contents;
	      return this.contents instanceof _Collection.default ? this.contents.getIn(path, keepScalar) : undefined;
	    }
	  }, {
	    key: "has",
	    value: function has(key) {
	      return this.contents instanceof _Collection.default ? this.contents.has(key) : false;
	    }
	  }, {
	    key: "hasIn",
	    value: function hasIn(path) {
	      if ((0, _Collection.isEmptyPath)(path)) return this.contents !== undefined;
	      return this.contents instanceof _Collection.default ? this.contents.hasIn(path) : false;
	    }
	  }, {
	    key: "set",
	    value: function set(key, value) {
	      this.assertCollectionContents();
	      this.contents.set(key, value);
	    }
	  }, {
	    key: "setIn",
	    value: function setIn(path, value) {
	      if ((0, _Collection.isEmptyPath)(path)) this.contents = value;else {
	        this.assertCollectionContents();
	        this.contents.setIn(path, value);
	      }
	    }
	  }, {
	    key: "setSchema",
	    value: function setSchema(id, customTags) {
	      if (!id && !customTags && this.schema) return;
	      if (typeof id === 'number') id = id.toFixed(1);

	      if (id === '1.0' || id === '1.1' || id === '1.2') {
	        if (this.version) this.version = id;else this.options.version = id;
	        delete this.options.schema;
	      } else if (id && typeof id === 'string') {
	        this.options.schema = id;
	      }

	      if (Array.isArray(customTags)) this.options.customTags = customTags;
	      var opt = Object.assign({}, this.getDefaults(), this.options);
	      this.schema = new _schema.default(opt);
	    }
	  }, {
	    key: "parse",
	    value: function parse(node, prevDoc) {
	      if (this.options.keepCstNodes) this.cstNode = node;
	      if (this.options.keepNodeTypes) this.type = 'DOCUMENT';
	      var _node$directives = node.directives,
	          directives = _node$directives === void 0 ? [] : _node$directives,
	          _node$contents = node.contents,
	          contents = _node$contents === void 0 ? [] : _node$contents,
	          directivesEndMarker = node.directivesEndMarker,
	          error = node.error,
	          valueRange = node.valueRange;

	      if (error) {
	        if (!error.source) error.source = this;
	        this.errors.push(error);
	      }

	      this.parseDirectives(directives, prevDoc);
	      if (directivesEndMarker) this.directivesEndMarker = true;
	      this.range = valueRange ? [valueRange.start, valueRange.end] : null;
	      this.setSchema();
	      this.anchors._cstAliases = [];
	      this.parseContents(contents);
	      this.anchors.resolveNodes();

	      if (this.options.prettyErrors) {
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;

	        try {
	          for (var _iterator = this.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var _error = _step.value;
	            if (_error instanceof errors.YAMLError) _error.makePretty();
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return != null) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }

	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;

	        try {
	          for (var _iterator2 = this.warnings[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var warn = _step2.value;
	            if (warn instanceof errors.YAMLError) warn.makePretty();
	          }
	        } catch (err) {
	          _didIteratorError2 = true;
	          _iteratorError2 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
	              _iterator2.return();
	            }
	          } finally {
	            if (_didIteratorError2) {
	              throw _iteratorError2;
	            }
	          }
	        }
	      }

	      return this;
	    }
	  }, {
	    key: "parseDirectives",
	    value: function parseDirectives(directives, prevDoc) {
	      var _this = this;

	      var directiveComments = [];
	      var hasDirectives = false;
	      directives.forEach(function (directive) {
	        var comment = directive.comment,
	            name = directive.name;

	        switch (name) {
	          case 'TAG':
	            _this.resolveTagDirective(directive);

	            hasDirectives = true;
	            break;

	          case 'YAML':
	          case 'YAML:1.0':
	            _this.resolveYamlDirective(directive);

	            hasDirectives = true;
	            break;

	          default:
	            if (name) {
	              var msg = "YAML only supports %TAG and %YAML directives, and not %".concat(name);

	              _this.warnings.push(new errors.YAMLWarning(directive, msg));
	            }

	        }

	        if (comment) directiveComments.push(comment);
	      });

	      if (prevDoc && !hasDirectives && '1.1' === (this.version || prevDoc.version || this.options.version)) {
	        var copyTagPrefix = function copyTagPrefix(_ref) {
	          var handle = _ref.handle,
	              prefix = _ref.prefix;
	          return {
	            handle: handle,
	            prefix: prefix
	          };
	        };

	        this.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
	        this.version = prevDoc.version;
	      }

	      this.commentBefore = directiveComments.join('\n') || null;
	    }
	  }, {
	    key: "parseContents",
	    value: function parseContents(contents) {
	      var _this2 = this;

	      var comments = {
	        before: [],
	        after: []
	      };
	      var contentNodes = [];
	      var spaceBefore = false;
	      contents.forEach(function (node) {
	        if (node.valueRange) {
	          if (contentNodes.length === 1) {
	            var msg = 'Document is not valid YAML (bad indentation?)';

	            _this2.errors.push(new errors.YAMLSyntaxError(node, msg));
	          }

	          var res = _this2.resolveNode(node);

	          if (spaceBefore) {
	            res.spaceBefore = true;
	            spaceBefore = false;
	          }

	          contentNodes.push(res);
	        } else if (node.comment !== null) {
	          var cc = contentNodes.length === 0 ? comments.before : comments.after;
	          cc.push(node.comment);
	        } else if (node.type === constants.Type.BLANK_LINE) {
	          spaceBefore = true;

	          if (contentNodes.length === 0 && comments.before.length > 0 && !_this2.commentBefore) {
	            // space-separated comments at start are parsed as document comments
	            _this2.commentBefore = comments.before.join('\n');
	            comments.before = [];
	          }
	        }
	      });

	      switch (contentNodes.length) {
	        case 0:
	          this.contents = null;
	          comments.after = comments.before;
	          break;

	        case 1:
	          this.contents = contentNodes[0];

	          if (this.contents) {
	            var cb = comments.before.join('\n') || null;

	            if (cb) {
	              var cbNode = this.contents instanceof _Collection.default && this.contents.items[0] ? this.contents.items[0] : this.contents;
	              cbNode.commentBefore = cbNode.commentBefore ? "".concat(cb, "\n").concat(cbNode.commentBefore) : cb;
	            }
	          } else {
	            comments.after = comments.before.concat(comments.after);
	          }

	          break;

	        default:
	          this.contents = contentNodes;

	          if (this.contents[0]) {
	            this.contents[0].commentBefore = comments.before.join('\n') || null;
	          } else {
	            comments.after = comments.before.concat(comments.after);
	          }

	      }

	      this.comment = comments.after.join('\n') || null;
	    }
	  }, {
	    key: "resolveTagDirective",
	    value: function resolveTagDirective(directive) {
	      var _directive$parameters = (0, _slicedToArray2.default)(directive.parameters, 2),
	          handle = _directive$parameters[0],
	          prefix = _directive$parameters[1];

	      if (handle && prefix) {
	        if (this.tagPrefixes.every(function (p) {
	          return p.handle !== handle;
	        })) {
	          this.tagPrefixes.push({
	            handle: handle,
	            prefix: prefix
	          });
	        } else {
	          var msg = 'The %TAG directive must only be given at most once per handle in the same document.';
	          this.errors.push(new errors.YAMLSemanticError(directive, msg));
	        }
	      } else {
	        var _msg = 'Insufficient parameters given for %TAG directive';
	        this.errors.push(new errors.YAMLSemanticError(directive, _msg));
	      }
	    }
	  }, {
	    key: "resolveYamlDirective",
	    value: function resolveYamlDirective(directive) {
	      var _directive$parameters2 = (0, _slicedToArray2.default)(directive.parameters, 1),
	          version = _directive$parameters2[0];

	      if (directive.name === 'YAML:1.0') version = '1.0';

	      if (this.version) {
	        var msg = 'The %YAML directive must only be given at most once per document.';
	        this.errors.push(new errors.YAMLSemanticError(directive, msg));
	      }

	      if (!version) {
	        var _msg2 = 'Insufficient parameters given for %YAML directive';
	        this.errors.push(new errors.YAMLSemanticError(directive, _msg2));
	      } else {
	        if (!Document.defaults[version]) {
	          var v0 = this.version || this.options.version;

	          var _msg3 = "Document will be parsed as YAML ".concat(v0, " rather than YAML ").concat(version);

	          this.warnings.push(new errors.YAMLWarning(directive, _msg3));
	        }

	        this.version = version;
	      }
	    }
	  }, {
	    key: "resolveTagName",
	    value: function resolveTagName(node) {
	      var tag = node.tag,
	          type = node.type;
	      var nonSpecific = false;

	      if (tag) {
	        var handle = tag.handle,
	            suffix = tag.suffix,
	            verbatim = tag.verbatim;

	        if (verbatim) {
	          if (verbatim !== '!' && verbatim !== '!!') return verbatim;
	          var msg = "Verbatim tags aren't resolved, so ".concat(verbatim, " is invalid.");
	          this.errors.push(new errors.YAMLSemanticError(node, msg));
	        } else if (handle === '!' && !suffix) {
	          nonSpecific = true;
	        } else {
	          var prefix = this.tagPrefixes.find(function (p) {
	            return p.handle === handle;
	          });

	          if (!prefix) {
	            var dtp = this.getDefaults().tagPrefixes;
	            if (dtp) prefix = dtp.find(function (p) {
	              return p.handle === handle;
	            });
	          }

	          if (prefix) {
	            if (suffix) {
	              if (handle === '!' && (this.version || this.options.version) === '1.0') {
	                if (suffix[0] === '^') return suffix;

	                if (/[:/]/.test(suffix)) {
	                  // word/foo -> tag:word.yaml.org,2002:foo
	                  var vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
	                  return vocab ? "tag:".concat(vocab[1], ".yaml.org,2002:").concat(vocab[2]) : "tag:".concat(suffix);
	                }
	              }

	              return prefix.prefix + decodeURIComponent(suffix);
	            }

	            this.errors.push(new errors.YAMLSemanticError(node, "The ".concat(handle, " tag has no suffix.")));
	          } else {
	            var _msg4 = "The ".concat(handle, " tag handle is non-default and was not declared.");

	            this.errors.push(new errors.YAMLSemanticError(node, _msg4));
	          }
	        }
	      }

	      switch (type) {
	        case constants.Type.BLOCK_FOLDED:
	        case constants.Type.BLOCK_LITERAL:
	        case constants.Type.QUOTE_DOUBLE:
	        case constants.Type.QUOTE_SINGLE:
	          return _schema.default.defaultTags.STR;

	        case constants.Type.FLOW_MAP:
	        case constants.Type.MAP:
	          return _schema.default.defaultTags.MAP;

	        case constants.Type.FLOW_SEQ:
	        case constants.Type.SEQ:
	          return _schema.default.defaultTags.SEQ;

	        case constants.Type.PLAIN:
	          return nonSpecific ? _schema.default.defaultTags.STR : null;

	        default:
	          return null;
	      }
	    }
	  }, {
	    key: "resolveNode",
	    value: function resolveNode(node) {
	      if (!node) return null;
	      var anchors = this.anchors,
	          errors$1 = this.errors,
	          schema = this.schema;
	      var hasAnchor = false;
	      var hasTag = false;
	      var comments = {
	        before: [],
	        after: []
	      };
	      var props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;
	      var _iteratorNormalCompletion3 = true;
	      var _didIteratorError3 = false;
	      var _iteratorError3 = undefined;

	      try {
	        for (var _iterator3 = props[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	          var _step3$value = _step3.value,
	              start = _step3$value.start,
	              end = _step3$value.end;

	          switch (node.context.src[start]) {
	            case constants.Char.COMMENT:
	              {
	                if (!node.commentHasRequiredWhitespace(start)) {
	                  var _msg7 = 'Comments must be separated from other tokens by white space characters';
	                  errors$1.push(new errors.YAMLSemanticError(node, _msg7));
	                }

	                var c = node.context.src.slice(start + 1, end);
	                var header = node.header,
	                    valueRange = node.valueRange;

	                if (valueRange && (start > valueRange.start || header && start > header.start)) {
	                  comments.after.push(c);
	                } else {
	                  comments.before.push(c);
	                }
	              }
	              break;

	            case constants.Char.ANCHOR:
	              if (hasAnchor) {
	                var _msg8 = 'A node can have at most one anchor';
	                errors$1.push(new errors.YAMLSemanticError(node, _msg8));
	              }

	              hasAnchor = true;
	              break;

	            case constants.Char.TAG:
	              if (hasTag) {
	                var _msg9 = 'A node can have at most one tag';
	                errors$1.push(new errors.YAMLSemanticError(node, _msg9));
	              }

	              hasTag = true;
	              break;
	          }
	        }
	      } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
	            _iterator3.return();
	          }
	        } finally {
	          if (_didIteratorError3) {
	            throw _iteratorError3;
	          }
	        }
	      }

	      if (hasAnchor) {
	        var name = node.anchor;
	        var prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor
	        // name have already been resolved, so it may safely be renamed.

	        if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as
	        // anchors need to be available during resolution to allow for
	        // circular references.

	        anchors.map[name] = node;
	      }

	      var res;

	      if (node.type === constants.Type.ALIAS) {
	        if (hasAnchor || hasTag) {
	          var msg = 'An alias node must not specify any properties';
	          errors$1.push(new errors.YAMLSemanticError(node, msg));
	        }

	        var _name = node.rawValue;
	        var src = anchors.getNode(_name);

	        if (!src) {
	          var _msg5 = "Aliased anchor not found: ".concat(_name);

	          errors$1.push(new errors.YAMLReferenceError(node, _msg5));
	          return null;
	        } // Lazy resolution for circular references


	        res = new _Alias.default(src);

	        anchors._cstAliases.push(res);
	      } else {
	        var tagName = this.resolveTagName(node);

	        if (tagName) {
	          res = schema.resolveNodeWithFallback(this, node, tagName);
	        } else {
	          if (node.type !== constants.Type.PLAIN) {
	            var _msg6 = "Failed to resolve ".concat(node.type, " node here");

	            errors$1.push(new errors.YAMLSyntaxError(node, _msg6));
	            return null;
	          }

	          try {
	            res = schema.resolveScalar(node.strValue || '');
	          } catch (error) {
	            if (!error.source) error.source = node;
	            errors$1.push(error);
	            return null;
	          }
	        }
	      }

	      if (res) {
	        res.range = [node.range.start, node.range.end];
	        if (this.options.keepCstNodes) res.cstNode = node;
	        if (this.options.keepNodeTypes) res.type = node.type;
	        var cb = comments.before.join('\n');

	        if (cb) {
	          res.commentBefore = res.commentBefore ? "".concat(res.commentBefore, "\n").concat(cb) : cb;
	        }

	        var ca = comments.after.join('\n');
	        if (ca) res.comment = res.comment ? "".concat(res.comment, "\n").concat(ca) : ca;
	      }

	      return node.resolved = res;
	    }
	  }, {
	    key: "listNonDefaultTags",
	    value: function listNonDefaultTags() {
	      return (0, _listTagNames.default)(this.contents).filter(function (t) {
	        return t.indexOf(_schema.default.defaultPrefix) !== 0;
	      });
	    }
	  }, {
	    key: "setTagPrefix",
	    value: function setTagPrefix(handle, prefix) {
	      if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');

	      if (prefix) {
	        var prev = this.tagPrefixes.find(function (p) {
	          return p.handle === handle;
	        });
	        if (prev) prev.prefix = prefix;else this.tagPrefixes.push({
	          handle: handle,
	          prefix: prefix
	        });
	      } else {
	        this.tagPrefixes = this.tagPrefixes.filter(function (p) {
	          return p.handle !== handle;
	        });
	      }
	    }
	  }, {
	    key: "stringifyTag",
	    value: function stringifyTag(tag) {
	      if ((this.version || this.options.version) === '1.0') {
	        var priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
	        if (priv) return '!' + priv[1];
	        var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
	        return vocab ? "!".concat(vocab[1], "/").concat(vocab[2]) : "!".concat(tag.replace(/^tag:/, ''));
	      } else {
	        var p = this.tagPrefixes.find(function (p) {
	          return tag.indexOf(p.prefix) === 0;
	        });

	        if (!p) {
	          var dtp = this.getDefaults().tagPrefixes;
	          p = dtp && dtp.find(function (p) {
	            return tag.indexOf(p.prefix) === 0;
	          });
	        }

	        if (!p) return tag[0] === '!' ? tag : "!<".concat(tag, ">");
	        var suffix = tag.substr(p.prefix.length).replace(/[!,[\]{}]/g, function (ch) {
	          return {
	            '!': '%21',
	            ',': '%2C',
	            '[': '%5B',
	            ']': '%5D',
	            '{': '%7B',
	            '}': '%7D'
	          }[ch];
	        });
	        return p.handle + suffix;
	      }
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON(arg) {
	      var _this3 = this;

	      var _this$options = this.options,
	          keepBlobsInJSON = _this$options.keepBlobsInJSON,
	          mapAsMap = _this$options.mapAsMap,
	          maxAliasCount = _this$options.maxAliasCount;
	      var keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof _Scalar.default));
	      var ctx = {
	        doc: this,
	        keep: keep,
	        mapAsMap: keep && !!mapAsMap,
	        maxAliasCount: maxAliasCount
	      };
	      var anchorNames = Object.keys(this.anchors.map);
	      if (anchorNames.length > 0) ctx.anchors = anchorNames.map(function (name) {
	        return {
	          alias: [],
	          aliasCount: 0,
	          count: 1,
	          node: _this3.anchors.map[name]
	        };
	      });
	      return (0, _toJSON2.default)(this.contents, arg, ctx);
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');
	      this.setSchema();
	      var lines = [];
	      var hasDirectives = false;

	      if (this.version) {
	        var vd = '%YAML 1.2';

	        if (this.schema.name === 'yaml-1.1') {
	          if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';
	        }

	        lines.push(vd);
	        hasDirectives = true;
	      }

	      var tagNames = this.listNonDefaultTags();
	      this.tagPrefixes.forEach(function (_ref2) {
	        var handle = _ref2.handle,
	            prefix = _ref2.prefix;

	        if (tagNames.some(function (t) {
	          return t.indexOf(prefix) === 0;
	        })) {
	          lines.push("%TAG ".concat(handle, " ").concat(prefix));
	          hasDirectives = true;
	        }
	      });
	      if (hasDirectives || this.directivesEndMarker) lines.push('---');

	      if (this.commentBefore) {
	        if (hasDirectives || !this.directivesEndMarker) lines.unshift('');
	        lines.unshift(this.commentBefore.replace(/^/gm, '#'));
	      }

	      var ctx = {
	        anchors: {},
	        doc: this,
	        indent: ''
	      };
	      var chompKeep = false;
	      var contentComment = null;

	      if (this.contents) {
	        if (this.contents instanceof _Node.default) {
	          if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');
	          if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment

	          ctx.forceBlockIndent = !!this.comment;
	          contentComment = this.contents.comment;
	        }

	        var onChompKeep = contentComment ? null : function () {
	          return chompKeep = true;
	        };
	        var body = this.schema.stringify(this.contents, ctx, function () {
	          return contentComment = null;
	        }, onChompKeep);
	        lines.push((0, _addComment.default)(body, '', contentComment));
	      } else if (this.contents !== undefined) {
	        lines.push(this.schema.stringify(this.contents, ctx));
	      }

	      if (this.comment) {
	        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');
	        lines.push(this.comment.replace(/^/gm, '#'));
	      }

	      return lines.join('\n') + '\n';
	    }
	  }]);
	  return Document;
	}();

	exports.default = Document;
	(0, _defineProperty2.default)(Document, "defaults", {
	  '1.0': {
	    schema: 'yaml-1.1',
	    merge: true,
	    tagPrefixes: [{
	      handle: '!',
	      prefix: _schema.default.defaultPrefix
	    }, {
	      handle: '!!',
	      prefix: 'tag:private.yaml.org,2002:'
	    }]
	  },
	  '1.1': {
	    schema: 'yaml-1.1',
	    merge: true,
	    tagPrefixes: [{
	      handle: '!',
	      prefix: '!'
	    }, {
	      handle: '!!',
	      prefix: _schema.default.defaultPrefix
	    }]
	  },
	  '1.2': {
	    schema: 'core',
	    merge: false,
	    tagPrefixes: [{
	      handle: '!',
	      prefix: '!'
	    }, {
	      handle: '!!',
	      prefix: _schema.default.defaultPrefix
	    }]
	  }
	});
	});

	unwrapExports(Document_1$1);

	var dist = createCommonjsModule$1(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

	var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

	var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

	var _inherits2 = interopRequireDefault(inherits$1);

	var _parse = interopRequireDefault(parse_1);

	var _Document = interopRequireDefault(Document_1$1);



	var _schema = interopRequireDefault(schema);



	var defaultOptions = {
	  anchorPrefix: 'a',
	  customTags: null,
	  keepCstNodes: false,
	  keepNodeTypes: true,
	  keepBlobsInJSON: true,
	  mapAsMap: false,
	  maxAliasCount: 100,
	  prettyErrors: false,
	  // TODO Set true in v2
	  simpleKeys: false,
	  version: '1.2'
	};

	function createNode(value) {
	  var wrapScalars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	  var tag = arguments.length > 2 ? arguments[2] : undefined;

	  if (tag === undefined && typeof wrapScalars === 'string') {
	    tag = wrapScalars;
	    wrapScalars = true;
	  }

	  var options = Object.assign({}, _Document.default.defaults[defaultOptions.version], defaultOptions);
	  var schema = new _schema.default(options);
	  return schema.createNode(value, wrapScalars, tag);
	}

	var Document =
	/*#__PURE__*/
	function (_YAMLDocument) {
	  (0, _inherits2.default)(Document, _YAMLDocument);

	  function Document(options) {
	    (0, _classCallCheck2.default)(this, Document);
	    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Document).call(this, Object.assign({}, defaultOptions, options)));
	  }

	  return Document;
	}(_Document.default);

	function parseAllDocuments(src, options) {
	  var stream = [];
	  var prev;
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = (0, _parse.default)(src)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var cstDoc = _step.value;
	      var doc = new Document(options);
	      doc.parse(cstDoc, prev);
	      stream.push(doc);
	      prev = doc;
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return != null) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  return stream;
	}

	function parseDocument(src, options) {
	  var cst = (0, _parse.default)(src);
	  var doc = new Document(options).parse(cst[0]);

	  if (cst.length > 1) {
	    var errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';
	    doc.errors.unshift(new errors.YAMLSemanticError(cst[1], errMsg));
	  }

	  return doc;
	}

	function parse(src, options) {
	  var doc = parseDocument(src, options);
	  doc.warnings.forEach(function (warning) {
	    return (0, warnings.warn)(warning);
	  });
	  if (doc.errors.length > 0) throw doc.errors[0];
	  return doc.toJSON();
	}

	function stringify(value, options) {
	  var doc = new Document(options);
	  doc.contents = value;
	  return String(doc);
	}

	var _default = {
	  createNode: createNode,
	  defaultOptions: defaultOptions,
	  Document: Document,
	  parse: parse,
	  parseAllDocuments: parseAllDocuments,
	  parseCST: _parse.default,
	  parseDocument: parseDocument,
	  stringify: stringify
	};
	exports.default = _default;
	});

	unwrapExports(dist);

	var browser$1$1 = dist.default;

	function _classCallCheck$1$1(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties$1$1(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass$1$1(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties$1$1(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties$1$1(Constructor, staticProps);
	  return Constructor;
	}

	function _defineProperty$1$1(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	var commonjsGlobal$1$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global$1$1 !== 'undefined' ? global$1$1 : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule$1$1(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var grpcWeb = createCommonjsModule$1$1(function (module) {
	var aa="function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value);},l="undefined"!=typeof window&&window===commonjsGlobal$1$1?commonjsGlobal$1$1:"undefined"!=typeof commonjsGlobal$1$1&&null!=commonjsGlobal$1$1?commonjsGlobal$1$1:commonjsGlobal$1$1;function ba(a){if(a){for(var b=l,c=["Promise"],d=0;d<c.length-1;d++){var e=c[d];e in b||(b[e]={});b=b[e];}c=c[c.length-1];d=b[c];a=a(d);a!=d&&null!=a&&aa(b,c,{configurable:!0,writable:!0,value:a});}}function ca(){ca=function(){};l.Symbol||(l.Symbol=da);}
	var da=function(){var a=0;return function(b){return "jscomp_symbol_"+(b||"")+a++}}();function m(){ca();var a=l.Symbol.iterator;a||(a=l.Symbol.iterator=l.Symbol("iterator"));"function"!=typeof Array.prototype[a]&&aa(Array.prototype,a,{configurable:!0,writable:!0,value:function(){return ea(this)}});m=function(){};}function ea(a){var b=0;return fa(function(){return b<a.length?{done:!1,value:a[b++]}:{done:!0}})}function fa(a){m();a={next:a};a[l.Symbol.iterator]=function(){return this};return a}
	function ha(a){m();var b=a[Symbol.iterator];return b?b.call(a):ea(a)}
	ba(function(a){function b(a){this.b=0;this.c=void 0;this.a=[];var b=this.f();try{a(b.resolve,b.reject);}catch(k){b.reject(k);}}function c(){this.a=null;}function d(a){return a instanceof b?a:new b(function(b){b(a);})}if(a)return a;c.prototype.b=function(a){null==this.a&&(this.a=[],this.f());this.a.push(a);};c.prototype.f=function(){var a=this;this.c(function(){a.h();});};var e=l.setTimeout;c.prototype.c=function(a){e(a,0);};c.prototype.h=function(){for(;this.a&&this.a.length;){var a=this.a;this.a=[];for(var b=
	0;b<a.length;++b){var c=a[b];a[b]=null;try{c();}catch(F){this.g(F);}}}this.a=null;};c.prototype.g=function(a){this.c(function(){throw a;});};b.prototype.f=function(){function a(a){return function(d){c||(c=!0,a.call(b,d));}}var b=this,c=!1;return {resolve:a(this.m),reject:a(this.g)}};b.prototype.m=function(a){if(a===this)this.g(new TypeError("A Promise cannot resolve to itself"));else if(a instanceof b)this.o(a);else {a:switch(typeof a){case "object":var c=null!=a;break a;case "function":c=!0;break a;default:c=
	!1;}c?this.l(a):this.h(a);}};b.prototype.l=function(a){var b=void 0;try{b=a.then;}catch(k){this.g(k);return}"function"==typeof b?this.u(b,a):this.h(a);};b.prototype.g=function(a){this.i(2,a);};b.prototype.h=function(a){this.i(1,a);};b.prototype.i=function(a,b){if(0!=this.b)throw Error("Cannot settle("+a+", "+b+"): Promise already settled in state"+this.b);this.b=a;this.c=b;this.j();};b.prototype.j=function(){if(null!=this.a){for(var a=0;a<this.a.length;++a)f.b(this.a[a]);this.a=null;}};var f=new c;b.prototype.o=
	function(a){var b=this.f();a.A(b.resolve,b.reject);};b.prototype.u=function(a,b){var c=this.f();try{a.call(b,c.resolve,c.reject);}catch(F){c.reject(F);}};b.prototype.then=function(a,c){function d(a,b){return "function"==typeof a?function(b){try{e(a(b));}catch(xb){f(xb);}}:b}var e,f,g=new b(function(a,b){e=a;f=b;});this.A(d(a,e),d(c,f));return g};b.prototype.catch=function(a){return this.then(void 0,a)};b.prototype.A=function(a,b){function c(){switch(d.b){case 1:a(d.c);break;case 2:b(d.c);break;default:throw Error("Unexpected state: "+
	d.b);}}var d=this;null==this.a?f.b(c):this.a.push(c);};b.resolve=d;b.reject=function(a){return new b(function(b,c){c(a);})};b.race=function(a){return new b(function(b,c){for(var e=ha(a),f=e.next();!f.done;f=e.next())d(f.value).A(b,c);})};b.all=function(a){var c=ha(a),e=c.next();return e.done?d([]):new b(function(a,b){function f(b){return function(c){g[b]=c;h--;0==h&&a(g);}}var g=[],h=0;do g.push(void 0),h++,d(e.value).A(f(g.length-1),b),e=c.next();while(!e.done)})};return b});var n=n||{},p=commonjsGlobal$1$1;
	function q(a){return "string"==typeof a}function r(a,b){a=a.split(".");b=b||p;for(var c=0;c<a.length;c++)if(b=b[a[c]],null==b)return null;return b}function t(){}
	function u(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return "array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return "object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return "array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return "function"}else return "null";
	else if("function"==b&&"undefined"==typeof a.call)return "object";return b}function v(a){var b=typeof a;return "object"==b&&null!=a||"function"==b}function ka(a,b,c){return a.call.apply(a.bind,arguments)}
	function la(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function w(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?w=ka:w=la;return w.apply(null,arguments)}function x(a,b){function c(){}c.prototype=b.prototype;a.T=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.V=function(a,c,f){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)};}function na(a){switch(a){case 0:return "No Error";case 1:return "Access denied to content document";case 2:return "File not found";case 3:return "Firefox silently errored";case 4:return "Application custom error";case 5:return "An exception occurred";case 6:return "Http response at 400 or 500 level";case 7:return "Request was aborted";case 8:return "Request timed out";case 9:return "The resource is not available offline";default:return "Unrecognized error code"}}function y(a){if(Error.captureStackTrace)Error.captureStackTrace(this,y);else {var b=Error().stack;b&&(this.stack=b);}a&&(this.message=String(a));}x(y,Error);y.prototype.name="CustomError";function oa(a,b){for(var c=a.split("%s"),d="",e=Array.prototype.slice.call(arguments,1);e.length&&1<c.length;)d+=c.shift()+e.shift();return d+c.join("%s")}var pa=String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")};function z(a,b){return a<b?-1:a>b?1:0}function qa(a,b){b.unshift(a);y.call(this,oa.apply(null,b));b.shift();}x(qa,y);qa.prototype.name="AssertionError";function ra(a,b){throw new qa("Failure"+(a?": "+a:""),Array.prototype.slice.call(arguments,1));}function sa(){this.j=null;this.i=[];this.l=0;this.b=ta;this.f=this.a=this.h=0;this.c=null;this.g=0;}var ta=0;function ua(a,b,c,d){a.b=3;a.j="The stream is broken @"+a.l+"/"+c+". Error: "+d+". With input:\n"+b;throw Error(a.j);}
	function va(a,b){function c(a){0==a?g.h=a:128==a?g.h=a:ua(g,h,k,"invalid frame byte");g.b=1;g.a=0;g.f=0;}function d(a){g.f++;g.a=(g.a<<8)+a;4==g.f&&(g.b=2,g.g=0,"undefined"!==typeof Uint8Array?g.c=new Uint8Array(g.a):g.c=Array(g.a),0==g.a&&f());}function e(a){g.c[g.g++]=a;g.g==g.a&&f();}function f(){var a={};a[g.h]=g.c;g.i.push(a);g.b=ta;}for(var g=a,h=b instanceof Array?b:new Uint8Array(b),k=0;k<h.length;){switch(g.b){case 3:ua(g,h,k,"stream already broken");break;case ta:c(h[k]);break;case 1:d(h[k]);
	break;case 2:e(h[k]);break;default:throw Error("unexpected parser state: "+g.b);}g.l++;k++;}a=g.i;g.i=[];return 0<a.length?a:null}var wa=Array.prototype.indexOf?function(a,b){return Array.prototype.indexOf.call(a,b,void 0)}:function(a,b){if(q(a))return q(b)&&1==b.length?a.indexOf(b,0):-1;for(var c=0;c<a.length;c++)if(c in a&&a[c]===b)return c;return -1};function xa(a){a:{var b=ya;for(var c=a.length,d=q(a)?a.split(""):a,e=0;e<c;e++)if(e in d&&b.call(void 0,d[e],e,a)){b=e;break a}b=-1;}return 0>b?null:q(a)?a.charAt(b):a[b]}var A;a:{var za=p.navigator;if(za){var Aa=za.userAgent;if(Aa){A=Aa;break a}}A="";}function Ba(a,b){for(var c in a)b.call(void 0,a[c],c,a);}var Ca="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");function Da(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<Ca.length;f++)c=Ca[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c]);}}function Ea(){this.H=this.H;}Ea.prototype.H=!1;function Ga(a){Ga[" "](a);return a}Ga[" "]=t;function Ha(a,b){var c=Ia;return Object.prototype.hasOwnProperty.call(c,a)?c[a]:c[a]=b(a)}var Ja=-1!=A.indexOf("Opera"),B=-1!=A.indexOf("Trident")||-1!=A.indexOf("MSIE"),Ka=-1!=A.indexOf("Edge"),La=-1!=A.indexOf("Gecko")&&!(-1!=A.toLowerCase().indexOf("webkit")&&-1==A.indexOf("Edge"))&&!(-1!=A.indexOf("Trident")||-1!=A.indexOf("MSIE"))&&-1==A.indexOf("Edge"),Ma=-1!=A.toLowerCase().indexOf("webkit")&&-1==A.indexOf("Edge");function Na(){var a=p.document;return a?a.documentMode:void 0}var C;
	a:{var Oa="",Pa=function(){var a=A;if(La)return /rv:([^\);]+)(\)|;)/.exec(a);if(Ka)return /Edge\/([\d\.]+)/.exec(a);if(B)return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(Ma)return /WebKit\/(\S+)/.exec(a);if(Ja)return /(?:Version)[ \/]?(\S+)/.exec(a)}();Pa&&(Oa=Pa?Pa[1]:"");if(B){var Qa=Na();if(null!=Qa&&Qa>parseFloat(Oa)){C=String(Qa);break a}}C=Oa;}var Ia={};
	function Ra(a){return Ha(a,function(){for(var b=0,c=pa(String(C)).split("."),d=pa(String(a)).split("."),e=Math.max(c.length,d.length),f=0;0==b&&f<e;f++){var g=c[f]||"",h=d[f]||"";do{g=/(\d*)(\D*)(.*)/.exec(g)||["","","",""];h=/(\d*)(\D*)(.*)/.exec(h)||["","","",""];if(0==g[0].length&&0==h[0].length)break;b=z(0==g[1].length?0:parseInt(g[1],10),0==h[1].length?0:parseInt(h[1],10))||z(0==g[2].length,0==h[2].length)||z(g[2],h[2]);g=g[3];h=h[3];}while(0==b)}return 0<=b})}var Sa;var Ta=p.document;
	Sa=Ta&&B?Na()||("CSS1Compat"==Ta.compatMode?parseInt(C,10):5):void 0;var Ua=Object.freeze||function(a){return a};var Va;(Va=!B)||(Va=9<=Number(Sa));var Wa=Va,Xa=B&&!Ra("9"),Ya=function(){if(!p.addEventListener||!Object.defineProperty)return !1;var a=!1,b=Object.defineProperty({},"passive",{get:function(){a=!0;}});p.addEventListener("test",t,b);p.removeEventListener("test",t,b);return a}();function D(a,b){this.type=a;this.a=this.target=b;}D.prototype.b=function(){};function E(a,b){D.call(this,a?a.type:"");this.relatedTarget=this.a=this.target=null;this.button=this.screenY=this.screenX=this.clientY=this.clientX=0;this.key="";this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1;this.pointerId=0;this.pointerType="";this.c=null;if(a){var c=this.type=a.type,d=a.changedTouches?a.changedTouches[0]:null;this.target=a.target||a.srcElement;this.a=b;if(b=a.relatedTarget){if(La){a:{try{Ga(b.nodeName);var e=!0;break a}catch(f){}e=!1;}e||(b=null);}}else "mouseover"==c?b=a.fromElement:
	"mouseout"==c&&(b=a.toElement);this.relatedTarget=b;null===d?(this.clientX=void 0!==a.clientX?a.clientX:a.pageX,this.clientY=void 0!==a.clientY?a.clientY:a.pageY,this.screenX=a.screenX||0,this.screenY=a.screenY||0):(this.clientX=void 0!==d.clientX?d.clientX:d.pageX,this.clientY=void 0!==d.clientY?d.clientY:d.pageY,this.screenX=d.screenX||0,this.screenY=d.screenY||0);this.button=a.button;this.key=a.key||"";this.ctrlKey=a.ctrlKey;this.altKey=a.altKey;this.shiftKey=a.shiftKey;this.metaKey=a.metaKey;
	this.pointerId=a.pointerId||0;this.pointerType=q(a.pointerType)?a.pointerType:Za[a.pointerType]||"";this.c=a;a.defaultPrevented&&this.b();}}x(E,D);var Za=Ua({2:"touch",3:"pen",4:"mouse"});E.prototype.b=function(){E.T.b.call(this);var a=this.c;if(a.preventDefault)a.preventDefault();else if(a.returnValue=!1,Xa)try{if(a.ctrlKey||112<=a.keyCode&&123>=a.keyCode)a.keyCode=-1;}catch(b){}};var G="closure_listenable_"+(1E6*Math.random()|0),$a=0;function ab(a,b,c,d,e){this.listener=a;this.proxy=null;this.src=b;this.type=c;this.capture=!!d;this.B=e;this.key=++$a;this.s=this.w=!1;}function bb(a){a.s=!0;a.listener=null;a.proxy=null;a.src=null;a.B=null;}function H(a){this.src=a;this.a={};this.b=0;}H.prototype.add=function(a,b,c,d,e){var f=a.toString();a=this.a[f];a||(a=this.a[f]=[],this.b++);var g=cb(a,b,d,e);-1<g?(b=a[g],c||(b.w=!1)):(b=new ab(b,this.src,f,!!d,e),b.w=c,a.push(b));return b};function db(a,b){var c=b.type;if(c in a.a){var d=a.a[c],e=wa(d,b),f;(f=0<=e)&&Array.prototype.splice.call(d,e,1);f&&(bb(b),0==a.a[c].length&&(delete a.a[c],a.b--));}}
	function cb(a,b,c,d){for(var e=0;e<a.length;++e){var f=a[e];if(!f.s&&f.listener==b&&f.capture==!!c&&f.B==d)return e}return -1}var eb="closure_lm_"+(1E6*Math.random()|0),fb={};function hb(a,b,c,d,e){if(d&&d.once)ib(a,b,c,d,e);else if("array"==u(b))for(var f=0;f<b.length;f++)hb(a,b[f],c,d,e);else c=jb(c),a&&a[G]?a.f.add(String(b),c,!1,v(d)?!!d.capture:!!d,e):kb(a,b,c,!1,d,e);}
	function kb(a,b,c,d,e,f){if(!b)throw Error("Invalid event type");var g=v(e)?!!e.capture:!!e,h=I(a);h||(a[eb]=h=new H(a));c=h.add(b,c,d,g,f);if(!c.proxy){d=lb();c.proxy=d;d.src=a;d.listener=c;if(a.addEventListener)Ya||(e=g),void 0===e&&(e=!1),a.addEventListener(b.toString(),d,e);else if(a.attachEvent)a.attachEvent(mb(b.toString()),d);else if(a.addListener&&a.removeListener)a.addListener(d);else throw Error("addEventListener and attachEvent are unavailable.");}}
	function lb(){var a=nb,b=Wa?function(c){return a.call(b.src,b.listener,c)}:function(c){c=a.call(b.src,b.listener,c);if(!c)return c};return b}function ib(a,b,c,d,e){if("array"==u(b))for(var f=0;f<b.length;f++)ib(a,b[f],c,d,e);else c=jb(c),a&&a[G]?a.f.add(String(b),c,!0,v(d)?!!d.capture:!!d,e):kb(a,b,c,!0,d,e);}
	function ob(a,b,c,d,e){if("array"==u(b))for(var f=0;f<b.length;f++)ob(a,b[f],c,d,e);else (d=v(d)?!!d.capture:!!d,c=jb(c),a&&a[G])?(a=a.f,b=String(b).toString(),b in a.a&&(f=a.a[b],c=cb(f,c,d,e),-1<c&&(bb(f[c]),Array.prototype.splice.call(f,c,1),0==f.length&&(delete a.a[b],a.b--)))):a&&(a=I(a))&&(b=a.a[b.toString()],a=-1,b&&(a=cb(b,c,d,e)),(c=-1<a?b[a]:null)&&pb(c));}
	function pb(a){if("number"!=typeof a&&a&&!a.s){var b=a.src;if(b&&b[G])db(b.f,a);else {var c=a.type,d=a.proxy;b.removeEventListener?b.removeEventListener(c,d,a.capture):b.detachEvent?b.detachEvent(mb(c),d):b.addListener&&b.removeListener&&b.removeListener(d);(c=I(b))?(db(c,a),0==c.b&&(c.src=null,b[eb]=null)):bb(a);}}}function mb(a){return a in fb?fb[a]:fb[a]="on"+a}
	function qb(a,b,c,d){var e=!0;if(a=I(a))if(b=a.a[b.toString()])for(b=b.concat(),a=0;a<b.length;a++){var f=b[a];f&&f.capture==c&&!f.s&&(f=rb(f,d),e=e&&!1!==f);}return e}function rb(a,b){var c=a.listener,d=a.B||a.src;a.w&&pb(a);return c.call(d,b)}
	function nb(a,b){if(a.s)return !0;if(!Wa){var c=b||r("window.event");b=new E(c,this);var d=!0;if(!(0>c.keyCode||void 0!=c.returnValue)){a:{var e=!1;if(0==c.keyCode)try{c.keyCode=-1;break a}catch(g){e=!0;}if(e||void 0==c.returnValue)c.returnValue=!0;}c=[];for(e=b.a;e;e=e.parentNode)c.push(e);a=a.type;for(e=c.length-1;0<=e;e--){b.a=c[e];var f=qb(c[e],a,!0,b);d=d&&f;}for(e=0;e<c.length;e++)b.a=c[e],f=qb(c[e],a,!1,b),d=d&&f;}return d}return rb(a,new E(b,this))}
	function I(a){a=a[eb];return a instanceof H?a:null}var sb="__closure_events_fn_"+(1E9*Math.random()>>>0);function jb(a){if("function"==u(a))return a;a[sb]||(a[sb]=function(b){return a.handleEvent(b)});return a[sb]}function J(){Ea.call(this);this.f=new H(this);this.P=this;}x(J,Ea);J.prototype[G]=!0;J.prototype.removeEventListener=function(a,b,c,d){ob(this,a,b,c,d);};function K(a,b){a=a.P;var c=b.type||b;if(q(b))b=new D(b,a);else if(b instanceof D)b.target=b.target||a;else {var d=b;b=new D(c,a);Da(b,d);}a=b.a=a;tb(a,c,!0,b);tb(a,c,!1,b);}
	function tb(a,b,c,d){if(b=a.f.a[String(b)]){b=b.concat();for(var e=!0,f=0;f<b.length;++f){var g=b[f];if(g&&!g.s&&g.capture==c){var h=g.listener,k=g.B||g.src;g.w&&db(a.f,g);e=!1!==h.call(k,d)&&e;}}}}function ub(a,b,c){if("function"==u(a))c&&(a=w(a,c));else if(a&&"function"==typeof a.handleEvent)a=w(a.handleEvent,a);else throw Error("Invalid listener argument");return 2147483647<Number(b)?-1:p.setTimeout(a,b||0)}function vb(a,b,c){this.reset(a,b,c,void 0,void 0);}vb.prototype.a=null;vb.prototype.reset=function(a,b,c,d,e){delete this.a;};function yb(a){this.f=a;this.b=this.c=this.a=null;}function L(a,b){this.name=a;this.value=b;}L.prototype.toString=function(){return this.name};var zb=new L("SEVERE",1E3),Ab=new L("CONFIG",700),Bb=new L("FINE",500);function Cb(a){if(a.c)return a.c;if(a.a)return Cb(a.a);ra("Root logger has no level set.");return null}yb.prototype.log=function(a,b,c){if(a.value>=Cb(this).value)for("function"==u(b)&&(b=b()),a=new vb(a,String(b),this.f),c&&(a.a=c),c=this;c;)c=c.a;};var Db={},M=null;
	function Eb(a){M||(M=new yb(""),Db[""]=M,M.c=Ab);var b;if(!(b=Db[a])){b=new yb(a);var c=a.lastIndexOf("."),d=a.substr(c+1);c=Eb(a.substr(0,c));c.b||(c.b={});c.b[d]=b;b.a=c;Db[a]=b;}return b}function N(a,b){a&&a.log(Bb,b,void 0);}function Fb(){}Fb.prototype.a=null;function Gb(a){var b;(b=a.a)||(b={},Hb(a)&&(b[0]=!0,b[1]=!0),b=a.a=b);return b}var Ib;function Jb(){}x(Jb,Fb);function Kb(a){return (a=Hb(a))?new ActiveXObject(a):new XMLHttpRequest}function Hb(a){if(!a.b&&"undefined"==typeof XMLHttpRequest&&"undefined"!=typeof ActiveXObject){for(var b=["MSXML2.XMLHTTP.6.0","MSXML2.XMLHTTP.3.0","MSXML2.XMLHTTP","Microsoft.XMLHTTP"],c=0;c<b.length;c++){var d=b[c];try{return new ActiveXObject(d),a.b=d}catch(e){}}throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");}return a.b}Ib=new Jb;function O(a,b){this.b={};this.a=[];this.c=0;var c=arguments.length;if(1<c){if(c%2)throw Error("Uneven number of arguments");for(var d=0;d<c;d+=2)this.set(arguments[d],arguments[d+1]);}else a&&Lb(this,a);}O.prototype.g=function(){P(this);for(var a=[],b=0;b<this.a.length;b++)a.push(this.b[this.a[b]]);return a};O.prototype.f=function(){P(this);return this.a.concat()};function Mb(a){a.b={};a.a.length=0;a.c=0;}
	function P(a){if(a.c!=a.a.length){for(var b=0,c=0;b<a.a.length;){var d=a.a[b];Q(a.b,d)&&(a.a[c++]=d);b++;}a.a.length=c;}if(a.c!=a.a.length){var e={};for(c=b=0;b<a.a.length;)d=a.a[b],Q(e,d)||(a.a[c++]=d,e[d]=1),b++;a.a.length=c;}}O.prototype.get=function(a,b){return Q(this.b,a)?this.b[a]:b};O.prototype.set=function(a,b){Q(this.b,a)||(this.c++,this.a.push(a));this.b[a]=b;};
	function Lb(a,b){if(b instanceof O){var c=b.f();b=b.g();}else {c=[];var d=0;for(e in b)c[d++]=e;d=[];var e=0;for(var f in b)d[e++]=b[f];b=d;}for(f=0;f<c.length;f++)a.set(c[f],b[f]);}O.prototype.forEach=function(a,b){for(var c=this.f(),d=0;d<c.length;d++){var e=c[d],f=this.get(e);a.call(b,f,e,this);}};function Nb(a){P(a);for(var b={},c=0;c<a.a.length;c++){var d=a.a[c];b[d]=a.b[d];}return b}function Q(a,b){return Object.prototype.hasOwnProperty.call(a,b)}var Ob=/^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;function R(a){J.call(this);this.headers=new O;this.v=a||null;this.c=!1;this.G=this.a=null;this.K=this.u="";this.g=0;this.j="";this.i=this.J=this.o=this.I=!1;this.l=0;this.D=null;this.h=Pb;this.F=this.m=!1;}x(R,J);var Pb="",Qb=R.prototype,Rb=Eb("goog.net.XhrIo");Qb.b=Rb;var Sb=/^https?$/i,Tb=["POST","PUT"];
	function Ub(a,b,c){if(a.a)throw Error("[goog.net.XhrIo] Object is active with another request="+a.u+"; newUri="+b);a.u=b;a.j="";a.g=0;a.K="POST";a.I=!1;a.c=!0;a.a=a.v?Kb(a.v):Kb(Ib);a.G=a.v?Gb(a.v):Gb(Ib);a.a.onreadystatechange=w(a.L,a);try{N(a.b,S(a,"Opening Xhr")),a.J=!0,a.a.open("POST",String(b),!0),a.J=!1;}catch(f){N(a.b,S(a,"Error opening Xhr: "+f.message));Vb(a,f);return}b=c||"";c=new O(a.headers);var d=xa(c.f()),e=p.FormData&&b instanceof p.FormData;!(0<=wa(Tb,"POST"))||d||e||c.set("Content-Type",
	"application/x-www-form-urlencoded;charset=utf-8");c.forEach(function(a,b){this.a.setRequestHeader(b,a);},a);a.h&&(a.a.responseType=a.h);"withCredentials"in a.a&&a.a.withCredentials!==a.m&&(a.a.withCredentials=a.m);try{Wb(a),0<a.l&&(a.F=Xb(a.a),N(a.b,S(a,"Will abort after "+a.l+"ms if incomplete, xhr2 "+a.F)),a.F?(a.a.timeout=a.l,a.a.ontimeout=w(a.M,a)):a.D=ub(a.M,a.l,a)),N(a.b,S(a,"Sending request")),a.o=!0,a.a.send(b),a.o=!1;}catch(f){N(a.b,S(a,"Send error: "+f.message)),Vb(a,f);}}
	function Xb(a){return B&&Ra(9)&&"number"==typeof a.timeout&&void 0!==a.ontimeout}function ya(a){return "content-type"==a.toLowerCase()}R.prototype.M=function(){"undefined"!=typeof n&&this.a&&(this.j="Timed out after "+this.l+"ms, aborting",this.g=8,N(this.b,S(this,this.j)),K(this,"timeout"),this.abort(8));};function Vb(a,b){a.c=!1;a.a&&(a.i=!0,a.a.abort(),a.i=!1);a.j=b;a.g=5;Yb(a);Zb(a);}function Yb(a){a.I||(a.I=!0,K(a,"complete"),K(a,"error"));}
	R.prototype.abort=function(a){this.a&&this.c&&(N(this.b,S(this,"Aborting")),this.c=!1,this.i=!0,this.a.abort(),this.i=!1,this.g=a||7,K(this,"complete"),K(this,"abort"),Zb(this));};R.prototype.L=function(){this.H||(this.J||this.o||this.i?$b(this):this.R());};R.prototype.R=function(){$b(this);};
	function $b(a){if(a.c&&"undefined"!=typeof n)if(a.G[1]&&4==T(a)&&2==U(a))N(a.b,S(a,"Local request error detected and ignored"));else if(a.o&&4==T(a))ub(a.L,0,a);else if(K(a,"readystatechange"),4==T(a)){N(a.b,S(a,"Request complete"));a.c=!1;try{var b=U(a);a:switch(b){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:var c=!0;break a;default:c=!1;}var d;if(!(d=c)){var e;if(e=0===b){var f=String(a.u).match(Ob)[1]||null;if(!f&&p.self&&p.self.location){var g=p.self.location.protocol;f=g.substr(0,
	g.length-1);}e=!Sb.test(f?f.toLowerCase():"");}d=e;}if(d)K(a,"complete"),K(a,"success");else {a.g=6;try{var h=2<T(a)?a.a.statusText:"";}catch(k){N(a.b,"Can not get status: "+k.message),h="";}a.j=h+" ["+U(a)+"]";Yb(a);}}finally{Zb(a);}}}function Zb(a){if(a.a){Wb(a);var b=a.a,c=a.G[0]?t:null;a.a=null;a.G=null;K(a,"ready");try{b.onreadystatechange=c;}catch(d){(a=a.b)&&a.log(zb,"Problem encountered resetting onreadystatechange: "+d.message,void 0);}}}
	function Wb(a){a.a&&a.F&&(a.a.ontimeout=null);a.D&&(p.clearTimeout(a.D),a.D=null);}function T(a){return a.a?a.a.readyState:0}function U(a){try{return 2<T(a)?a.a.status:-1}catch(b){return -1}}
	function ac(a){try{if(!a.a)return null;if("response"in a.a)return a.a.response;switch(a.h){case Pb:case "text":return a.a.responseText;case "arraybuffer":if("mozResponseArrayBuffer"in a.a)return a.a.mozResponseArrayBuffer}var b=a.b;b&&b.log(zb,"Response type "+a.h+" is not supported on this browser",void 0);return null}catch(c){return N(a.b,"Can not get response: "+c.message),null}}function bc(a,b){if(a.a&&4==T(a))return a=a.a.getResponseHeader(b),null===a?void 0:a}
	function cc(a,b){return a.a?a.a.getResponseHeader(b):null}function S(a,b){return b+" ["+a.K+" "+a.u+" "+U(a)+"]"}var V=null,W=null;function dc(a){ec();for(var b=V,c=[],d=0;d<a.length;d+=3){var e=a[d],f=d+1<a.length,g=f?a[d+1]:0,h=d+2<a.length,k=h?a[d+2]:0,F=e>>2;e=(e&3)<<4|g>>4;g=(g&15)<<2|k>>6;k&=63;h||(k=64,f||(g=64));c.push(b[F],b[e],b[g],b[k]);}return c.join("")}function fc(a){var b=a.length,c=0;"="===a[b-2]?c=2:"="===a[b-1]&&(c=1);var d=new Uint8Array(Math.ceil(3*b/4)-c),e=0;gc(a,function(a){d[e++]=a;});return d.subarray(0,e)}
	function gc(a,b){function c(b){for(;d<a.length;){var c=a.charAt(d++),e=W[c];if(null!=e)return e;if(!/^[\s\xa0]*$/.test(c))throw Error("Unknown base64 encoding at char: "+c);}return b}ec();for(var d=0;;){var e=c(-1),f=c(0),g=c(64),h=c(64);if(64===h&&-1===e)break;b(e<<2|f>>4);64!=g&&(b(f<<4&240|g>>2),64!=h&&b(g<<6&192|h));}}
	function ec(){if(!V){V={};W={};for(var a=0;65>a;a++)V[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a),W[V[a]]=a,62<=a&&(W["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(a)]=a);}}function X(a){this.a=a.O;this.f=this.c=this.b=this.i=this.h=null;this.g=0;this.j=new sa;var b=this;hb(this.a,"readystatechange",function(){var a=cc(b.a,"Content-Type");if(a){a=a.toLowerCase();var d=cc(b.a,"grpc-status"),e=cc(b.a,"grpc-message");d&&b.b&&b.b({code:Number(d),details:e||"",metadata:void 0});if(0==a.lastIndexOf("application/grpc-web-text",0)){a=b.a;try{var f=a.a?a.a.responseText:"";}catch(k){N(a.b,"Can not get responseText: "+k.message),f="";}a=f.length-f.length%4;f=f.substr(b.g,a-b.g);
	if(0==f.length)return;b.g=a;f=fc(f);}else if(0==a.lastIndexOf("application/grpc",0))f=new Uint8Array(ac(b.a));else return;if(f=va(b.j,[].slice.call(f)))for(a=0;a<f.length;a++)if(0 in f[a]&&(d=f[a][0])&&(d=b.h(d))&&b.i(d),128 in f[a]&&0<f[a][128].length){d="";for(e=0;e<f[a][128].length;e++)d+=String.fromCharCode(f[a][128][e]);var g;d=d.trim().split("\r\n");e={};for(g=0;g<d.length;g++){var h=d[g].indexOf(":");e[d[g].substring(0,h).trim()]=d[g].substring(h+1).trim();}g=e;d=0;e="";"grpc-status"in g&&(d=
	g["grpc-status"]);"grpc-message"in g&&(e=g["grpc-message"]);b.b&&b.b({code:Number(d),details:e,metadata:g});}4==T(b.a)&&b.f&&b.f();}});hb(this.a,"complete",function(){if(b.c){var a=b.a.g;if(0!=a)b.c({code:14,message:na(a)});else {a={};var d=b.a;d=(d.a&&4==T(d)?d.a.getAllResponseHeaders():"").split("\r\n");for(var e=0;e<d.length;e++)if(!/^[\s\xa0]*$/.test(d[e])){var f=2;for(var g=d[e].split(": "),h=[];0<f&&g.length;)h.push(g.shift()),f--;g.length&&h.push(g.join(": "));f=h;a[f[0]]=a[f[0]]?a[f[0]]+(", "+
	f[1]):f[1];}"grpc-status"in a&&0!=Number(bc(b.a,"grpc-status"))&&b.c({code:Number(bc(b.a,"grpc-status")),message:bc(b.a,"grpc-message")});}}});}X.prototype.C=function(a,b){"data"==a?this.i=b:"status"==a?this.b=b:"end"==a?this.f=b:"error"==a&&(this.c=b);return this};X.prototype.on=X.prototype.C;X.prototype.cancel=function(){this.a.abort();};X.prototype.cancel=X.prototype.cancel;function hc(a){var b="";Ba(a,function(a,d){b+=d;b+=":";b+=a;b+="\r\n";});return b}function ic(a,b){a:{for(c in b){var c=!1;break a}c=!0;}if(c)return a;c=hc(b);if(q(a)){b=encodeURIComponent("$httpHeaders");c=null!=c?"="+encodeURIComponent(String(c)):"";if(b+=c){c=a.indexOf("#");0>c&&(c=a.length);var d=a.indexOf("?");if(0>d||d>c){d=c;var e="";}else e=a.substring(d+1,c);a=[a.substr(0,d),e,a.substr(c)];c=a[1];a[1]=b?c?c+"&"+b:b:c;a=a[0]+(a[1]?"?"+a[1]:"")+a[2];}return a}a.a("$httpHeaders",c);return a}function Y(a){this.a=r("format",a)||"text";this.c=r("suppressCorsPreflight",a)||!1;this.b=r("withCredentials",a)||!1;}
	Y.prototype.N=function(a,b,c,d,e){var f=new R;f.m=this.b;var g=new X({O:f});g.h=d.b;g.C("data",function(a){e(null,a);});g.C("status",function(a){0!=a.code&&e({code:a.code,message:a.details},null);});g.C("error",function(a){0!=a.code&&e({code:a.code,message:a.message},null);});Lb(f.headers,c);jc(this,f);this.c&&(c=Nb(f.headers),Mb(f.headers),a=ic(a,c));b=d.a(b);b=kc(b);"text"==this.a?b=dc(b):"binary"==this.a&&(f.h="arraybuffer");Ub(f,a,b);return g};Y.prototype.rpcCall=Y.prototype.N;
	Y.prototype.U=function(a,b,c,d){var e=this;return new Promise(function(f,g){e.N(a,b,c,d,function(a,b){a?g(a):f(b);});})};Y.prototype.unaryCall=Y.prototype.U;Y.prototype.S=function(a,b,c,d){var e=new R;e.m=this.b;var f=new X({O:e});f.h=d.b;Lb(e.headers,c);jc(this,e);this.c&&(c=Nb(e.headers),Mb(e.headers),a=ic(a,c));b=d.a(b);b=kc(b);"text"==this.a?b=dc(b):"binary"==this.a&&(e.h="arraybuffer");Ub(e,a,b);return f};Y.prototype.serverStreaming=Y.prototype.S;
	function kc(a){for(var b=a.length,c=[0,0,0,0],d=new Uint8Array(5+b),e=3;0<=e;e--)c[e]=b%256,b>>>=8;d.set(new Uint8Array(c),1);d.set(a,5);return d}
	function jc(a,b){"text"==a.a?(b.headers.set("Content-Type","application/grpc-web-text"),b.headers.set("Accept","application/grpc-web-text")):b.headers.set("Content-Type","application/grpc-web+proto");b.headers.set("X-User-Agent","grpc-web-javascript/0.1");b.headers.set("X-Grpc-Web","1");if(Q(b.headers.b,"deadline")){a=b.headers.get("deadline");a=Math.round(a-(new Date).getTime());var c=b.headers;Q(c.b,"deadline")&&(delete c.b.deadline,c.c--,c.a.length>2*c.c&&P(c));Infinity===a&&(a=0);0<a&&b.headers.set("grpc-timeout",
	a+"m");}}var Z=module.exports;Z.AbstractClientBase={MethodInfo:function(a,b,c,d){this.name=d;this.a=b;this.b=c;}};Z.GrpcWebClientBase=Y;Z.StatusCode={OK:0,CANCELLED:1,UNKNOWN:2,INVALID_ARGUMENT:3,DEADLINE_EXCEEDED:4,NOT_FOUND:5,ALREADY_EXISTS:6,PERMISSION_DENIED:7,UNAUTHENTICATED:16,RESOURCE_EXHAUSTED:8,FAILED_PRECONDITION:9,ABORTED:10,OUT_OF_RANGE:11,UNIMPLEMENTED:12,INTERNAL:13,UNAVAILABLE:14,DATA_LOSS:15};Z.MethodDescriptor=function(a,b,c,d,e,f){this.name=a;this.a=e;this.b=f;};
	Z.MethodType={UNARY:"unary",SERVER_STREAMING:"server_streaming"};
	});
	var grpcWeb_1 = grpcWeb.AbstractClientBase;
	var grpcWeb_2 = grpcWeb.GrpcWebClientBase;

	var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.findInternal=function(a,b,c){a instanceof String&&(a=String(a));for(var d=a.length,e=0;e<d;e++){var f=a[e];if(b.call(c,f,e,a))return {i:e,v:f}}return {i:-1,v:void 0}};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.SIMPLE_FROUND_POLYFILL=!1;
	$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value);};$jscomp.getGlobal=function(a){return "undefined"!=typeof window&&window===a?a:"undefined"!=typeof commonjsGlobal$1$1&&null!=commonjsGlobal$1$1?commonjsGlobal$1$1:a};$jscomp.global=$jscomp.getGlobal(commonjsGlobal$1$1);
	$jscomp.polyfill=function(a,b,c,d){if(b){c=$jscomp.global;a=a.split(".");for(d=0;d<a.length-1;d++){var e=a[d];e in c||(c[e]={});c=c[e];}a=a[a.length-1];d=c[a];b=b(d);b!=d&&null!=b&&$jscomp.defineProperty(c,a,{configurable:!0,writable:!0,value:b});}};$jscomp.polyfill("Array.prototype.findIndex",function(a){return a?a:function(a,c){return $jscomp.findInternal(this,a,c).i}},"es6","es3");
	$jscomp.checkStringArgs=function(a,b,c){if(null==a)throw new TypeError("The 'this' value for String.prototype."+c+" must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype."+c+" must not be a regular expression");return a+""};
	$jscomp.polyfill("String.prototype.endsWith",function(a){return a?a:function(a,c){var b=$jscomp.checkStringArgs(this,a,"endsWith");a+="";void 0===c&&(c=b.length);c=Math.max(0,Math.min(c|0,b.length));for(var e=a.length;0<e&&0<c;)if(b[--c]!=a[--e])return !1;return 0>=e}},"es6","es3");$jscomp.polyfill("Array.prototype.find",function(a){return a?a:function(a,c){return $jscomp.findInternal(this,a,c).v}},"es6","es3");
	$jscomp.polyfill("String.prototype.startsWith",function(a){return a?a:function(a,c){var b=$jscomp.checkStringArgs(this,a,"startsWith");a+="";var e=b.length,f=a.length;c=Math.max(0,Math.min(c|0,b.length));for(var g=0;g<f&&c<e;)if(b[c++]!=a[g++])return !1;return g>=f}},"es6","es3");
	$jscomp.polyfill("String.prototype.repeat",function(a){return a?a:function(a){var b=$jscomp.checkStringArgs(this,null,"repeat");if(0>a||1342177279<a)throw new RangeError("Invalid count value");a|=0;for(var d="";a;)if(a&1&&(d+=b),a>>>=1)b+=b;return d}},"es6","es3");var COMPILED=!0,goog=goog||{};goog.global=commonjsGlobal$1$1||self;goog.isDef=function(a){return void 0!==a};goog.isString=function(a){return "string"==typeof a};goog.isBoolean=function(a){return "boolean"==typeof a};
	goog.isNumber=function(a){return "number"==typeof a};goog.exportPath_=function(a,b,c){a=a.split(".");c=c||goog.global;a[0]in c||"undefined"==typeof c.execScript||c.execScript("var "+a[0]);for(var d;a.length&&(d=a.shift());)!a.length&&goog.isDef(b)?c[d]=b:c=c[d]&&c[d]!==Object.prototype[d]?c[d]:c[d]={};};
	goog.define=function(a,b){return b};goog.FEATURESET_YEAR=2012;goog.DEBUG=!0;goog.LOCALE="en";goog.TRUSTED_SITE=!0;goog.STRICT_MODE_COMPATIBLE=!1;goog.DISALLOW_TEST_ONLY_CODE=!goog.DEBUG;goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING=!1;
	goog.provide=function(a){if(goog.isInModuleLoader_())throw Error("goog.provide cannot be used within a module.");goog.constructNamespace_(a);};goog.constructNamespace_=function(a,b){goog.exportPath_(a,b);};
	goog.getScriptNonce=function(a){if(a&&a!=goog.global)return goog.getScriptNonce_(a.document);null===goog.cspNonce_&&(goog.cspNonce_=goog.getScriptNonce_(goog.global.document));return goog.cspNonce_};goog.NONCE_PATTERN_=/^[\w+/_-]+[=]{0,2}$/;goog.cspNonce_=null;goog.getScriptNonce_=function(a){return (a=a.querySelector&&a.querySelector("script[nonce]"))&&(a=a.nonce||a.getAttribute("nonce"))&&goog.NONCE_PATTERN_.test(a)?a:""};goog.VALID_MODULE_RE_=/^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
	goog.module=function(a){if(!goog.isString(a)||!a||-1==a.search(goog.VALID_MODULE_RE_))throw Error("Invalid module identifier");if(!goog.isInGoogModuleLoader_())throw Error("Module "+a+" has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");
	if(goog.moduleLoaderState_.moduleName)throw Error("goog.module may only be called once per module.");goog.moduleLoaderState_.moduleName=a;};goog.module.get=function(a){return goog.module.getInternal_(a)};
	goog.module.getInternal_=function(a){return null};goog.ModuleType={ES6:"es6",GOOG:"goog"};goog.moduleLoaderState_=null;goog.isInModuleLoader_=function(){return goog.isInGoogModuleLoader_()||goog.isInEs6ModuleLoader_()};goog.isInGoogModuleLoader_=function(){return !!goog.moduleLoaderState_&&goog.moduleLoaderState_.type==goog.ModuleType.GOOG};
	goog.isInEs6ModuleLoader_=function(){if(goog.moduleLoaderState_&&goog.moduleLoaderState_.type==goog.ModuleType.ES6)return !0;var a=goog.global.$jscomp;return a?"function"!=typeof a.getCurrentModulePath?!1:!!a.getCurrentModulePath():!1};
	goog.module.declareLegacyNamespace=function(){goog.moduleLoaderState_.declareLegacyNamespace=!0;};
	goog.declareModuleId=function(a){if(goog.moduleLoaderState_)goog.moduleLoaderState_.moduleName=a;else {var b=goog.global.$jscomp;if(!b||"function"!=typeof b.getCurrentModulePath)throw Error('Module with namespace "'+
	a+'" has been loaded incorrectly.');b=b.require(b.getCurrentModulePath());goog.loadedModules_[a]={exports:b,type:goog.ModuleType.ES6,moduleId:a};}};goog.setTestOnly=function(a){if(goog.DISALLOW_TEST_ONLY_CODE)throw a=a||"",Error("Importing test-only code into non-debug environment"+(a?": "+a:"."));};goog.forwardDeclare=function(a){};
	goog.getObjectByName=function(a,b){a=a.split(".");b=b||goog.global;for(var c=0;c<a.length;c++)if(b=b[a[c]],!goog.isDefAndNotNull(b))return null;return b};goog.globalize=function(a,b){b=b||goog.global;for(var c in a)b[c]=a[c];};
	goog.addDependency=function(a,b,c,d){};goog.ENABLE_DEBUG_LOADER=!0;goog.logToConsole_=function(a){goog.global.console&&goog.global.console.error(a);};
	goog.require=function(a){};goog.requireType=function(a){return {}};goog.basePath="";goog.nullFunction=function(){};
	goog.abstractMethod=function(){throw Error("unimplemented abstract method");};goog.addSingletonGetter=function(a){a.instance_=void 0;a.getInstance=function(){if(a.instance_)return a.instance_;goog.DEBUG&&(goog.instantiatedSingletons_[goog.instantiatedSingletons_.length]=a);return a.instance_=new a};};goog.instantiatedSingletons_=[];goog.LOAD_MODULE_USING_EVAL=!0;goog.SEAL_MODULE_EXPORTS=goog.DEBUG;goog.loadedModules_={};goog.DEPENDENCIES_ENABLED=!COMPILED;goog.TRANSPILE="detect";
	goog.ASSUME_ES_MODULES_TRANSPILED=!1;goog.TRANSPILE_TO_LANGUAGE="";goog.TRANSPILER="transpile.js";goog.hasBadLetScoping=null;goog.useSafari10Workaround=function(){if(null==goog.hasBadLetScoping){try{var a=!eval('"use strict";let x = 1; function f() { return typeof x; };f() == "number";');}catch(b){a=!1;}goog.hasBadLetScoping=a;}return goog.hasBadLetScoping};goog.workaroundSafari10EvalBug=function(a){return "(function(){"+a+"\n;})();\n"};
	goog.loadModule=function(a){var b=goog.moduleLoaderState_;try{goog.moduleLoaderState_={moduleName:"",declareLegacyNamespace:!1,type:goog.ModuleType.GOOG};if(goog.isFunction(a))var c=a.call(void 0,{});else if(goog.isString(a))goog.useSafari10Workaround()&&(a=goog.workaroundSafari10EvalBug(a)),c=goog.loadModuleFromSource_.call(void 0,a);else throw Error("Invalid module definition");var d=goog.moduleLoaderState_.moduleName;if(goog.isString(d)&&d)goog.moduleLoaderState_.declareLegacyNamespace?goog.constructNamespace_(d,
	c):goog.SEAL_MODULE_EXPORTS&&Object.seal&&"object"==typeof c&&null!=c&&Object.seal(c),goog.loadedModules_[d]={exports:c,type:goog.ModuleType.GOOG,moduleId:goog.moduleLoaderState_.moduleName};else throw Error('Invalid module name "'+d+'"');}finally{goog.moduleLoaderState_=b;}};goog.loadModuleFromSource_=function(a){eval(a);return {}};goog.normalizePath_=function(a){a=a.split("/");for(var b=0;b<a.length;)"."==a[b]?a.splice(b,1):b&&".."==a[b]&&a[b-1]&&".."!=a[b-1]?a.splice(--b,2):b++;return a.join("/")};
	goog.loadFileSync_=function(a){if(goog.global.CLOSURE_LOAD_FILE_SYNC)return goog.global.CLOSURE_LOAD_FILE_SYNC(a);try{var b=new goog.global.XMLHttpRequest;b.open("get",a,!1);b.send();return 0==b.status||200==b.status?b.responseText:null}catch(c){return null}};
	goog.transpile_=function(a,b,c){var d=goog.global.$jscomp;d||(goog.global.$jscomp=d={});var e=d.transpile;if(!e){var f=goog.basePath+goog.TRANSPILER,g=goog.loadFileSync_(f);if(g){(function(){(0, eval)(g+"\n//# sourceURL="+f);}).call(goog.global);if(goog.global.$gwtExport&&goog.global.$gwtExport.$jscomp&&!goog.global.$gwtExport.$jscomp.transpile)throw Error('The transpiler did not properly export the "transpile" method. $gwtExport: '+JSON.stringify(goog.global.$gwtExport));goog.global.$jscomp.transpile=
	goog.global.$gwtExport.$jscomp.transpile;d=goog.global.$jscomp;e=d.transpile;}}e||(e=d.transpile=function(a,b){goog.logToConsole_(b+" requires transpilation but no transpiler was found.");return a});return e(a,b,c)};
	goog.typeOf=function(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return "array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return "object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return "array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return "function"}else return "null";
	else if("function"==b&&"undefined"==typeof a.call)return "object";return b};goog.isNull=function(a){return null===a};goog.isDefAndNotNull=function(a){return null!=a};goog.isArray=function(a){return "array"==goog.typeOf(a)};goog.isArrayLike=function(a){var b=goog.typeOf(a);return "array"==b||"object"==b&&"number"==typeof a.length};goog.isDateLike=function(a){return goog.isObject(a)&&"function"==typeof a.getFullYear};goog.isFunction=function(a){return "function"==goog.typeOf(a)};
	goog.isObject=function(a){var b=typeof a;return "object"==b&&null!=a||"function"==b};goog.getUid=function(a){return a[goog.UID_PROPERTY_]||(a[goog.UID_PROPERTY_]=++goog.uidCounter_)};goog.hasUid=function(a){return !!a[goog.UID_PROPERTY_]};goog.removeUid=function(a){null!==a&&"removeAttribute"in a&&a.removeAttribute(goog.UID_PROPERTY_);try{delete a[goog.UID_PROPERTY_];}catch(b){}};goog.UID_PROPERTY_="closure_uid_"+(1E9*Math.random()>>>0);goog.uidCounter_=0;goog.getHashCode=goog.getUid;
	goog.removeHashCode=goog.removeUid;goog.cloneObject=function(a){var b=goog.typeOf(a);if("object"==b||"array"==b){if("function"===typeof a.clone)return a.clone();b="array"==b?[]:{};for(var c in a)b[c]=goog.cloneObject(a[c]);return b}return a};goog.bindNative_=function(a,b,c){return a.call.apply(a.bind,arguments)};
	goog.bindJs_=function(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}};goog.bind=function(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?goog.bind=goog.bindNative_:goog.bind=goog.bindJs_;return goog.bind.apply(null,arguments)};
	goog.partial=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}};goog.mixin=function(a,b){for(var c in b)a[c]=b[c];};goog.now=goog.TRUSTED_SITE&&Date.now||function(){return +new Date};
	goog.globalEval=function(a){if(goog.global.execScript)goog.global.execScript(a,"JavaScript");else if(goog.global.eval){if(null==goog.evalWorksForGlobals_){try{goog.global.eval("var _evalTest_ = 1;");}catch(d){}if("undefined"!=typeof goog.global._evalTest_){try{delete goog.global._evalTest_;}catch(d){}goog.evalWorksForGlobals_=!0;}else goog.evalWorksForGlobals_=!1;}if(goog.evalWorksForGlobals_)goog.global.eval(a);else {var b=goog.global.document,c=b.createElement("SCRIPT");c.type="text/javascript";c.defer=
	!1;c.appendChild(b.createTextNode(a));b.head.appendChild(c);b.head.removeChild(c);}}else throw Error("goog.globalEval not available");};goog.evalWorksForGlobals_=null;
	goog.getCssName=function(a,b){if("."==String(a).charAt(0))throw Error('className passed in goog.getCssName must not start with ".". You passed: '+a);var c=function(a){return goog.cssNameMapping_[a]||a},d=function(a){a=a.split("-");for(var b=[],d=0;d<a.length;d++)b.push(c(a[d]));return b.join("-")};d=goog.cssNameMapping_?"BY_WHOLE"==goog.cssNameMappingStyle_?c:d:function(a){return a};a=b?a+"-"+d(b):d(a);return goog.global.CLOSURE_CSS_NAME_MAP_FN?goog.global.CLOSURE_CSS_NAME_MAP_FN(a):a};
	goog.setCssNameMapping=function(a,b){goog.cssNameMapping_=a;goog.cssNameMappingStyle_=b;};goog.getMsg=function(a,b,c){c&&c.html&&(a=a.replace(/</g,"&lt;"));b&&(a=a.replace(/\{\$([^}]+)}/g,function(a,c){return null!=b&&c in b?b[c]:a}));return a};goog.getMsgWithFallback=function(a,b){return a};goog.exportSymbol=function(a,b,c){goog.exportPath_(a,b,c);};
	goog.exportProperty=function(a,b,c){a[b]=c;};goog.inherits=function(a,b){function c(){}c.prototype=b.prototype;a.superClass_=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.base=function(a,c,f){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)};};
	goog.base=function(a,b,c){var d=arguments.callee.caller;if(goog.STRICT_MODE_COMPATIBLE||goog.DEBUG&&!d)throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");if("undefined"!==typeof d.superClass_){for(var e=Array(arguments.length-1),f=1;f<arguments.length;f++)e[f-1]=arguments[f];return d.superClass_.constructor.apply(a,e)}if("string"!=typeof b&&"symbol"!=typeof b)throw Error("method names provided to goog.base must be a string or a symbol");
	e=Array(arguments.length-2);for(f=2;f<arguments.length;f++)e[f-2]=arguments[f];f=!1;for(var g=a.constructor.prototype;g;g=Object.getPrototypeOf(g))if(g[b]===d)f=!0;else if(f)return g[b].apply(a,e);if(a[b]===d)return a.constructor.prototype[b].apply(a,e);throw Error("goog.base called from a method of one name to a method of a different name");};goog.scope=function(a){if(goog.isInModuleLoader_())throw Error("goog.scope is not supported within a module.");a.call(goog.global);};
	goog.defineClass=function(a,b){var c=b.constructor,d=b.statics;c&&c!=Object.prototype.constructor||(c=function(){throw Error("cannot instantiate an interface (no constructor defined).");});c=goog.defineClass.createSealingConstructor_(c,a);a&&goog.inherits(c,a);delete b.constructor;delete b.statics;goog.defineClass.applyProperties_(c.prototype,b);null!=d&&(d instanceof Function?d(c):goog.defineClass.applyProperties_(c,d));return c};
	goog.defineClass.SEAL_CLASS_INSTANCES=goog.DEBUG;goog.defineClass.createSealingConstructor_=function(a,b){if(!goog.defineClass.SEAL_CLASS_INSTANCES)return a;var c=!goog.defineClass.isUnsealable_(b),d=function(){var b=a.apply(this,arguments)||this;b[goog.UID_PROPERTY_]=b[goog.UID_PROPERTY_];this.constructor===d&&c&&Object.seal instanceof Function&&Object.seal(b);return b};return d};goog.defineClass.isUnsealable_=function(a){return a&&a.prototype&&a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]};
	goog.defineClass.OBJECT_PROTOTYPE_FIELDS_="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");goog.defineClass.applyProperties_=function(a,b){for(var c in b)Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c]);for(var d=0;d<goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length;d++)c=goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d],Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c]);};
	goog.tagUnsealableClass=function(a){};goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_="goog_defineClass_legacy_unsealable";
	goog.TRUSTED_TYPES_POLICY_NAME="";goog.identity_=function(a){return a};goog.createTrustedTypesPolicy=function(a){var b=null;if("undefined"===typeof TrustedTypes||!TrustedTypes.createPolicy)return b;try{b=TrustedTypes.createPolicy(a,{createHTML:goog.identity_,createScript:goog.identity_,createScriptURL:goog.identity_,createURL:goog.identity_});}catch(c){goog.logToConsole_(c.message);}return b};
	goog.TRUSTED_TYPES_POLICY_=goog.TRUSTED_TYPES_POLICY_NAME?goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME+"#base"):null;var jspb={BinaryConstants:{},ConstBinaryMessage:function(){},BinaryMessage:function(){}};jspb.BinaryConstants.FieldType={INVALID:-1,DOUBLE:1,FLOAT:2,INT64:3,UINT64:4,INT32:5,FIXED64:6,FIXED32:7,BOOL:8,STRING:9,GROUP:10,MESSAGE:11,BYTES:12,UINT32:13,ENUM:14,SFIXED32:15,SFIXED64:16,SINT32:17,SINT64:18,FHASH64:30,VHASH64:31};jspb.BinaryConstants.WireType={INVALID:-1,VARINT:0,FIXED64:1,DELIMITED:2,START_GROUP:3,END_GROUP:4,FIXED32:5};
	jspb.BinaryConstants.FieldTypeToWireType=function(a){var b=jspb.BinaryConstants.FieldType,c=jspb.BinaryConstants.WireType;switch(a){case b.INT32:case b.INT64:case b.UINT32:case b.UINT64:case b.SINT32:case b.SINT64:case b.BOOL:case b.ENUM:case b.VHASH64:return c.VARINT;case b.DOUBLE:case b.FIXED64:case b.SFIXED64:case b.FHASH64:return c.FIXED64;case b.STRING:case b.MESSAGE:case b.BYTES:return c.DELIMITED;case b.FLOAT:case b.FIXED32:case b.SFIXED32:return c.FIXED32;default:return c.INVALID}};
	jspb.BinaryConstants.INVALID_FIELD_NUMBER=-1;jspb.BinaryConstants.FLOAT32_EPS=1.401298464324817E-45;jspb.BinaryConstants.FLOAT32_MIN=1.1754943508222875E-38;jspb.BinaryConstants.FLOAT32_MAX=3.4028234663852886E38;jspb.BinaryConstants.FLOAT64_EPS=4.9E-324;jspb.BinaryConstants.FLOAT64_MIN=2.2250738585072014E-308;jspb.BinaryConstants.FLOAT64_MAX=1.7976931348623157E308;jspb.BinaryConstants.TWO_TO_20=1048576;jspb.BinaryConstants.TWO_TO_23=8388608;jspb.BinaryConstants.TWO_TO_31=2147483648;
	jspb.BinaryConstants.TWO_TO_32=4294967296;jspb.BinaryConstants.TWO_TO_52=4503599627370496;jspb.BinaryConstants.TWO_TO_63=0x7fffffffffffffff;jspb.BinaryConstants.TWO_TO_64=1.8446744073709552E19;jspb.BinaryConstants.ZERO_HASH="\x00\x00\x00\x00\x00\x00\x00\x00";goog.dom={};goog.dom.NodeType={ELEMENT:1,ATTRIBUTE:2,TEXT:3,CDATA_SECTION:4,ENTITY_REFERENCE:5,ENTITY:6,PROCESSING_INSTRUCTION:7,COMMENT:8,DOCUMENT:9,DOCUMENT_TYPE:10,DOCUMENT_FRAGMENT:11,NOTATION:12};goog.debug={};goog.debug.Error=function(a){if(Error.captureStackTrace)Error.captureStackTrace(this,goog.debug.Error);else {var b=Error().stack;b&&(this.stack=b);}a&&(this.message=String(a));this.reportErrorToServer=!0;};goog.inherits(goog.debug.Error,Error);goog.debug.Error.prototype.name="CustomError";goog.asserts={};goog.asserts.ENABLE_ASSERTS=goog.DEBUG;goog.asserts.AssertionError=function(a,b){goog.debug.Error.call(this,goog.asserts.subs_(a,b));this.messagePattern=a;};goog.inherits(goog.asserts.AssertionError,goog.debug.Error);goog.asserts.AssertionError.prototype.name="AssertionError";goog.asserts.DEFAULT_ERROR_HANDLER=function(a){throw a;};goog.asserts.errorHandler_=goog.asserts.DEFAULT_ERROR_HANDLER;
	goog.asserts.subs_=function(a,b){a=a.split("%s");for(var c="",d=a.length-1,e=0;e<d;e++)c+=a[e]+(e<b.length?b[e]:"%s");return c+a[d]};goog.asserts.doAssertFailure_=function(a,b,c,d){var e="Assertion failed";if(c){e+=": "+c;var f=d;}else a&&(e+=": "+a,f=b);a=new goog.asserts.AssertionError(""+e,f||[]);goog.asserts.errorHandler_(a);};goog.asserts.setErrorHandler=function(a){goog.asserts.ENABLE_ASSERTS&&(goog.asserts.errorHandler_=a);};
	goog.asserts.assert=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!a&&goog.asserts.doAssertFailure_("",null,b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertExists=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&null==a&&goog.asserts.doAssertFailure_("Expected to exist: %s.",[a],b,Array.prototype.slice.call(arguments,2));return a};
	goog.asserts.fail=function(a,b){goog.asserts.ENABLE_ASSERTS&&goog.asserts.errorHandler_(new goog.asserts.AssertionError("Failure"+(a?": "+a:""),Array.prototype.slice.call(arguments,1)));};goog.asserts.assertNumber=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isNumber(a)&&goog.asserts.doAssertFailure_("Expected number but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
	goog.asserts.assertString=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isString(a)&&goog.asserts.doAssertFailure_("Expected string but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertFunction=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isFunction(a)&&goog.asserts.doAssertFailure_("Expected function but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
	goog.asserts.assertObject=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isObject(a)&&goog.asserts.doAssertFailure_("Expected object but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertArray=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isArray(a)&&goog.asserts.doAssertFailure_("Expected array but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
	goog.asserts.assertBoolean=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isBoolean(a)&&goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertElement=function(a,b,c){!goog.asserts.ENABLE_ASSERTS||goog.isObject(a)&&a.nodeType==goog.dom.NodeType.ELEMENT||goog.asserts.doAssertFailure_("Expected Element but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
	goog.asserts.assertInstanceof=function(a,b,c,d){!goog.asserts.ENABLE_ASSERTS||a instanceof b||goog.asserts.doAssertFailure_("Expected instanceof %s but got %s.",[goog.asserts.getType_(b),goog.asserts.getType_(a)],c,Array.prototype.slice.call(arguments,3));return a};goog.asserts.assertFinite=function(a,b,c){!goog.asserts.ENABLE_ASSERTS||"number"==typeof a&&isFinite(a)||goog.asserts.doAssertFailure_("Expected %s to be a finite number but it is not.",[a],b,Array.prototype.slice.call(arguments,2));return a};
	goog.asserts.assertObjectPrototypeIsIntact=function(){for(var a in Object.prototype)goog.asserts.fail(a+" should not be enumerable in Object.prototype.");};goog.asserts.getType_=function(a){return a instanceof Function?a.displayName||a.name||"unknown type name":a instanceof Object?a.constructor.displayName||a.constructor.name||Object.prototype.toString.call(a):null===a?"null":typeof a};goog.array={};goog.NATIVE_ARRAY_PROTOTYPES=goog.TRUSTED_SITE;goog.array.ASSUME_NATIVE_FUNCTIONS=2012<goog.FEATURESET_YEAR;goog.array.peek=function(a){return a[a.length-1]};goog.array.last=goog.array.peek;
	goog.array.indexOf=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.indexOf)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(goog.isString(a))return goog.isString(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return -1};
	goog.array.lastIndexOf=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.lastIndexOf)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.lastIndexOf.call(a,b,null==c?a.length-1:c)}:function(a,b,c){c=null==c?a.length-1:c;0>c&&(c=Math.max(0,a.length+c));if(goog.isString(a))return goog.isString(b)&&1==b.length?a.lastIndexOf(b,c):-1;for(;0<=c;c--)if(c in a&&a[c]===b)return c;return -1};
	goog.array.forEach=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.forEach)?function(a,b,c){goog.asserts.assert(null!=a.length);Array.prototype.forEach.call(a,b,c);}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a);};goog.array.forEachRight=function(a,b,c){var d=a.length,e=goog.isString(a)?a.split(""):a;for(--d;0<=d;--d)d in e&&b.call(c,e[d],d,a);};
	goog.array.filter=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.filter)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,g=goog.isString(a)?a.split(""):a,h=0;h<d;h++)if(h in g){var k=g[h];b.call(c,k,h,a)&&(e[f++]=k);}return e};
	goog.array.map=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.map)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=goog.isString(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e};
	goog.array.reduce=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.reduce)?function(a,b,c,d){goog.asserts.assert(null!=a.length);d&&(b=goog.bind(b,d));return Array.prototype.reduce.call(a,b,c)}:function(a,b,c,d){var e=c;goog.array.forEach(a,function(c,g){e=b.call(d,e,c,g,a);});return e};
	goog.array.reduceRight=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.reduceRight)?function(a,b,c,d){goog.asserts.assert(null!=a.length);goog.asserts.assert(null!=b);d&&(b=goog.bind(b,d));return Array.prototype.reduceRight.call(a,b,c)}:function(a,b,c,d){var e=c;goog.array.forEachRight(a,function(c,g){e=b.call(d,e,c,g,a);});return e};
	goog.array.some=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.some)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.some.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return !0;return !1};
	goog.array.every=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.every)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return !1;return !0};goog.array.count=function(a,b,c){var d=0;goog.array.forEach(a,function(a,f,g){b.call(c,a,f,g)&&++d;},c);return d};
	goog.array.find=function(a,b,c){b=goog.array.findIndex(a,b,c);return 0>b?null:goog.isString(a)?a.charAt(b):a[b]};goog.array.findIndex=function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return f;return -1};goog.array.findRight=function(a,b,c){b=goog.array.findIndexRight(a,b,c);return 0>b?null:goog.isString(a)?a.charAt(b):a[b]};
	goog.array.findIndexRight=function(a,b,c){var d=a.length,e=goog.isString(a)?a.split(""):a;for(--d;0<=d;d--)if(d in e&&b.call(c,e[d],d,a))return d;return -1};goog.array.contains=function(a,b){return 0<=goog.array.indexOf(a,b)};goog.array.isEmpty=function(a){return 0==a.length};goog.array.clear=function(a){if(!goog.isArray(a))for(var b=a.length-1;0<=b;b--)delete a[b];a.length=0;};goog.array.insert=function(a,b){goog.array.contains(a,b)||a.push(b);};
	goog.array.insertAt=function(a,b,c){goog.array.splice(a,c,0,b);};goog.array.insertArrayAt=function(a,b,c){goog.partial(goog.array.splice,a,c,0).apply(null,b);};goog.array.insertBefore=function(a,b,c){var d;2==arguments.length||0>(d=goog.array.indexOf(a,c))?a.push(b):goog.array.insertAt(a,b,d);};goog.array.remove=function(a,b){b=goog.array.indexOf(a,b);var c;(c=0<=b)&&goog.array.removeAt(a,b);return c};
	goog.array.removeLast=function(a,b){b=goog.array.lastIndexOf(a,b);return 0<=b?(goog.array.removeAt(a,b),!0):!1};goog.array.removeAt=function(a,b){goog.asserts.assert(null!=a.length);return 1==Array.prototype.splice.call(a,b,1).length};goog.array.removeIf=function(a,b,c){b=goog.array.findIndex(a,b,c);return 0<=b?(goog.array.removeAt(a,b),!0):!1};goog.array.removeAllIf=function(a,b,c){var d=0;goog.array.forEachRight(a,function(e,f){b.call(c,e,f,a)&&goog.array.removeAt(a,f)&&d++;});return d};
	goog.array.concat=function(a){return Array.prototype.concat.apply([],arguments)};goog.array.join=function(a){return Array.prototype.concat.apply([],arguments)};goog.array.toArray=function(a){var b=a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return []};goog.array.clone=goog.array.toArray;goog.array.extend=function(a,b){for(var c=1;c<arguments.length;c++){var d=arguments[c];if(goog.isArrayLike(d)){var e=a.length||0,f=d.length||0;a.length=e+f;for(var g=0;g<f;g++)a[e+g]=d[g];}else a.push(d);}};
	goog.array.splice=function(a,b,c,d){goog.asserts.assert(null!=a.length);return Array.prototype.splice.apply(a,goog.array.slice(arguments,1))};goog.array.slice=function(a,b,c){goog.asserts.assert(null!=a.length);return 2>=arguments.length?Array.prototype.slice.call(a,b):Array.prototype.slice.call(a,b,c)};
	goog.array.removeDuplicates=function(a,b,c){b=b||a;var d=function(a){return goog.isObject(a)?"o"+goog.getUid(a):(typeof a).charAt(0)+a};c=c||d;d={};for(var e=0,f=0;f<a.length;){var g=a[f++],h=c(g);Object.prototype.hasOwnProperty.call(d,h)||(d[h]=!0,b[e++]=g);}b.length=e;};goog.array.binarySearch=function(a,b,c){return goog.array.binarySearch_(a,c||goog.array.defaultCompare,!1,b)};goog.array.binarySelect=function(a,b,c){return goog.array.binarySearch_(a,b,!0,void 0,c)};
	goog.array.binarySearch_=function(a,b,c,d,e){for(var f=0,g=a.length,h;f<g;){var k=f+g>>1;var l=c?b.call(e,a[k],k,a):b(d,a[k]);0<l?f=k+1:(g=k,h=!l);}return h?f:~f};goog.array.sort=function(a,b){a.sort(b||goog.array.defaultCompare);};goog.array.stableSort=function(a,b){for(var c=Array(a.length),d=0;d<a.length;d++)c[d]={index:d,value:a[d]};var e=b||goog.array.defaultCompare;goog.array.sort(c,function(a,b){return e(a.value,b.value)||a.index-b.index});for(d=0;d<a.length;d++)a[d]=c[d].value;};
	goog.array.sortByKey=function(a,b,c){var d=c||goog.array.defaultCompare;goog.array.sort(a,function(a,c){return d(b(a),b(c))});};goog.array.sortObjectsByKey=function(a,b,c){goog.array.sortByKey(a,function(a){return a[b]},c);};goog.array.isSorted=function(a,b,c){b=b||goog.array.defaultCompare;for(var d=1;d<a.length;d++){var e=b(a[d-1],a[d]);if(0<e||0==e&&c)return !1}return !0};
	goog.array.equals=function(a,b,c){if(!goog.isArrayLike(a)||!goog.isArrayLike(b)||a.length!=b.length)return !1;var d=a.length;c=c||goog.array.defaultCompareEquality;for(var e=0;e<d;e++)if(!c(a[e],b[e]))return !1;return !0};goog.array.compare3=function(a,b,c){c=c||goog.array.defaultCompare;for(var d=Math.min(a.length,b.length),e=0;e<d;e++){var f=c(a[e],b[e]);if(0!=f)return f}return goog.array.defaultCompare(a.length,b.length)};goog.array.defaultCompare=function(a,b){return a>b?1:a<b?-1:0};
	goog.array.inverseDefaultCompare=function(a,b){return -goog.array.defaultCompare(a,b)};goog.array.defaultCompareEquality=function(a,b){return a===b};goog.array.binaryInsert=function(a,b,c){c=goog.array.binarySearch(a,b,c);return 0>c?(goog.array.insertAt(a,b,-(c+1)),!0):!1};goog.array.binaryRemove=function(a,b,c){b=goog.array.binarySearch(a,b,c);return 0<=b?goog.array.removeAt(a,b):!1};
	goog.array.bucket=function(a,b,c){for(var d={},e=0;e<a.length;e++){var f=a[e],g=b.call(c,f,e,a);goog.isDef(g)&&(d[g]||(d[g]=[])).push(f);}return d};goog.array.toObject=function(a,b,c){var d={};goog.array.forEach(a,function(e,f){d[b.call(c,e,f,a)]=e;});return d};goog.array.range=function(a,b,c){var d=[],e=0,f=a;c=c||1;void 0!==b&&(e=a,f=b);if(0>c*(f-e))return [];if(0<c)for(a=e;a<f;a+=c)d.push(a);else for(a=e;a>f;a+=c)d.push(a);return d};
	goog.array.repeat=function(a,b){for(var c=[],d=0;d<b;d++)c[d]=a;return c};goog.array.flatten=function(a){for(var b=[],c=0;c<arguments.length;c++){var d=arguments[c];if(goog.isArray(d))for(var e=0;e<d.length;e+=8192){var f=goog.array.slice(d,e,e+8192);f=goog.array.flatten.apply(null,f);for(var g=0;g<f.length;g++)b.push(f[g]);}else b.push(d);}return b};
	goog.array.rotate=function(a,b){goog.asserts.assert(null!=a.length);a.length&&(b%=a.length,0<b?Array.prototype.unshift.apply(a,a.splice(-b,b)):0>b&&Array.prototype.push.apply(a,a.splice(0,-b)));return a};goog.array.moveItem=function(a,b,c){goog.asserts.assert(0<=b&&b<a.length);goog.asserts.assert(0<=c&&c<a.length);b=Array.prototype.splice.call(a,b,1);Array.prototype.splice.call(a,c,0,b[0]);};
	goog.array.zip=function(a){if(!arguments.length)return [];for(var b=[],c=arguments[0].length,d=1;d<arguments.length;d++)arguments[d].length<c&&(c=arguments[d].length);for(d=0;d<c;d++){for(var e=[],f=0;f<arguments.length;f++)e.push(arguments[f][d]);b.push(e);}return b};goog.array.shuffle=function(a,b){b=b||Math.random;for(var c=a.length-1;0<c;c--){var d=Math.floor(b()*(c+1)),e=a[c];a[c]=a[d];a[d]=e;}};goog.array.copyByIndex=function(a,b){var c=[];goog.array.forEach(b,function(b){c.push(a[b]);});return c};
	goog.array.concatMap=function(a,b,c){return goog.array.concat.apply([],goog.array.map(a,b,c))};goog.crypt={};goog.crypt.stringToByteArray=function(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);255<e&&(b[c++]=e&255,e>>=8);b[c++]=e;}return b};goog.crypt.byteArrayToString=function(a){if(8192>=a.length)return String.fromCharCode.apply(null,a);for(var b="",c=0;c<a.length;c+=8192){var d=goog.array.slice(a,c,c+8192);b+=String.fromCharCode.apply(null,d);}return b};
	goog.crypt.byteArrayToHex=function(a,b){return goog.array.map(a,function(a){a=a.toString(16);return 1<a.length?a:"0"+a}).join(b||"")};goog.crypt.hexToByteArray=function(a){goog.asserts.assert(0==a.length%2,"Key string length must be multiple of 2");for(var b=[],c=0;c<a.length;c+=2)b.push(parseInt(a.substring(c,c+2),16));return b};
	goog.crypt.stringToUtf8ByteArray=function(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);128>e?b[c++]=e:(2048>e?b[c++]=e>>6|192:(55296==(e&64512)&&d+1<a.length&&56320==(a.charCodeAt(d+1)&64512)?(e=65536+((e&1023)<<10)+(a.charCodeAt(++d)&1023),b[c++]=e>>18|240,b[c++]=e>>12&63|128):b[c++]=e>>12|224,b[c++]=e>>6&63|128),b[c++]=e&63|128);}return b};
	goog.crypt.utf8ByteArrayToString=function(a){for(var b=[],c=0,d=0;c<a.length;){var e=a[c++];if(128>e)b[d++]=String.fromCharCode(e);else if(191<e&&224>e){var f=a[c++];b[d++]=String.fromCharCode((e&31)<<6|f&63);}else if(239<e&&365>e){f=a[c++];var g=a[c++],h=a[c++];e=((e&7)<<18|(f&63)<<12|(g&63)<<6|h&63)-65536;b[d++]=String.fromCharCode(55296+(e>>10));b[d++]=String.fromCharCode(56320+(e&1023));}else f=a[c++],g=a[c++],b[d++]=String.fromCharCode((e&15)<<12|(f&63)<<6|g&63);}return b.join("")};
	goog.crypt.xorByteArray=function(a,b){goog.asserts.assert(a.length==b.length,"XOR array lengths must match");for(var c=[],d=0;d<a.length;d++)c.push(a[d]^b[d]);return c};goog.string={};goog.string.internal={};goog.string.internal.startsWith=function(a,b){return 0==a.lastIndexOf(b,0)};goog.string.internal.endsWith=function(a,b){var c=a.length-b.length;return 0<=c&&a.indexOf(b,c)==c};goog.string.internal.caseInsensitiveStartsWith=function(a,b){return 0==goog.string.internal.caseInsensitiveCompare(b,a.substr(0,b.length))};goog.string.internal.caseInsensitiveEndsWith=function(a,b){return 0==goog.string.internal.caseInsensitiveCompare(b,a.substr(a.length-b.length,b.length))};
	goog.string.internal.caseInsensitiveEquals=function(a,b){return a.toLowerCase()==b.toLowerCase()};goog.string.internal.isEmptyOrWhitespace=function(a){return /^[\s\xa0]*$/.test(a)};goog.string.internal.trim=goog.TRUSTED_SITE&&String.prototype.trim?function(a){return a.trim()}:function(a){return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1]};goog.string.internal.caseInsensitiveCompare=function(a,b){a=String(a).toLowerCase();b=String(b).toLowerCase();return a<b?-1:a==b?0:1};
	goog.string.internal.newLineToBr=function(a,b){return a.replace(/(\r\n|\r|\n)/g,b?"<br />":"<br>")};
	goog.string.internal.htmlEscape=function(a,b){if(b)a=a.replace(goog.string.internal.AMP_RE_,"&amp;").replace(goog.string.internal.LT_RE_,"&lt;").replace(goog.string.internal.GT_RE_,"&gt;").replace(goog.string.internal.QUOT_RE_,"&quot;").replace(goog.string.internal.SINGLE_QUOTE_RE_,"&#39;").replace(goog.string.internal.NULL_RE_,"&#0;");else {if(!goog.string.internal.ALL_RE_.test(a))return a;-1!=a.indexOf("&")&&(a=a.replace(goog.string.internal.AMP_RE_,"&amp;"));-1!=a.indexOf("<")&&(a=a.replace(goog.string.internal.LT_RE_,
	"&lt;"));-1!=a.indexOf(">")&&(a=a.replace(goog.string.internal.GT_RE_,"&gt;"));-1!=a.indexOf('"')&&(a=a.replace(goog.string.internal.QUOT_RE_,"&quot;"));-1!=a.indexOf("'")&&(a=a.replace(goog.string.internal.SINGLE_QUOTE_RE_,"&#39;"));-1!=a.indexOf("\x00")&&(a=a.replace(goog.string.internal.NULL_RE_,"&#0;"));}return a};goog.string.internal.AMP_RE_=/&/g;goog.string.internal.LT_RE_=/</g;goog.string.internal.GT_RE_=/>/g;goog.string.internal.QUOT_RE_=/"/g;goog.string.internal.SINGLE_QUOTE_RE_=/'/g;
	goog.string.internal.NULL_RE_=/\x00/g;goog.string.internal.ALL_RE_=/[\x00&<>"']/;goog.string.internal.whitespaceEscape=function(a,b){return goog.string.internal.newLineToBr(a.replace(/  /g," &#160;"),b)};goog.string.internal.contains=function(a,b){return -1!=a.indexOf(b)};goog.string.internal.caseInsensitiveContains=function(a,b){return goog.string.internal.contains(a.toLowerCase(),b.toLowerCase())};
	goog.string.internal.compareVersions=function(a,b){var c=0;a=goog.string.internal.trim(String(a)).split(".");b=goog.string.internal.trim(String(b)).split(".");for(var d=Math.max(a.length,b.length),e=0;0==c&&e<d;e++){var f=a[e]||"",g=b[e]||"";do{f=/(\d*)(\D*)(.*)/.exec(f)||["","","",""];g=/(\d*)(\D*)(.*)/.exec(g)||["","","",""];if(0==f[0].length&&0==g[0].length)break;c=0==f[1].length?0:parseInt(f[1],10);var h=0==g[1].length?0:parseInt(g[1],10);c=goog.string.internal.compareElements_(c,h)||goog.string.internal.compareElements_(0==
	f[2].length,0==g[2].length)||goog.string.internal.compareElements_(f[2],g[2]);f=f[3];g=g[3];}while(0==c)}return c};goog.string.internal.compareElements_=function(a,b){return a<b?-1:a>b?1:0};goog.string.TypedString=function(){};goog.string.Const=function(a,b){this.stringConstValueWithSecurityContract__googStringSecurityPrivate_=a===goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_&&b||"";this.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_=goog.string.Const.TYPE_MARKER_;};goog.string.Const.prototype.implementsGoogStringTypedString=!0;goog.string.Const.prototype.getTypedStringValue=function(){return this.stringConstValueWithSecurityContract__googStringSecurityPrivate_};
	goog.string.Const.prototype.toString=function(){return "Const{"+this.stringConstValueWithSecurityContract__googStringSecurityPrivate_+"}"};goog.string.Const.unwrap=function(a){if(a instanceof goog.string.Const&&a.constructor===goog.string.Const&&a.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_===goog.string.Const.TYPE_MARKER_)return a.stringConstValueWithSecurityContract__googStringSecurityPrivate_;goog.asserts.fail("expected object of type Const, got '"+a+"'");return "type_error:Const"};
	goog.string.Const.from=function(a){return new goog.string.Const(goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_,a)};goog.string.Const.TYPE_MARKER_={};goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_={};goog.string.Const.EMPTY=goog.string.Const.from("");goog.fs={};goog.fs.url={};goog.fs.url.createObjectUrl=function(a){return goog.fs.url.getUrlObject_().createObjectURL(a)};goog.fs.url.revokeObjectUrl=function(a){goog.fs.url.getUrlObject_().revokeObjectURL(a);};goog.fs.url.getUrlObject_=function(){var a=goog.fs.url.findUrlObject_();if(null!=a)return a;throw Error("This browser doesn't seem to support blob URLs");};
	goog.fs.url.findUrlObject_=function(){return goog.isDef(goog.global.URL)&&goog.isDef(goog.global.URL.createObjectURL)?goog.global.URL:goog.isDef(goog.global.webkitURL)&&goog.isDef(goog.global.webkitURL.createObjectURL)?goog.global.webkitURL:goog.isDef(goog.global.createObjectURL)?goog.global:null};goog.fs.url.browserSupportsObjectUrls=function(){return null!=goog.fs.url.findUrlObject_()};goog.html={};goog.html.trustedtypes={};goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY=goog.TRUSTED_TYPES_POLICY_NAME?goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME+"#html"):null;goog.i18n={};goog.i18n.bidi={};goog.i18n.bidi.FORCE_RTL=!1;
	goog.i18n.bidi.IS_RTL=goog.i18n.bidi.FORCE_RTL||("ar"==goog.LOCALE.substring(0,2).toLowerCase()||"fa"==goog.LOCALE.substring(0,2).toLowerCase()||"he"==goog.LOCALE.substring(0,2).toLowerCase()||"iw"==goog.LOCALE.substring(0,2).toLowerCase()||"ps"==goog.LOCALE.substring(0,2).toLowerCase()||"sd"==goog.LOCALE.substring(0,2).toLowerCase()||"ug"==goog.LOCALE.substring(0,2).toLowerCase()||"ur"==goog.LOCALE.substring(0,2).toLowerCase()||"yi"==goog.LOCALE.substring(0,2).toLowerCase())&&(2==goog.LOCALE.length||
	"-"==goog.LOCALE.substring(2,3)||"_"==goog.LOCALE.substring(2,3))||3<=goog.LOCALE.length&&"ckb"==goog.LOCALE.substring(0,3).toLowerCase()&&(3==goog.LOCALE.length||"-"==goog.LOCALE.substring(3,4)||"_"==goog.LOCALE.substring(3,4))||7<=goog.LOCALE.length&&("-"==goog.LOCALE.substring(2,3)||"_"==goog.LOCALE.substring(2,3))&&("adlm"==goog.LOCALE.substring(3,7).toLowerCase()||"arab"==goog.LOCALE.substring(3,7).toLowerCase()||"hebr"==goog.LOCALE.substring(3,7).toLowerCase()||"nkoo"==goog.LOCALE.substring(3,
	7).toLowerCase()||"rohg"==goog.LOCALE.substring(3,7).toLowerCase()||"thaa"==goog.LOCALE.substring(3,7).toLowerCase())||8<=goog.LOCALE.length&&("-"==goog.LOCALE.substring(3,4)||"_"==goog.LOCALE.substring(3,4))&&("adlm"==goog.LOCALE.substring(4,8).toLowerCase()||"arab"==goog.LOCALE.substring(4,8).toLowerCase()||"hebr"==goog.LOCALE.substring(4,8).toLowerCase()||"nkoo"==goog.LOCALE.substring(4,8).toLowerCase()||"rohg"==goog.LOCALE.substring(4,8).toLowerCase()||"thaa"==goog.LOCALE.substring(4,8).toLowerCase());
	goog.i18n.bidi.Format={LRE:"\u202a",RLE:"\u202b",PDF:"\u202c",LRM:"\u200e",RLM:"\u200f"};goog.i18n.bidi.Dir={LTR:1,RTL:-1,NEUTRAL:0};goog.i18n.bidi.RIGHT="right";goog.i18n.bidi.LEFT="left";goog.i18n.bidi.I18N_RIGHT=goog.i18n.bidi.IS_RTL?goog.i18n.bidi.LEFT:goog.i18n.bidi.RIGHT;goog.i18n.bidi.I18N_LEFT=goog.i18n.bidi.IS_RTL?goog.i18n.bidi.RIGHT:goog.i18n.bidi.LEFT;
	goog.i18n.bidi.toDir=function(a,b){return "number"==typeof a?0<a?goog.i18n.bidi.Dir.LTR:0>a?goog.i18n.bidi.Dir.RTL:b?null:goog.i18n.bidi.Dir.NEUTRAL:null==a?null:a?goog.i18n.bidi.Dir.RTL:goog.i18n.bidi.Dir.LTR};goog.i18n.bidi.ltrChars_="A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0900-\u1fff\u200e\u2c00-\ud801\ud804-\ud839\ud83c-\udbff\uf900-\ufb1c\ufe00-\ufe6f\ufefd-\uffff";goog.i18n.bidi.rtlChars_="\u0591-\u06ef\u06fa-\u08ff\u200f\ud802-\ud803\ud83a-\ud83b\ufb1d-\ufdff\ufe70-\ufefc";
	goog.i18n.bidi.htmlSkipReg_=/<[^>]*>|&[^;]+;/g;goog.i18n.bidi.stripHtmlIfNeeded_=function(a,b){return b?a.replace(goog.i18n.bidi.htmlSkipReg_,""):a};goog.i18n.bidi.rtlCharReg_=new RegExp("["+goog.i18n.bidi.rtlChars_+"]");goog.i18n.bidi.ltrCharReg_=new RegExp("["+goog.i18n.bidi.ltrChars_+"]");goog.i18n.bidi.hasAnyRtl=function(a,b){return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.hasRtlChar=goog.i18n.bidi.hasAnyRtl;
	goog.i18n.bidi.hasAnyLtr=function(a,b){return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.ltrRe_=new RegExp("^["+goog.i18n.bidi.ltrChars_+"]");goog.i18n.bidi.rtlRe_=new RegExp("^["+goog.i18n.bidi.rtlChars_+"]");goog.i18n.bidi.isRtlChar=function(a){return goog.i18n.bidi.rtlRe_.test(a)};goog.i18n.bidi.isLtrChar=function(a){return goog.i18n.bidi.ltrRe_.test(a)};goog.i18n.bidi.isNeutralChar=function(a){return !goog.i18n.bidi.isLtrChar(a)&&!goog.i18n.bidi.isRtlChar(a)};
	goog.i18n.bidi.ltrDirCheckRe_=new RegExp("^[^"+goog.i18n.bidi.rtlChars_+"]*["+goog.i18n.bidi.ltrChars_+"]");goog.i18n.bidi.rtlDirCheckRe_=new RegExp("^[^"+goog.i18n.bidi.ltrChars_+"]*["+goog.i18n.bidi.rtlChars_+"]");goog.i18n.bidi.startsWithRtl=function(a,b){return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isRtlText=goog.i18n.bidi.startsWithRtl;
	goog.i18n.bidi.startsWithLtr=function(a,b){return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isLtrText=goog.i18n.bidi.startsWithLtr;goog.i18n.bidi.isRequiredLtrRe_=/^http:\/\/.*/;goog.i18n.bidi.isNeutralText=function(a,b){a=goog.i18n.bidi.stripHtmlIfNeeded_(a,b);return goog.i18n.bidi.isRequiredLtrRe_.test(a)||!goog.i18n.bidi.hasAnyLtr(a)&&!goog.i18n.bidi.hasAnyRtl(a)};
	goog.i18n.bidi.ltrExitDirCheckRe_=new RegExp("["+goog.i18n.bidi.ltrChars_+"][^"+goog.i18n.bidi.rtlChars_+"]*$");goog.i18n.bidi.rtlExitDirCheckRe_=new RegExp("["+goog.i18n.bidi.rtlChars_+"][^"+goog.i18n.bidi.ltrChars_+"]*$");goog.i18n.bidi.endsWithLtr=function(a,b){return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isLtrExitText=goog.i18n.bidi.endsWithLtr;
	goog.i18n.bidi.endsWithRtl=function(a,b){return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isRtlExitText=goog.i18n.bidi.endsWithRtl;goog.i18n.bidi.rtlLocalesRe_=/^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;goog.i18n.bidi.isRtlLanguage=function(a){return goog.i18n.bidi.rtlLocalesRe_.test(a)};goog.i18n.bidi.bracketGuardTextRe_=/(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g;
	goog.i18n.bidi.guardBracketInText=function(a,b){b=(void 0===b?goog.i18n.bidi.hasAnyRtl(a):b)?goog.i18n.bidi.Format.RLM:goog.i18n.bidi.Format.LRM;return a.replace(goog.i18n.bidi.bracketGuardTextRe_,b+"$&"+b)};goog.i18n.bidi.enforceRtlInHtml=function(a){return "<"==a.charAt(0)?a.replace(/<\w+/,"$& dir=rtl"):"\n<span dir=rtl>"+a+"</span>"};goog.i18n.bidi.enforceRtlInText=function(a){return goog.i18n.bidi.Format.RLE+a+goog.i18n.bidi.Format.PDF};
	goog.i18n.bidi.enforceLtrInHtml=function(a){return "<"==a.charAt(0)?a.replace(/<\w+/,"$& dir=ltr"):"\n<span dir=ltr>"+a+"</span>"};goog.i18n.bidi.enforceLtrInText=function(a){return goog.i18n.bidi.Format.LRE+a+goog.i18n.bidi.Format.PDF};goog.i18n.bidi.dimensionsRe_=/:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g;goog.i18n.bidi.leftRe_=/left/gi;goog.i18n.bidi.rightRe_=/right/gi;goog.i18n.bidi.tempRe_=/%%%%/g;
	goog.i18n.bidi.mirrorCSS=function(a){return a.replace(goog.i18n.bidi.dimensionsRe_,":$1 $4 $3 $2").replace(goog.i18n.bidi.leftRe_,"%%%%").replace(goog.i18n.bidi.rightRe_,goog.i18n.bidi.LEFT).replace(goog.i18n.bidi.tempRe_,goog.i18n.bidi.RIGHT)};goog.i18n.bidi.doubleQuoteSubstituteRe_=/([\u0591-\u05f2])"/g;goog.i18n.bidi.singleQuoteSubstituteRe_=/([\u0591-\u05f2])'/g;
	goog.i18n.bidi.normalizeHebrewQuote=function(a){return a.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_,"$1\u05f4").replace(goog.i18n.bidi.singleQuoteSubstituteRe_,"$1\u05f3")};goog.i18n.bidi.wordSeparatorRe_=/\s+/;goog.i18n.bidi.hasNumeralsRe_=/[\d\u06f0-\u06f9]/;goog.i18n.bidi.rtlDetectionThreshold_=.4;
	goog.i18n.bidi.estimateDirection=function(a,b){var c=0,d=0,e=!1;a=goog.i18n.bidi.stripHtmlIfNeeded_(a,b).split(goog.i18n.bidi.wordSeparatorRe_);for(b=0;b<a.length;b++){var f=a[b];goog.i18n.bidi.startsWithRtl(f)?(c++,d++):goog.i18n.bidi.isRequiredLtrRe_.test(f)?e=!0:goog.i18n.bidi.hasAnyLtr(f)?d++:goog.i18n.bidi.hasNumeralsRe_.test(f)&&(e=!0);}return 0==d?e?goog.i18n.bidi.Dir.LTR:goog.i18n.bidi.Dir.NEUTRAL:c/d>goog.i18n.bidi.rtlDetectionThreshold_?goog.i18n.bidi.Dir.RTL:goog.i18n.bidi.Dir.LTR};
	goog.i18n.bidi.detectRtlDirectionality=function(a,b){return goog.i18n.bidi.estimateDirection(a,b)==goog.i18n.bidi.Dir.RTL};goog.i18n.bidi.setElementDirAndAlign=function(a,b){a&&(b=goog.i18n.bidi.toDir(b))&&(a.style.textAlign=b==goog.i18n.bidi.Dir.RTL?goog.i18n.bidi.RIGHT:goog.i18n.bidi.LEFT,a.dir=b==goog.i18n.bidi.Dir.RTL?"rtl":"ltr");};
	goog.i18n.bidi.setElementDirByTextDirectionality=function(a,b){switch(goog.i18n.bidi.estimateDirection(b)){case goog.i18n.bidi.Dir.LTR:a.dir="ltr";break;case goog.i18n.bidi.Dir.RTL:a.dir="rtl";break;default:a.removeAttribute("dir");}};goog.i18n.bidi.DirectionalString=function(){};goog.html.TrustedResourceUrl=function(){this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_="";this.trustedURL_=null;this.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;};goog.html.TrustedResourceUrl.prototype.implementsGoogStringTypedString=!0;goog.html.TrustedResourceUrl.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_.toString()};
	goog.html.TrustedResourceUrl.prototype.implementsGoogI18nBidiDirectionalString=!0;goog.html.TrustedResourceUrl.prototype.getDirection=function(){return goog.i18n.bidi.Dir.LTR};
	goog.html.TrustedResourceUrl.prototype.cloneWithParams=function(a,b){var c=goog.html.TrustedResourceUrl.unwrap(this);c=goog.html.TrustedResourceUrl.URL_PARAM_PARSER_.exec(c);var d=c[3]||"";return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(c[1]+goog.html.TrustedResourceUrl.stringifyParams_("?",c[2]||"",a)+goog.html.TrustedResourceUrl.stringifyParams_("#",d,b))};
	goog.DEBUG&&(goog.html.TrustedResourceUrl.prototype.toString=function(){return "TrustedResourceUrl{"+this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_+"}"});goog.html.TrustedResourceUrl.unwrap=function(a){return goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(a).toString()};
	goog.html.TrustedResourceUrl.unwrapTrustedScriptURL=function(a){if(a instanceof goog.html.TrustedResourceUrl&&a.constructor===goog.html.TrustedResourceUrl&&a.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_;goog.asserts.fail("expected object of type TrustedResourceUrl, got '"+a+"' of type "+goog.typeOf(a));return "type_error:TrustedResourceUrl"};
	goog.html.TrustedResourceUrl.unwrapTrustedURL=function(a){return a.trustedURL_?a.trustedURL_:goog.html.TrustedResourceUrl.unwrap(a)};
	goog.html.TrustedResourceUrl.format=function(a,b){var c=goog.string.Const.unwrap(a);if(!goog.html.TrustedResourceUrl.BASE_URL_.test(c))throw Error("Invalid TrustedResourceUrl format: "+c);a=c.replace(goog.html.TrustedResourceUrl.FORMAT_MARKER_,function(a,e){if(!Object.prototype.hasOwnProperty.call(b,e))throw Error('Found marker, "'+e+'", in format string, "'+c+'", but no valid label mapping found in args: '+JSON.stringify(b));a=b[e];return a instanceof goog.string.Const?goog.string.Const.unwrap(a):
	encodeURIComponent(String(a))});return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(a)};goog.html.TrustedResourceUrl.FORMAT_MARKER_=/%{(\w+)}/g;goog.html.TrustedResourceUrl.BASE_URL_=/^((https:)?\/\/[0-9a-z.:[\]-]+\/|\/[^/\\]|[^:/\\%]+\/|[^:/\\%]*[?#]|about:blank#)/i;goog.html.TrustedResourceUrl.URL_PARAM_PARSER_=/^([^?#]*)(\?[^#]*)?(#[\s\S]*)?/;
	goog.html.TrustedResourceUrl.formatWithParams=function(a,b,c,d){return goog.html.TrustedResourceUrl.format(a,b).cloneWithParams(c,d)};goog.html.TrustedResourceUrl.fromConstant=function(a){return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(a))};goog.html.TrustedResourceUrl.fromConstants=function(a){for(var b="",c=0;c<a.length;c++)b+=goog.string.Const.unwrap(a[c]);return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(b)};
	goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
	goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse=function(a){var b=new goog.html.TrustedResourceUrl;b.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScriptURL(a):a;goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY&&(b.trustedURL_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createURL(a));return b};
	goog.html.TrustedResourceUrl.stringifyParams_=function(a,b,c){if(null==c)return b;if(goog.isString(c))return c?a+encodeURIComponent(c):"";for(var d in c){var e=c[d];e=goog.isArray(e)?e:[e];for(var f=0;f<e.length;f++){var g=e[f];null!=g&&(b||(b=a),b+=(b.length>a.length?"&":"")+encodeURIComponent(d)+"="+encodeURIComponent(String(g)));}}return b};goog.html.SafeUrl=function(){this.privateDoNotAccessOrElseSafeUrlWrappedValue_="";this.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;};goog.html.SafeUrl.INNOCUOUS_STRING="about:invalid#zClosurez";goog.html.SafeUrl.prototype.implementsGoogStringTypedString=!0;goog.html.SafeUrl.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeUrlWrappedValue_.toString()};
	goog.html.SafeUrl.prototype.implementsGoogI18nBidiDirectionalString=!0;goog.html.SafeUrl.prototype.getDirection=function(){return goog.i18n.bidi.Dir.LTR};goog.DEBUG&&(goog.html.SafeUrl.prototype.toString=function(){return "SafeUrl{"+this.privateDoNotAccessOrElseSafeUrlWrappedValue_+"}"});goog.html.SafeUrl.unwrap=function(a){return goog.html.SafeUrl.unwrapTrustedURL(a).toString()};
	goog.html.SafeUrl.unwrapTrustedURL=function(a){if(a instanceof goog.html.SafeUrl&&a.constructor===goog.html.SafeUrl&&a.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeUrlWrappedValue_;goog.asserts.fail("expected object of type SafeUrl, got '"+a+"' of type "+goog.typeOf(a));return "type_error:SafeUrl"};goog.html.SafeUrl.fromConstant=function(a){return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(a))};
	goog.html.SAFE_MIME_TYPE_PATTERN_=/^(?:audio\/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-wav|wav|webm)|image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon)|text\/csv|video\/(?:mpeg|mp4|ogg|webm|quicktime))(?:;\w+=(?:\w+|"[\w;=]+"))*$/i;goog.html.SafeUrl.isSafeMimeType=function(a){return goog.html.SAFE_MIME_TYPE_PATTERN_.test(a)};goog.html.SafeUrl.fromBlob=function(a){a=goog.html.SAFE_MIME_TYPE_PATTERN_.test(a.type)?goog.fs.url.createObjectUrl(a):goog.html.SafeUrl.INNOCUOUS_STRING;return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
	goog.html.DATA_URL_PATTERN_=/^data:([^,]*);base64,[a-z0-9+\/]+=*$/i;goog.html.SafeUrl.fromDataUrl=function(a){a=a.replace(/(%0A|%0D)/g,"");var b=a.match(goog.html.DATA_URL_PATTERN_);b=b&&goog.html.SAFE_MIME_TYPE_PATTERN_.test(b[1]);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b?a:goog.html.SafeUrl.INNOCUOUS_STRING)};goog.html.SafeUrl.fromTelUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"tel:")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
	goog.html.SIP_URL_PATTERN_=/^sip[s]?:[+a-z0-9_.!$%&'*\/=^`{|}~-]+@([a-z0-9-]+\.)+[a-z0-9]{2,63}$/i;goog.html.SafeUrl.fromSipUrl=function(a){goog.html.SIP_URL_PATTERN_.test(decodeURIComponent(a))||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeUrl.fromFacebookMessengerUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"fb-messenger://share")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
	goog.html.SafeUrl.fromWhatsAppUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"whatsapp://send")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeUrl.fromSmsUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"sms:")&&goog.html.SafeUrl.isSmsUrlBodyValid_(a)||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
	goog.html.SafeUrl.isSmsUrlBodyValid_=function(a){var b=a.indexOf("#");0<b&&(a=a.substring(0,b));b=a.match(/[?&]body=/gi);if(!b)return !0;if(1<b.length)return !1;a=a.match(/[?&]body=([^&]*)/)[1];if(!a)return !0;try{decodeURIComponent(a);}catch(c){return !1}return /^(?:[a-z0-9\-_.~]|%[0-9a-f]{2})+$/i.test(a)};goog.html.SafeUrl.fromSshUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"ssh://")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
	goog.html.SafeUrl.sanitizeChromeExtensionUrl=function(a,b){return goog.html.SafeUrl.sanitizeExtensionUrl_(/^chrome-extension:\/\/([^\/]+)\//,a,b)};goog.html.SafeUrl.sanitizeFirefoxExtensionUrl=function(a,b){return goog.html.SafeUrl.sanitizeExtensionUrl_(/^moz-extension:\/\/([^\/]+)\//,a,b)};goog.html.SafeUrl.sanitizeEdgeExtensionUrl=function(a,b){return goog.html.SafeUrl.sanitizeExtensionUrl_(/^ms-browser-extension:\/\/([^\/]+)\//,a,b)};
	goog.html.SafeUrl.sanitizeExtensionUrl_=function(a,b,c){(a=a.exec(b))?(a=a[1],-1==(c instanceof goog.string.Const?[goog.string.Const.unwrap(c)]:c.map(function(a){return goog.string.Const.unwrap(a)})).indexOf(a)&&(b=goog.html.SafeUrl.INNOCUOUS_STRING)):b=goog.html.SafeUrl.INNOCUOUS_STRING;return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b)};goog.html.SafeUrl.fromTrustedResourceUrl=function(a){return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.html.TrustedResourceUrl.unwrap(a))};
	goog.html.SAFE_URL_PATTERN_=/^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;goog.html.SafeUrl.SAFE_URL_PATTERN=goog.html.SAFE_URL_PATTERN_;goog.html.SafeUrl.sanitize=function(a){if(a instanceof goog.html.SafeUrl)return a;a="object"==typeof a&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);goog.html.SAFE_URL_PATTERN_.test(a)||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
	goog.html.SafeUrl.sanitizeAssertUnchanged=function(a,b){if(a instanceof goog.html.SafeUrl)return a;a="object"==typeof a&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);if(b&&/^data:/i.test(a)&&(b=goog.html.SafeUrl.fromDataUrl(a),b.getTypedStringValue()==a))return b;goog.asserts.assert(goog.html.SAFE_URL_PATTERN_.test(a),"%s does not match the safe URL pattern",a)||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
	goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse=function(a){var b=new goog.html.SafeUrl;b.privateDoNotAccessOrElseSafeUrlWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createURL(a):a;return b};goog.html.SafeUrl.ABOUT_BLANK=goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse("about:blank");goog.html.SafeStyle=function(){this.privateDoNotAccessOrElseSafeStyleWrappedValue_="";this.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;};goog.html.SafeStyle.prototype.implementsGoogStringTypedString=!0;goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
	goog.html.SafeStyle.fromConstant=function(a){a=goog.string.Const.unwrap(a);if(0===a.length)return goog.html.SafeStyle.EMPTY;goog.asserts.assert(goog.string.internal.endsWith(a,";"),"Last character of style string is not ';': "+a);goog.asserts.assert(goog.string.internal.contains(a,":"),"Style string must contain at least one ':', to specify a \"name: value\" pair: "+a);return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(a)};
	goog.html.SafeStyle.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeStyleWrappedValue_};goog.DEBUG&&(goog.html.SafeStyle.prototype.toString=function(){return "SafeStyle{"+this.privateDoNotAccessOrElseSafeStyleWrappedValue_+"}"});
	goog.html.SafeStyle.unwrap=function(a){if(a instanceof goog.html.SafeStyle&&a.constructor===goog.html.SafeStyle&&a.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeStyleWrappedValue_;goog.asserts.fail("expected object of type SafeStyle, got '"+a+"' of type "+goog.typeOf(a));return "type_error:SafeStyle"};goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse=function(a){return (new goog.html.SafeStyle).initSecurityPrivateDoNotAccessOrElse_(a)};
	goog.html.SafeStyle.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeStyleWrappedValue_=a;return this};goog.html.SafeStyle.EMPTY=goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse("");goog.html.SafeStyle.INNOCUOUS_STRING="zClosurez";
	goog.html.SafeStyle.create=function(a){var b="",c;for(c in a){if(!/^[-_a-zA-Z0-9]+$/.test(c))throw Error("Name allows only [-_a-zA-Z0-9], got: "+c);var d=a[c];null!=d&&(d=goog.isArray(d)?goog.array.map(d,goog.html.SafeStyle.sanitizePropertyValue_).join(" "):goog.html.SafeStyle.sanitizePropertyValue_(d),b+=c+":"+d+";");}return b?goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b):goog.html.SafeStyle.EMPTY};
	goog.html.SafeStyle.sanitizePropertyValue_=function(a){if(a instanceof goog.html.SafeUrl)return 'url("'+goog.html.SafeUrl.unwrap(a).replace(/</g,"%3c").replace(/[\\"]/g,"\\$&")+'")';a=a instanceof goog.string.Const?goog.string.Const.unwrap(a):goog.html.SafeStyle.sanitizePropertyValueString_(String(a));if(/[{;}]/.test(a))throw new goog.asserts.AssertionError("Value does not allow [{;}], got: %s.",[a]);return a};
	goog.html.SafeStyle.sanitizePropertyValueString_=function(a){var b=a.replace(goog.html.SafeStyle.FUNCTIONS_RE_,"$1").replace(goog.html.SafeStyle.FUNCTIONS_RE_,"$1").replace(goog.html.SafeStyle.URL_RE_,"url");if(goog.html.SafeStyle.VALUE_RE_.test(b)){if(goog.html.SafeStyle.COMMENT_RE_.test(a))return goog.asserts.fail("String value disallows comments, got: "+a),goog.html.SafeStyle.INNOCUOUS_STRING;if(!goog.html.SafeStyle.hasBalancedQuotes_(a))return goog.asserts.fail("String value requires balanced quotes, got: "+
	a),goog.html.SafeStyle.INNOCUOUS_STRING;if(!goog.html.SafeStyle.hasBalancedSquareBrackets_(a))return goog.asserts.fail("String value requires balanced square brackets and one identifier per pair of brackets, got: "+a),goog.html.SafeStyle.INNOCUOUS_STRING}else return goog.asserts.fail("String value allows only "+goog.html.SafeStyle.VALUE_ALLOWED_CHARS_+" and simple functions, got: "+a),goog.html.SafeStyle.INNOCUOUS_STRING;return goog.html.SafeStyle.sanitizeUrl_(a)};
	goog.html.SafeStyle.hasBalancedQuotes_=function(a){for(var b=!0,c=!0,d=0;d<a.length;d++){var e=a.charAt(d);"'"==e&&c?b=!b:'"'==e&&b&&(c=!c);}return b&&c};goog.html.SafeStyle.hasBalancedSquareBrackets_=function(a){for(var b=!0,c=/^[-_a-zA-Z0-9]$/,d=0;d<a.length;d++){var e=a.charAt(d);if("]"==e){if(b)return !1;b=!0;}else if("["==e){if(!b)return !1;b=!1;}else if(!b&&!c.test(e))return !1}return b};goog.html.SafeStyle.VALUE_ALLOWED_CHARS_="[-,.\"'%_!# a-zA-Z0-9\\[\\]]";
	goog.html.SafeStyle.VALUE_RE_=new RegExp("^"+goog.html.SafeStyle.VALUE_ALLOWED_CHARS_+"+$");goog.html.SafeStyle.URL_RE_=/\b(url\([ \t\n]*)('[ -&(-\[\]-~]*'|"[ !#-\[\]-~]*"|[!#-&*-\[\]-~]*)([ \t\n]*\))/g;goog.html.SafeStyle.FUNCTIONS_RE_=/\b(hsl|hsla|rgb|rgba|matrix|calc|minmax|fit-content|repeat|(rotate|scale|translate)(X|Y|Z|3d)?)\([-+*/0-9a-z.%\[\], ]+\)/g;goog.html.SafeStyle.COMMENT_RE_=/\/\*/;
	goog.html.SafeStyle.sanitizeUrl_=function(a){return a.replace(goog.html.SafeStyle.URL_RE_,function(a,c,d,e){var b="";d=d.replace(/^(['"])(.*)\1$/,function(a,c,d){b=c;return d});a=goog.html.SafeUrl.sanitize(d).getTypedStringValue();return c+b+a+b+e})};goog.html.SafeStyle.concat=function(a){var b="",c=function(a){goog.isArray(a)?goog.array.forEach(a,c):b+=goog.html.SafeStyle.unwrap(a);};goog.array.forEach(arguments,c);return b?goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b):goog.html.SafeStyle.EMPTY};goog.html.SafeScript=function(){this.privateDoNotAccessOrElseSafeScriptWrappedValue_="";this.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;};goog.html.SafeScript.prototype.implementsGoogStringTypedString=!0;goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog.html.SafeScript.fromConstant=function(a){a=goog.string.Const.unwrap(a);return 0===a.length?goog.html.SafeScript.EMPTY:goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(a)};
	goog.html.SafeScript.fromConstantAndArgs=function(a,b){for(var c=[],d=1;d<arguments.length;d++)c.push(goog.html.SafeScript.stringify_(arguments[d]));return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("("+goog.string.Const.unwrap(a)+")("+c.join(", ")+");")};goog.html.SafeScript.fromJson=function(a){return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(goog.html.SafeScript.stringify_(a))};goog.html.SafeScript.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeScriptWrappedValue_.toString()};
	goog.DEBUG&&(goog.html.SafeScript.prototype.toString=function(){return "SafeScript{"+this.privateDoNotAccessOrElseSafeScriptWrappedValue_+"}"});goog.html.SafeScript.unwrap=function(a){return goog.html.SafeScript.unwrapTrustedScript(a).toString()};
	goog.html.SafeScript.unwrapTrustedScript=function(a){if(a instanceof goog.html.SafeScript&&a.constructor===goog.html.SafeScript&&a.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeScriptWrappedValue_;goog.asserts.fail("expected object of type SafeScript, got '"+a+"' of type "+goog.typeOf(a));return "type_error:SafeScript"};
	goog.html.SafeScript.stringify_=function(a){return JSON.stringify(a).replace(/</g,"\\x3c")};goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse=function(a){return (new goog.html.SafeScript).initSecurityPrivateDoNotAccessOrElse_(a)};
	goog.html.SafeScript.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeScriptWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScript(a):a;return this};goog.html.SafeScript.EMPTY=goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("");goog.object={};goog.object.is=function(a,b){return a===b?0!==a||1/a===1/b:a!==a&&b!==b};goog.object.forEach=function(a,b,c){for(var d in a)b.call(c,a[d],d,a);};goog.object.filter=function(a,b,c){var d={},e;for(e in a)b.call(c,a[e],e,a)&&(d[e]=a[e]);return d};goog.object.map=function(a,b,c){var d={},e;for(e in a)d[e]=b.call(c,a[e],e,a);return d};goog.object.some=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return !0;return !1};
	goog.object.every=function(a,b,c){for(var d in a)if(!b.call(c,a[d],d,a))return !1;return !0};goog.object.getCount=function(a){var b=0,c;for(c in a)b++;return b};goog.object.getAnyKey=function(a){for(var b in a)return b};goog.object.getAnyValue=function(a){for(var b in a)return a[b]};goog.object.contains=function(a,b){return goog.object.containsValue(a,b)};goog.object.getValues=function(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b};
	goog.object.getKeys=function(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b};goog.object.getValueByKeys=function(a,b){var c=goog.isArrayLike(b),d=c?b:arguments;for(c=c?0:1;c<d.length;c++){if(null==a)return;a=a[d[c]];}return a};goog.object.containsKey=function(a,b){return null!==a&&b in a};goog.object.containsValue=function(a,b){for(var c in a)if(a[c]==b)return !0;return !1};goog.object.findKey=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return d};
	goog.object.findValue=function(a,b,c){return (b=goog.object.findKey(a,b,c))&&a[b]};goog.object.isEmpty=function(a){for(var b in a)return !1;return !0};goog.object.clear=function(a){for(var b in a)delete a[b];};goog.object.remove=function(a,b){var c;(c=b in a)&&delete a[b];return c};goog.object.add=function(a,b,c){if(null!==a&&b in a)throw Error('The object already contains the key "'+b+'"');goog.object.set(a,b,c);};goog.object.get=function(a,b,c){return null!==a&&b in a?a[b]:c};
	goog.object.set=function(a,b,c){a[b]=c;};goog.object.setIfUndefined=function(a,b,c){return b in a?a[b]:a[b]=c};goog.object.setWithReturnValueIfNotSet=function(a,b,c){if(b in a)return a[b];c=c();return a[b]=c};goog.object.equals=function(a,b){for(var c in a)if(!(c in b)||a[c]!==b[c])return !1;for(var d in b)if(!(d in a))return !1;return !0};goog.object.clone=function(a){var b={},c;for(c in a)b[c]=a[c];return b};
	goog.object.unsafeClone=function(a){var b=goog.typeOf(a);if("object"==b||"array"==b){if(goog.isFunction(a.clone))return a.clone();b="array"==b?[]:{};for(var c in a)b[c]=goog.object.unsafeClone(a[c]);return b}return a};goog.object.transpose=function(a){var b={},c;for(c in a)b[a[c]]=c;return b};goog.object.PROTOTYPE_FIELDS_="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
	goog.object.extend=function(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<goog.object.PROTOTYPE_FIELDS_.length;f++)c=goog.object.PROTOTYPE_FIELDS_[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c]);}};
	goog.object.create=function(a){var b=arguments.length;if(1==b&&goog.isArray(arguments[0]))return goog.object.create.apply(null,arguments[0]);if(b%2)throw Error("Uneven number of arguments");for(var c={},d=0;d<b;d+=2)c[arguments[d]]=arguments[d+1];return c};goog.object.createSet=function(a){var b=arguments.length;if(1==b&&goog.isArray(arguments[0]))return goog.object.createSet.apply(null,arguments[0]);for(var c={},d=0;d<b;d++)c[arguments[d]]=!0;return c};
	goog.object.createImmutableView=function(a){var b=a;Object.isFrozen&&!Object.isFrozen(a)&&(b=Object.create(a),Object.freeze(b));return b};goog.object.isImmutableView=function(a){return !!Object.isFrozen&&Object.isFrozen(a)};
	goog.object.getAllPropertyNames=function(a,b,c){if(!a)return [];if(!Object.getOwnPropertyNames||!Object.getPrototypeOf)return goog.object.getKeys(a);for(var d={};a&&(a!==Object.prototype||b)&&(a!==Function.prototype||c);){for(var e=Object.getOwnPropertyNames(a),f=0;f<e.length;f++)d[e[f]]=!0;a=Object.getPrototypeOf(a);}return goog.object.getKeys(d)};goog.object.getSuperClass=function(a){return (a=Object.getPrototypeOf(a.prototype))&&a.constructor};goog.html.SafeStyleSheet=function(){this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_="";this.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;};goog.html.SafeStyleSheet.prototype.implementsGoogStringTypedString=!0;goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
	goog.html.SafeStyleSheet.createRule=function(a,b){if(goog.string.internal.contains(a,"<"))throw Error("Selector does not allow '<', got: "+a);var c=a.replace(/('|")((?!\1)[^\r\n\f\\]|\\[\s\S])*\1/g,"");if(!/^[-_a-zA-Z0-9#.:* ,>+~[\]()=^$|]+$/.test(c))throw Error("Selector allows only [-_a-zA-Z0-9#.:* ,>+~[\\]()=^$|] and strings, got: "+a);if(!goog.html.SafeStyleSheet.hasBalancedBrackets_(c))throw Error("() and [] in selector must be balanced, got: "+a);b instanceof goog.html.SafeStyle||(b=goog.html.SafeStyle.create(b));
	a=a+"{"+goog.html.SafeStyle.unwrap(b).replace(/</g,"\\3C ")+"}";return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeStyleSheet.hasBalancedBrackets_=function(a){for(var b={"(":")","[":"]"},c=[],d=0;d<a.length;d++){var e=a[d];if(b[e])c.push(b[e]);else if(goog.object.contains(b,e)&&c.pop()!=e)return !1}return 0==c.length};
	goog.html.SafeStyleSheet.concat=function(a){var b="",c=function(a){goog.isArray(a)?goog.array.forEach(a,c):b+=goog.html.SafeStyleSheet.unwrap(a);};goog.array.forEach(arguments,c);return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(b)};
	goog.html.SafeStyleSheet.fromConstant=function(a){a=goog.string.Const.unwrap(a);if(0===a.length)return goog.html.SafeStyleSheet.EMPTY;goog.asserts.assert(!goog.string.internal.contains(a,"<"),"Forbidden '<' character in style sheet string: "+a);return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeStyleSheet.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_};
	goog.DEBUG&&(goog.html.SafeStyleSheet.prototype.toString=function(){return "SafeStyleSheet{"+this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_+"}"});
	goog.html.SafeStyleSheet.unwrap=function(a){if(a instanceof goog.html.SafeStyleSheet&&a.constructor===goog.html.SafeStyleSheet&&a.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;goog.asserts.fail("expected object of type SafeStyleSheet, got '"+a+"' of type "+goog.typeOf(a));return "type_error:SafeStyleSheet"};
	goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse=function(a){return (new goog.html.SafeStyleSheet).initSecurityPrivateDoNotAccessOrElse_(a)};goog.html.SafeStyleSheet.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_=a;return this};goog.html.SafeStyleSheet.EMPTY=goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse("");goog.dom.tags={};goog.dom.tags.VOID_TAGS_={area:!0,base:!0,br:!0,col:!0,command:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0};goog.dom.tags.isVoidTag=function(a){return !0===goog.dom.tags.VOID_TAGS_[a]};goog.dom.HtmlElement=function(){};goog.dom.TagName=function(a){this.tagName_=a;};goog.dom.TagName.prototype.toString=function(){return this.tagName_};goog.dom.TagName.A=new goog.dom.TagName("A");goog.dom.TagName.ABBR=new goog.dom.TagName("ABBR");goog.dom.TagName.ACRONYM=new goog.dom.TagName("ACRONYM");goog.dom.TagName.ADDRESS=new goog.dom.TagName("ADDRESS");goog.dom.TagName.APPLET=new goog.dom.TagName("APPLET");goog.dom.TagName.AREA=new goog.dom.TagName("AREA");goog.dom.TagName.ARTICLE=new goog.dom.TagName("ARTICLE");
	goog.dom.TagName.ASIDE=new goog.dom.TagName("ASIDE");goog.dom.TagName.AUDIO=new goog.dom.TagName("AUDIO");goog.dom.TagName.B=new goog.dom.TagName("B");goog.dom.TagName.BASE=new goog.dom.TagName("BASE");goog.dom.TagName.BASEFONT=new goog.dom.TagName("BASEFONT");goog.dom.TagName.BDI=new goog.dom.TagName("BDI");goog.dom.TagName.BDO=new goog.dom.TagName("BDO");goog.dom.TagName.BIG=new goog.dom.TagName("BIG");goog.dom.TagName.BLOCKQUOTE=new goog.dom.TagName("BLOCKQUOTE");goog.dom.TagName.BODY=new goog.dom.TagName("BODY");
	goog.dom.TagName.BR=new goog.dom.TagName("BR");goog.dom.TagName.BUTTON=new goog.dom.TagName("BUTTON");goog.dom.TagName.CANVAS=new goog.dom.TagName("CANVAS");goog.dom.TagName.CAPTION=new goog.dom.TagName("CAPTION");goog.dom.TagName.CENTER=new goog.dom.TagName("CENTER");goog.dom.TagName.CITE=new goog.dom.TagName("CITE");goog.dom.TagName.CODE=new goog.dom.TagName("CODE");goog.dom.TagName.COL=new goog.dom.TagName("COL");goog.dom.TagName.COLGROUP=new goog.dom.TagName("COLGROUP");
	goog.dom.TagName.COMMAND=new goog.dom.TagName("COMMAND");goog.dom.TagName.DATA=new goog.dom.TagName("DATA");goog.dom.TagName.DATALIST=new goog.dom.TagName("DATALIST");goog.dom.TagName.DD=new goog.dom.TagName("DD");goog.dom.TagName.DEL=new goog.dom.TagName("DEL");goog.dom.TagName.DETAILS=new goog.dom.TagName("DETAILS");goog.dom.TagName.DFN=new goog.dom.TagName("DFN");goog.dom.TagName.DIALOG=new goog.dom.TagName("DIALOG");goog.dom.TagName.DIR=new goog.dom.TagName("DIR");goog.dom.TagName.DIV=new goog.dom.TagName("DIV");
	goog.dom.TagName.DL=new goog.dom.TagName("DL");goog.dom.TagName.DT=new goog.dom.TagName("DT");goog.dom.TagName.EM=new goog.dom.TagName("EM");goog.dom.TagName.EMBED=new goog.dom.TagName("EMBED");goog.dom.TagName.FIELDSET=new goog.dom.TagName("FIELDSET");goog.dom.TagName.FIGCAPTION=new goog.dom.TagName("FIGCAPTION");goog.dom.TagName.FIGURE=new goog.dom.TagName("FIGURE");goog.dom.TagName.FONT=new goog.dom.TagName("FONT");goog.dom.TagName.FOOTER=new goog.dom.TagName("FOOTER");goog.dom.TagName.FORM=new goog.dom.TagName("FORM");
	goog.dom.TagName.FRAME=new goog.dom.TagName("FRAME");goog.dom.TagName.FRAMESET=new goog.dom.TagName("FRAMESET");goog.dom.TagName.H1=new goog.dom.TagName("H1");goog.dom.TagName.H2=new goog.dom.TagName("H2");goog.dom.TagName.H3=new goog.dom.TagName("H3");goog.dom.TagName.H4=new goog.dom.TagName("H4");goog.dom.TagName.H5=new goog.dom.TagName("H5");goog.dom.TagName.H6=new goog.dom.TagName("H6");goog.dom.TagName.HEAD=new goog.dom.TagName("HEAD");goog.dom.TagName.HEADER=new goog.dom.TagName("HEADER");
	goog.dom.TagName.HGROUP=new goog.dom.TagName("HGROUP");goog.dom.TagName.HR=new goog.dom.TagName("HR");goog.dom.TagName.HTML=new goog.dom.TagName("HTML");goog.dom.TagName.I=new goog.dom.TagName("I");goog.dom.TagName.IFRAME=new goog.dom.TagName("IFRAME");goog.dom.TagName.IMG=new goog.dom.TagName("IMG");goog.dom.TagName.INPUT=new goog.dom.TagName("INPUT");goog.dom.TagName.INS=new goog.dom.TagName("INS");goog.dom.TagName.ISINDEX=new goog.dom.TagName("ISINDEX");goog.dom.TagName.KBD=new goog.dom.TagName("KBD");
	goog.dom.TagName.KEYGEN=new goog.dom.TagName("KEYGEN");goog.dom.TagName.LABEL=new goog.dom.TagName("LABEL");goog.dom.TagName.LEGEND=new goog.dom.TagName("LEGEND");goog.dom.TagName.LI=new goog.dom.TagName("LI");goog.dom.TagName.LINK=new goog.dom.TagName("LINK");goog.dom.TagName.MAIN=new goog.dom.TagName("MAIN");goog.dom.TagName.MAP=new goog.dom.TagName("MAP");goog.dom.TagName.MARK=new goog.dom.TagName("MARK");goog.dom.TagName.MATH=new goog.dom.TagName("MATH");goog.dom.TagName.MENU=new goog.dom.TagName("MENU");
	goog.dom.TagName.MENUITEM=new goog.dom.TagName("MENUITEM");goog.dom.TagName.META=new goog.dom.TagName("META");goog.dom.TagName.METER=new goog.dom.TagName("METER");goog.dom.TagName.NAV=new goog.dom.TagName("NAV");goog.dom.TagName.NOFRAMES=new goog.dom.TagName("NOFRAMES");goog.dom.TagName.NOSCRIPT=new goog.dom.TagName("NOSCRIPT");goog.dom.TagName.OBJECT=new goog.dom.TagName("OBJECT");goog.dom.TagName.OL=new goog.dom.TagName("OL");goog.dom.TagName.OPTGROUP=new goog.dom.TagName("OPTGROUP");
	goog.dom.TagName.OPTION=new goog.dom.TagName("OPTION");goog.dom.TagName.OUTPUT=new goog.dom.TagName("OUTPUT");goog.dom.TagName.P=new goog.dom.TagName("P");goog.dom.TagName.PARAM=new goog.dom.TagName("PARAM");goog.dom.TagName.PICTURE=new goog.dom.TagName("PICTURE");goog.dom.TagName.PRE=new goog.dom.TagName("PRE");goog.dom.TagName.PROGRESS=new goog.dom.TagName("PROGRESS");goog.dom.TagName.Q=new goog.dom.TagName("Q");goog.dom.TagName.RP=new goog.dom.TagName("RP");goog.dom.TagName.RT=new goog.dom.TagName("RT");
	goog.dom.TagName.RTC=new goog.dom.TagName("RTC");goog.dom.TagName.RUBY=new goog.dom.TagName("RUBY");goog.dom.TagName.S=new goog.dom.TagName("S");goog.dom.TagName.SAMP=new goog.dom.TagName("SAMP");goog.dom.TagName.SCRIPT=new goog.dom.TagName("SCRIPT");goog.dom.TagName.SECTION=new goog.dom.TagName("SECTION");goog.dom.TagName.SELECT=new goog.dom.TagName("SELECT");goog.dom.TagName.SMALL=new goog.dom.TagName("SMALL");goog.dom.TagName.SOURCE=new goog.dom.TagName("SOURCE");goog.dom.TagName.SPAN=new goog.dom.TagName("SPAN");
	goog.dom.TagName.STRIKE=new goog.dom.TagName("STRIKE");goog.dom.TagName.STRONG=new goog.dom.TagName("STRONG");goog.dom.TagName.STYLE=new goog.dom.TagName("STYLE");goog.dom.TagName.SUB=new goog.dom.TagName("SUB");goog.dom.TagName.SUMMARY=new goog.dom.TagName("SUMMARY");goog.dom.TagName.SUP=new goog.dom.TagName("SUP");goog.dom.TagName.SVG=new goog.dom.TagName("SVG");goog.dom.TagName.TABLE=new goog.dom.TagName("TABLE");goog.dom.TagName.TBODY=new goog.dom.TagName("TBODY");goog.dom.TagName.TD=new goog.dom.TagName("TD");
	goog.dom.TagName.TEMPLATE=new goog.dom.TagName("TEMPLATE");goog.dom.TagName.TEXTAREA=new goog.dom.TagName("TEXTAREA");goog.dom.TagName.TFOOT=new goog.dom.TagName("TFOOT");goog.dom.TagName.TH=new goog.dom.TagName("TH");goog.dom.TagName.THEAD=new goog.dom.TagName("THEAD");goog.dom.TagName.TIME=new goog.dom.TagName("TIME");goog.dom.TagName.TITLE=new goog.dom.TagName("TITLE");goog.dom.TagName.TR=new goog.dom.TagName("TR");goog.dom.TagName.TRACK=new goog.dom.TagName("TRACK");goog.dom.TagName.TT=new goog.dom.TagName("TT");
	goog.dom.TagName.U=new goog.dom.TagName("U");goog.dom.TagName.UL=new goog.dom.TagName("UL");goog.dom.TagName.VAR=new goog.dom.TagName("VAR");goog.dom.TagName.VIDEO=new goog.dom.TagName("VIDEO");goog.dom.TagName.WBR=new goog.dom.TagName("WBR");goog.labs={};goog.labs.userAgent={};goog.labs.userAgent.util={};goog.labs.userAgent.util.getNativeUserAgentString_=function(){var a=goog.labs.userAgent.util.getNavigator_();return a&&(a=a.userAgent)?a:""};goog.labs.userAgent.util.getNavigator_=function(){return goog.global.navigator};goog.labs.userAgent.util.userAgent_=goog.labs.userAgent.util.getNativeUserAgentString_();goog.labs.userAgent.util.setUserAgent=function(a){goog.labs.userAgent.util.userAgent_=a||goog.labs.userAgent.util.getNativeUserAgentString_();};
	goog.labs.userAgent.util.getUserAgent=function(){return goog.labs.userAgent.util.userAgent_};goog.labs.userAgent.util.matchUserAgent=function(a){var b=goog.labs.userAgent.util.getUserAgent();return goog.string.internal.contains(b,a)};goog.labs.userAgent.util.matchUserAgentIgnoreCase=function(a){var b=goog.labs.userAgent.util.getUserAgent();return goog.string.internal.caseInsensitiveContains(b,a)};
	goog.labs.userAgent.util.extractVersionTuples=function(a){for(var b=/(\w[\w ]+)\/([^\s]+)\s*(?:\((.*?)\))?/g,c=[],d;d=b.exec(a);)c.push([d[1],d[2],d[3]||void 0]);return c};goog.labs.userAgent.browser={};goog.labs.userAgent.browser.matchOpera_=function(){return goog.labs.userAgent.util.matchUserAgent("Opera")};goog.labs.userAgent.browser.matchIE_=function(){return goog.labs.userAgent.util.matchUserAgent("Trident")||goog.labs.userAgent.util.matchUserAgent("MSIE")};goog.labs.userAgent.browser.matchEdgeHtml_=function(){return goog.labs.userAgent.util.matchUserAgent("Edge")};goog.labs.userAgent.browser.matchEdgeChromium_=function(){return goog.labs.userAgent.util.matchUserAgent("Edg/")};
	goog.labs.userAgent.browser.matchOperaChromium_=function(){return goog.labs.userAgent.util.matchUserAgent("OPR")};goog.labs.userAgent.browser.matchFirefox_=function(){return goog.labs.userAgent.util.matchUserAgent("Firefox")||goog.labs.userAgent.util.matchUserAgent("FxiOS")};
	goog.labs.userAgent.browser.matchSafari_=function(){return goog.labs.userAgent.util.matchUserAgent("Safari")&&!(goog.labs.userAgent.browser.matchChrome_()||goog.labs.userAgent.browser.matchCoast_()||goog.labs.userAgent.browser.matchOpera_()||goog.labs.userAgent.browser.matchEdgeHtml_()||goog.labs.userAgent.browser.matchEdgeChromium_()||goog.labs.userAgent.browser.matchOperaChromium_()||goog.labs.userAgent.browser.matchFirefox_()||goog.labs.userAgent.browser.isSilk()||goog.labs.userAgent.util.matchUserAgent("Android"))};
	goog.labs.userAgent.browser.matchCoast_=function(){return goog.labs.userAgent.util.matchUserAgent("Coast")};goog.labs.userAgent.browser.matchIosWebview_=function(){return (goog.labs.userAgent.util.matchUserAgent("iPad")||goog.labs.userAgent.util.matchUserAgent("iPhone"))&&!goog.labs.userAgent.browser.matchSafari_()&&!goog.labs.userAgent.browser.matchChrome_()&&!goog.labs.userAgent.browser.matchCoast_()&&!goog.labs.userAgent.browser.matchFirefox_()&&goog.labs.userAgent.util.matchUserAgent("AppleWebKit")};
	goog.labs.userAgent.browser.matchChrome_=function(){return (goog.labs.userAgent.util.matchUserAgent("Chrome")||goog.labs.userAgent.util.matchUserAgent("CriOS"))&&!goog.labs.userAgent.browser.matchEdgeHtml_()};goog.labs.userAgent.browser.matchAndroidBrowser_=function(){return goog.labs.userAgent.util.matchUserAgent("Android")&&!(goog.labs.userAgent.browser.isChrome()||goog.labs.userAgent.browser.isFirefox()||goog.labs.userAgent.browser.isOpera()||goog.labs.userAgent.browser.isSilk())};
	goog.labs.userAgent.browser.isOpera=goog.labs.userAgent.browser.matchOpera_;goog.labs.userAgent.browser.isIE=goog.labs.userAgent.browser.matchIE_;goog.labs.userAgent.browser.isEdge=goog.labs.userAgent.browser.matchEdgeHtml_;goog.labs.userAgent.browser.isEdgeChromium=goog.labs.userAgent.browser.matchEdgeChromium_;goog.labs.userAgent.browser.isOperaChromium=goog.labs.userAgent.browser.matchOperaChromium_;goog.labs.userAgent.browser.isFirefox=goog.labs.userAgent.browser.matchFirefox_;
	goog.labs.userAgent.browser.isSafari=goog.labs.userAgent.browser.matchSafari_;goog.labs.userAgent.browser.isCoast=goog.labs.userAgent.browser.matchCoast_;goog.labs.userAgent.browser.isIosWebview=goog.labs.userAgent.browser.matchIosWebview_;goog.labs.userAgent.browser.isChrome=goog.labs.userAgent.browser.matchChrome_;goog.labs.userAgent.browser.isAndroidBrowser=goog.labs.userAgent.browser.matchAndroidBrowser_;goog.labs.userAgent.browser.isSilk=function(){return goog.labs.userAgent.util.matchUserAgent("Silk")};
	goog.labs.userAgent.browser.getVersion=function(){function a(a){a=goog.array.find(a,d);return c[a]||""}var b=goog.labs.userAgent.util.getUserAgent();if(goog.labs.userAgent.browser.isIE())return goog.labs.userAgent.browser.getIEVersion_(b);b=goog.labs.userAgent.util.extractVersionTuples(b);var c={};goog.array.forEach(b,function(a){c[a[0]]=a[1];});var d=goog.partial(goog.object.containsKey,c);return goog.labs.userAgent.browser.isOpera()?a(["Version","Opera"]):goog.labs.userAgent.browser.isEdge()?a(["Edge"]):
	goog.labs.userAgent.browser.isEdgeChromium()?a(["Edg"]):goog.labs.userAgent.browser.isChrome()?a(["Chrome","CriOS"]):(b=b[2])&&b[1]||""};goog.labs.userAgent.browser.isVersionOrHigher=function(a){return 0<=goog.string.internal.compareVersions(goog.labs.userAgent.browser.getVersion(),a)};
	goog.labs.userAgent.browser.getIEVersion_=function(a){var b=/rv: *([\d\.]*)/.exec(a);if(b&&b[1])return b[1];b="";var c=/MSIE +([\d\.]+)/.exec(a);if(c&&c[1])if(a=/Trident\/(\d.\d)/.exec(a),"7.0"==c[1])if(a&&a[1])switch(a[1]){case "4.0":b="8.0";break;case "5.0":b="9.0";break;case "6.0":b="10.0";break;case "7.0":b="11.0";}else b="7.0";else b=c[1];return b};goog.html.SafeHtml=function(){this.privateDoNotAccessOrElseSafeHtmlWrappedValue_="";this.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;this.dir_=null;};goog.html.SafeHtml.prototype.implementsGoogI18nBidiDirectionalString=!0;goog.html.SafeHtml.prototype.getDirection=function(){return this.dir_};goog.html.SafeHtml.prototype.implementsGoogStringTypedString=!0;goog.html.SafeHtml.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_.toString()};
	goog.DEBUG&&(goog.html.SafeHtml.prototype.toString=function(){return "SafeHtml{"+this.privateDoNotAccessOrElseSafeHtmlWrappedValue_+"}"});goog.html.SafeHtml.unwrap=function(a){return goog.html.SafeHtml.unwrapTrustedHTML(a).toString()};
	goog.html.SafeHtml.unwrapTrustedHTML=function(a){if(a instanceof goog.html.SafeHtml&&a.constructor===goog.html.SafeHtml&&a.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeHtmlWrappedValue_;goog.asserts.fail("expected object of type SafeHtml, got '"+a+"' of type "+goog.typeOf(a));return "type_error:SafeHtml"};
	goog.html.SafeHtml.htmlEscape=function(a){if(a instanceof goog.html.SafeHtml)return a;var b="object"==typeof a,c=null;b&&a.implementsGoogI18nBidiDirectionalString&&(c=a.getDirection());a=b&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.htmlEscape(a),c)};
	goog.html.SafeHtml.htmlEscapePreservingNewlines=function(a){if(a instanceof goog.html.SafeHtml)return a;a=goog.html.SafeHtml.htmlEscape(a);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.newLineToBr(goog.html.SafeHtml.unwrap(a)),a.getDirection())};
	goog.html.SafeHtml.htmlEscapePreservingNewlinesAndSpaces=function(a){if(a instanceof goog.html.SafeHtml)return a;a=goog.html.SafeHtml.htmlEscape(a);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.whitespaceEscape(goog.html.SafeHtml.unwrap(a)),a.getDirection())};goog.html.SafeHtml.from=goog.html.SafeHtml.htmlEscape;goog.html.SafeHtml.VALID_NAMES_IN_TAG_=/^[a-zA-Z0-9-]+$/;
	goog.html.SafeHtml.URL_ATTRIBUTES_={action:!0,cite:!0,data:!0,formaction:!0,href:!0,manifest:!0,poster:!0,src:!0};goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_={APPLET:!0,BASE:!0,EMBED:!0,IFRAME:!0,LINK:!0,MATH:!0,META:!0,OBJECT:!0,SCRIPT:!0,STYLE:!0,SVG:!0,TEMPLATE:!0};goog.html.SafeHtml.create=function(a,b,c){goog.html.SafeHtml.verifyTagName(String(a));return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(String(a),b,c)};
	goog.html.SafeHtml.verifyTagName=function(a){if(!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(a))throw Error("Invalid tag name <"+a+">.");if(a.toUpperCase()in goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_)throw Error("Tag name <"+a+"> is not allowed for SafeHtml.");};
	goog.html.SafeHtml.createIframe=function(a,b,c,d){a&&goog.html.TrustedResourceUrl.unwrap(a);var e={};e.src=a||null;e.srcdoc=b&&goog.html.SafeHtml.unwrap(b);a=goog.html.SafeHtml.combineAttributes(e,{sandbox:""},c);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe",a,d)};
	goog.html.SafeHtml.createSandboxIframe=function(a,b,c,d){if(!goog.html.SafeHtml.canUseSandboxIframe())throw Error("The browser does not support sandboxed iframes.");var e={};e.src=a?goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(a)):null;e.srcdoc=b||null;e.sandbox="";a=goog.html.SafeHtml.combineAttributes(e,{},c);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe",a,d)};
	goog.html.SafeHtml.canUseSandboxIframe=function(){return goog.global.HTMLIFrameElement&&"sandbox"in goog.global.HTMLIFrameElement.prototype};goog.html.SafeHtml.createScriptSrc=function(a,b){goog.html.TrustedResourceUrl.unwrap(a);a=goog.html.SafeHtml.combineAttributes({src:a},{},b);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script",a)};
	goog.html.SafeHtml.createScript=function(a,b){for(var c in b){var d=c.toLowerCase();if("language"==d||"src"==d||"text"==d||"type"==d)throw Error('Cannot set "'+d+'" attribute');}c="";a=goog.array.concat(a);for(d=0;d<a.length;d++)c+=goog.html.SafeScript.unwrap(a[d]);a=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(c,goog.i18n.bidi.Dir.NEUTRAL);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script",b,a)};
	goog.html.SafeHtml.createStyle=function(a,b){b=goog.html.SafeHtml.combineAttributes({type:"text/css"},{},b);var c="";a=goog.array.concat(a);for(var d=0;d<a.length;d++)c+=goog.html.SafeStyleSheet.unwrap(a[d]);a=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(c,goog.i18n.bidi.Dir.NEUTRAL);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("style",b,a)};
	goog.html.SafeHtml.createMetaRefresh=function(a,b){a=goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(a));(goog.labs.userAgent.browser.isIE()||goog.labs.userAgent.browser.isEdge())&&goog.string.internal.contains(a,";")&&(a="'"+a.replace(/'/g,"%27")+"'");return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("meta",{"http-equiv":"refresh",content:(b||0)+"; url="+a})};
	goog.html.SafeHtml.getAttrNameAndValue_=function(a,b,c){if(c instanceof goog.string.Const)c=goog.string.Const.unwrap(c);else if("style"==b.toLowerCase())c=goog.html.SafeHtml.getStyleValue_(c);else {if(/^on/i.test(b))throw Error('Attribute "'+b+'" requires goog.string.Const value, "'+c+'" given.');if(b.toLowerCase()in goog.html.SafeHtml.URL_ATTRIBUTES_)if(c instanceof goog.html.TrustedResourceUrl)c=goog.html.TrustedResourceUrl.unwrap(c);else if(c instanceof goog.html.SafeUrl)c=goog.html.SafeUrl.unwrap(c);
	else if(goog.isString(c))c=goog.html.SafeUrl.sanitize(c).getTypedStringValue();else throw Error('Attribute "'+b+'" on tag "'+a+'" requires goog.html.SafeUrl, goog.string.Const, or string, value "'+c+'" given.');}c.implementsGoogStringTypedString&&(c=c.getTypedStringValue());goog.asserts.assert(goog.isString(c)||goog.isNumber(c),"String or number value expected, got "+typeof c+" with value: "+c);return b+'="'+goog.string.internal.htmlEscape(String(c))+'"'};
	goog.html.SafeHtml.getStyleValue_=function(a){if(!goog.isObject(a))throw Error('The "style" attribute requires goog.html.SafeStyle or map of style properties, '+typeof a+" given: "+a);a instanceof goog.html.SafeStyle||(a=goog.html.SafeStyle.create(a));return goog.html.SafeStyle.unwrap(a)};goog.html.SafeHtml.createWithDir=function(a,b,c,d){b=goog.html.SafeHtml.create(b,c,d);b.dir_=a;return b};
	goog.html.SafeHtml.join=function(a,b){a=goog.html.SafeHtml.htmlEscape(a);var c=a.getDirection(),d=[],e=function(a){goog.isArray(a)?goog.array.forEach(a,e):(a=goog.html.SafeHtml.htmlEscape(a),d.push(goog.html.SafeHtml.unwrap(a)),a=a.getDirection(),c==goog.i18n.bidi.Dir.NEUTRAL?c=a:a!=goog.i18n.bidi.Dir.NEUTRAL&&c!=a&&(c=null));};goog.array.forEach(b,e);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(d.join(goog.html.SafeHtml.unwrap(a)),c)};
	goog.html.SafeHtml.concat=function(a){return goog.html.SafeHtml.join(goog.html.SafeHtml.EMPTY,Array.prototype.slice.call(arguments))};goog.html.SafeHtml.concatWithDir=function(a,b){var c=goog.html.SafeHtml.concat(goog.array.slice(arguments,1));c.dir_=a;return c};goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse=function(a,b){return (new goog.html.SafeHtml).initSecurityPrivateDoNotAccessOrElse_(a,b)};
	goog.html.SafeHtml.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a,b){this.privateDoNotAccessOrElseSafeHtmlWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createHTML(a):a;this.dir_=b;return this};
	goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse=function(a,b,c){var d=null;var e="<"+a+goog.html.SafeHtml.stringifyAttributes(a,b);goog.isDefAndNotNull(c)?goog.isArray(c)||(c=[c]):c=[];goog.dom.tags.isVoidTag(a.toLowerCase())?(goog.asserts.assert(!c.length,"Void tag <"+a+"> does not allow content."),e+=">"):(d=goog.html.SafeHtml.concat(c),e+=">"+goog.html.SafeHtml.unwrap(d)+"</"+a+">",d=d.getDirection());(a=b&&b.dir)&&(d=/^(ltr|rtl|auto)$/i.test(a)?goog.i18n.bidi.Dir.NEUTRAL:
	null);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(e,d)};goog.html.SafeHtml.stringifyAttributes=function(a,b){var c="";if(b)for(var d in b){if(!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(d))throw Error('Invalid attribute name "'+d+'".');var e=b[d];goog.isDefAndNotNull(e)&&(c+=" "+goog.html.SafeHtml.getAttrNameAndValue_(a,d,e));}return c};
	goog.html.SafeHtml.combineAttributes=function(a,b,c){var d={},e;for(e in a)goog.asserts.assert(e.toLowerCase()==e,"Must be lower case"),d[e]=a[e];for(e in b)goog.asserts.assert(e.toLowerCase()==e,"Must be lower case"),d[e]=b[e];for(e in c){var f=e.toLowerCase();if(f in a)throw Error('Cannot override "'+f+'" attribute, got "'+e+'" with value "'+c[e]+'"');f in b&&delete d[f];d[e]=c[e];}return d};
	goog.html.SafeHtml.DOCTYPE_HTML=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<!DOCTYPE html>",goog.i18n.bidi.Dir.NEUTRAL);goog.html.SafeHtml.EMPTY=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("",goog.i18n.bidi.Dir.NEUTRAL);goog.html.SafeHtml.BR=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<br>",goog.i18n.bidi.Dir.NEUTRAL);goog.html.uncheckedconversions={};goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract=function(a,b,c){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(b,c||null)};
	goog.html.uncheckedconversions.safeScriptFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(b)};
	goog.html.uncheckedconversions.safeStyleFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b)};
	goog.html.uncheckedconversions.safeStyleSheetFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(b)};
	goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b)};
	goog.html.uncheckedconversions.trustedResourceUrlFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(b)};goog.dom.asserts={};goog.dom.asserts.assertIsLocation=function(a){if(goog.asserts.ENABLE_ASSERTS){var b=goog.dom.asserts.getWindow_(a);b&&(!a||!(a instanceof b.Location)&&a instanceof b.Element)&&goog.asserts.fail("Argument is not a Location (or a non-Element mock); got: %s",goog.dom.asserts.debugStringForType_(a));}return a};
	goog.dom.asserts.assertIsElementType_=function(a,b){if(goog.asserts.ENABLE_ASSERTS){var c=goog.dom.asserts.getWindow_(a);c&&"undefined"!=typeof c[b]&&(a&&(a instanceof c[b]||!(a instanceof c.Location||a instanceof c.Element))||goog.asserts.fail("Argument is not a %s (or a non-Element, non-Location mock); got: %s",b,goog.dom.asserts.debugStringForType_(a)));}return a};goog.dom.asserts.assertIsHTMLAnchorElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLAnchorElement")};
	goog.dom.asserts.assertIsHTMLButtonElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLButtonElement")};goog.dom.asserts.assertIsHTMLLinkElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLLinkElement")};goog.dom.asserts.assertIsHTMLImageElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLImageElement")};goog.dom.asserts.assertIsHTMLAudioElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLAudioElement")};
	goog.dom.asserts.assertIsHTMLVideoElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLVideoElement")};goog.dom.asserts.assertIsHTMLInputElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLInputElement")};goog.dom.asserts.assertIsHTMLTextAreaElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLTextAreaElement")};goog.dom.asserts.assertIsHTMLCanvasElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLCanvasElement")};
	goog.dom.asserts.assertIsHTMLEmbedElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLEmbedElement")};goog.dom.asserts.assertIsHTMLFormElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLFormElement")};goog.dom.asserts.assertIsHTMLFrameElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLFrameElement")};goog.dom.asserts.assertIsHTMLIFrameElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLIFrameElement")};
	goog.dom.asserts.assertIsHTMLObjectElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLObjectElement")};goog.dom.asserts.assertIsHTMLScriptElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLScriptElement")};
	goog.dom.asserts.debugStringForType_=function(a){if(goog.isObject(a))try{return a.constructor.displayName||a.constructor.name||Object.prototype.toString.call(a)}catch(b){return "<object could not be stringified>"}else return void 0===a?"undefined":null===a?"null":typeof a};goog.dom.asserts.getWindow_=function(a){try{var b=a&&a.ownerDocument,c=b&&(b.defaultView||b.parentWindow);c=c||goog.global;if(c.Element&&c.Location)return c}catch(d){}return null};goog.functions={};goog.functions.constant=function(a){return function(){return a}};goog.functions.FALSE=function(){return !1};goog.functions.TRUE=function(){return !0};goog.functions.NULL=function(){return null};goog.functions.identity=function(a,b){return a};goog.functions.error=function(a){return function(){throw Error(a);}};goog.functions.fail=function(a){return function(){throw a;}};
	goog.functions.lock=function(a,b){b=b||0;return function(){return a.apply(this,Array.prototype.slice.call(arguments,0,b))}};goog.functions.nth=function(a){return function(){return arguments[a]}};goog.functions.partialRight=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=Array.prototype.slice.call(arguments);b.push.apply(b,c);return a.apply(this,b)}};goog.functions.withReturnValue=function(a,b){return goog.functions.sequence(a,goog.functions.constant(b))};
	goog.functions.equalTo=function(a,b){return function(c){return b?a==c:a===c}};goog.functions.compose=function(a,b){var c=arguments,d=c.length;return function(){var a;d&&(a=c[d-1].apply(this,arguments));for(var b=d-2;0<=b;b--)a=c[b].call(this,a);return a}};goog.functions.sequence=function(a){var b=arguments,c=b.length;return function(){for(var a,e=0;e<c;e++)a=b[e].apply(this,arguments);return a}};
	goog.functions.and=function(a){var b=arguments,c=b.length;return function(){for(var a=0;a<c;a++)if(!b[a].apply(this,arguments))return !1;return !0}};goog.functions.or=function(a){var b=arguments,c=b.length;return function(){for(var a=0;a<c;a++)if(b[a].apply(this,arguments))return !0;return !1}};goog.functions.not=function(a){return function(){return !a.apply(this,arguments)}};
	goog.functions.create=function(a,b){var c=function(){};c.prototype=a.prototype;c=new c;a.apply(c,Array.prototype.slice.call(arguments,1));return c};goog.functions.CACHE_RETURN_VALUE=!0;goog.functions.cacheReturnValue=function(a){var b=!1,c;return function(){if(!goog.functions.CACHE_RETURN_VALUE)return a();b||(c=a(),b=!0);return c}};goog.functions.once=function(a){var b=a;return function(){if(b){var a=b;b=null;a();}}};
	goog.functions.debounce=function(a,b,c){var d=0;return function(e){goog.global.clearTimeout(d);var f=arguments;d=goog.global.setTimeout(function(){a.apply(c,f);},b);}};goog.functions.throttle=function(a,b,c){var d=0,e=!1,f=[],g=function(){d=0;e&&(e=!1,h());},h=function(){d=goog.global.setTimeout(g,b);a.apply(c,f);};return function(a){f=arguments;d?e=!0:h();}};goog.functions.rateLimit=function(a,b,c){var d=0,e=function(){d=0;};return function(f){d||(d=goog.global.setTimeout(e,b),a.apply(c,arguments));}};goog.dom.safe={};goog.dom.safe.InsertAdjacentHtmlPosition={AFTERBEGIN:"afterbegin",AFTEREND:"afterend",BEFOREBEGIN:"beforebegin",BEFOREEND:"beforeend"};goog.dom.safe.insertAdjacentHtml=function(a,b,c){a.insertAdjacentHTML(b,goog.html.SafeHtml.unwrapTrustedHTML(c));};goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_={MATH:!0,SCRIPT:!0,STYLE:!0,SVG:!0,TEMPLATE:!0};
	goog.dom.safe.isInnerHtmlCleanupRecursive_=goog.functions.cacheReturnValue(function(){if(goog.DEBUG&&"undefined"===typeof document)return !1;var a=document.createElement("div"),b=document.createElement("div");b.appendChild(document.createElement("div"));a.appendChild(b);if(goog.DEBUG&&!a.firstChild)return !1;b=a.firstChild.firstChild;a.innerHTML=goog.html.SafeHtml.unwrapTrustedHTML(goog.html.SafeHtml.EMPTY);return !b.parentElement});
	goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse=function(a,b){if(goog.dom.safe.isInnerHtmlCleanupRecursive_())for(;a.lastChild;)a.removeChild(a.lastChild);a.innerHTML=goog.html.SafeHtml.unwrapTrustedHTML(b);};
	goog.dom.safe.setInnerHtml=function(a,b){if(goog.asserts.ENABLE_ASSERTS){var c=a.tagName.toUpperCase();if(goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_[c])throw Error("goog.dom.safe.setInnerHtml cannot be used to set content of "+a.tagName+".");}goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse(a,b);};goog.dom.safe.setOuterHtml=function(a,b){a.outerHTML=goog.html.SafeHtml.unwrapTrustedHTML(b);};
	goog.dom.safe.setFormElementAction=function(a,b){b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);goog.dom.asserts.assertIsHTMLFormElement(a).action=goog.html.SafeUrl.unwrapTrustedURL(b);};goog.dom.safe.setButtonFormAction=function(a,b){b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);goog.dom.asserts.assertIsHTMLButtonElement(a).formAction=goog.html.SafeUrl.unwrapTrustedURL(b);};
	goog.dom.safe.setInputFormAction=function(a,b){b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);goog.dom.asserts.assertIsHTMLInputElement(a).formAction=goog.html.SafeUrl.unwrapTrustedURL(b);};goog.dom.safe.setStyle=function(a,b){a.style.cssText=goog.html.SafeStyle.unwrap(b);};goog.dom.safe.documentWrite=function(a,b){a.write(goog.html.SafeHtml.unwrapTrustedHTML(b));};
	goog.dom.safe.setAnchorHref=function(a,b){goog.dom.asserts.assertIsHTMLAnchorElement(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.href=goog.html.SafeUrl.unwrapTrustedURL(b);};goog.dom.safe.setImageSrc=function(a,b){goog.dom.asserts.assertIsHTMLImageElement(a);if(!(b instanceof goog.html.SafeUrl)){var c=/^data:image\//i.test(b);b=goog.html.SafeUrl.sanitizeAssertUnchanged(b,c);}a.src=goog.html.SafeUrl.unwrapTrustedURL(b);};
	goog.dom.safe.setAudioSrc=function(a,b){goog.dom.asserts.assertIsHTMLAudioElement(a);if(!(b instanceof goog.html.SafeUrl)){var c=/^data:audio\//i.test(b);b=goog.html.SafeUrl.sanitizeAssertUnchanged(b,c);}a.src=goog.html.SafeUrl.unwrapTrustedURL(b);};goog.dom.safe.setVideoSrc=function(a,b){goog.dom.asserts.assertIsHTMLVideoElement(a);if(!(b instanceof goog.html.SafeUrl)){var c=/^data:video\//i.test(b);b=goog.html.SafeUrl.sanitizeAssertUnchanged(b,c);}a.src=goog.html.SafeUrl.unwrapTrustedURL(b);};
	goog.dom.safe.setEmbedSrc=function(a,b){goog.dom.asserts.assertIsHTMLEmbedElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b);};goog.dom.safe.setFrameSrc=function(a,b){goog.dom.asserts.assertIsHTMLFrameElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedURL(b);};goog.dom.safe.setIframeSrc=function(a,b){goog.dom.asserts.assertIsHTMLIFrameElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedURL(b);};
	goog.dom.safe.setIframeSrcdoc=function(a,b){goog.dom.asserts.assertIsHTMLIFrameElement(a);a.srcdoc=goog.html.SafeHtml.unwrapTrustedHTML(b);};
	goog.dom.safe.setLinkHrefAndRel=function(a,b,c){goog.dom.asserts.assertIsHTMLLinkElement(a);a.rel=c;goog.string.internal.caseInsensitiveContains(c,"stylesheet")?(goog.asserts.assert(b instanceof goog.html.TrustedResourceUrl,'URL must be TrustedResourceUrl because "rel" contains "stylesheet"'),a.href=goog.html.TrustedResourceUrl.unwrapTrustedURL(b)):a.href=b instanceof goog.html.TrustedResourceUrl?goog.html.TrustedResourceUrl.unwrapTrustedURL(b):b instanceof goog.html.SafeUrl?goog.html.SafeUrl.unwrapTrustedURL(b):
	goog.html.SafeUrl.unwrapTrustedURL(goog.html.SafeUrl.sanitizeAssertUnchanged(b));};goog.dom.safe.setObjectData=function(a,b){goog.dom.asserts.assertIsHTMLObjectElement(a);a.data=goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b);};goog.dom.safe.setScriptSrc=function(a,b){goog.dom.asserts.assertIsHTMLScriptElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b);(b=goog.getScriptNonce())&&a.setAttribute("nonce",b);};
	goog.dom.safe.setScriptContent=function(a,b){goog.dom.asserts.assertIsHTMLScriptElement(a);a.text=goog.html.SafeScript.unwrapTrustedScript(b);(b=goog.getScriptNonce())&&a.setAttribute("nonce",b);};goog.dom.safe.setLocationHref=function(a,b){goog.dom.asserts.assertIsLocation(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.href=goog.html.SafeUrl.unwrapTrustedURL(b);};
	goog.dom.safe.assignLocation=function(a,b){goog.dom.asserts.assertIsLocation(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.assign(goog.html.SafeUrl.unwrapTrustedURL(b));};goog.dom.safe.replaceLocation=function(a,b){goog.dom.asserts.assertIsLocation(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.replace(goog.html.SafeUrl.unwrapTrustedURL(b));};
	goog.dom.safe.openInWindow=function(a,b,c,d,e){a=a instanceof goog.html.SafeUrl?a:goog.html.SafeUrl.sanitizeAssertUnchanged(a);return (b||goog.global).open(goog.html.SafeUrl.unwrapTrustedURL(a),c?goog.string.Const.unwrap(c):"",d,e)};goog.dom.safe.parseFromStringHtml=function(a,b){return goog.dom.safe.parseFromString(a,b,"text/html")};goog.dom.safe.parseFromString=function(a,b,c){return a.parseFromString(goog.html.SafeHtml.unwrapTrustedHTML(b),c)};
	goog.dom.safe.createImageFromBlob=function(a){if(!/^image\/.*/g.test(a.type))throw Error("goog.dom.safe.createImageFromBlob only accepts MIME type image/.*.");var b=goog.global.URL.createObjectURL(a);a=new goog.global.Image;a.onload=function(){goog.global.URL.revokeObjectURL(b);};goog.dom.safe.setImageSrc(a,goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Image blob URL."),b));return a};goog.string.DETECT_DOUBLE_ESCAPING=!1;goog.string.FORCE_NON_DOM_HTML_UNESCAPING=!1;goog.string.Unicode={NBSP:"\u00a0"};goog.string.startsWith=goog.string.internal.startsWith;goog.string.endsWith=goog.string.internal.endsWith;goog.string.caseInsensitiveStartsWith=goog.string.internal.caseInsensitiveStartsWith;goog.string.caseInsensitiveEndsWith=goog.string.internal.caseInsensitiveEndsWith;goog.string.caseInsensitiveEquals=goog.string.internal.caseInsensitiveEquals;
	goog.string.subs=function(a,b){for(var c=a.split("%s"),d="",e=Array.prototype.slice.call(arguments,1);e.length&&1<c.length;)d+=c.shift()+e.shift();return d+c.join("%s")};goog.string.collapseWhitespace=function(a){return a.replace(/[\s\xa0]+/g," ").replace(/^\s+|\s+$/g,"")};goog.string.isEmptyOrWhitespace=goog.string.internal.isEmptyOrWhitespace;goog.string.isEmptyString=function(a){return 0==a.length};goog.string.isEmpty=goog.string.isEmptyOrWhitespace;goog.string.isEmptyOrWhitespaceSafe=function(a){return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(a))};
	goog.string.isEmptySafe=goog.string.isEmptyOrWhitespaceSafe;goog.string.isBreakingWhitespace=function(a){return !/[^\t\n\r ]/.test(a)};goog.string.isAlpha=function(a){return !/[^a-zA-Z]/.test(a)};goog.string.isNumeric=function(a){return !/[^0-9]/.test(a)};goog.string.isAlphaNumeric=function(a){return !/[^a-zA-Z0-9]/.test(a)};goog.string.isSpace=function(a){return " "==a};goog.string.isUnicodeChar=function(a){return 1==a.length&&" "<=a&&"~">=a||"\u0080"<=a&&"\ufffd">=a};
	goog.string.stripNewlines=function(a){return a.replace(/(\r\n|\r|\n)+/g," ")};goog.string.canonicalizeNewlines=function(a){return a.replace(/(\r\n|\r|\n)/g,"\n")};goog.string.normalizeWhitespace=function(a){return a.replace(/\xa0|\s/g," ")};goog.string.normalizeSpaces=function(a){return a.replace(/\xa0|[ \t]+/g," ")};goog.string.collapseBreakingSpaces=function(a){return a.replace(/[\t\r\n ]+/g," ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g,"")};goog.string.trim=goog.string.internal.trim;
	goog.string.trimLeft=function(a){return a.replace(/^[\s\xa0]+/,"")};goog.string.trimRight=function(a){return a.replace(/[\s\xa0]+$/,"")};goog.string.caseInsensitiveCompare=goog.string.internal.caseInsensitiveCompare;
	goog.string.numberAwareCompare_=function(a,b,c){if(a==b)return 0;if(!a)return -1;if(!b)return 1;for(var d=a.toLowerCase().match(c),e=b.toLowerCase().match(c),f=Math.min(d.length,e.length),g=0;g<f;g++){c=d[g];var h=e[g];if(c!=h)return a=parseInt(c,10),!isNaN(a)&&(b=parseInt(h,10),!isNaN(b)&&a-b)?a-b:c<h?-1:1}return d.length!=e.length?d.length-e.length:a<b?-1:1};goog.string.intAwareCompare=function(a,b){return goog.string.numberAwareCompare_(a,b,/\d+|\D+/g)};
	goog.string.floatAwareCompare=function(a,b){return goog.string.numberAwareCompare_(a,b,/\d+|\.\d+|\D+/g)};goog.string.numerateCompare=goog.string.floatAwareCompare;goog.string.urlEncode=function(a){return encodeURIComponent(String(a))};goog.string.urlDecode=function(a){return decodeURIComponent(a.replace(/\+/g," "))};goog.string.newLineToBr=goog.string.internal.newLineToBr;
	goog.string.htmlEscape=function(a,b){a=goog.string.internal.htmlEscape(a,b);goog.string.DETECT_DOUBLE_ESCAPING&&(a=a.replace(goog.string.E_RE_,"&#101;"));return a};goog.string.E_RE_=/e/g;goog.string.unescapeEntities=function(a){return goog.string.contains(a,"&")?!goog.string.FORCE_NON_DOM_HTML_UNESCAPING&&"document"in goog.global?goog.string.unescapeEntitiesUsingDom_(a):goog.string.unescapePureXmlEntities_(a):a};
	goog.string.unescapeEntitiesWithDocument=function(a,b){return goog.string.contains(a,"&")?goog.string.unescapeEntitiesUsingDom_(a,b):a};
	goog.string.unescapeEntitiesUsingDom_=function(a,b){var c={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"'};var d=b?b.createElement("div"):goog.global.document.createElement("div");return a.replace(goog.string.HTML_ENTITY_PATTERN_,function(a,b){var e=c[a];if(e)return e;"#"==b.charAt(0)&&(b=Number("0"+b.substr(1)),isNaN(b)||(e=String.fromCharCode(b)));e||(goog.dom.safe.setInnerHtml(d,goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Single HTML entity."),
	a+" ")),e=d.firstChild.nodeValue.slice(0,-1));return c[a]=e})};goog.string.unescapePureXmlEntities_=function(a){return a.replace(/&([^;]+);/g,function(a,c){switch(c){case "amp":return "&";case "lt":return "<";case "gt":return ">";case "quot":return '"';default:return "#"!=c.charAt(0)||(c=Number("0"+c.substr(1)),isNaN(c))?a:String.fromCharCode(c)}})};goog.string.HTML_ENTITY_PATTERN_=/&([^;\s<&]+);?/g;goog.string.whitespaceEscape=function(a,b){return goog.string.newLineToBr(a.replace(/  /g," &#160;"),b)};
	goog.string.preserveSpaces=function(a){return a.replace(/(^|[\n ]) /g,"$1"+goog.string.Unicode.NBSP)};goog.string.stripQuotes=function(a,b){for(var c=b.length,d=0;d<c;d++){var e=1==c?b:b.charAt(d);if(a.charAt(0)==e&&a.charAt(a.length-1)==e)return a.substring(1,a.length-1)}return a};goog.string.truncate=function(a,b,c){c&&(a=goog.string.unescapeEntities(a));a.length>b&&(a=a.substring(0,b-3)+"...");c&&(a=goog.string.htmlEscape(a));return a};
	goog.string.truncateMiddle=function(a,b,c,d){c&&(a=goog.string.unescapeEntities(a));if(d&&a.length>b){d>b&&(d=b);var e=a.length-d;a=a.substring(0,b-d)+"..."+a.substring(e);}else a.length>b&&(d=Math.floor(b/2),e=a.length-d,a=a.substring(0,d+b%2)+"..."+a.substring(e));c&&(a=goog.string.htmlEscape(a));return a};goog.string.specialEscapeChars_={"\x00":"\\0","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\x0B",'"':'\\"',"\\":"\\\\","<":"\\u003C"};goog.string.jsEscapeCache_={"'":"\\'"};
	goog.string.quote=function(a){a=String(a);for(var b=['"'],c=0;c<a.length;c++){var d=a.charAt(c),e=d.charCodeAt(0);b[c+1]=goog.string.specialEscapeChars_[d]||(31<e&&127>e?d:goog.string.escapeChar(d));}b.push('"');return b.join("")};goog.string.escapeString=function(a){for(var b=[],c=0;c<a.length;c++)b[c]=goog.string.escapeChar(a.charAt(c));return b.join("")};
	goog.string.escapeChar=function(a){if(a in goog.string.jsEscapeCache_)return goog.string.jsEscapeCache_[a];if(a in goog.string.specialEscapeChars_)return goog.string.jsEscapeCache_[a]=goog.string.specialEscapeChars_[a];var b=a.charCodeAt(0);if(31<b&&127>b)var c=a;else {if(256>b){if(c="\\x",16>b||256<b)c+="0";}else c="\\u",4096>b&&(c+="0");c+=b.toString(16).toUpperCase();}return goog.string.jsEscapeCache_[a]=c};goog.string.contains=goog.string.internal.contains;goog.string.caseInsensitiveContains=goog.string.internal.caseInsensitiveContains;
	goog.string.countOf=function(a,b){return a&&b?a.split(b).length-1:0};goog.string.removeAt=function(a,b,c){var d=a;0<=b&&b<a.length&&0<c&&(d=a.substr(0,b)+a.substr(b+c,a.length-b-c));return d};goog.string.remove=function(a,b){return a.replace(b,"")};goog.string.removeAll=function(a,b){b=new RegExp(goog.string.regExpEscape(b),"g");return a.replace(b,"")};goog.string.replaceAll=function(a,b,c){b=new RegExp(goog.string.regExpEscape(b),"g");return a.replace(b,c.replace(/\$/g,"$$$$"))};
	goog.string.regExpEscape=function(a){return String(a).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")};goog.string.repeat=String.prototype.repeat?function(a,b){return a.repeat(b)}:function(a,b){return Array(b+1).join(a)};goog.string.padNumber=function(a,b,c){a=goog.isDef(c)?a.toFixed(c):String(a);c=a.indexOf(".");-1==c&&(c=a.length);return goog.string.repeat("0",Math.max(0,b-c))+a};goog.string.makeSafe=function(a){return null==a?"":String(a)};
	goog.string.buildString=function(a){return Array.prototype.join.call(arguments,"")};goog.string.getRandomString=function(){return Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^goog.now()).toString(36)};goog.string.compareVersions=goog.string.internal.compareVersions;goog.string.hashCode=function(a){for(var b=0,c=0;c<a.length;++c)b=31*b+a.charCodeAt(c)>>>0;return b};goog.string.uniqueStringCounter_=2147483648*Math.random()|0;
	goog.string.createUniqueString=function(){return "goog_"+goog.string.uniqueStringCounter_++};goog.string.toNumber=function(a){var b=Number(a);return 0==b&&goog.string.isEmptyOrWhitespace(a)?NaN:b};goog.string.isLowerCamelCase=function(a){return /^[a-z]+([A-Z][a-z]*)*$/.test(a)};goog.string.isUpperCamelCase=function(a){return /^([A-Z][a-z]*)+$/.test(a)};goog.string.toCamelCase=function(a){return String(a).replace(/\-([a-z])/g,function(a,c){return c.toUpperCase()})};
	goog.string.toSelectorCase=function(a){return String(a).replace(/([A-Z])/g,"-$1").toLowerCase()};goog.string.toTitleCase=function(a,b){b=goog.isString(b)?goog.string.regExpEscape(b):"\\s";return a.replace(new RegExp("(^"+(b?"|["+b+"]+":"")+")([a-z])","g"),function(a,b,e){return b+e.toUpperCase()})};goog.string.capitalize=function(a){return String(a.charAt(0)).toUpperCase()+String(a.substr(1)).toLowerCase()};
	goog.string.parseInt=function(a){isFinite(a)&&(a=String(a));return goog.isString(a)?/^\s*-?0x/i.test(a)?parseInt(a,16):parseInt(a,10):NaN};goog.string.splitLimit=function(a,b,c){a=a.split(b);for(var d=[];0<c&&a.length;)d.push(a.shift()),c--;a.length&&d.push(a.join(b));return d};goog.string.lastComponent=function(a,b){if(b)"string"==typeof b&&(b=[b]);else return a;for(var c=-1,d=0;d<b.length;d++)if(""!=b[d]){var e=a.lastIndexOf(b[d]);e>c&&(c=e);}return -1==c?a:a.slice(c+1)};
	goog.string.editDistance=function(a,b){var c=[],d=[];if(a==b)return 0;if(!a.length||!b.length)return Math.max(a.length,b.length);for(var e=0;e<b.length+1;e++)c[e]=e;for(e=0;e<a.length;e++){d[0]=e+1;for(var f=0;f<b.length;f++)d[f+1]=Math.min(d[f]+1,c[f+1]+1,c[f]+Number(a[e]!=b[f]));for(f=0;f<c.length;f++)c[f]=d[f];}return d[b.length]};goog.labs.userAgent.platform={};goog.labs.userAgent.platform.isAndroid=function(){return goog.labs.userAgent.util.matchUserAgent("Android")};goog.labs.userAgent.platform.isIpod=function(){return goog.labs.userAgent.util.matchUserAgent("iPod")};goog.labs.userAgent.platform.isIphone=function(){return goog.labs.userAgent.util.matchUserAgent("iPhone")&&!goog.labs.userAgent.util.matchUserAgent("iPod")&&!goog.labs.userAgent.util.matchUserAgent("iPad")};goog.labs.userAgent.platform.isIpad=function(){return goog.labs.userAgent.util.matchUserAgent("iPad")};
	goog.labs.userAgent.platform.isIos=function(){return goog.labs.userAgent.platform.isIphone()||goog.labs.userAgent.platform.isIpad()||goog.labs.userAgent.platform.isIpod()};goog.labs.userAgent.platform.isMacintosh=function(){return goog.labs.userAgent.util.matchUserAgent("Macintosh")};goog.labs.userAgent.platform.isLinux=function(){return goog.labs.userAgent.util.matchUserAgent("Linux")};goog.labs.userAgent.platform.isWindows=function(){return goog.labs.userAgent.util.matchUserAgent("Windows")};
	goog.labs.userAgent.platform.isChromeOS=function(){return goog.labs.userAgent.util.matchUserAgent("CrOS")};goog.labs.userAgent.platform.isChromecast=function(){return goog.labs.userAgent.util.matchUserAgent("CrKey")};goog.labs.userAgent.platform.isKaiOS=function(){return goog.labs.userAgent.util.matchUserAgentIgnoreCase("KaiOS")};goog.labs.userAgent.platform.isGo2Phone=function(){return goog.labs.userAgent.util.matchUserAgentIgnoreCase("GAFP")};
	goog.labs.userAgent.platform.getVersion=function(){var a=goog.labs.userAgent.util.getUserAgent(),b="";goog.labs.userAgent.platform.isWindows()?(b=/Windows (?:NT|Phone) ([0-9.]+)/,b=(a=b.exec(a))?a[1]:"0.0"):goog.labs.userAgent.platform.isIos()?(b=/(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/,b=(a=b.exec(a))&&a[1].replace(/_/g,".")):goog.labs.userAgent.platform.isMacintosh()?(b=/Mac OS X ([0-9_.]+)/,b=(a=b.exec(a))?a[1].replace(/_/g,"."):"10"):goog.labs.userAgent.platform.isKaiOS()?(b=/(?:KaiOS)\/(\S+)/i,
	b=(a=b.exec(a))&&a[1]):goog.labs.userAgent.platform.isAndroid()?(b=/Android\s+([^\);]+)(\)|;)/,b=(a=b.exec(a))&&a[1]):goog.labs.userAgent.platform.isChromeOS()&&(b=/(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/,b=(a=b.exec(a))&&a[1]);return b||""};goog.labs.userAgent.platform.isVersionOrHigher=function(a){return 0<=goog.string.compareVersions(goog.labs.userAgent.platform.getVersion(),a)};goog.reflect={};goog.reflect.object=function(a,b){return b};goog.reflect.objectProperty=function(a,b){return a};goog.reflect.sinkValue=function(a){goog.reflect.sinkValue[" "](a);return a};goog.reflect.sinkValue[" "]=goog.nullFunction;goog.reflect.canAccessProperty=function(a,b){try{return goog.reflect.sinkValue(a[b]),!0}catch(c){}return !1};goog.reflect.cache=function(a,b,c,d){d=d?d(b):b;return Object.prototype.hasOwnProperty.call(a,d)?a[d]:a[d]=c(b)};goog.labs.userAgent.engine={};goog.labs.userAgent.engine.isPresto=function(){return goog.labs.userAgent.util.matchUserAgent("Presto")};goog.labs.userAgent.engine.isTrident=function(){return goog.labs.userAgent.util.matchUserAgent("Trident")||goog.labs.userAgent.util.matchUserAgent("MSIE")};goog.labs.userAgent.engine.isEdge=function(){return goog.labs.userAgent.util.matchUserAgent("Edge")};
	goog.labs.userAgent.engine.isWebKit=function(){return goog.labs.userAgent.util.matchUserAgentIgnoreCase("WebKit")&&!goog.labs.userAgent.engine.isEdge()};goog.labs.userAgent.engine.isGecko=function(){return goog.labs.userAgent.util.matchUserAgent("Gecko")&&!goog.labs.userAgent.engine.isWebKit()&&!goog.labs.userAgent.engine.isTrident()&&!goog.labs.userAgent.engine.isEdge()};
	goog.labs.userAgent.engine.getVersion=function(){var a=goog.labs.userAgent.util.getUserAgent();if(a){a=goog.labs.userAgent.util.extractVersionTuples(a);var b=goog.labs.userAgent.engine.getEngineTuple_(a);if(b)return "Gecko"==b[0]?goog.labs.userAgent.engine.getVersionForKey_(a,"Firefox"):b[1];a=a[0];var c;if(a&&(c=a[2])&&(c=/Trident\/([^\s;]+)/.exec(c)))return c[1]}return ""};
	goog.labs.userAgent.engine.getEngineTuple_=function(a){if(!goog.labs.userAgent.engine.isEdge())return a[1];for(var b=0;b<a.length;b++){var c=a[b];if("Edge"==c[0])return c}};goog.labs.userAgent.engine.isVersionOrHigher=function(a){return 0<=goog.string.compareVersions(goog.labs.userAgent.engine.getVersion(),a)};goog.labs.userAgent.engine.getVersionForKey_=function(a,b){return (a=goog.array.find(a,function(a){return b==a[0]}))&&a[1]||""};goog.userAgent={};goog.userAgent.ASSUME_IE=!1;goog.userAgent.ASSUME_EDGE=!1;goog.userAgent.ASSUME_GECKO=!1;goog.userAgent.ASSUME_WEBKIT=!1;goog.userAgent.ASSUME_MOBILE_WEBKIT=!1;goog.userAgent.ASSUME_OPERA=!1;goog.userAgent.ASSUME_ANY_VERSION=!1;goog.userAgent.BROWSER_KNOWN_=goog.userAgent.ASSUME_IE||goog.userAgent.ASSUME_EDGE||goog.userAgent.ASSUME_GECKO||goog.userAgent.ASSUME_MOBILE_WEBKIT||goog.userAgent.ASSUME_WEBKIT||goog.userAgent.ASSUME_OPERA;goog.userAgent.getUserAgentString=function(){return goog.labs.userAgent.util.getUserAgent()};
	goog.userAgent.getNavigatorTyped=function(){return goog.global.navigator||null};goog.userAgent.getNavigator=function(){return goog.userAgent.getNavigatorTyped()};goog.userAgent.OPERA=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_OPERA:goog.labs.userAgent.browser.isOpera();goog.userAgent.IE=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_IE:goog.labs.userAgent.browser.isIE();goog.userAgent.EDGE=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_EDGE:goog.labs.userAgent.engine.isEdge();
	goog.userAgent.EDGE_OR_IE=goog.userAgent.EDGE||goog.userAgent.IE;goog.userAgent.GECKO=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_GECKO:goog.labs.userAgent.engine.isGecko();goog.userAgent.WEBKIT=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_WEBKIT||goog.userAgent.ASSUME_MOBILE_WEBKIT:goog.labs.userAgent.engine.isWebKit();goog.userAgent.isMobile_=function(){return goog.userAgent.WEBKIT&&goog.labs.userAgent.util.matchUserAgent("Mobile")};
	goog.userAgent.MOBILE=goog.userAgent.ASSUME_MOBILE_WEBKIT||goog.userAgent.isMobile_();goog.userAgent.SAFARI=goog.userAgent.WEBKIT;goog.userAgent.determinePlatform_=function(){var a=goog.userAgent.getNavigatorTyped();return a&&a.platform||""};goog.userAgent.PLATFORM=goog.userAgent.determinePlatform_();goog.userAgent.ASSUME_MAC=!1;goog.userAgent.ASSUME_WINDOWS=!1;goog.userAgent.ASSUME_LINUX=!1;goog.userAgent.ASSUME_X11=!1;goog.userAgent.ASSUME_ANDROID=!1;goog.userAgent.ASSUME_IPHONE=!1;
	goog.userAgent.ASSUME_IPAD=!1;goog.userAgent.ASSUME_IPOD=!1;goog.userAgent.ASSUME_KAIOS=!1;goog.userAgent.ASSUME_GO2PHONE=!1;goog.userAgent.PLATFORM_KNOWN_=goog.userAgent.ASSUME_MAC||goog.userAgent.ASSUME_WINDOWS||goog.userAgent.ASSUME_LINUX||goog.userAgent.ASSUME_X11||goog.userAgent.ASSUME_ANDROID||goog.userAgent.ASSUME_IPHONE||goog.userAgent.ASSUME_IPAD||goog.userAgent.ASSUME_IPOD;goog.userAgent.MAC=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_MAC:goog.labs.userAgent.platform.isMacintosh();
	goog.userAgent.WINDOWS=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_WINDOWS:goog.labs.userAgent.platform.isWindows();goog.userAgent.isLegacyLinux_=function(){return goog.labs.userAgent.platform.isLinux()||goog.labs.userAgent.platform.isChromeOS()};goog.userAgent.LINUX=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_LINUX:goog.userAgent.isLegacyLinux_();goog.userAgent.isX11_=function(){var a=goog.userAgent.getNavigatorTyped();return !!a&&goog.string.contains(a.appVersion||"","X11")};
	goog.userAgent.X11=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_X11:goog.userAgent.isX11_();goog.userAgent.ANDROID=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_ANDROID:goog.labs.userAgent.platform.isAndroid();goog.userAgent.IPHONE=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPHONE:goog.labs.userAgent.platform.isIphone();goog.userAgent.IPAD=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPAD:goog.labs.userAgent.platform.isIpad();
	goog.userAgent.IPOD=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPOD:goog.labs.userAgent.platform.isIpod();goog.userAgent.IOS=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPHONE||goog.userAgent.ASSUME_IPAD||goog.userAgent.ASSUME_IPOD:goog.labs.userAgent.platform.isIos();goog.userAgent.KAIOS=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_KAIOS:goog.labs.userAgent.platform.isKaiOS();goog.userAgent.GO2PHONE=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_GO2PHONE:goog.labs.userAgent.platform.isGo2Phone();
	goog.userAgent.determineVersion_=function(){var a="",b=goog.userAgent.getVersionRegexResult_();b&&(a=b?b[1]:"");return goog.userAgent.IE&&(b=goog.userAgent.getDocumentMode_(),null!=b&&b>parseFloat(a))?String(b):a};
	goog.userAgent.getVersionRegexResult_=function(){var a=goog.userAgent.getUserAgentString();if(goog.userAgent.GECKO)return /rv:([^\);]+)(\)|;)/.exec(a);if(goog.userAgent.EDGE)return /Edge\/([\d\.]+)/.exec(a);if(goog.userAgent.IE)return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(goog.userAgent.WEBKIT)return /WebKit\/(\S+)/.exec(a);if(goog.userAgent.OPERA)return /(?:Version)[ \/]?(\S+)/.exec(a)};goog.userAgent.getDocumentMode_=function(){var a=goog.global.document;return a?a.documentMode:void 0};
	goog.userAgent.VERSION=goog.userAgent.determineVersion_();goog.userAgent.compare=function(a,b){return goog.string.compareVersions(a,b)};goog.userAgent.isVersionOrHigherCache_={};goog.userAgent.isVersionOrHigher=function(a){return goog.userAgent.ASSUME_ANY_VERSION||goog.reflect.cache(goog.userAgent.isVersionOrHigherCache_,a,function(){return 0<=goog.string.compareVersions(goog.userAgent.VERSION,a)})};goog.userAgent.isVersion=goog.userAgent.isVersionOrHigher;
	goog.userAgent.isDocumentModeOrHigher=function(a){return Number(goog.userAgent.DOCUMENT_MODE)>=a};goog.userAgent.isDocumentMode=goog.userAgent.isDocumentModeOrHigher;goog.userAgent.DOCUMENT_MODE=function(){if(goog.global.document&&goog.userAgent.IE)return goog.userAgent.getDocumentMode_()}();goog.userAgent.product={};goog.userAgent.product.ASSUME_FIREFOX=!1;goog.userAgent.product.ASSUME_IPHONE=!1;goog.userAgent.product.ASSUME_IPAD=!1;goog.userAgent.product.ASSUME_ANDROID=!1;goog.userAgent.product.ASSUME_CHROME=!1;goog.userAgent.product.ASSUME_SAFARI=!1;
	goog.userAgent.product.PRODUCT_KNOWN_=goog.userAgent.ASSUME_IE||goog.userAgent.ASSUME_EDGE||goog.userAgent.ASSUME_OPERA||goog.userAgent.product.ASSUME_FIREFOX||goog.userAgent.product.ASSUME_IPHONE||goog.userAgent.product.ASSUME_IPAD||goog.userAgent.product.ASSUME_ANDROID||goog.userAgent.product.ASSUME_CHROME||goog.userAgent.product.ASSUME_SAFARI;goog.userAgent.product.OPERA=goog.userAgent.OPERA;goog.userAgent.product.IE=goog.userAgent.IE;goog.userAgent.product.EDGE=goog.userAgent.EDGE;
	goog.userAgent.product.FIREFOX=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_FIREFOX:goog.labs.userAgent.browser.isFirefox();goog.userAgent.product.isIphoneOrIpod_=function(){return goog.labs.userAgent.platform.isIphone()||goog.labs.userAgent.platform.isIpod()};goog.userAgent.product.IPHONE=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_IPHONE:goog.userAgent.product.isIphoneOrIpod_();
	goog.userAgent.product.IPAD=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_IPAD:goog.labs.userAgent.platform.isIpad();goog.userAgent.product.ANDROID=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_ANDROID:goog.labs.userAgent.browser.isAndroidBrowser();goog.userAgent.product.CHROME=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_CHROME:goog.labs.userAgent.browser.isChrome();
	goog.userAgent.product.isSafariDesktop_=function(){return goog.labs.userAgent.browser.isSafari()&&!goog.labs.userAgent.platform.isIos()};goog.userAgent.product.SAFARI=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_SAFARI:goog.userAgent.product.isSafariDesktop_();goog.crypt.base64={};goog.crypt.base64.DEFAULT_ALPHABET_COMMON_="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";goog.crypt.base64.ENCODED_VALS=goog.crypt.base64.DEFAULT_ALPHABET_COMMON_+"+/=";goog.crypt.base64.ENCODED_VALS_WEBSAFE=goog.crypt.base64.DEFAULT_ALPHABET_COMMON_+"-_.";goog.crypt.base64.Alphabet={DEFAULT:0,NO_PADDING:1,WEBSAFE:2,WEBSAFE_DOT_PADDING:3,WEBSAFE_NO_PADDING:4};goog.crypt.base64.paddingChars_="=.";
	goog.crypt.base64.isPadding_=function(a){return goog.string.contains(goog.crypt.base64.paddingChars_,a)};goog.crypt.base64.byteToCharMaps_={};goog.crypt.base64.charToByteMap_=null;goog.crypt.base64.ASSUME_NATIVE_SUPPORT_=goog.userAgent.GECKO||goog.userAgent.WEBKIT&&!goog.userAgent.product.SAFARI||goog.userAgent.OPERA;goog.crypt.base64.HAS_NATIVE_ENCODE_=goog.crypt.base64.ASSUME_NATIVE_SUPPORT_||"function"==typeof goog.global.btoa;
	goog.crypt.base64.HAS_NATIVE_DECODE_=goog.crypt.base64.ASSUME_NATIVE_SUPPORT_||!goog.userAgent.product.SAFARI&&!goog.userAgent.IE&&"function"==typeof goog.global.atob;
	goog.crypt.base64.encodeByteArray=function(a,b){goog.asserts.assert(goog.isArrayLike(a),"encodeByteArray takes an array as a parameter");void 0===b&&(b=goog.crypt.base64.Alphabet.DEFAULT);goog.crypt.base64.init_();b=goog.crypt.base64.byteToCharMaps_[b];for(var c=[],d=0;d<a.length;d+=3){var e=a[d],f=d+1<a.length,g=f?a[d+1]:0,h=d+2<a.length,k=h?a[d+2]:0,l=e>>2;e=(e&3)<<4|g>>4;g=(g&15)<<2|k>>6;k&=63;h||(k=64,f||(g=64));c.push(b[l],b[e],b[g]||"",b[k]||"");}return c.join("")};
	goog.crypt.base64.encodeString=function(a,b){return goog.crypt.base64.HAS_NATIVE_ENCODE_&&!b?goog.global.btoa(a):goog.crypt.base64.encodeByteArray(goog.crypt.stringToByteArray(a),b)};goog.crypt.base64.decodeString=function(a,b){if(goog.crypt.base64.HAS_NATIVE_DECODE_&&!b)return goog.global.atob(a);var c="";goog.crypt.base64.decodeStringInternal_(a,function(a){c+=String.fromCharCode(a);});return c};
	goog.crypt.base64.decodeStringToByteArray=function(a,b){var c=[];goog.crypt.base64.decodeStringInternal_(a,function(a){c.push(a);});return c};
	goog.crypt.base64.decodeStringToUint8Array=function(a){goog.asserts.assert(!goog.userAgent.IE||goog.userAgent.isVersionOrHigher("10"),"Browser does not support typed arrays");var b=a.length,c=3*b/4;c%3?c=Math.floor(c):goog.crypt.base64.isPadding_(a[b-1])&&(c=goog.crypt.base64.isPadding_(a[b-2])?c-2:c-1);var d=new Uint8Array(c),e=0;goog.crypt.base64.decodeStringInternal_(a,function(a){d[e++]=a;});return d.subarray(0,e)};
	goog.crypt.base64.decodeStringInternal_=function(a,b){function c(b){for(;d<a.length;){var c=a.charAt(d++),e=goog.crypt.base64.charToByteMap_[c];if(null!=e)return e;if(!goog.string.isEmptyOrWhitespace(c))throw Error("Unknown base64 encoding at char: "+c);}return b}goog.crypt.base64.init_();for(var d=0;;){var e=c(-1),f=c(0),g=c(64),h=c(64);if(64===h&&-1===e)break;b(e<<2|f>>4);64!=g&&(b(f<<4&240|g>>2),64!=h&&b(g<<6&192|h));}};
	goog.crypt.base64.init_=function(){if(!goog.crypt.base64.charToByteMap_){goog.crypt.base64.charToByteMap_={};for(var a=goog.crypt.base64.DEFAULT_ALPHABET_COMMON_.split(""),b=["+/=","+/","-_=","-_.","-_"],c=0;5>c;c++){var d=a.concat(b[c].split(""));goog.crypt.base64.byteToCharMaps_[c]=d;for(var e=0;e<d.length;e++){var f=d[e],g=goog.crypt.base64.charToByteMap_[f];void 0===g?goog.crypt.base64.charToByteMap_[f]=e:goog.asserts.assert(g===e);}}}};jspb.utils={};jspb.utils.split64Low=0;jspb.utils.split64High=0;jspb.utils.splitUint64=function(a){var b=a>>>0;a=Math.floor((a-b)/jspb.BinaryConstants.TWO_TO_32)>>>0;jspb.utils.split64Low=b;jspb.utils.split64High=a;};jspb.utils.splitInt64=function(a){var b=0>a;a=Math.abs(a);var c=a>>>0;a=Math.floor((a-c)/jspb.BinaryConstants.TWO_TO_32);a>>>=0;b&&(a=~a>>>0,c=(~c>>>0)+1,4294967295<c&&(c=0,a++,4294967295<a&&(a=0)));jspb.utils.split64Low=c;jspb.utils.split64High=a;};
	jspb.utils.splitZigzag64=function(a){var b=0>a;a=2*Math.abs(a);jspb.utils.splitUint64(a);a=jspb.utils.split64Low;var c=jspb.utils.split64High;b&&(0==a?0==c?c=a=4294967295:(c--,a=4294967295):a--);jspb.utils.split64Low=a;jspb.utils.split64High=c;};
	jspb.utils.splitFloat32=function(a){var b=0>a?1:0;a=b?-a:a;if(0===a)0<1/a?(jspb.utils.split64High=0,jspb.utils.split64Low=0):(jspb.utils.split64High=0,jspb.utils.split64Low=2147483648);else if(isNaN(a))jspb.utils.split64High=0,jspb.utils.split64Low=2147483647;else if(a>jspb.BinaryConstants.FLOAT32_MAX)jspb.utils.split64High=0,jspb.utils.split64Low=(b<<31|2139095040)>>>0;else if(a<jspb.BinaryConstants.FLOAT32_MIN)a=Math.round(a/Math.pow(2,-149)),jspb.utils.split64High=0,jspb.utils.split64Low=(b<<31|
	a)>>>0;else {var c=Math.floor(Math.log(a)/Math.LN2);a*=Math.pow(2,-c);a=Math.round(a*jspb.BinaryConstants.TWO_TO_23)&8388607;jspb.utils.split64High=0;jspb.utils.split64Low=(b<<31|c+127<<23|a)>>>0;}};
	jspb.utils.splitFloat64=function(a){var b=0>a?1:0;a=b?-a:a;if(0===a)jspb.utils.split64High=0<1/a?0:2147483648,jspb.utils.split64Low=0;else if(isNaN(a))jspb.utils.split64High=2147483647,jspb.utils.split64Low=4294967295;else if(a>jspb.BinaryConstants.FLOAT64_MAX)jspb.utils.split64High=(b<<31|2146435072)>>>0,jspb.utils.split64Low=0;else if(a<jspb.BinaryConstants.FLOAT64_MIN){var c=a/Math.pow(2,-1074);a=c/jspb.BinaryConstants.TWO_TO_32;jspb.utils.split64High=(b<<31|a)>>>0;jspb.utils.split64Low=c>>>0;}else {var d=
	Math.floor(Math.log(a)/Math.LN2);1024==d&&(d=1023);c=a*Math.pow(2,-d);a=c*jspb.BinaryConstants.TWO_TO_20&1048575;c=c*jspb.BinaryConstants.TWO_TO_52>>>0;jspb.utils.split64High=(b<<31|d+1023<<20|a)>>>0;jspb.utils.split64Low=c;}};
	jspb.utils.splitHash64=function(a){var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=a.charCodeAt(4),g=a.charCodeAt(5),h=a.charCodeAt(6);a=a.charCodeAt(7);jspb.utils.split64Low=b+(c<<8)+(d<<16)+(e<<24)>>>0;jspb.utils.split64High=f+(g<<8)+(h<<16)+(a<<24)>>>0;};jspb.utils.joinUint64=function(a,b){return b*jspb.BinaryConstants.TWO_TO_32+(a>>>0)};
	jspb.utils.joinInt64=function(a,b){var c=b&2147483648;c&&(a=~a+1>>>0,b=~b>>>0,0==a&&(b=b+1>>>0));a=jspb.utils.joinUint64(a,b);return c?-a:a};jspb.utils.toZigzag64=function(a,b,c){var d=b>>31;return c(a<<1^d,(b<<1|a>>>31)^d)};jspb.utils.joinZigzag64=function(a,b){return jspb.utils.fromZigzag64(a,b,jspb.utils.joinInt64)};jspb.utils.fromZigzag64=function(a,b,c){var d=-(a&1);return c((a>>>1|b<<31)^d,b>>>1^d)};
	jspb.utils.joinFloat32=function(a,b){b=2*(a>>31)+1;var c=a>>>23&255;a&=8388607;return 255==c?a?NaN:Infinity*b:0==c?b*Math.pow(2,-149)*a:b*Math.pow(2,c-150)*(a+Math.pow(2,23))};jspb.utils.joinFloat64=function(a,b){var c=2*(b>>31)+1,d=b>>>20&2047;a=jspb.BinaryConstants.TWO_TO_32*(b&1048575)+a;return 2047==d?a?NaN:Infinity*c:0==d?c*Math.pow(2,-1074)*a:c*Math.pow(2,d-1075)*(a+jspb.BinaryConstants.TWO_TO_52)};
	jspb.utils.joinHash64=function(a,b){return String.fromCharCode(a>>>0&255,a>>>8&255,a>>>16&255,a>>>24&255,b>>>0&255,b>>>8&255,b>>>16&255,b>>>24&255)};jspb.utils.DIGITS="0123456789abcdef".split("");jspb.utils.ZERO_CHAR_CODE_=48;jspb.utils.A_CHAR_CODE_=97;
	jspb.utils.joinUnsignedDecimalString=function(a,b){function c(a,b){a=a?String(a):"";return b?"0000000".slice(a.length)+a:a}if(2097151>=b)return ""+(jspb.BinaryConstants.TWO_TO_32*b+a);var d=(a>>>24|b<<8)>>>0&16777215;b=b>>16&65535;a=(a&16777215)+6777216*d+6710656*b;d+=8147497*b;b*=2;1E7<=a&&(d+=Math.floor(a/1E7),a%=1E7);1E7<=d&&(b+=Math.floor(d/1E7),d%=1E7);return c(b,0)+c(d,b)+c(a,1)};
	jspb.utils.joinSignedDecimalString=function(a,b){var c=b&2147483648;c&&(a=~a+1>>>0,b=~b+(0==a?1:0)>>>0);a=jspb.utils.joinUnsignedDecimalString(a,b);return c?"-"+a:a};jspb.utils.hash64ToDecimalString=function(a,b){jspb.utils.splitHash64(a);a=jspb.utils.split64Low;var c=jspb.utils.split64High;return b?jspb.utils.joinSignedDecimalString(a,c):jspb.utils.joinUnsignedDecimalString(a,c)};
	jspb.utils.hash64ArrayToDecimalStrings=function(a,b){for(var c=Array(a.length),d=0;d<a.length;d++)c[d]=jspb.utils.hash64ToDecimalString(a[d],b);return c};
	jspb.utils.decimalStringToHash64=function(a){function b(a,b){for(var c=0;8>c&&(1!==a||0<b);c++)b=a*e[c]+b,e[c]=b&255,b>>>=8;}function c(){for(var a=0;8>a;a++)e[a]=~e[a]&255;}goog.asserts.assert(0<a.length);var d=!1;"-"===a[0]&&(d=!0,a=a.slice(1));for(var e=[0,0,0,0,0,0,0,0],f=0;f<a.length;f++)b(10,a.charCodeAt(f)-jspb.utils.ZERO_CHAR_CODE_);d&&(c(),b(1,1));return goog.crypt.byteArrayToString(e)};jspb.utils.splitDecimalString=function(a){jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a));};
	jspb.utils.toHexDigit_=function(a){return String.fromCharCode(10>a?jspb.utils.ZERO_CHAR_CODE_+a:jspb.utils.A_CHAR_CODE_-10+a)};jspb.utils.fromHexCharCode_=function(a){return a>=jspb.utils.A_CHAR_CODE_?a-jspb.utils.A_CHAR_CODE_+10:a-jspb.utils.ZERO_CHAR_CODE_};jspb.utils.hash64ToHexString=function(a){var b=Array(18);b[0]="0";b[1]="x";for(var c=0;8>c;c++){var d=a.charCodeAt(7-c);b[2*c+2]=jspb.utils.toHexDigit_(d>>4);b[2*c+3]=jspb.utils.toHexDigit_(d&15);}return b.join("")};
	jspb.utils.hexStringToHash64=function(a){a=a.toLowerCase();goog.asserts.assert(18==a.length);goog.asserts.assert("0"==a[0]);goog.asserts.assert("x"==a[1]);for(var b="",c=0;8>c;c++){var d=jspb.utils.fromHexCharCode_(a.charCodeAt(2*c+2)),e=jspb.utils.fromHexCharCode_(a.charCodeAt(2*c+3));b=String.fromCharCode(16*d+e)+b;}return b};
	jspb.utils.hash64ToNumber=function(a,b){jspb.utils.splitHash64(a);a=jspb.utils.split64Low;var c=jspb.utils.split64High;return b?jspb.utils.joinInt64(a,c):jspb.utils.joinUint64(a,c)};jspb.utils.numberToHash64=function(a){jspb.utils.splitInt64(a);return jspb.utils.joinHash64(jspb.utils.split64Low,jspb.utils.split64High)};jspb.utils.countVarints=function(a,b,c){for(var d=0,e=b;e<c;e++)d+=a[e]>>7;return c-b-d};
	jspb.utils.countVarintFields=function(a,b,c,d){var e=0;d=8*d+jspb.BinaryConstants.WireType.VARINT;if(128>d)for(;b<c&&a[b++]==d;)for(e++;;){var f=a[b++];if(0==(f&128))break}else for(;b<c;){for(f=d;128<f;){if(a[b]!=(f&127|128))return e;b++;f>>=7;}if(a[b++]!=f)break;for(e++;f=a[b++],0!=(f&128););}return e};jspb.utils.countFixedFields_=function(a,b,c,d,e){var f=0;if(128>d)for(;b<c&&a[b++]==d;)f++,b+=e;else for(;b<c;){for(var g=d;128<g;){if(a[b++]!=(g&127|128))return f;g>>=7;}if(a[b++]!=g)break;f++;b+=e;}return f};
	jspb.utils.countFixed32Fields=function(a,b,c,d){return jspb.utils.countFixedFields_(a,b,c,8*d+jspb.BinaryConstants.WireType.FIXED32,4)};jspb.utils.countFixed64Fields=function(a,b,c,d){return jspb.utils.countFixedFields_(a,b,c,8*d+jspb.BinaryConstants.WireType.FIXED64,8)};
	jspb.utils.countDelimitedFields=function(a,b,c,d){var e=0;for(d=8*d+jspb.BinaryConstants.WireType.DELIMITED;b<c;){for(var f=d;128<f;){if(a[b++]!=(f&127|128))return e;f>>=7;}if(a[b++]!=f)break;e++;for(var g=0,h=1;f=a[b++],g+=(f&127)*h,h*=128,0!=(f&128););b+=g;}return e};jspb.utils.debugBytesToTextFormat=function(a){var b='"';if(a){a=jspb.utils.byteSourceToUint8Array(a);for(var c=0;c<a.length;c++)b+="\\x",16>a[c]&&(b+="0"),b+=a[c].toString(16);}return b+'"'};
	jspb.utils.debugScalarToTextFormat=function(a){return goog.isString(a)?goog.string.quote(a):a.toString()};jspb.utils.stringToByteArray=function(a){for(var b=new Uint8Array(a.length),c=0;c<a.length;c++){var d=a.charCodeAt(c);if(255<d)throw Error("Conversion error: string contains codepoint outside of byte range");b[c]=d;}return b};
	jspb.utils.byteSourceToUint8Array=function(a){if(a.constructor===Uint8Array)return a;if(a.constructor===ArrayBuffer||"undefined"!=typeof Buffer$1&&a.constructor===Buffer$1||a.constructor===Array)return new Uint8Array(a);if(a.constructor===String)return goog.crypt.base64.decodeStringToUint8Array(a);goog.asserts.fail("Type not convertible to Uint8Array.");return new Uint8Array(0)};jspb.BinaryDecoder=function(a,b,c){this.bytes_=null;this.cursor_=this.end_=this.start_=0;this.error_=!1;a&&this.setBlock(a,b,c);};jspb.BinaryDecoder.instanceCache_=[];jspb.BinaryDecoder.alloc=function(a,b,c){if(jspb.BinaryDecoder.instanceCache_.length){var d=jspb.BinaryDecoder.instanceCache_.pop();a&&d.setBlock(a,b,c);return d}return new jspb.BinaryDecoder(a,b,c)};jspb.BinaryDecoder.prototype.free=function(){this.clear();100>jspb.BinaryDecoder.instanceCache_.length&&jspb.BinaryDecoder.instanceCache_.push(this);};
	jspb.BinaryDecoder.prototype.clone=function(){return jspb.BinaryDecoder.alloc(this.bytes_,this.start_,this.end_-this.start_)};jspb.BinaryDecoder.prototype.clear=function(){this.bytes_=null;this.cursor_=this.end_=this.start_=0;this.error_=!1;};jspb.BinaryDecoder.prototype.getBuffer=function(){return this.bytes_};
	jspb.BinaryDecoder.prototype.setBlock=function(a,b,c){this.bytes_=jspb.utils.byteSourceToUint8Array(a);this.start_=goog.isDef(b)?b:0;this.end_=goog.isDef(c)?this.start_+c:this.bytes_.length;this.cursor_=this.start_;};jspb.BinaryDecoder.prototype.getEnd=function(){return this.end_};jspb.BinaryDecoder.prototype.setEnd=function(a){this.end_=a;};jspb.BinaryDecoder.prototype.reset=function(){this.cursor_=this.start_;};jspb.BinaryDecoder.prototype.getCursor=function(){return this.cursor_};
	jspb.BinaryDecoder.prototype.setCursor=function(a){this.cursor_=a;};jspb.BinaryDecoder.prototype.advance=function(a){this.cursor_+=a;goog.asserts.assert(this.cursor_<=this.end_);};jspb.BinaryDecoder.prototype.atEnd=function(){return this.cursor_==this.end_};jspb.BinaryDecoder.prototype.pastEnd=function(){return this.cursor_>this.end_};jspb.BinaryDecoder.prototype.getError=function(){return this.error_||0>this.cursor_||this.cursor_>this.end_};
	jspb.BinaryDecoder.prototype.readSplitVarint64=function(a){for(var b=128,c=0,d=0,e=0;4>e&&128<=b;e++)b=this.bytes_[this.cursor_++],c|=(b&127)<<7*e;128<=b&&(b=this.bytes_[this.cursor_++],c|=(b&127)<<28,d|=(b&127)>>4);if(128<=b)for(e=0;5>e&&128<=b;e++)b=this.bytes_[this.cursor_++],d|=(b&127)<<7*e+3;if(128>b)return a(c>>>0,d>>>0);goog.asserts.fail("Failed to read varint, encoding is invalid.");this.error_=!0;};
	jspb.BinaryDecoder.prototype.readSplitZigzagVarint64=function(a){return this.readSplitVarint64(function(b,c){return jspb.utils.fromZigzag64(b,c,a)})};jspb.BinaryDecoder.prototype.readSplitFixed64=function(a){var b=this.bytes_,c=this.cursor_;this.cursor_+=8;for(var d=0,e=0,f=c+7;f>=c;f--)d=d<<8|b[f],e=e<<8|b[f+4];return a(d,e)};jspb.BinaryDecoder.prototype.skipVarint=function(){for(;this.bytes_[this.cursor_]&128;)this.cursor_++;this.cursor_++;};
	jspb.BinaryDecoder.prototype.unskipVarint=function(a){for(;128<a;)this.cursor_--,a>>>=7;this.cursor_--;};
	jspb.BinaryDecoder.prototype.readUnsignedVarint32=function(){var a=this.bytes_;var b=a[this.cursor_+0];var c=b&127;if(128>b)return this.cursor_+=1,goog.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+1];c|=(b&127)<<7;if(128>b)return this.cursor_+=2,goog.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+2];c|=(b&127)<<14;if(128>b)return this.cursor_+=3,goog.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+3];c|=(b&127)<<21;if(128>b)return this.cursor_+=4,goog.asserts.assert(this.cursor_<=
	this.end_),c;b=a[this.cursor_+4];c|=(b&15)<<28;if(128>b)return this.cursor_+=5,goog.asserts.assert(this.cursor_<=this.end_),c>>>0;this.cursor_+=5;128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&goog.asserts.assert(!1);goog.asserts.assert(this.cursor_<=this.end_);return c};jspb.BinaryDecoder.prototype.readSignedVarint32=jspb.BinaryDecoder.prototype.readUnsignedVarint32;jspb.BinaryDecoder.prototype.readUnsignedVarint32String=function(){return this.readUnsignedVarint32().toString()};
	jspb.BinaryDecoder.prototype.readSignedVarint32String=function(){return this.readSignedVarint32().toString()};jspb.BinaryDecoder.prototype.readZigzagVarint32=function(){var a=this.readUnsignedVarint32();return a>>>1^-(a&1)};jspb.BinaryDecoder.prototype.readUnsignedVarint64=function(){return this.readSplitVarint64(jspb.utils.joinUint64)};jspb.BinaryDecoder.prototype.readUnsignedVarint64String=function(){return this.readSplitVarint64(jspb.utils.joinUnsignedDecimalString)};
	jspb.BinaryDecoder.prototype.readSignedVarint64=function(){return this.readSplitVarint64(jspb.utils.joinInt64)};jspb.BinaryDecoder.prototype.readSignedVarint64String=function(){return this.readSplitVarint64(jspb.utils.joinSignedDecimalString)};jspb.BinaryDecoder.prototype.readZigzagVarint64=function(){return this.readSplitVarint64(jspb.utils.joinZigzag64)};jspb.BinaryDecoder.prototype.readZigzagVarintHash64=function(){return this.readSplitZigzagVarint64(jspb.utils.joinHash64)};
	jspb.BinaryDecoder.prototype.readZigzagVarint64String=function(){return this.readSplitZigzagVarint64(jspb.utils.joinSignedDecimalString)};jspb.BinaryDecoder.prototype.readUint8=function(){var a=this.bytes_[this.cursor_+0];this.cursor_+=1;goog.asserts.assert(this.cursor_<=this.end_);return a};jspb.BinaryDecoder.prototype.readUint16=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1];this.cursor_+=2;goog.asserts.assert(this.cursor_<=this.end_);return a<<0|b<<8};
	jspb.BinaryDecoder.prototype.readUint32=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1],c=this.bytes_[this.cursor_+2],d=this.bytes_[this.cursor_+3];this.cursor_+=4;goog.asserts.assert(this.cursor_<=this.end_);return (a<<0|b<<8|c<<16|d<<24)>>>0};jspb.BinaryDecoder.prototype.readUint64=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinUint64(a,b)};
	jspb.BinaryDecoder.prototype.readUint64String=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinUnsignedDecimalString(a,b)};jspb.BinaryDecoder.prototype.readInt8=function(){var a=this.bytes_[this.cursor_+0];this.cursor_+=1;goog.asserts.assert(this.cursor_<=this.end_);return a<<24>>24};
	jspb.BinaryDecoder.prototype.readInt16=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1];this.cursor_+=2;goog.asserts.assert(this.cursor_<=this.end_);return (a<<0|b<<8)<<16>>16};jspb.BinaryDecoder.prototype.readInt32=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1],c=this.bytes_[this.cursor_+2],d=this.bytes_[this.cursor_+3];this.cursor_+=4;goog.asserts.assert(this.cursor_<=this.end_);return a<<0|b<<8|c<<16|d<<24};
	jspb.BinaryDecoder.prototype.readInt64=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinInt64(a,b)};jspb.BinaryDecoder.prototype.readInt64String=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinSignedDecimalString(a,b)};jspb.BinaryDecoder.prototype.readFloat=function(){var a=this.readUint32();return jspb.utils.joinFloat32(a,0)};
	jspb.BinaryDecoder.prototype.readDouble=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinFloat64(a,b)};jspb.BinaryDecoder.prototype.readBool=function(){return !!this.bytes_[this.cursor_++]};jspb.BinaryDecoder.prototype.readEnum=function(){return this.readSignedVarint32()};
	jspb.BinaryDecoder.prototype.readString=function(a){var b=this.bytes_,c=this.cursor_;a=c+a;for(var d=[],e="";c<a;){var f=b[c++];if(128>f)d.push(f);else if(192>f)continue;else if(224>f){var g=b[c++];d.push((f&31)<<6|g&63);}else if(240>f){g=b[c++];var h=b[c++];d.push((f&15)<<12|(g&63)<<6|h&63);}else if(248>f){g=b[c++];h=b[c++];var k=b[c++];f=(f&7)<<18|(g&63)<<12|(h&63)<<6|k&63;f-=65536;d.push((f>>10&1023)+55296,(f&1023)+56320);}8192<=d.length&&(e+=String.fromCharCode.apply(null,d),d.length=0);}e+=goog.crypt.byteArrayToString(d);
	this.cursor_=c;return e};jspb.BinaryDecoder.prototype.readStringWithLength=function(){var a=this.readUnsignedVarint32();return this.readString(a)};jspb.BinaryDecoder.prototype.readBytes=function(a){if(0>a||this.cursor_+a>this.bytes_.length)return this.error_=!0,goog.asserts.fail("Invalid byte length!"),new Uint8Array(0);var b=this.bytes_.subarray(this.cursor_,this.cursor_+a);this.cursor_+=a;goog.asserts.assert(this.cursor_<=this.end_);return b};jspb.BinaryDecoder.prototype.readVarintHash64=function(){return this.readSplitVarint64(jspb.utils.joinHash64)};
	jspb.BinaryDecoder.prototype.readFixedHash64=function(){var a=this.bytes_,b=this.cursor_,c=a[b+0],d=a[b+1],e=a[b+2],f=a[b+3],g=a[b+4],h=a[b+5],k=a[b+6];a=a[b+7];this.cursor_+=8;return String.fromCharCode(c,d,e,f,g,h,k,a)};jspb.BinaryReader=function(a,b,c){this.decoder_=jspb.BinaryDecoder.alloc(a,b,c);this.fieldCursor_=this.decoder_.getCursor();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;this.error_=!1;this.readCallbacks_=null;};jspb.BinaryReader.instanceCache_=[];
	jspb.BinaryReader.alloc=function(a,b,c){if(jspb.BinaryReader.instanceCache_.length){var d=jspb.BinaryReader.instanceCache_.pop();a&&d.decoder_.setBlock(a,b,c);return d}return new jspb.BinaryReader(a,b,c)};jspb.BinaryReader.prototype.alloc=jspb.BinaryReader.alloc;
	jspb.BinaryReader.prototype.free=function(){this.decoder_.clear();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;this.error_=!1;this.readCallbacks_=null;100>jspb.BinaryReader.instanceCache_.length&&jspb.BinaryReader.instanceCache_.push(this);};jspb.BinaryReader.prototype.getFieldCursor=function(){return this.fieldCursor_};jspb.BinaryReader.prototype.getCursor=function(){return this.decoder_.getCursor()};
	jspb.BinaryReader.prototype.getBuffer=function(){return this.decoder_.getBuffer()};jspb.BinaryReader.prototype.getFieldNumber=function(){return this.nextField_};jspb.BinaryReader.prototype.getWireType=function(){return this.nextWireType_};jspb.BinaryReader.prototype.isEndGroup=function(){return this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP};jspb.BinaryReader.prototype.getError=function(){return this.error_||this.decoder_.getError()};
	jspb.BinaryReader.prototype.setBlock=function(a,b,c){this.decoder_.setBlock(a,b,c);this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;};jspb.BinaryReader.prototype.reset=function(){this.decoder_.reset();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;};jspb.BinaryReader.prototype.advance=function(a){this.decoder_.advance(a);};
	jspb.BinaryReader.prototype.nextField=function(){if(this.decoder_.atEnd())return !1;if(this.getError())return goog.asserts.fail("Decoder hit an error"),!1;this.fieldCursor_=this.decoder_.getCursor();var a=this.decoder_.readUnsignedVarint32(),b=a>>>3;a&=7;if(a!=jspb.BinaryConstants.WireType.VARINT&&a!=jspb.BinaryConstants.WireType.FIXED32&&a!=jspb.BinaryConstants.WireType.FIXED64&&a!=jspb.BinaryConstants.WireType.DELIMITED&&a!=jspb.BinaryConstants.WireType.START_GROUP&&a!=jspb.BinaryConstants.WireType.END_GROUP)return goog.asserts.fail("Invalid wire type: %s (at position %s)",
	a,this.fieldCursor_),this.error_=!0,!1;this.nextField_=b;this.nextWireType_=a;return !0};jspb.BinaryReader.prototype.unskipHeader=function(){this.decoder_.unskipVarint(this.nextField_<<3|this.nextWireType_);};jspb.BinaryReader.prototype.skipMatchingFields=function(){var a=this.nextField_;for(this.unskipHeader();this.nextField()&&this.getFieldNumber()==a;)this.skipField();this.decoder_.atEnd()||this.unskipHeader();};
	jspb.BinaryReader.prototype.skipVarintField=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.VARINT?(goog.asserts.fail("Invalid wire type for skipVarintField"),this.skipField()):this.decoder_.skipVarint();};jspb.BinaryReader.prototype.skipDelimitedField=function(){if(this.nextWireType_!=jspb.BinaryConstants.WireType.DELIMITED)goog.asserts.fail("Invalid wire type for skipDelimitedField"),this.skipField();else {var a=this.decoder_.readUnsignedVarint32();this.decoder_.advance(a);}};
	jspb.BinaryReader.prototype.skipFixed32Field=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.FIXED32?(goog.asserts.fail("Invalid wire type for skipFixed32Field"),this.skipField()):this.decoder_.advance(4);};jspb.BinaryReader.prototype.skipFixed64Field=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.FIXED64?(goog.asserts.fail("Invalid wire type for skipFixed64Field"),this.skipField()):this.decoder_.advance(8);};
	jspb.BinaryReader.prototype.skipGroup=function(){var a=this.nextField_;do{if(!this.nextField()){goog.asserts.fail("Unmatched start-group tag: stream EOF");this.error_=!0;break}if(this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP){this.nextField_!=a&&(goog.asserts.fail("Unmatched end-group tag"),this.error_=!0);break}this.skipField();}while(1)};
	jspb.BinaryReader.prototype.skipField=function(){switch(this.nextWireType_){case jspb.BinaryConstants.WireType.VARINT:this.skipVarintField();break;case jspb.BinaryConstants.WireType.FIXED64:this.skipFixed64Field();break;case jspb.BinaryConstants.WireType.DELIMITED:this.skipDelimitedField();break;case jspb.BinaryConstants.WireType.FIXED32:this.skipFixed32Field();break;case jspb.BinaryConstants.WireType.START_GROUP:this.skipGroup();break;default:goog.asserts.fail("Invalid wire encoding for field.");}};
	jspb.BinaryReader.prototype.registerReadCallback=function(a,b){goog.isNull(this.readCallbacks_)&&(this.readCallbacks_={});goog.asserts.assert(!this.readCallbacks_[a]);this.readCallbacks_[a]=b;};jspb.BinaryReader.prototype.runReadCallback=function(a){goog.asserts.assert(!goog.isNull(this.readCallbacks_));a=this.readCallbacks_[a];goog.asserts.assert(a);return a(this)};
	jspb.BinaryReader.prototype.readAny=function(a){this.nextWireType_=jspb.BinaryConstants.FieldTypeToWireType(a);var b=jspb.BinaryConstants.FieldType;switch(a){case b.DOUBLE:return this.readDouble();case b.FLOAT:return this.readFloat();case b.INT64:return this.readInt64();case b.UINT64:return this.readUint64();case b.INT32:return this.readInt32();case b.FIXED64:return this.readFixed64();case b.FIXED32:return this.readFixed32();case b.BOOL:return this.readBool();case b.STRING:return this.readString();
	case b.GROUP:goog.asserts.fail("Group field type not supported in readAny()");case b.MESSAGE:goog.asserts.fail("Message field type not supported in readAny()");case b.BYTES:return this.readBytes();case b.UINT32:return this.readUint32();case b.ENUM:return this.readEnum();case b.SFIXED32:return this.readSfixed32();case b.SFIXED64:return this.readSfixed64();case b.SINT32:return this.readSint32();case b.SINT64:return this.readSint64();case b.FHASH64:return this.readFixedHash64();case b.VHASH64:return this.readVarintHash64();
	default:goog.asserts.fail("Invalid field type in readAny()");}return 0};jspb.BinaryReader.prototype.readMessage=function(a,b){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var c=this.decoder_.getEnd(),d=this.decoder_.readUnsignedVarint32();d=this.decoder_.getCursor()+d;this.decoder_.setEnd(d);b(a,this);this.decoder_.setCursor(d);this.decoder_.setEnd(c);};
	jspb.BinaryReader.prototype.readGroup=function(a,b,c){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.START_GROUP);goog.asserts.assert(this.nextField_==a);c(b,this);this.error_||this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP||(goog.asserts.fail("Group submessage did not end with an END_GROUP tag"),this.error_=!0);};
	jspb.BinaryReader.prototype.getFieldDecoder=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32(),b=this.decoder_.getCursor(),c=b+a;a=jspb.BinaryDecoder.alloc(this.decoder_.getBuffer(),b,a);this.decoder_.setCursor(c);return a};jspb.BinaryReader.prototype.readInt32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint32()};
	jspb.BinaryReader.prototype.readInt32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint32String()};jspb.BinaryReader.prototype.readInt64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64()};jspb.BinaryReader.prototype.readInt64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64String()};
	jspb.BinaryReader.prototype.readUint32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint32()};jspb.BinaryReader.prototype.readUint32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint32String()};jspb.BinaryReader.prototype.readUint64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint64()};
	jspb.BinaryReader.prototype.readUint64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint64String()};jspb.BinaryReader.prototype.readSint32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint32()};jspb.BinaryReader.prototype.readSint64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint64()};
	jspb.BinaryReader.prototype.readSint64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint64String()};jspb.BinaryReader.prototype.readFixed32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readUint32()};jspb.BinaryReader.prototype.readFixed64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readUint64()};
	jspb.BinaryReader.prototype.readFixed64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readUint64String()};jspb.BinaryReader.prototype.readSfixed32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readInt32()};jspb.BinaryReader.prototype.readSfixed32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readInt32().toString()};
	jspb.BinaryReader.prototype.readSfixed64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readInt64()};jspb.BinaryReader.prototype.readSfixed64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readInt64String()};jspb.BinaryReader.prototype.readFloat=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readFloat()};
	jspb.BinaryReader.prototype.readDouble=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readDouble()};jspb.BinaryReader.prototype.readBool=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return !!this.decoder_.readUnsignedVarint32()};jspb.BinaryReader.prototype.readEnum=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64()};
	jspb.BinaryReader.prototype.readString=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32();return this.decoder_.readString(a)};jspb.BinaryReader.prototype.readBytes=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32();return this.decoder_.readBytes(a)};
	jspb.BinaryReader.prototype.readVarintHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readVarintHash64()};jspb.BinaryReader.prototype.readSintHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarintHash64()};jspb.BinaryReader.prototype.readSplitVarint64=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSplitVarint64(a)};
	jspb.BinaryReader.prototype.readSplitZigzagVarint64=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSplitVarint64(function(b,c){return jspb.utils.fromZigzag64(b,c,a)})};jspb.BinaryReader.prototype.readFixedHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readFixedHash64()};
	jspb.BinaryReader.prototype.readSplitFixed64=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readSplitFixed64(a)};jspb.BinaryReader.prototype.readPackedField_=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var b=this.decoder_.readUnsignedVarint32();b=this.decoder_.getCursor()+b;for(var c=[];this.decoder_.getCursor()<b;)c.push(a.call(this.decoder_));return c};
	jspb.BinaryReader.prototype.readPackedInt32=function(){return this.readPackedField_(this.decoder_.readSignedVarint32)};jspb.BinaryReader.prototype.readPackedInt32String=function(){return this.readPackedField_(this.decoder_.readSignedVarint32String)};jspb.BinaryReader.prototype.readPackedInt64=function(){return this.readPackedField_(this.decoder_.readSignedVarint64)};jspb.BinaryReader.prototype.readPackedInt64String=function(){return this.readPackedField_(this.decoder_.readSignedVarint64String)};
	jspb.BinaryReader.prototype.readPackedUint32=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint32)};jspb.BinaryReader.prototype.readPackedUint32String=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint32String)};jspb.BinaryReader.prototype.readPackedUint64=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint64)};jspb.BinaryReader.prototype.readPackedUint64String=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint64String)};
	jspb.BinaryReader.prototype.readPackedSint32=function(){return this.readPackedField_(this.decoder_.readZigzagVarint32)};jspb.BinaryReader.prototype.readPackedSint64=function(){return this.readPackedField_(this.decoder_.readZigzagVarint64)};jspb.BinaryReader.prototype.readPackedSint64String=function(){return this.readPackedField_(this.decoder_.readZigzagVarint64String)};jspb.BinaryReader.prototype.readPackedFixed32=function(){return this.readPackedField_(this.decoder_.readUint32)};
	jspb.BinaryReader.prototype.readPackedFixed64=function(){return this.readPackedField_(this.decoder_.readUint64)};jspb.BinaryReader.prototype.readPackedFixed64String=function(){return this.readPackedField_(this.decoder_.readUint64String)};jspb.BinaryReader.prototype.readPackedSfixed32=function(){return this.readPackedField_(this.decoder_.readInt32)};jspb.BinaryReader.prototype.readPackedSfixed64=function(){return this.readPackedField_(this.decoder_.readInt64)};
	jspb.BinaryReader.prototype.readPackedSfixed64String=function(){return this.readPackedField_(this.decoder_.readInt64String)};jspb.BinaryReader.prototype.readPackedFloat=function(){return this.readPackedField_(this.decoder_.readFloat)};jspb.BinaryReader.prototype.readPackedDouble=function(){return this.readPackedField_(this.decoder_.readDouble)};jspb.BinaryReader.prototype.readPackedBool=function(){return this.readPackedField_(this.decoder_.readBool)};jspb.BinaryReader.prototype.readPackedEnum=function(){return this.readPackedField_(this.decoder_.readEnum)};
	jspb.BinaryReader.prototype.readPackedVarintHash64=function(){return this.readPackedField_(this.decoder_.readVarintHash64)};jspb.BinaryReader.prototype.readPackedFixedHash64=function(){return this.readPackedField_(this.decoder_.readFixedHash64)};jspb.Map=function(a,b){this.arr_=a;this.valueCtor_=b;this.map_={};this.arrClean=!0;0<this.arr_.length&&this.loadFromArray_();};jspb.Map.prototype.loadFromArray_=function(){for(var a=0;a<this.arr_.length;a++){var b=this.arr_[a],c=b[0];this.map_[c.toString()]=new jspb.Map.Entry_(c,b[1]);}this.arrClean=!0;};
	jspb.Map.prototype.toArray=function(){if(this.arrClean){if(this.valueCtor_){var a=this.map_,b;for(b in a)if(Object.prototype.hasOwnProperty.call(a,b)){var c=a[b].valueWrapper;c&&c.toArray();}}}else {this.arr_.length=0;a=this.stringKeys_();a.sort();for(b=0;b<a.length;b++){var d=this.map_[a[b]];(c=d.valueWrapper)&&c.toArray();this.arr_.push([d.key,d.value]);}this.arrClean=!0;}return this.arr_};
	jspb.Map.prototype.toObject=function(a,b){for(var c=this.toArray(),d=[],e=0;e<c.length;e++){var f=this.map_[c[e][0].toString()];this.wrapEntry_(f);var g=f.valueWrapper;g?(goog.asserts.assert(b),d.push([f.key,b(a,g)])):d.push([f.key,f.value]);}return d};jspb.Map.fromObject=function(a,b,c){b=new jspb.Map([],b);for(var d=0;d<a.length;d++){var e=a[d][0],f=c(a[d][1]);b.set(e,f);}return b};jspb.Map.ArrayIteratorIterable_=function(a){this.idx_=0;this.arr_=a;};
	jspb.Map.ArrayIteratorIterable_.prototype.next=function(){return this.idx_<this.arr_.length?{done:!1,value:this.arr_[this.idx_++]}:{done:!0,value:void 0}};"undefined"!=typeof Symbol&&(jspb.Map.ArrayIteratorIterable_.prototype[Symbol.iterator]=function(){return this});jspb.Map.prototype.getLength=function(){return this.stringKeys_().length};jspb.Map.prototype.clear=function(){this.map_={};this.arrClean=!1;};
	jspb.Map.prototype.del=function(a){a=a.toString();var b=this.map_.hasOwnProperty(a);delete this.map_[a];this.arrClean=!1;return b};jspb.Map.prototype.getEntryList=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++){var d=this.map_[b[c]];a.push([d.key,d.value]);}return a};jspb.Map.prototype.entries=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++){var d=this.map_[b[c]];a.push([d.key,this.wrapEntry_(d)]);}return new jspb.Map.ArrayIteratorIterable_(a)};
	jspb.Map.prototype.keys=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++)a.push(this.map_[b[c]].key);return new jspb.Map.ArrayIteratorIterable_(a)};jspb.Map.prototype.values=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++)a.push(this.wrapEntry_(this.map_[b[c]]));return new jspb.Map.ArrayIteratorIterable_(a)};
	jspb.Map.prototype.forEach=function(a,b){var c=this.stringKeys_();c.sort();for(var d=0;d<c.length;d++){var e=this.map_[c[d]];a.call(b,this.wrapEntry_(e),e.key,this);}};jspb.Map.prototype.set=function(a,b){var c=new jspb.Map.Entry_(a);this.valueCtor_?(c.valueWrapper=b,c.value=b.toArray()):c.value=b;this.map_[a.toString()]=c;this.arrClean=!1;return this};jspb.Map.prototype.wrapEntry_=function(a){return this.valueCtor_?(a.valueWrapper||(a.valueWrapper=new this.valueCtor_(a.value)),a.valueWrapper):a.value};
	jspb.Map.prototype.get=function(a){if(a=this.map_[a.toString()])return this.wrapEntry_(a)};jspb.Map.prototype.has=function(a){return a.toString()in this.map_};jspb.Map.prototype.serializeBinary=function(a,b,c,d,e){var f=this.stringKeys_();f.sort();for(var g=0;g<f.length;g++){var h=this.map_[f[g]];b.beginSubMessage(a);c.call(b,1,h.key);this.valueCtor_?d.call(b,2,this.wrapEntry_(h),e):d.call(b,2,h.value);b.endSubMessage();}};
	jspb.Map.deserializeBinary=function(a,b,c,d,e,f,g){for(;b.nextField()&&!b.isEndGroup();){var h=b.getFieldNumber();1==h?f=c.call(b):2==h&&(a.valueCtor_?(goog.asserts.assert(e),g||(g=new a.valueCtor_),d.call(b,g,e)):g=d.call(b));}goog.asserts.assert(void 0!=f);goog.asserts.assert(void 0!=g);a.set(f,g);};jspb.Map.prototype.stringKeys_=function(){var a=this.map_,b=[],c;for(c in a)Object.prototype.hasOwnProperty.call(a,c)&&b.push(c);return b};
	jspb.Map.Entry_=function(a,b){this.key=a;this.value=b;this.valueWrapper=void 0;};jspb.ExtensionFieldInfo=function(a,b,c,d,e){this.fieldIndex=a;this.fieldName=b;this.ctor=c;this.toObjectFn=d;this.isRepeated=e;};jspb.ExtensionFieldBinaryInfo=function(a,b,c,d,e,f){this.fieldInfo=a;this.binaryReaderFn=b;this.binaryWriterFn=c;this.binaryMessageSerializeFn=d;this.binaryMessageDeserializeFn=e;this.isPacked=f;};jspb.ExtensionFieldInfo.prototype.isMessageType=function(){return !!this.ctor};jspb.Message=function(){};jspb.Message.GENERATE_TO_OBJECT=!0;jspb.Message.GENERATE_FROM_OBJECT=!goog.DISALLOW_TEST_ONLY_CODE;
	jspb.Message.GENERATE_TO_STRING=!0;jspb.Message.ASSUME_LOCAL_ARRAYS=!1;jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS=!0;jspb.Message.SUPPORTS_UINT8ARRAY_="function"==typeof Uint8Array;jspb.Message.prototype.getJsPbMessageId=function(){return this.messageId_};jspb.Message.getIndex_=function(a,b){return b+a.arrayIndexOffset_};jspb.Message.hiddenES6Property_=function(){};jspb.Message.getFieldNumber_=function(a,b){return b-a.arrayIndexOffset_};
	jspb.Message.initialize=function(a,b,c,d,e,f){a.wrappers_=null;b||(b=c?[c]:[]);a.messageId_=c?String(c):void 0;a.arrayIndexOffset_=0===c?-1:0;a.array=b;jspb.Message.initPivotAndExtensionObject_(a,d);a.convertedPrimitiveFields_={};jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS||(a.repeatedFields=e);if(e)for(b=0;b<e.length;b++)c=e[b],c<a.pivot_?(c=jspb.Message.getIndex_(a,c),a.array[c]=a.array[c]||jspb.Message.EMPTY_LIST_SENTINEL_):(jspb.Message.maybeInitEmptyExtensionObject_(a),a.extensionObject_[c]=
	a.extensionObject_[c]||jspb.Message.EMPTY_LIST_SENTINEL_);if(f&&f.length)for(b=0;b<f.length;b++)jspb.Message.computeOneofCase(a,f[b]);};jspb.Message.EMPTY_LIST_SENTINEL_=goog.DEBUG&&Object.freeze?Object.freeze([]):[];jspb.Message.isArray_=function(a){return jspb.Message.ASSUME_LOCAL_ARRAYS?a instanceof Array:goog.isArray(a)};jspb.Message.isExtensionObject_=function(a){return null!==a&&"object"==typeof a&&!jspb.Message.isArray_(a)&&!(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)};
	jspb.Message.initPivotAndExtensionObject_=function(a,b){var c=a.array.length,d=-1;if(c&&(d=c-1,c=a.array[d],jspb.Message.isExtensionObject_(c))){a.pivot_=jspb.Message.getFieldNumber_(a,d);a.extensionObject_=c;return}-1<b?(a.pivot_=Math.max(b,jspb.Message.getFieldNumber_(a,d+1)),a.extensionObject_=null):a.pivot_=Number.MAX_VALUE;};jspb.Message.maybeInitEmptyExtensionObject_=function(a){var b=jspb.Message.getIndex_(a,a.pivot_);a.array[b]||(a.extensionObject_=a.array[b]={});};
	jspb.Message.toObjectList=function(a,b,c){for(var d=[],e=0;e<a.length;e++)d[e]=b.call(a[e],c,a[e]);return d};jspb.Message.toObjectExtension=function(a,b,c,d,e){for(var f in c){var g=c[f],h=d.call(a,g);if(null!=h){for(var k in g.fieldName)if(g.fieldName.hasOwnProperty(k))break;b[k]=g.toObjectFn?g.isRepeated?jspb.Message.toObjectList(h,g.toObjectFn,e):g.toObjectFn(e,h):h;}}};
	jspb.Message.serializeBinaryExtensions=function(a,b,c,d){for(var e in c){var f=c[e],g=f.fieldInfo;if(!f.binaryWriterFn)throw Error("Message extension present that was generated without binary serialization support");var h=d.call(a,g);if(null!=h)if(g.isMessageType())if(f.binaryMessageSerializeFn)f.binaryWriterFn.call(b,g.fieldIndex,h,f.binaryMessageSerializeFn);else throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
	else f.binaryWriterFn.call(b,g.fieldIndex,h);}};jspb.Message.readBinaryExtension=function(a,b,c,d,e){var f=c[b.getFieldNumber()];if(f){c=f.fieldInfo;if(!f.binaryReaderFn)throw Error("Deserializing extension whose generated code does not support binary format");if(c.isMessageType()){var g=new c.ctor;f.binaryReaderFn.call(b,g,f.binaryMessageDeserializeFn);}else g=f.binaryReaderFn.call(b);c.isRepeated&&!f.isPacked?(b=d.call(a,c))?b.push(g):e.call(a,c,[g]):e.call(a,c,g);}else b.skipField();};
	jspb.Message.getField=function(a,b){if(b<a.pivot_){b=jspb.Message.getIndex_(a,b);var c=a.array[b];return c===jspb.Message.EMPTY_LIST_SENTINEL_?a.array[b]=[]:c}if(a.extensionObject_)return c=a.extensionObject_[b],c===jspb.Message.EMPTY_LIST_SENTINEL_?a.extensionObject_[b]=[]:c};jspb.Message.getRepeatedField=function(a,b){return jspb.Message.getField(a,b)};jspb.Message.getOptionalFloatingPointField=function(a,b){a=jspb.Message.getField(a,b);return null==a?a:+a};
	jspb.Message.getBooleanField=function(a,b){a=jspb.Message.getField(a,b);return null==a?a:!!a};jspb.Message.getRepeatedFloatingPointField=function(a,b){var c=jspb.Message.getRepeatedField(a,b);a.convertedPrimitiveFields_||(a.convertedPrimitiveFields_={});if(!a.convertedPrimitiveFields_[b]){for(var d=0;d<c.length;d++)c[d]=+c[d];a.convertedPrimitiveFields_[b]=!0;}return c};
	jspb.Message.getRepeatedBooleanField=function(a,b){var c=jspb.Message.getRepeatedField(a,b);a.convertedPrimitiveFields_||(a.convertedPrimitiveFields_={});if(!a.convertedPrimitiveFields_[b]){for(var d=0;d<c.length;d++)c[d]=!!c[d];a.convertedPrimitiveFields_[b]=!0;}return c};
	jspb.Message.bytesAsB64=function(a){if(null==a||goog.isString(a))return a;if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)return goog.crypt.base64.encodeByteArray(a);goog.asserts.fail("Cannot coerce to b64 string: "+goog.typeOf(a));return null};jspb.Message.bytesAsU8=function(a){if(null==a||a instanceof Uint8Array)return a;if(goog.isString(a))return goog.crypt.base64.decodeStringToUint8Array(a);goog.asserts.fail("Cannot coerce to Uint8Array: "+goog.typeOf(a));return null};
	jspb.Message.bytesListAsB64=function(a){jspb.Message.assertConsistentTypes_(a);return !a.length||goog.isString(a[0])?a:goog.array.map(a,jspb.Message.bytesAsB64)};jspb.Message.bytesListAsU8=function(a){jspb.Message.assertConsistentTypes_(a);return !a.length||a[0]instanceof Uint8Array?a:goog.array.map(a,jspb.Message.bytesAsU8)};
	jspb.Message.assertConsistentTypes_=function(a){if(goog.DEBUG&&a&&1<a.length){var b=goog.typeOf(a[0]);goog.array.forEach(a,function(a){goog.typeOf(a)!=b&&goog.asserts.fail("Inconsistent type in JSPB repeated field array. Got "+goog.typeOf(a)+" expected "+b);});}};jspb.Message.getFieldWithDefault=function(a,b,c){a=jspb.Message.getField(a,b);return null==a?c:a};jspb.Message.getBooleanFieldWithDefault=function(a,b,c){a=jspb.Message.getBooleanField(a,b);return null==a?c:a};
	jspb.Message.getFloatingPointFieldWithDefault=function(a,b,c){a=jspb.Message.getOptionalFloatingPointField(a,b);return null==a?c:a};jspb.Message.getFieldProto3=jspb.Message.getFieldWithDefault;jspb.Message.getMapField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});if(b in a.wrappers_)return a.wrappers_[b];var e=jspb.Message.getField(a,b);if(!e){if(c)return;e=[];jspb.Message.setField(a,b,e);}return a.wrappers_[b]=new jspb.Map(e,d)};
	jspb.Message.setField=function(a,b,c){goog.asserts.assertInstanceof(a,jspb.Message);b<a.pivot_?a.array[jspb.Message.getIndex_(a,b)]=c:(jspb.Message.maybeInitEmptyExtensionObject_(a),a.extensionObject_[b]=c);return a};jspb.Message.setProto3IntField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,0)};jspb.Message.setProto3FloatField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,0)};
	jspb.Message.setProto3BooleanField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,!1)};jspb.Message.setProto3StringField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,"")};jspb.Message.setProto3BytesField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,"")};jspb.Message.setProto3EnumField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,0)};
	jspb.Message.setProto3StringIntField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,"0")};jspb.Message.setFieldIgnoringDefault_=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);c!==d?jspb.Message.setField(a,b,c):a.array[jspb.Message.getIndex_(a,b)]=null;return a};jspb.Message.addToRepeatedField=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);b=jspb.Message.getRepeatedField(a,b);void 0!=d?b.splice(d,0,c):b.push(c);return a};
	jspb.Message.setOneofField=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);(c=jspb.Message.computeOneofCase(a,c))&&c!==b&&void 0!==d&&(a.wrappers_&&c in a.wrappers_&&(a.wrappers_[c]=void 0),jspb.Message.setField(a,c,void 0));return jspb.Message.setField(a,b,d)};jspb.Message.computeOneofCase=function(a,b){for(var c,d,e=0;e<b.length;e++){var f=b[e],g=jspb.Message.getField(a,f);null!=g&&(c=f,d=g,jspb.Message.setField(a,f,void 0));}return c?(jspb.Message.setField(a,c,d),c):0};
	jspb.Message.getWrapperField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});if(!a.wrappers_[c]){var e=jspb.Message.getField(a,c);if(d||e)a.wrappers_[c]=new b(e);}return a.wrappers_[c]};jspb.Message.getRepeatedWrapperField=function(a,b,c){jspb.Message.wrapRepeatedField_(a,b,c);b=a.wrappers_[c];b==jspb.Message.EMPTY_LIST_SENTINEL_&&(b=a.wrappers_[c]=[]);return b};
	jspb.Message.wrapRepeatedField_=function(a,b,c){a.wrappers_||(a.wrappers_={});if(!a.wrappers_[c]){for(var d=jspb.Message.getRepeatedField(a,c),e=[],f=0;f<d.length;f++)e[f]=new b(d[f]);a.wrappers_[c]=e;}};jspb.Message.setWrapperField=function(a,b,c){goog.asserts.assertInstanceof(a,jspb.Message);a.wrappers_||(a.wrappers_={});var d=c?c.toArray():c;a.wrappers_[b]=c;return jspb.Message.setField(a,b,d)};
	jspb.Message.setOneofWrapperField=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);a.wrappers_||(a.wrappers_={});var e=d?d.toArray():d;a.wrappers_[b]=d;return jspb.Message.setOneofField(a,b,c,e)};jspb.Message.setRepeatedWrapperField=function(a,b,c){goog.asserts.assertInstanceof(a,jspb.Message);a.wrappers_||(a.wrappers_={});c=c||[];for(var d=[],e=0;e<c.length;e++)d[e]=c[e].toArray();a.wrappers_[b]=c;return jspb.Message.setField(a,b,d)};
	jspb.Message.addToRepeatedWrapperField=function(a,b,c,d,e){jspb.Message.wrapRepeatedField_(a,d,b);var f=a.wrappers_[b];f||(f=a.wrappers_[b]=[]);c=c?c:new d;a=jspb.Message.getRepeatedField(a,b);void 0!=e?(f.splice(e,0,c),a.splice(e,0,c.toArray())):(f.push(c),a.push(c.toArray()));return c};jspb.Message.toMap=function(a,b,c,d){for(var e={},f=0;f<a.length;f++)e[b.call(a[f])]=c?c.call(a[f],d,a[f]):a[f];return e};
	jspb.Message.prototype.syncMapFields_=function(){if(this.wrappers_)for(var a in this.wrappers_){var b=this.wrappers_[a];if(goog.isArray(b))for(var c=0;c<b.length;c++)b[c]&&b[c].toArray();else b&&b.toArray();}};jspb.Message.prototype.toArray=function(){this.syncMapFields_();return this.array};jspb.Message.GENERATE_TO_STRING&&(jspb.Message.prototype.toString=function(){this.syncMapFields_();return this.array.toString()});
	jspb.Message.prototype.getExtension=function(a){if(this.extensionObject_){this.wrappers_||(this.wrappers_={});var b=a.fieldIndex;if(a.isRepeated){if(a.isMessageType())return this.wrappers_[b]||(this.wrappers_[b]=goog.array.map(this.extensionObject_[b]||[],function(b){return new a.ctor(b)})),this.wrappers_[b]}else if(a.isMessageType())return !this.wrappers_[b]&&this.extensionObject_[b]&&(this.wrappers_[b]=new a.ctor(this.extensionObject_[b])),this.wrappers_[b];return this.extensionObject_[b]}};
	jspb.Message.prototype.setExtension=function(a,b){this.wrappers_||(this.wrappers_={});jspb.Message.maybeInitEmptyExtensionObject_(this);var c=a.fieldIndex;a.isRepeated?(b=b||[],a.isMessageType()?(this.wrappers_[c]=b,this.extensionObject_[c]=goog.array.map(b,function(a){return a.toArray()})):this.extensionObject_[c]=b):a.isMessageType()?(this.wrappers_[c]=b,this.extensionObject_[c]=b?b.toArray():b):this.extensionObject_[c]=b;return this};
	jspb.Message.difference=function(a,b){if(!(a instanceof b.constructor))throw Error("Messages have different types.");var c=a.toArray();b=b.toArray();var d=[],e=0,f=c.length>b.length?c.length:b.length;a.getJsPbMessageId()&&(d[0]=a.getJsPbMessageId(),e=1);for(;e<f;e++)jspb.Message.compareFields(c[e],b[e])||(d[e]=b[e]);return new a.constructor(d)};jspb.Message.equals=function(a,b){return a==b||!(!a||!b)&&a instanceof b.constructor&&jspb.Message.compareFields(a.toArray(),b.toArray())};
	jspb.Message.compareExtensions=function(a,b){a=a||{};b=b||{};var c={},d;for(d in a)c[d]=0;for(d in b)c[d]=0;for(d in c)if(!jspb.Message.compareFields(a[d],b[d]))return !1;return !0};
	jspb.Message.compareFields=function(a,b){if(a==b)return !0;if(!goog.isObject(a)||!goog.isObject(b))return goog.isNumber(a)&&isNaN(a)||goog.isNumber(b)&&isNaN(b)?String(a)==String(b):!1;if(a.constructor!=b.constructor)return !1;if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a.constructor===Uint8Array){if(a.length!=b.length)return !1;for(var c=0;c<a.length;c++)if(a[c]!=b[c])return !1;return !0}if(a.constructor===Array){var d=void 0,e=void 0,f=Math.max(a.length,b.length);for(c=0;c<f;c++){var g=a[c],h=b[c];g&&g.constructor==
	Object&&(goog.asserts.assert(void 0===d),goog.asserts.assert(c===a.length-1),d=g,g=void 0);h&&h.constructor==Object&&(goog.asserts.assert(void 0===e),goog.asserts.assert(c===b.length-1),e=h,h=void 0);if(!jspb.Message.compareFields(g,h))return !1}return d||e?(d=d||{},e=e||{},jspb.Message.compareExtensions(d,e)):!0}if(a.constructor===Object)return jspb.Message.compareExtensions(a,b);throw Error("Invalid type in JSPB array");};jspb.Message.prototype.cloneMessage=function(){return jspb.Message.cloneMessage(this)};
	jspb.Message.prototype.clone=function(){return jspb.Message.cloneMessage(this)};jspb.Message.clone=function(a){return jspb.Message.cloneMessage(a)};jspb.Message.cloneMessage=function(a){return new a.constructor(jspb.Message.clone_(a.toArray()))};
	jspb.Message.copyInto=function(a,b){goog.asserts.assertInstanceof(a,jspb.Message);goog.asserts.assertInstanceof(b,jspb.Message);goog.asserts.assert(a.constructor==b.constructor,"Copy source and target message should have the same type.");a=jspb.Message.clone(a);for(var c=b.toArray(),d=a.toArray(),e=c.length=0;e<d.length;e++)c[e]=d[e];b.wrappers_=a.wrappers_;b.extensionObject_=a.extensionObject_;};
	jspb.Message.clone_=function(a){if(goog.isArray(a)){for(var b=Array(a.length),c=0;c<a.length;c++){var d=a[c];null!=d&&(b[c]="object"==typeof d?jspb.Message.clone_(goog.asserts.assert(d)):d);}return b}if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)return new Uint8Array(a);b={};for(c in a)d=a[c],null!=d&&(b[c]="object"==typeof d?jspb.Message.clone_(goog.asserts.assert(d)):d);return b};jspb.Message.registerMessageType=function(a,b){b.messageId=a;};jspb.Message.messageSetExtensions={};
	jspb.Message.messageSetExtensionsBinary={};jspb.arith={};jspb.arith.UInt64=function(a,b){this.lo=a;this.hi=b;};jspb.arith.UInt64.prototype.cmp=function(a){return this.hi<a.hi||this.hi==a.hi&&this.lo<a.lo?-1:this.hi==a.hi&&this.lo==a.lo?0:1};jspb.arith.UInt64.prototype.rightShift=function(){return new jspb.arith.UInt64((this.lo>>>1|(this.hi&1)<<31)>>>0,this.hi>>>1>>>0)};jspb.arith.UInt64.prototype.leftShift=function(){return new jspb.arith.UInt64(this.lo<<1>>>0,(this.hi<<1|this.lo>>>31)>>>0)};
	jspb.arith.UInt64.prototype.msb=function(){return !!(this.hi&2147483648)};jspb.arith.UInt64.prototype.lsb=function(){return !!(this.lo&1)};jspb.arith.UInt64.prototype.zero=function(){return 0==this.lo&&0==this.hi};jspb.arith.UInt64.prototype.add=function(a){return new jspb.arith.UInt64((this.lo+a.lo&4294967295)>>>0>>>0,((this.hi+a.hi&4294967295)>>>0)+(4294967296<=this.lo+a.lo?1:0)>>>0)};
	jspb.arith.UInt64.prototype.sub=function(a){return new jspb.arith.UInt64((this.lo-a.lo&4294967295)>>>0>>>0,((this.hi-a.hi&4294967295)>>>0)-(0>this.lo-a.lo?1:0)>>>0)};jspb.arith.UInt64.mul32x32=function(a,b){var c=a&65535;a>>>=16;var d=b&65535,e=b>>>16;b=c*d+65536*(c*e&65535)+65536*(a*d&65535);for(c=a*e+(c*e>>>16)+(a*d>>>16);4294967296<=b;)b-=4294967296,c+=1;return new jspb.arith.UInt64(b>>>0,c>>>0)};
	jspb.arith.UInt64.prototype.mul=function(a){var b=jspb.arith.UInt64.mul32x32(this.lo,a);a=jspb.arith.UInt64.mul32x32(this.hi,a);a.hi=a.lo;a.lo=0;return b.add(a)};
	jspb.arith.UInt64.prototype.div=function(a){if(0==a)return [];var b=new jspb.arith.UInt64(0,0),c=new jspb.arith.UInt64(this.lo,this.hi);a=new jspb.arith.UInt64(a,0);for(var d=new jspb.arith.UInt64(1,0);!a.msb();)a=a.leftShift(),d=d.leftShift();for(;!d.zero();)0>=a.cmp(c)&&(b=b.add(d),c=c.sub(a)),a=a.rightShift(),d=d.rightShift();return [b,c]};jspb.arith.UInt64.prototype.toString=function(){for(var a="",b=this;!b.zero();){b=b.div(10);var c=b[0];a=b[1].lo+a;b=c;}""==a&&(a="0");return a};
	jspb.arith.UInt64.fromString=function(a){for(var b=new jspb.arith.UInt64(0,0),c=new jspb.arith.UInt64(0,0),d=0;d<a.length;d++){if("0">a[d]||"9"<a[d])return null;var e=parseInt(a[d],10);c.lo=e;b=b.mul(10).add(c);}return b};jspb.arith.UInt64.prototype.clone=function(){return new jspb.arith.UInt64(this.lo,this.hi)};jspb.arith.Int64=function(a,b){this.lo=a;this.hi=b;};
	jspb.arith.Int64.prototype.add=function(a){return new jspb.arith.Int64((this.lo+a.lo&4294967295)>>>0>>>0,((this.hi+a.hi&4294967295)>>>0)+(4294967296<=this.lo+a.lo?1:0)>>>0)};jspb.arith.Int64.prototype.sub=function(a){return new jspb.arith.Int64((this.lo-a.lo&4294967295)>>>0>>>0,((this.hi-a.hi&4294967295)>>>0)-(0>this.lo-a.lo?1:0)>>>0)};jspb.arith.Int64.prototype.clone=function(){return new jspb.arith.Int64(this.lo,this.hi)};
	jspb.arith.Int64.prototype.toString=function(){var a=0!=(this.hi&2147483648),b=new jspb.arith.UInt64(this.lo,this.hi);a&&(b=(new jspb.arith.UInt64(0,0)).sub(b));return (a?"-":"")+b.toString()};jspb.arith.Int64.fromString=function(a){var b=0<a.length&&"-"==a[0];b&&(a=a.substring(1));a=jspb.arith.UInt64.fromString(a);if(null===a)return null;b&&(a=(new jspb.arith.UInt64(0,0)).sub(a));return new jspb.arith.Int64(a.lo,a.hi)};jspb.BinaryEncoder=function(){this.buffer_=[];};jspb.BinaryEncoder.prototype.length=function(){return this.buffer_.length};jspb.BinaryEncoder.prototype.end=function(){var a=this.buffer_;this.buffer_=[];return a};
	jspb.BinaryEncoder.prototype.writeSplitVarint64=function(a,b){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(b==Math.floor(b));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);for(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32);0<b||127<a;)this.buffer_.push(a&127|128),a=(a>>>7|b<<25)>>>0,b>>>=7;this.buffer_.push(a);};
	jspb.BinaryEncoder.prototype.writeSplitFixed64=function(a,b){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(b==Math.floor(b));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32);this.writeUint32(a);this.writeUint32(b);};
	jspb.BinaryEncoder.prototype.writeUnsignedVarint32=function(a){goog.asserts.assert(a==Math.floor(a));for(goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);127<a;)this.buffer_.push(a&127|128),a>>>=7;this.buffer_.push(a);};
	jspb.BinaryEncoder.prototype.writeSignedVarint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);if(0<=a)this.writeUnsignedVarint32(a);else {for(var b=0;9>b;b++)this.buffer_.push(a&127|128),a>>=7;this.buffer_.push(1);}};
	jspb.BinaryEncoder.prototype.writeUnsignedVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_64);jspb.utils.splitInt64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High);};
	jspb.BinaryEncoder.prototype.writeSignedVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitInt64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High);};
	jspb.BinaryEncoder.prototype.writeZigzagVarint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.writeUnsignedVarint32((a<<1^a>>31)>>>0);};jspb.BinaryEncoder.prototype.writeZigzagVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitZigzag64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High);};
	jspb.BinaryEncoder.prototype.writeZigzagVarint64String=function(a){this.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(a));};jspb.BinaryEncoder.prototype.writeZigzagVarintHash64=function(a){var b=this;jspb.utils.splitHash64(a);jspb.utils.toZigzag64(jspb.utils.split64Low,jspb.utils.split64High,function(a,d){b.writeSplitVarint64(a>>>0,d>>>0);});};
	jspb.BinaryEncoder.prototype.writeUint8=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&256>a);this.buffer_.push(a>>>0&255);};jspb.BinaryEncoder.prototype.writeUint16=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&65536>a);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);};
	jspb.BinaryEncoder.prototype.writeUint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);this.buffer_.push(a>>>16&255);this.buffer_.push(a>>>24&255);};jspb.BinaryEncoder.prototype.writeUint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_64);jspb.utils.splitUint64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High);};
	jspb.BinaryEncoder.prototype.writeInt8=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(-128<=a&&128>a);this.buffer_.push(a>>>0&255);};jspb.BinaryEncoder.prototype.writeInt16=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(-32768<=a&&32768>a);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);};
	jspb.BinaryEncoder.prototype.writeInt32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);this.buffer_.push(a>>>16&255);this.buffer_.push(a>>>24&255);};
	jspb.BinaryEncoder.prototype.writeInt64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitInt64(a);this.writeSplitFixed64(jspb.utils.split64Low,jspb.utils.split64High);};
	jspb.BinaryEncoder.prototype.writeInt64String=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(+a>=-jspb.BinaryConstants.TWO_TO_63&&+a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a));this.writeSplitFixed64(jspb.utils.split64Low,jspb.utils.split64High);};jspb.BinaryEncoder.prototype.writeFloat=function(a){goog.asserts.assert(a>=-jspb.BinaryConstants.FLOAT32_MAX&&a<=jspb.BinaryConstants.FLOAT32_MAX);jspb.utils.splitFloat32(a);this.writeUint32(jspb.utils.split64Low);};
	jspb.BinaryEncoder.prototype.writeDouble=function(a){goog.asserts.assert(a>=-jspb.BinaryConstants.FLOAT64_MAX&&a<=jspb.BinaryConstants.FLOAT64_MAX);jspb.utils.splitFloat64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High);};jspb.BinaryEncoder.prototype.writeBool=function(a){goog.asserts.assert(goog.isBoolean(a)||goog.isNumber(a));this.buffer_.push(a?1:0);};
	jspb.BinaryEncoder.prototype.writeEnum=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.writeSignedVarint32(a);};jspb.BinaryEncoder.prototype.writeBytes=function(a){this.buffer_.push.apply(this.buffer_,a);};jspb.BinaryEncoder.prototype.writeVarintHash64=function(a){jspb.utils.splitHash64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High);};
	jspb.BinaryEncoder.prototype.writeFixedHash64=function(a){jspb.utils.splitHash64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High);};
	jspb.BinaryEncoder.prototype.writeString=function(a){for(var b=this.buffer_.length,c=0;c<a.length;c++){var d=a.charCodeAt(c);if(128>d)this.buffer_.push(d);else if(2048>d)this.buffer_.push(d>>6|192),this.buffer_.push(d&63|128);else if(65536>d)if(55296<=d&&56319>=d&&c+1<a.length){var e=a.charCodeAt(c+1);56320<=e&&57343>=e&&(d=1024*(d-55296)+e-56320+65536,this.buffer_.push(d>>18|240),this.buffer_.push(d>>12&63|128),this.buffer_.push(d>>6&63|128),this.buffer_.push(d&63|128),c++);}else this.buffer_.push(d>>
	12|224),this.buffer_.push(d>>6&63|128),this.buffer_.push(d&63|128);}return this.buffer_.length-b};jspb.BinaryWriter=function(){this.blocks_=[];this.totalLength_=0;this.encoder_=new jspb.BinaryEncoder;this.bookmarks_=[];};jspb.BinaryWriter.prototype.appendUint8Array_=function(a){var b=this.encoder_.end();this.blocks_.push(b);this.blocks_.push(a);this.totalLength_+=b.length+a.length;};
	jspb.BinaryWriter.prototype.beginDelimited_=function(a){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);a=this.encoder_.end();this.blocks_.push(a);this.totalLength_+=a.length;a.push(this.totalLength_);return a};jspb.BinaryWriter.prototype.endDelimited_=function(a){var b=a.pop();b=this.totalLength_+this.encoder_.length()-b;for(goog.asserts.assert(0<=b);127<b;)a.push(b&127|128),b>>>=7,this.totalLength_++;a.push(b);this.totalLength_++;};
	jspb.BinaryWriter.prototype.writeSerializedMessage=function(a,b,c){this.appendUint8Array_(a.subarray(b,c));};jspb.BinaryWriter.prototype.maybeWriteSerializedMessage=function(a,b,c){null!=a&&null!=b&&null!=c&&this.writeSerializedMessage(a,b,c);};jspb.BinaryWriter.prototype.reset=function(){this.blocks_=[];this.encoder_.end();this.totalLength_=0;this.bookmarks_=[];};
	jspb.BinaryWriter.prototype.getResultBuffer=function(){goog.asserts.assert(0==this.bookmarks_.length);for(var a=new Uint8Array(this.totalLength_+this.encoder_.length()),b=this.blocks_,c=b.length,d=0,e=0;e<c;e++){var f=b[e];a.set(f,d);d+=f.length;}b=this.encoder_.end();a.set(b,d);d+=b.length;goog.asserts.assert(d==a.length);this.blocks_=[a];return a};jspb.BinaryWriter.prototype.getResultBase64String=function(a){return goog.crypt.base64.encodeByteArray(this.getResultBuffer(),a)};
	jspb.BinaryWriter.prototype.beginSubMessage=function(a){this.bookmarks_.push(this.beginDelimited_(a));};jspb.BinaryWriter.prototype.endSubMessage=function(){goog.asserts.assert(0<=this.bookmarks_.length);this.endDelimited_(this.bookmarks_.pop());};jspb.BinaryWriter.prototype.writeFieldHeader_=function(a,b){goog.asserts.assert(1<=a&&a==Math.floor(a));this.encoder_.writeUnsignedVarint32(8*a+b);};
	jspb.BinaryWriter.prototype.writeAny=function(a,b,c){var d=jspb.BinaryConstants.FieldType;switch(a){case d.DOUBLE:this.writeDouble(b,c);break;case d.FLOAT:this.writeFloat(b,c);break;case d.INT64:this.writeInt64(b,c);break;case d.UINT64:this.writeUint64(b,c);break;case d.INT32:this.writeInt32(b,c);break;case d.FIXED64:this.writeFixed64(b,c);break;case d.FIXED32:this.writeFixed32(b,c);break;case d.BOOL:this.writeBool(b,c);break;case d.STRING:this.writeString(b,c);break;case d.GROUP:goog.asserts.fail("Group field type not supported in writeAny()");
	break;case d.MESSAGE:goog.asserts.fail("Message field type not supported in writeAny()");break;case d.BYTES:this.writeBytes(b,c);break;case d.UINT32:this.writeUint32(b,c);break;case d.ENUM:this.writeEnum(b,c);break;case d.SFIXED32:this.writeSfixed32(b,c);break;case d.SFIXED64:this.writeSfixed64(b,c);break;case d.SINT32:this.writeSint32(b,c);break;case d.SINT64:this.writeSint64(b,c);break;case d.FHASH64:this.writeFixedHash64(b,c);break;case d.VHASH64:this.writeVarintHash64(b,c);break;default:goog.asserts.fail("Invalid field type in writeAny()");}};
	jspb.BinaryWriter.prototype.writeUnsignedVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeUnsignedVarint32(b));};jspb.BinaryWriter.prototype.writeSignedVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(b));};jspb.BinaryWriter.prototype.writeUnsignedVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeUnsignedVarint64(b));};
	jspb.BinaryWriter.prototype.writeSignedVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint64(b));};jspb.BinaryWriter.prototype.writeZigzagVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint32(b));};jspb.BinaryWriter.prototype.writeZigzagVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint64(b));};
	jspb.BinaryWriter.prototype.writeZigzagVarint64String_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint64String(b));};jspb.BinaryWriter.prototype.writeZigzagVarintHash64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarintHash64(b));};
	jspb.BinaryWriter.prototype.writeInt32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeSignedVarint32_(a,b));};jspb.BinaryWriter.prototype.writeInt32String=function(a,b){null!=b&&(b=parseInt(b,10),goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeSignedVarint32_(a,b));};
	jspb.BinaryWriter.prototype.writeInt64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeSignedVarint64_(a,b));};jspb.BinaryWriter.prototype.writeInt64String=function(a,b){null!=b&&(b=jspb.arith.Int64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSplitVarint64(b.lo,b.hi));};
	jspb.BinaryWriter.prototype.writeUint32=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeUnsignedVarint32_(a,b));};jspb.BinaryWriter.prototype.writeUint32String=function(a,b){null!=b&&(b=parseInt(b,10),goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeUnsignedVarint32_(a,b));};jspb.BinaryWriter.prototype.writeUint64=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_64),this.writeUnsignedVarint64_(a,b));};
	jspb.BinaryWriter.prototype.writeUint64String=function(a,b){null!=b&&(b=jspb.arith.UInt64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSplitVarint64(b.lo,b.hi));};jspb.BinaryWriter.prototype.writeSint32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeZigzagVarint32_(a,b));};
	jspb.BinaryWriter.prototype.writeSint64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeZigzagVarint64_(a,b));};jspb.BinaryWriter.prototype.writeSintHash64=function(a,b){null!=b&&this.writeZigzagVarintHash64_(a,b);};jspb.BinaryWriter.prototype.writeSint64String=function(a,b){null!=b&&this.writeZigzagVarint64String_(a,b);};
	jspb.BinaryWriter.prototype.writeFixed32=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeUint32(b));};jspb.BinaryWriter.prototype.writeFixed64=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_64),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeUint64(b));};
	jspb.BinaryWriter.prototype.writeFixed64String=function(a,b){null!=b&&(b=jspb.arith.UInt64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeSplitFixed64(b.lo,b.hi));};jspb.BinaryWriter.prototype.writeSfixed32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeInt32(b));};
	jspb.BinaryWriter.prototype.writeSfixed64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeInt64(b));};jspb.BinaryWriter.prototype.writeSfixed64String=function(a,b){null!=b&&(b=jspb.arith.Int64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeSplitFixed64(b.lo,b.hi));};
	jspb.BinaryWriter.prototype.writeFloat=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeFloat(b));};jspb.BinaryWriter.prototype.writeDouble=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeDouble(b));};jspb.BinaryWriter.prototype.writeBool=function(a,b){null!=b&&(goog.asserts.assert(goog.isBoolean(b)||goog.isNumber(b)),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeBool(b));};
	jspb.BinaryWriter.prototype.writeEnum=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(b));};jspb.BinaryWriter.prototype.writeString=function(a,b){null!=b&&(a=this.beginDelimited_(a),this.encoder_.writeString(b),this.endDelimited_(a));};
	jspb.BinaryWriter.prototype.writeBytes=function(a,b){null!=b&&(b=jspb.utils.byteSourceToUint8Array(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(b.length),this.appendUint8Array_(b));};jspb.BinaryWriter.prototype.writeMessage=function(a,b,c){null!=b&&(a=this.beginDelimited_(a),c(b,this),this.endDelimited_(a));};
	jspb.BinaryWriter.prototype.writeMessageSet=function(a,b,c){null!=b&&(this.writeFieldHeader_(1,jspb.BinaryConstants.WireType.START_GROUP),this.writeFieldHeader_(2,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(a),a=this.beginDelimited_(3),c(b,this),this.endDelimited_(a),this.writeFieldHeader_(1,jspb.BinaryConstants.WireType.END_GROUP));};
	jspb.BinaryWriter.prototype.writeGroup=function(a,b,c){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.START_GROUP),c(b,this),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.END_GROUP));};jspb.BinaryWriter.prototype.writeFixedHash64=function(a,b){null!=b&&(goog.asserts.assert(8==b.length),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeFixedHash64(b));};
	jspb.BinaryWriter.prototype.writeVarintHash64=function(a,b){null!=b&&(goog.asserts.assert(8==b.length),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeVarintHash64(b));};jspb.BinaryWriter.prototype.writeSplitFixed64=function(a,b,c){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64);this.encoder_.writeSplitFixed64(b,c);};
	jspb.BinaryWriter.prototype.writeSplitVarint64=function(a,b,c){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT);this.encoder_.writeSplitVarint64(b,c);};jspb.BinaryWriter.prototype.writeSplitZigzagVarint64=function(a,b,c){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT);var d=this.encoder_;jspb.utils.toZigzag64(b,c,function(a,b){d.writeSplitVarint64(a>>>0,b>>>0);});};
	jspb.BinaryWriter.prototype.writeRepeatedInt32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSignedVarint32_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedInt32String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeInt32String(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedInt64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSignedVarint64_(a,b[c]);};
	jspb.BinaryWriter.prototype.writeRepeatedSplitFixed64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitFixed64(a,c(b[e]),d(b[e]));};jspb.BinaryWriter.prototype.writeRepeatedSplitVarint64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitVarint64(a,c(b[e]),d(b[e]));};jspb.BinaryWriter.prototype.writeRepeatedSplitZigzagVarint64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitZigzagVarint64(a,c(b[e]),d(b[e]));};
	jspb.BinaryWriter.prototype.writeRepeatedInt64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeInt64String(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedUint32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUnsignedVarint32_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedUint32String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUint32String(a,b[c]);};
	jspb.BinaryWriter.prototype.writeRepeatedUint64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUnsignedVarint64_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedUint64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUint64String(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSint32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint32_(a,b[c]);};
	jspb.BinaryWriter.prototype.writeRepeatedSint64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint64_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSint64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint64String_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSintHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarintHash64_(a,b[c]);};
	jspb.BinaryWriter.prototype.writeRepeatedFixed32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed32(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedFixed64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed64(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedFixed64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed64String(a,b[c]);};
	jspb.BinaryWriter.prototype.writeRepeatedSfixed32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed32(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSfixed64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed64(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSfixed64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed64String(a,b[c]);};
	jspb.BinaryWriter.prototype.writeRepeatedFloat=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFloat(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedDouble=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeDouble(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedBool=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeBool(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedEnum=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeEnum(a,b[c]);};
	jspb.BinaryWriter.prototype.writeRepeatedString=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeString(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedBytes=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeBytes(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedMessage=function(a,b,c){if(null!=b)for(var d=0;d<b.length;d++){var e=this.beginDelimited_(a);c(b[d],this);this.endDelimited_(e);}};
	jspb.BinaryWriter.prototype.writeRepeatedGroup=function(a,b,c){if(null!=b)for(var d=0;d<b.length;d++)this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.START_GROUP),c(b[d],this),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.END_GROUP);};jspb.BinaryWriter.prototype.writeRepeatedFixedHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixedHash64(a,b[c]);};
	jspb.BinaryWriter.prototype.writeRepeatedVarintHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeVarintHash64(a,b[c]);};jspb.BinaryWriter.prototype.writePackedInt32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint32(b[c]);this.endDelimited_(a);}};
	jspb.BinaryWriter.prototype.writePackedInt32String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint32(parseInt(b[c],10));this.endDelimited_(a);}};jspb.BinaryWriter.prototype.writePackedInt64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint64(b[c]);this.endDelimited_(a);}};
	jspb.BinaryWriter.prototype.writePackedSplitFixed64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=0;e<b.length;e++)this.encoder_.writeSplitFixed64(c(b[e]),d(b[e]));this.endDelimited_(a);}};jspb.BinaryWriter.prototype.writePackedSplitVarint64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=0;e<b.length;e++)this.encoder_.writeSplitVarint64(c(b[e]),d(b[e]));this.endDelimited_(a);}};
	jspb.BinaryWriter.prototype.writePackedSplitZigzagVarint64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=this.encoder_,f=0;f<b.length;f++)jspb.utils.toZigzag64(c(b[f]),d(b[f]),function(a,b){e.writeSplitVarint64(a>>>0,b>>>0);});this.endDelimited_(a);}};jspb.BinaryWriter.prototype.writePackedInt64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++){var d=jspb.arith.Int64.fromString(b[c]);this.encoder_.writeSplitVarint64(d.lo,d.hi);}this.endDelimited_(a);}};
	jspb.BinaryWriter.prototype.writePackedUint32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint32(b[c]);this.endDelimited_(a);}};jspb.BinaryWriter.prototype.writePackedUint32String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint32(parseInt(b[c],10));this.endDelimited_(a);}};
	jspb.BinaryWriter.prototype.writePackedUint64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint64(b[c]);this.endDelimited_(a);}};jspb.BinaryWriter.prototype.writePackedUint64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++){var d=jspb.arith.UInt64.fromString(b[c]);this.encoder_.writeSplitVarint64(d.lo,d.hi);}this.endDelimited_(a);}};
	jspb.BinaryWriter.prototype.writePackedSint32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarint32(b[c]);this.endDelimited_(a);}};jspb.BinaryWriter.prototype.writePackedSint64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarint64(b[c]);this.endDelimited_(a);}};
	jspb.BinaryWriter.prototype.writePackedSint64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(b[c]));this.endDelimited_(a);}};jspb.BinaryWriter.prototype.writePackedSintHash64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarintHash64(b[c]);this.endDelimited_(a);}};
	jspb.BinaryWriter.prototype.writePackedFixed32=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeUint32(b[a]);};jspb.BinaryWriter.prototype.writePackedFixed64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeUint64(b[a]);};
	jspb.BinaryWriter.prototype.writePackedFixed64String=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++){var c=jspb.arith.UInt64.fromString(b[a]);this.encoder_.writeSplitFixed64(c.lo,c.hi);}};
	jspb.BinaryWriter.prototype.writePackedSfixed32=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeInt32(b[a]);};jspb.BinaryWriter.prototype.writePackedSfixed64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeInt64(b[a]);};
	jspb.BinaryWriter.prototype.writePackedSfixed64String=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeInt64String(b[a]);};jspb.BinaryWriter.prototype.writePackedFloat=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeFloat(b[a]);};
	jspb.BinaryWriter.prototype.writePackedDouble=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeDouble(b[a]);};jspb.BinaryWriter.prototype.writePackedBool=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(b.length),a=0;a<b.length;a++)this.encoder_.writeBool(b[a]);};
	jspb.BinaryWriter.prototype.writePackedEnum=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeEnum(b[c]);this.endDelimited_(a);}};jspb.BinaryWriter.prototype.writePackedFixedHash64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeFixedHash64(b[a]);};
	jspb.BinaryWriter.prototype.writePackedVarintHash64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeVarintHash64(b[c]);this.endDelimited_(a);}};jspb.Export={};var Map$1$1=jspb.Map;var Message=jspb.Message;var BinaryReader=jspb.BinaryReader;var BinaryWriter=jspb.BinaryWriter;var ExtensionFieldInfo=jspb.ExtensionFieldInfo;var ExtensionFieldBinaryInfo=jspb.ExtensionFieldBinaryInfo;var exportSymbol=goog.exportSymbol;var inherits$1$1=goog.inherits;var object={extend:goog.object.extend};var typeOf=goog.typeOf;

	var googleProtobuf = {
		Map: Map$1$1,
		Message: Message,
		BinaryReader: BinaryReader,
		BinaryWriter: BinaryWriter,
		ExtensionFieldInfo: ExtensionFieldInfo,
		ExtensionFieldBinaryInfo: ExtensionFieldBinaryInfo,
		exportSymbol: exportSymbol,
		inherits: inherits$1$1,
		object: object,
		typeOf: typeOf
	};

	var field_mask_pb = createCommonjsModule$1$1(function (module, exports) {
	// source: google/protobuf/field_mask.proto
	/**
	 * @fileoverview
	 * @enhanceable
	 * @suppress {messageConventions} JS Compiler reports an error if a variable or
	 *     field starts with 'MSG_' and isn't a translatable message.
	 * @public
	 */
	// GENERATED CODE -- DO NOT EDIT!


	var goog = googleProtobuf;
	var global = Function('return this')();

	goog.exportSymbol('proto.google.protobuf.FieldMask', null, global);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.google.protobuf.FieldMask = function(opt_data) {
	  googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.google.protobuf.FieldMask.repeatedFields_, null);
	};
	goog.inherits(proto.google.protobuf.FieldMask, googleProtobuf.Message);

	/**
	 * List of repeated fields within this message type.
	 * @private {!Array<number>}
	 * @const
	 */
	proto.google.protobuf.FieldMask.repeatedFields_ = [1];



	if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * Optional fields that are not set will be set to undefined.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
	 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
	 *     JSPB instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.google.protobuf.FieldMask.prototype.toObject = function(opt_includeInstance) {
	  return proto.google.protobuf.FieldMask.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
	 *     the JSPB instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.google.protobuf.FieldMask} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.google.protobuf.FieldMask.toObject = function(includeInstance, msg) {
	  var f, obj = {
	    pathsList: (f = googleProtobuf.Message.getRepeatedField(msg, 1)) == null ? undefined : f
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.google.protobuf.FieldMask}
	 */
	proto.google.protobuf.FieldMask.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf.BinaryReader(bytes);
	  var msg = new proto.google.protobuf.FieldMask;
	  return proto.google.protobuf.FieldMask.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.google.protobuf.FieldMask} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.google.protobuf.FieldMask}
	 */
	proto.google.protobuf.FieldMask.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {string} */ (reader.readString());
	      msg.addPaths(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.google.protobuf.FieldMask.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf.BinaryWriter();
	  proto.google.protobuf.FieldMask.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.google.protobuf.FieldMask} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.google.protobuf.FieldMask.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getPathsList();
	  if (f.length > 0) {
	    writer.writeRepeatedString(
	      1,
	      f
	    );
	  }
	};


	/**
	 * repeated string paths = 1;
	 * @return {!Array<string>}
	 */
	proto.google.protobuf.FieldMask.prototype.getPathsList = function() {
	  return /** @type {!Array<string>} */ (googleProtobuf.Message.getRepeatedField(this, 1));
	};


	/**
	 * @param {!Array<string>} value
	 * @return {!proto.google.protobuf.FieldMask} returns this
	 */
	proto.google.protobuf.FieldMask.prototype.setPathsList = function(value) {
	  return googleProtobuf.Message.setField(this, 1, value || []);
	};


	/**
	 * @param {string} value
	 * @param {number=} opt_index
	 * @return {!proto.google.protobuf.FieldMask} returns this
	 */
	proto.google.protobuf.FieldMask.prototype.addPaths = function(value, opt_index) {
	  return googleProtobuf.Message.addToRepeatedField(this, 1, value, opt_index);
	};


	/**
	 * Clears the list making it empty but non-null.
	 * @return {!proto.google.protobuf.FieldMask} returns this
	 */
	proto.google.protobuf.FieldMask.prototype.clearPathsList = function() {
	  return this.setPathsList([]);
	};


	goog.object.extend(exports, proto.google.protobuf);
	});

	var types_pb = createCommonjsModule$1$1(function (module, exports) {
	  /**
	   * @fileoverview
	   * @enhanceable
	   * @suppress {messageConventions} JS Compiler reports an error if a variable or
	   *     field starts with 'MSG_' and isn't a translatable message.
	   * @public
	   */
	  // GENERATED CODE -- DO NOT EDIT!
	  var goog = googleProtobuf;
	  var global = Function('return this')();
	  goog.exportSymbol('proto.aitmed.ecos.v1beta1.Doc', null, global);
	  goog.exportSymbol('proto.aitmed.ecos.v1beta1.Edge', null, global);
	  goog.exportSymbol('proto.aitmed.ecos.v1beta1.Vertex', null, global);
	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */

	  proto.aitmed.ecos.v1beta1.Vertex = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };

	  goog.inherits(proto.aitmed.ecos.v1beta1.Vertex, googleProtobuf.Message);
	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */


	  proto.aitmed.ecos.v1beta1.Edge = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };

	  goog.inherits(proto.aitmed.ecos.v1beta1.Edge, googleProtobuf.Message);
	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */


	  proto.aitmed.ecos.v1beta1.Doc = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };

	  goog.inherits(proto.aitmed.ecos.v1beta1.Doc, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.aitmed.ecos.v1beta1.Vertex.prototype.toObject = function (opt_includeInstance) {
	      return proto.aitmed.ecos.v1beta1.Vertex.toObject(opt_includeInstance, this);
	    };
	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.aitmed.ecos.v1beta1.Vertex} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */


	    proto.aitmed.ecos.v1beta1.Vertex.toObject = function (includeInstance, msg) {
	      var obj = {
	        ctime: googleProtobuf.Message.getFieldWithDefault(msg, 1, 0),
	        mtime: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        atime: googleProtobuf.Message.getFieldWithDefault(msg, 3, 0),
	        atimes: googleProtobuf.Message.getFieldWithDefault(msg, 4, 0),
	        tage: googleProtobuf.Message.getFieldWithDefault(msg, 5, 0),
	        id: msg.getId_asB64(),
	        type: googleProtobuf.Message.getFieldWithDefault(msg, 7, 0),
	        name: googleProtobuf.Message.getFieldWithDefault(msg, 8, ""),
	        deat: googleProtobuf.Message.getFieldWithDefault(msg, 9, ""),
	        pk: msg.getPk_asB64(),
	        esk: msg.getEsk_asB64(),
	        uid: googleProtobuf.Message.getFieldWithDefault(msg, 12, "")
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }

	      return obj;
	    };
	  }
	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.aitmed.ecos.v1beta1.Vertex}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.aitmed.ecos.v1beta1.Vertex();
	    return proto.aitmed.ecos.v1beta1.Vertex.deserializeBinaryFromReader(msg, reader);
	  };
	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.aitmed.ecos.v1beta1.Vertex} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.aitmed.ecos.v1beta1.Vertex}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }

	      var field = reader.getFieldNumber();

	      switch (field) {
	        case 1:
	          var value =
	          /** @type {number} */
	          reader.readInt64();
	          msg.setCtime(value);
	          break;

	        case 2:
	          var value =
	          /** @type {number} */
	          reader.readInt64();
	          msg.setMtime(value);
	          break;

	        case 3:
	          var value =
	          /** @type {number} */
	          reader.readInt64();
	          msg.setAtime(value);
	          break;

	        case 4:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setAtimes(value);
	          break;

	        case 5:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setTage(value);
	          break;

	        case 6:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.setId(value);
	          break;

	        case 7:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setType(value);
	          break;

	        case 8:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setName(value);
	          break;

	        case 9:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setDeat(value);
	          break;

	        case 10:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.setPk(value);
	          break;

	        case 11:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.setEsk(value);
	          break;

	        case 12:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setUid(value);
	          break;

	        default:
	          reader.skipField();
	          break;
	      }
	    }

	    return msg;
	  };
	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.aitmed.ecos.v1beta1.Vertex.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };
	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.aitmed.ecos.v1beta1.Vertex} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getCtime();

	    if (f !== 0) {
	      writer.writeInt64(1, f);
	    }

	    f = message.getMtime();

	    if (f !== 0) {
	      writer.writeInt64(2, f);
	    }

	    f = message.getAtime();

	    if (f !== 0) {
	      writer.writeInt64(3, f);
	    }

	    f = message.getAtimes();

	    if (f !== 0) {
	      writer.writeInt32(4, f);
	    }

	    f = message.getTage();

	    if (f !== 0) {
	      writer.writeInt32(5, f);
	    }

	    f = message.getId_asU8();

	    if (f.length > 0) {
	      writer.writeBytes(6, f);
	    }

	    f = message.getType();

	    if (f !== 0) {
	      writer.writeInt32(7, f);
	    }

	    f = message.getName();

	    if (f.length > 0) {
	      writer.writeString(8, f);
	    }

	    f = message.getDeat();

	    if (f.length > 0) {
	      writer.writeString(9, f);
	    }

	    f = message.getPk_asU8();

	    if (f.length > 0) {
	      writer.writeBytes(10, f);
	    }

	    f = message.getEsk_asU8();

	    if (f.length > 0) {
	      writer.writeBytes(11, f);
	    }

	    f = message.getUid();

	    if (f.length > 0) {
	      writer.writeString(12, f);
	    }
	  };
	  /**
	   * optional int64 ctime = 1;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getCtime = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 1, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.setCtime = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 1, value);
	  };
	  /**
	   * optional int64 mtime = 2;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getMtime = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.setMtime = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 2, value);
	  };
	  /**
	   * optional int64 atime = 3;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getAtime = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 3, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.setAtime = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 3, value);
	  };
	  /**
	   * optional int32 atimes = 4;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getAtimes = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 4, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.setAtimes = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 4, value);
	  };
	  /**
	   * optional int32 tage = 5;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getTage = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 5, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.setTage = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 5, value);
	  };
	  /**
	   * optional bytes id = 6;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getId = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 6, "")
	    );
	  };
	  /**
	   * optional bytes id = 6;
	   * This is a type-conversion wrapper around `getId()`
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getId_asB64 = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.bytesAsB64(this.getId())
	    );
	  };
	  /**
	   * optional bytes id = 6;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getId()`
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getId_asU8 = function () {
	    return (
	      /** @type {!Uint8Array} */
	      googleProtobuf.Message.bytesAsU8(this.getId())
	    );
	  };
	  /** @param {!(string|Uint8Array)} value */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.setId = function (value) {
	    googleProtobuf.Message.setProto3BytesField(this, 6, value);
	  };
	  /**
	   * optional int32 type = 7;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getType = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 7, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.setType = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 7, value);
	  };
	  /**
	   * optional string name = 8;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getName = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 8, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.setName = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 8, value);
	  };
	  /**
	   * optional string deat = 9;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getDeat = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 9, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.setDeat = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 9, value);
	  };
	  /**
	   * optional bytes pk = 10;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getPk = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 10, "")
	    );
	  };
	  /**
	   * optional bytes pk = 10;
	   * This is a type-conversion wrapper around `getPk()`
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getPk_asB64 = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.bytesAsB64(this.getPk())
	    );
	  };
	  /**
	   * optional bytes pk = 10;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getPk()`
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getPk_asU8 = function () {
	    return (
	      /** @type {!Uint8Array} */
	      googleProtobuf.Message.bytesAsU8(this.getPk())
	    );
	  };
	  /** @param {!(string|Uint8Array)} value */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.setPk = function (value) {
	    googleProtobuf.Message.setProto3BytesField(this, 10, value);
	  };
	  /**
	   * optional bytes esk = 11;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getEsk = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 11, "")
	    );
	  };
	  /**
	   * optional bytes esk = 11;
	   * This is a type-conversion wrapper around `getEsk()`
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getEsk_asB64 = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.bytesAsB64(this.getEsk())
	    );
	  };
	  /**
	   * optional bytes esk = 11;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getEsk()`
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getEsk_asU8 = function () {
	    return (
	      /** @type {!Uint8Array} */
	      googleProtobuf.Message.bytesAsU8(this.getEsk())
	    );
	  };
	  /** @param {!(string|Uint8Array)} value */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.setEsk = function (value) {
	    googleProtobuf.Message.setProto3BytesField(this, 11, value);
	  };
	  /**
	   * optional string uid = 12;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.getUid = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 12, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.Vertex.prototype.setUid = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 12, value);
	  };

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.aitmed.ecos.v1beta1.Edge.prototype.toObject = function (opt_includeInstance) {
	      return proto.aitmed.ecos.v1beta1.Edge.toObject(opt_includeInstance, this);
	    };
	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.aitmed.ecos.v1beta1.Edge} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */


	    proto.aitmed.ecos.v1beta1.Edge.toObject = function (includeInstance, msg) {
	      var obj = {
	        ctime: googleProtobuf.Message.getFieldWithDefault(msg, 1, 0),
	        mtime: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        atime: googleProtobuf.Message.getFieldWithDefault(msg, 3, 0),
	        atimes: googleProtobuf.Message.getFieldWithDefault(msg, 4, 0),
	        tage: googleProtobuf.Message.getFieldWithDefault(msg, 5, 0),
	        id: msg.getId_asB64(),
	        type: googleProtobuf.Message.getFieldWithDefault(msg, 7, 0),
	        name: googleProtobuf.Message.getFieldWithDefault(msg, 8, ""),
	        deat: googleProtobuf.Message.getFieldWithDefault(msg, 9, ""),
	        subtype: googleProtobuf.Message.getFieldWithDefault(msg, 10, 0),
	        bvid: msg.getBvid_asB64(),
	        evid: msg.getEvid_asB64(),
	        stime: googleProtobuf.Message.getFieldWithDefault(msg, 13, 0),
	        etime: googleProtobuf.Message.getFieldWithDefault(msg, 14, 0),
	        refid: msg.getRefid_asB64(),
	        besak: msg.getBesak_asB64(),
	        eesak: msg.getEesak_asB64(),
	        sig: msg.getSig_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }

	      return obj;
	    };
	  }
	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.aitmed.ecos.v1beta1.Edge}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.aitmed.ecos.v1beta1.Edge();
	    return proto.aitmed.ecos.v1beta1.Edge.deserializeBinaryFromReader(msg, reader);
	  };
	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.aitmed.ecos.v1beta1.Edge} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.aitmed.ecos.v1beta1.Edge}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }

	      var field = reader.getFieldNumber();

	      switch (field) {
	        case 1:
	          var value =
	          /** @type {number} */
	          reader.readInt64();
	          msg.setCtime(value);
	          break;

	        case 2:
	          var value =
	          /** @type {number} */
	          reader.readInt64();
	          msg.setMtime(value);
	          break;

	        case 3:
	          var value =
	          /** @type {number} */
	          reader.readInt64();
	          msg.setAtime(value);
	          break;

	        case 4:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setAtimes(value);
	          break;

	        case 5:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setTage(value);
	          break;

	        case 6:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.setId(value);
	          break;

	        case 7:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setType(value);
	          break;

	        case 8:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setName(value);
	          break;

	        case 9:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setDeat(value);
	          break;

	        case 10:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setSubtype(value);
	          break;

	        case 11:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.setBvid(value);
	          break;

	        case 12:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.setEvid(value);
	          break;

	        case 13:
	          var value =
	          /** @type {number} */
	          reader.readInt64();
	          msg.setStime(value);
	          break;

	        case 14:
	          var value =
	          /** @type {number} */
	          reader.readInt64();
	          msg.setEtime(value);
	          break;

	        case 15:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.setRefid(value);
	          break;

	        case 16:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.setBesak(value);
	          break;

	        case 17:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.setEesak(value);
	          break;

	        case 18:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.setSig(value);
	          break;

	        default:
	          reader.skipField();
	          break;
	      }
	    }

	    return msg;
	  };
	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.aitmed.ecos.v1beta1.Edge.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };
	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.aitmed.ecos.v1beta1.Edge} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */


	  proto.aitmed.ecos.v1beta1.Edge.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getCtime();

	    if (f !== 0) {
	      writer.writeInt64(1, f);
	    }

	    f = message.getMtime();

	    if (f !== 0) {
	      writer.writeInt64(2, f);
	    }

	    f = message.getAtime();

	    if (f !== 0) {
	      writer.writeInt64(3, f);
	    }

	    f = message.getAtimes();

	    if (f !== 0) {
	      writer.writeInt32(4, f);
	    }

	    f = message.getTage();

	    if (f !== 0) {
	      writer.writeInt32(5, f);
	    }

	    f = message.getId_asU8();

	    if (f.length > 0) {
	      writer.writeBytes(6, f);
	    }

	    f = message.getType();

	    if (f !== 0) {
	      writer.writeInt32(7, f);
	    }

	    f = message.getName();

	    if (f.length > 0) {
	      writer.writeString(8, f);
	    }

	    f = message.getDeat();

	    if (f.length > 0) {
	      writer.writeString(9, f);
	    }

	    f = message.getSubtype();

	    if (f !== 0) {
	      writer.writeInt32(10, f);
	    }

	    f = message.getBvid_asU8();

	    if (f.length > 0) {
	      writer.writeBytes(11, f);
	    }

	    f = message.getEvid_asU8();

	    if (f.length > 0) {
	      writer.writeBytes(12, f);
	    }

	    f = message.getStime();

	    if (f !== 0) {
	      writer.writeInt64(13, f);
	    }

	    f = message.getEtime();

	    if (f !== 0) {
	      writer.writeInt64(14, f);
	    }

	    f = message.getRefid_asU8();

	    if (f.length > 0) {
	      writer.writeBytes(15, f);
	    }

	    f = message.getBesak_asU8();

	    if (f.length > 0) {
	      writer.writeBytes(16, f);
	    }

	    f = message.getEesak_asU8();

	    if (f.length > 0) {
	      writer.writeBytes(17, f);
	    }

	    f = message.getSig_asU8();

	    if (f.length > 0) {
	      writer.writeBytes(18, f);
	    }
	  };
	  /**
	   * optional int64 ctime = 1;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getCtime = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 1, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setCtime = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 1, value);
	  };
	  /**
	   * optional int64 mtime = 2;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getMtime = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setMtime = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 2, value);
	  };
	  /**
	   * optional int64 atime = 3;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getAtime = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 3, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setAtime = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 3, value);
	  };
	  /**
	   * optional int32 atimes = 4;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getAtimes = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 4, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setAtimes = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 4, value);
	  };
	  /**
	   * optional int32 tage = 5;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getTage = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 5, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setTage = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 5, value);
	  };
	  /**
	   * optional bytes id = 6;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getId = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 6, "")
	    );
	  };
	  /**
	   * optional bytes id = 6;
	   * This is a type-conversion wrapper around `getId()`
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getId_asB64 = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.bytesAsB64(this.getId())
	    );
	  };
	  /**
	   * optional bytes id = 6;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getId()`
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getId_asU8 = function () {
	    return (
	      /** @type {!Uint8Array} */
	      googleProtobuf.Message.bytesAsU8(this.getId())
	    );
	  };
	  /** @param {!(string|Uint8Array)} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setId = function (value) {
	    googleProtobuf.Message.setProto3BytesField(this, 6, value);
	  };
	  /**
	   * optional int32 type = 7;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getType = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 7, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setType = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 7, value);
	  };
	  /**
	   * optional string name = 8;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getName = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 8, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setName = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 8, value);
	  };
	  /**
	   * optional string deat = 9;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getDeat = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 9, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setDeat = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 9, value);
	  };
	  /**
	   * optional int32 subtype = 10;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getSubtype = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 10, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setSubtype = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 10, value);
	  };
	  /**
	   * optional bytes bvid = 11;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getBvid = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 11, "")
	    );
	  };
	  /**
	   * optional bytes bvid = 11;
	   * This is a type-conversion wrapper around `getBvid()`
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getBvid_asB64 = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.bytesAsB64(this.getBvid())
	    );
	  };
	  /**
	   * optional bytes bvid = 11;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getBvid()`
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getBvid_asU8 = function () {
	    return (
	      /** @type {!Uint8Array} */
	      googleProtobuf.Message.bytesAsU8(this.getBvid())
	    );
	  };
	  /** @param {!(string|Uint8Array)} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setBvid = function (value) {
	    googleProtobuf.Message.setProto3BytesField(this, 11, value);
	  };
	  /**
	   * optional bytes evid = 12;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getEvid = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 12, "")
	    );
	  };
	  /**
	   * optional bytes evid = 12;
	   * This is a type-conversion wrapper around `getEvid()`
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getEvid_asB64 = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.bytesAsB64(this.getEvid())
	    );
	  };
	  /**
	   * optional bytes evid = 12;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getEvid()`
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getEvid_asU8 = function () {
	    return (
	      /** @type {!Uint8Array} */
	      googleProtobuf.Message.bytesAsU8(this.getEvid())
	    );
	  };
	  /** @param {!(string|Uint8Array)} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setEvid = function (value) {
	    googleProtobuf.Message.setProto3BytesField(this, 12, value);
	  };
	  /**
	   * optional int64 stime = 13;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getStime = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 13, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setStime = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 13, value);
	  };
	  /**
	   * optional int64 etime = 14;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getEtime = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 14, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setEtime = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 14, value);
	  };
	  /**
	   * optional bytes refid = 15;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getRefid = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 15, "")
	    );
	  };
	  /**
	   * optional bytes refid = 15;
	   * This is a type-conversion wrapper around `getRefid()`
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getRefid_asB64 = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.bytesAsB64(this.getRefid())
	    );
	  };
	  /**
	   * optional bytes refid = 15;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getRefid()`
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getRefid_asU8 = function () {
	    return (
	      /** @type {!Uint8Array} */
	      googleProtobuf.Message.bytesAsU8(this.getRefid())
	    );
	  };
	  /** @param {!(string|Uint8Array)} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setRefid = function (value) {
	    googleProtobuf.Message.setProto3BytesField(this, 15, value);
	  };
	  /**
	   * optional bytes besak = 16;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getBesak = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 16, "")
	    );
	  };
	  /**
	   * optional bytes besak = 16;
	   * This is a type-conversion wrapper around `getBesak()`
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getBesak_asB64 = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.bytesAsB64(this.getBesak())
	    );
	  };
	  /**
	   * optional bytes besak = 16;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getBesak()`
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getBesak_asU8 = function () {
	    return (
	      /** @type {!Uint8Array} */
	      googleProtobuf.Message.bytesAsU8(this.getBesak())
	    );
	  };
	  /** @param {!(string|Uint8Array)} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setBesak = function (value) {
	    googleProtobuf.Message.setProto3BytesField(this, 16, value);
	  };
	  /**
	   * optional bytes eesak = 17;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getEesak = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 17, "")
	    );
	  };
	  /**
	   * optional bytes eesak = 17;
	   * This is a type-conversion wrapper around `getEesak()`
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getEesak_asB64 = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.bytesAsB64(this.getEesak())
	    );
	  };
	  /**
	   * optional bytes eesak = 17;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getEesak()`
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getEesak_asU8 = function () {
	    return (
	      /** @type {!Uint8Array} */
	      googleProtobuf.Message.bytesAsU8(this.getEesak())
	    );
	  };
	  /** @param {!(string|Uint8Array)} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setEesak = function (value) {
	    googleProtobuf.Message.setProto3BytesField(this, 17, value);
	  };
	  /**
	   * optional bytes sig = 18;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getSig = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 18, "")
	    );
	  };
	  /**
	   * optional bytes sig = 18;
	   * This is a type-conversion wrapper around `getSig()`
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getSig_asB64 = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.bytesAsB64(this.getSig())
	    );
	  };
	  /**
	   * optional bytes sig = 18;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getSig()`
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.getSig_asU8 = function () {
	    return (
	      /** @type {!Uint8Array} */
	      googleProtobuf.Message.bytesAsU8(this.getSig())
	    );
	  };
	  /** @param {!(string|Uint8Array)} value */


	  proto.aitmed.ecos.v1beta1.Edge.prototype.setSig = function (value) {
	    googleProtobuf.Message.setProto3BytesField(this, 18, value);
	  };

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.aitmed.ecos.v1beta1.Doc.prototype.toObject = function (opt_includeInstance) {
	      return proto.aitmed.ecos.v1beta1.Doc.toObject(opt_includeInstance, this);
	    };
	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.aitmed.ecos.v1beta1.Doc} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */


	    proto.aitmed.ecos.v1beta1.Doc.toObject = function (includeInstance, msg) {
	      var obj = {
	        ctime: googleProtobuf.Message.getFieldWithDefault(msg, 1, 0),
	        mtime: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        atime: googleProtobuf.Message.getFieldWithDefault(msg, 3, 0),
	        atimes: googleProtobuf.Message.getFieldWithDefault(msg, 4, 0),
	        tage: googleProtobuf.Message.getFieldWithDefault(msg, 5, 0),
	        id: msg.getId_asB64(),
	        type: googleProtobuf.Message.getFieldWithDefault(msg, 7, 0),
	        name: googleProtobuf.Message.getFieldWithDefault(msg, 8, ""),
	        deat: googleProtobuf.Message.getFieldWithDefault(msg, 9, ""),
	        size: googleProtobuf.Message.getFieldWithDefault(msg, 10, 0),
	        fid: msg.getFid_asB64(),
	        eid: msg.getEid_asB64(),
	        bsig: msg.getBsig_asB64(),
	        esig: msg.getEsig_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }

	      return obj;
	    };
	  }
	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.aitmed.ecos.v1beta1.Doc}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.aitmed.ecos.v1beta1.Doc();
	    return proto.aitmed.ecos.v1beta1.Doc.deserializeBinaryFromReader(msg, reader);
	  };
	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.aitmed.ecos.v1beta1.Doc} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.aitmed.ecos.v1beta1.Doc}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }

	      var field = reader.getFieldNumber();

	      switch (field) {
	        case 1:
	          var value =
	          /** @type {number} */
	          reader.readInt64();
	          msg.setCtime(value);
	          break;

	        case 2:
	          var value =
	          /** @type {number} */
	          reader.readInt64();
	          msg.setMtime(value);
	          break;

	        case 3:
	          var value =
	          /** @type {number} */
	          reader.readInt64();
	          msg.setAtime(value);
	          break;

	        case 4:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setAtimes(value);
	          break;

	        case 5:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setTage(value);
	          break;

	        case 6:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.setId(value);
	          break;

	        case 7:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setType(value);
	          break;

	        case 8:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setName(value);
	          break;

	        case 9:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setDeat(value);
	          break;

	        case 10:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setSize(value);
	          break;

	        case 11:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.setFid(value);
	          break;

	        case 12:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.setEid(value);
	          break;

	        case 13:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.setBsig(value);
	          break;

	        case 14:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.setEsig(value);
	          break;

	        default:
	          reader.skipField();
	          break;
	      }
	    }

	    return msg;
	  };
	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.aitmed.ecos.v1beta1.Doc.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };
	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.aitmed.ecos.v1beta1.Doc} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */


	  proto.aitmed.ecos.v1beta1.Doc.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getCtime();

	    if (f !== 0) {
	      writer.writeInt64(1, f);
	    }

	    f = message.getMtime();

	    if (f !== 0) {
	      writer.writeInt64(2, f);
	    }

	    f = message.getAtime();

	    if (f !== 0) {
	      writer.writeInt64(3, f);
	    }

	    f = message.getAtimes();

	    if (f !== 0) {
	      writer.writeInt32(4, f);
	    }

	    f = message.getTage();

	    if (f !== 0) {
	      writer.writeInt32(5, f);
	    }

	    f = message.getId_asU8();

	    if (f.length > 0) {
	      writer.writeBytes(6, f);
	    }

	    f = message.getType();

	    if (f !== 0) {
	      writer.writeInt32(7, f);
	    }

	    f = message.getName();

	    if (f.length > 0) {
	      writer.writeString(8, f);
	    }

	    f = message.getDeat();

	    if (f.length > 0) {
	      writer.writeString(9, f);
	    }

	    f = message.getSize();

	    if (f !== 0) {
	      writer.writeInt32(10, f);
	    }

	    f = message.getFid_asU8();

	    if (f.length > 0) {
	      writer.writeBytes(11, f);
	    }

	    f = message.getEid_asU8();

	    if (f.length > 0) {
	      writer.writeBytes(12, f);
	    }

	    f = message.getBsig_asU8();

	    if (f.length > 0) {
	      writer.writeBytes(13, f);
	    }

	    f = message.getEsig_asU8();

	    if (f.length > 0) {
	      writer.writeBytes(14, f);
	    }
	  };
	  /**
	   * optional int64 ctime = 1;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getCtime = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 1, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.setCtime = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 1, value);
	  };
	  /**
	   * optional int64 mtime = 2;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getMtime = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.setMtime = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 2, value);
	  };
	  /**
	   * optional int64 atime = 3;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getAtime = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 3, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.setAtime = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 3, value);
	  };
	  /**
	   * optional int32 atimes = 4;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getAtimes = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 4, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.setAtimes = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 4, value);
	  };
	  /**
	   * optional int32 tage = 5;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getTage = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 5, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.setTage = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 5, value);
	  };
	  /**
	   * optional bytes id = 6;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getId = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 6, "")
	    );
	  };
	  /**
	   * optional bytes id = 6;
	   * This is a type-conversion wrapper around `getId()`
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getId_asB64 = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.bytesAsB64(this.getId())
	    );
	  };
	  /**
	   * optional bytes id = 6;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getId()`
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getId_asU8 = function () {
	    return (
	      /** @type {!Uint8Array} */
	      googleProtobuf.Message.bytesAsU8(this.getId())
	    );
	  };
	  /** @param {!(string|Uint8Array)} value */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.setId = function (value) {
	    googleProtobuf.Message.setProto3BytesField(this, 6, value);
	  };
	  /**
	   * optional int32 type = 7;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getType = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 7, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.setType = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 7, value);
	  };
	  /**
	   * optional string name = 8;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getName = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 8, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.setName = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 8, value);
	  };
	  /**
	   * optional string deat = 9;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getDeat = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 9, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.setDeat = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 9, value);
	  };
	  /**
	   * optional int32 size = 10;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getSize = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 10, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.setSize = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 10, value);
	  };
	  /**
	   * optional bytes fid = 11;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getFid = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 11, "")
	    );
	  };
	  /**
	   * optional bytes fid = 11;
	   * This is a type-conversion wrapper around `getFid()`
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getFid_asB64 = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.bytesAsB64(this.getFid())
	    );
	  };
	  /**
	   * optional bytes fid = 11;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getFid()`
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getFid_asU8 = function () {
	    return (
	      /** @type {!Uint8Array} */
	      googleProtobuf.Message.bytesAsU8(this.getFid())
	    );
	  };
	  /** @param {!(string|Uint8Array)} value */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.setFid = function (value) {
	    googleProtobuf.Message.setProto3BytesField(this, 11, value);
	  };
	  /**
	   * optional bytes eid = 12;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getEid = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 12, "")
	    );
	  };
	  /**
	   * optional bytes eid = 12;
	   * This is a type-conversion wrapper around `getEid()`
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getEid_asB64 = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.bytesAsB64(this.getEid())
	    );
	  };
	  /**
	   * optional bytes eid = 12;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getEid()`
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getEid_asU8 = function () {
	    return (
	      /** @type {!Uint8Array} */
	      googleProtobuf.Message.bytesAsU8(this.getEid())
	    );
	  };
	  /** @param {!(string|Uint8Array)} value */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.setEid = function (value) {
	    googleProtobuf.Message.setProto3BytesField(this, 12, value);
	  };
	  /**
	   * optional bytes bsig = 13;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getBsig = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 13, "")
	    );
	  };
	  /**
	   * optional bytes bsig = 13;
	   * This is a type-conversion wrapper around `getBsig()`
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getBsig_asB64 = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.bytesAsB64(this.getBsig())
	    );
	  };
	  /**
	   * optional bytes bsig = 13;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getBsig()`
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getBsig_asU8 = function () {
	    return (
	      /** @type {!Uint8Array} */
	      googleProtobuf.Message.bytesAsU8(this.getBsig())
	    );
	  };
	  /** @param {!(string|Uint8Array)} value */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.setBsig = function (value) {
	    googleProtobuf.Message.setProto3BytesField(this, 13, value);
	  };
	  /**
	   * optional bytes esig = 14;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getEsig = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 14, "")
	    );
	  };
	  /**
	   * optional bytes esig = 14;
	   * This is a type-conversion wrapper around `getEsig()`
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getEsig_asB64 = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.bytesAsB64(this.getEsig())
	    );
	  };
	  /**
	   * optional bytes esig = 14;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getEsig()`
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.getEsig_asU8 = function () {
	    return (
	      /** @type {!Uint8Array} */
	      googleProtobuf.Message.bytesAsU8(this.getEsig())
	    );
	  };
	  /** @param {!(string|Uint8Array)} value */


	  proto.aitmed.ecos.v1beta1.Doc.prototype.setEsig = function (value) {
	    googleProtobuf.Message.setProto3BytesField(this, 14, value);
	  };

	  goog.object.extend(exports, proto.aitmed.ecos.v1beta1);
	});
	var types_pb_1 = types_pb.Edge;
	var types_pb_2 = types_pb.Vertex;
	var types_pb_3 = types_pb.Doc;

	var ecos_api_pb = createCommonjsModule$1$1(function (module, exports) {
	  /**
	   * @fileoverview
	   * @enhanceable
	   * @suppress {messageConventions} JS Compiler reports an error if a variable or
	   *     field starts with 'MSG_' and isn't a translatable message.
	   * @public
	   */
	  // GENERATED CODE -- DO NOT EDIT!
	  var goog = googleProtobuf;
	  var global = Function('return this')();
	  goog.object.extend(proto, field_mask_pb);
	  goog.object.extend(proto, types_pb);
	  goog.exportSymbol('proto.aitmed.ecos.v1beta1.cdReq', null, global);
	  goog.exportSymbol('proto.aitmed.ecos.v1beta1.cdResp', null, global);
	  goog.exportSymbol('proto.aitmed.ecos.v1beta1.ceReq', null, global);
	  goog.exportSymbol('proto.aitmed.ecos.v1beta1.ceResp', null, global);
	  goog.exportSymbol('proto.aitmed.ecos.v1beta1.cvReq', null, global);
	  goog.exportSymbol('proto.aitmed.ecos.v1beta1.cvResp', null, global);
	  goog.exportSymbol('proto.aitmed.ecos.v1beta1.dxReq', null, global);
	  goog.exportSymbol('proto.aitmed.ecos.v1beta1.dxResp', null, global);
	  goog.exportSymbol('proto.aitmed.ecos.v1beta1.rdResp', null, global);
	  goog.exportSymbol('proto.aitmed.ecos.v1beta1.reResp', null, global);
	  goog.exportSymbol('proto.aitmed.ecos.v1beta1.rvResp', null, global);
	  goog.exportSymbol('proto.aitmed.ecos.v1beta1.rxReq', null, global);
	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */

	  proto.aitmed.ecos.v1beta1.ceReq = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };

	  goog.inherits(proto.aitmed.ecos.v1beta1.ceReq, googleProtobuf.Message);
	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */


	  proto.aitmed.ecos.v1beta1.ceResp = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };

	  goog.inherits(proto.aitmed.ecos.v1beta1.ceResp, googleProtobuf.Message);
	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */


	  proto.aitmed.ecos.v1beta1.rxReq = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.aitmed.ecos.v1beta1.rxReq.repeatedFields_, null);
	  };

	  goog.inherits(proto.aitmed.ecos.v1beta1.rxReq, googleProtobuf.Message);
	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */


	  proto.aitmed.ecos.v1beta1.reResp = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.aitmed.ecos.v1beta1.reResp.repeatedFields_, null);
	  };

	  goog.inherits(proto.aitmed.ecos.v1beta1.reResp, googleProtobuf.Message);
	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */


	  proto.aitmed.ecos.v1beta1.rvResp = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.aitmed.ecos.v1beta1.rvResp.repeatedFields_, null);
	  };

	  goog.inherits(proto.aitmed.ecos.v1beta1.rvResp, googleProtobuf.Message);
	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */


	  proto.aitmed.ecos.v1beta1.rdResp = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.aitmed.ecos.v1beta1.rdResp.repeatedFields_, null);
	  };

	  goog.inherits(proto.aitmed.ecos.v1beta1.rdResp, googleProtobuf.Message);
	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */


	  proto.aitmed.ecos.v1beta1.dxReq = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.aitmed.ecos.v1beta1.dxReq.repeatedFields_, null);
	  };

	  goog.inherits(proto.aitmed.ecos.v1beta1.dxReq, googleProtobuf.Message);
	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */


	  proto.aitmed.ecos.v1beta1.dxResp = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };

	  goog.inherits(proto.aitmed.ecos.v1beta1.dxResp, googleProtobuf.Message);
	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */


	  proto.aitmed.ecos.v1beta1.cvReq = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };

	  goog.inherits(proto.aitmed.ecos.v1beta1.cvReq, googleProtobuf.Message);
	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */


	  proto.aitmed.ecos.v1beta1.cvResp = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };

	  goog.inherits(proto.aitmed.ecos.v1beta1.cvResp, googleProtobuf.Message);
	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */


	  proto.aitmed.ecos.v1beta1.cdReq = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };

	  goog.inherits(proto.aitmed.ecos.v1beta1.cdReq, googleProtobuf.Message);
	  /**
	   * Generated by JsPbCodeGenerator.
	   * @param {Array=} opt_data Optional initial data array, typically from a
	   * server response, or constructed directly in Javascript. The array is used
	   * in place and becomes part of the constructed object. It is not cloned.
	   * If no data is provided, the constructed object will be empty, but still
	   * valid.
	   * @extends {jspb.Message}
	   * @constructor
	   */


	  proto.aitmed.ecos.v1beta1.cdResp = function (opt_data) {
	    googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
	  };

	  goog.inherits(proto.aitmed.ecos.v1beta1.cdResp, googleProtobuf.Message);

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.aitmed.ecos.v1beta1.ceReq.prototype.toObject = function (opt_includeInstance) {
	      return proto.aitmed.ecos.v1beta1.ceReq.toObject(opt_includeInstance, this);
	    };
	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.aitmed.ecos.v1beta1.ceReq} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */


	    proto.aitmed.ecos.v1beta1.ceReq.toObject = function (includeInstance, msg) {
	      var f,
	          obj = {
	        jwt: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        pmask: (f = msg.getPmask()) && field_mask_pb.FieldMask.toObject(includeInstance, f),
	        rmask: (f = msg.getRmask()) && field_mask_pb.FieldMask.toObject(includeInstance, f),
	        edge: (f = msg.getEdge()) && types_pb.Edge.toObject(includeInstance, f)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }

	      return obj;
	    };
	  }
	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.aitmed.ecos.v1beta1.ceReq}
	   */


	  proto.aitmed.ecos.v1beta1.ceReq.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.aitmed.ecos.v1beta1.ceReq();
	    return proto.aitmed.ecos.v1beta1.ceReq.deserializeBinaryFromReader(msg, reader);
	  };
	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.aitmed.ecos.v1beta1.ceReq} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.aitmed.ecos.v1beta1.ceReq}
	   */


	  proto.aitmed.ecos.v1beta1.ceReq.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }

	      var field = reader.getFieldNumber();

	      switch (field) {
	        case 1:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setJwt(value);
	          break;

	        case 2:
	          var value = new field_mask_pb.FieldMask();
	          reader.readMessage(value, field_mask_pb.FieldMask.deserializeBinaryFromReader);
	          msg.setPmask(value);
	          break;

	        case 3:
	          var value = new field_mask_pb.FieldMask();
	          reader.readMessage(value, field_mask_pb.FieldMask.deserializeBinaryFromReader);
	          msg.setRmask(value);
	          break;

	        case 4:
	          var value = new types_pb.Edge();
	          reader.readMessage(value, types_pb.Edge.deserializeBinaryFromReader);
	          msg.setEdge(value);
	          break;

	        default:
	          reader.skipField();
	          break;
	      }
	    }

	    return msg;
	  };
	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.ceReq.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.aitmed.ecos.v1beta1.ceReq.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };
	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.aitmed.ecos.v1beta1.ceReq} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */


	  proto.aitmed.ecos.v1beta1.ceReq.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getJwt();

	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }

	    f = message.getPmask();

	    if (f != null) {
	      writer.writeMessage(2, f, field_mask_pb.FieldMask.serializeBinaryToWriter);
	    }

	    f = message.getRmask();

	    if (f != null) {
	      writer.writeMessage(3, f, field_mask_pb.FieldMask.serializeBinaryToWriter);
	    }

	    f = message.getEdge();

	    if (f != null) {
	      writer.writeMessage(4, f, types_pb.Edge.serializeBinaryToWriter);
	    }
	  };
	  /**
	   * optional string jwt = 1;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.ceReq.prototype.getJwt = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.ceReq.prototype.setJwt = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 1, value);
	  };
	  /**
	   * optional google.protobuf.FieldMask pmask = 2;
	   * @return {?proto.google.protobuf.FieldMask}
	   */


	  proto.aitmed.ecos.v1beta1.ceReq.prototype.getPmask = function () {
	    return (
	      /** @type{?proto.google.protobuf.FieldMask} */
	      googleProtobuf.Message.getWrapperField(this, field_mask_pb.FieldMask, 2)
	    );
	  };
	  /** @param {?proto.google.protobuf.FieldMask|undefined} value */


	  proto.aitmed.ecos.v1beta1.ceReq.prototype.setPmask = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 2, value);
	  };
	  /**
	   * Clears the message field making it undefined.
	   */


	  proto.aitmed.ecos.v1beta1.ceReq.prototype.clearPmask = function () {
	    this.setPmask(undefined);
	  };
	  /**
	   * Returns whether this field is set.
	   * @return {boolean}
	   */


	  proto.aitmed.ecos.v1beta1.ceReq.prototype.hasPmask = function () {
	    return googleProtobuf.Message.getField(this, 2) != null;
	  };
	  /**
	   * optional google.protobuf.FieldMask rmask = 3;
	   * @return {?proto.google.protobuf.FieldMask}
	   */


	  proto.aitmed.ecos.v1beta1.ceReq.prototype.getRmask = function () {
	    return (
	      /** @type{?proto.google.protobuf.FieldMask} */
	      googleProtobuf.Message.getWrapperField(this, field_mask_pb.FieldMask, 3)
	    );
	  };
	  /** @param {?proto.google.protobuf.FieldMask|undefined} value */


	  proto.aitmed.ecos.v1beta1.ceReq.prototype.setRmask = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 3, value);
	  };
	  /**
	   * Clears the message field making it undefined.
	   */


	  proto.aitmed.ecos.v1beta1.ceReq.prototype.clearRmask = function () {
	    this.setRmask(undefined);
	  };
	  /**
	   * Returns whether this field is set.
	   * @return {boolean}
	   */


	  proto.aitmed.ecos.v1beta1.ceReq.prototype.hasRmask = function () {
	    return googleProtobuf.Message.getField(this, 3) != null;
	  };
	  /**
	   * optional Edge edge = 4;
	   * @return {?proto.aitmed.ecos.v1beta1.Edge}
	   */


	  proto.aitmed.ecos.v1beta1.ceReq.prototype.getEdge = function () {
	    return (
	      /** @type{?proto.aitmed.ecos.v1beta1.Edge} */
	      googleProtobuf.Message.getWrapperField(this, types_pb.Edge, 4)
	    );
	  };
	  /** @param {?proto.aitmed.ecos.v1beta1.Edge|undefined} value */


	  proto.aitmed.ecos.v1beta1.ceReq.prototype.setEdge = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 4, value);
	  };
	  /**
	   * Clears the message field making it undefined.
	   */


	  proto.aitmed.ecos.v1beta1.ceReq.prototype.clearEdge = function () {
	    this.setEdge(undefined);
	  };
	  /**
	   * Returns whether this field is set.
	   * @return {boolean}
	   */


	  proto.aitmed.ecos.v1beta1.ceReq.prototype.hasEdge = function () {
	    return googleProtobuf.Message.getField(this, 4) != null;
	  };

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.aitmed.ecos.v1beta1.ceResp.prototype.toObject = function (opt_includeInstance) {
	      return proto.aitmed.ecos.v1beta1.ceResp.toObject(opt_includeInstance, this);
	    };
	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.aitmed.ecos.v1beta1.ceResp} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */


	    proto.aitmed.ecos.v1beta1.ceResp.toObject = function (includeInstance, msg) {
	      var f,
	          obj = {
	        jwt: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        code: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        error: googleProtobuf.Message.getFieldWithDefault(msg, 3, ""),
	        edge: (f = msg.getEdge()) && types_pb.Edge.toObject(includeInstance, f)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }

	      return obj;
	    };
	  }
	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.aitmed.ecos.v1beta1.ceResp}
	   */


	  proto.aitmed.ecos.v1beta1.ceResp.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.aitmed.ecos.v1beta1.ceResp();
	    return proto.aitmed.ecos.v1beta1.ceResp.deserializeBinaryFromReader(msg, reader);
	  };
	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.aitmed.ecos.v1beta1.ceResp} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.aitmed.ecos.v1beta1.ceResp}
	   */


	  proto.aitmed.ecos.v1beta1.ceResp.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }

	      var field = reader.getFieldNumber();

	      switch (field) {
	        case 1:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setJwt(value);
	          break;

	        case 2:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setCode(value);
	          break;

	        case 3:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setError(value);
	          break;

	        case 4:
	          var value = new types_pb.Edge();
	          reader.readMessage(value, types_pb.Edge.deserializeBinaryFromReader);
	          msg.setEdge(value);
	          break;

	        default:
	          reader.skipField();
	          break;
	      }
	    }

	    return msg;
	  };
	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.ceResp.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.aitmed.ecos.v1beta1.ceResp.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };
	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.aitmed.ecos.v1beta1.ceResp} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */


	  proto.aitmed.ecos.v1beta1.ceResp.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getJwt();

	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }

	    f = message.getCode();

	    if (f !== 0) {
	      writer.writeInt32(2, f);
	    }

	    f = message.getError();

	    if (f.length > 0) {
	      writer.writeString(3, f);
	    }

	    f = message.getEdge();

	    if (f != null) {
	      writer.writeMessage(4, f, types_pb.Edge.serializeBinaryToWriter);
	    }
	  };
	  /**
	   * optional string jwt = 1;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.ceResp.prototype.getJwt = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.ceResp.prototype.setJwt = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 1, value);
	  };
	  /**
	   * optional int32 code = 2;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.ceResp.prototype.getCode = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.ceResp.prototype.setCode = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 2, value);
	  };
	  /**
	   * optional string error = 3;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.ceResp.prototype.getError = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.ceResp.prototype.setError = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 3, value);
	  };
	  /**
	   * optional Edge edge = 4;
	   * @return {?proto.aitmed.ecos.v1beta1.Edge}
	   */


	  proto.aitmed.ecos.v1beta1.ceResp.prototype.getEdge = function () {
	    return (
	      /** @type{?proto.aitmed.ecos.v1beta1.Edge} */
	      googleProtobuf.Message.getWrapperField(this, types_pb.Edge, 4)
	    );
	  };
	  /** @param {?proto.aitmed.ecos.v1beta1.Edge|undefined} value */


	  proto.aitmed.ecos.v1beta1.ceResp.prototype.setEdge = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 4, value);
	  };
	  /**
	   * Clears the message field making it undefined.
	   */


	  proto.aitmed.ecos.v1beta1.ceResp.prototype.clearEdge = function () {
	    this.setEdge(undefined);
	  };
	  /**
	   * Returns whether this field is set.
	   * @return {boolean}
	   */


	  proto.aitmed.ecos.v1beta1.ceResp.prototype.hasEdge = function () {
	    return googleProtobuf.Message.getField(this, 4) != null;
	  };
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.repeatedFields_ = [5];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.aitmed.ecos.v1beta1.rxReq.prototype.toObject = function (opt_includeInstance) {
	      return proto.aitmed.ecos.v1beta1.rxReq.toObject(opt_includeInstance, this);
	    };
	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.aitmed.ecos.v1beta1.rxReq} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */


	    proto.aitmed.ecos.v1beta1.rxReq.toObject = function (includeInstance, msg) {
	      var f,
	          obj = {
	        jwt: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        pmask: (f = msg.getPmask()) && field_mask_pb.FieldMask.toObject(includeInstance, f),
	        rmask: (f = msg.getRmask()) && field_mask_pb.FieldMask.toObject(includeInstance, f),
	        objtype: googleProtobuf.Message.getFieldWithDefault(msg, 4, 0),
	        idList: msg.getIdList_asB64(),
	        xfname: googleProtobuf.Message.getFieldWithDefault(msg, 6, ""),
	        type: googleProtobuf.Message.getFieldWithDefault(msg, 7, 0),
	        key: googleProtobuf.Message.getFieldWithDefault(msg, 8, ""),
	        sfname: googleProtobuf.Message.getFieldWithDefault(msg, 9, ""),
	        loid: msg.getLoid_asB64(),
	        maxcount: googleProtobuf.Message.getFieldWithDefault(msg, 11, 0),
	        obfname: googleProtobuf.Message.getFieldWithDefault(msg, 12, ""),
	        scondition: googleProtobuf.Message.getFieldWithDefault(msg, 13, ""),
	        asc: googleProtobuf.Message.getFieldWithDefault(msg, 14, false)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }

	      return obj;
	    };
	  }
	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.aitmed.ecos.v1beta1.rxReq}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.aitmed.ecos.v1beta1.rxReq();
	    return proto.aitmed.ecos.v1beta1.rxReq.deserializeBinaryFromReader(msg, reader);
	  };
	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.aitmed.ecos.v1beta1.rxReq} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.aitmed.ecos.v1beta1.rxReq}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }

	      var field = reader.getFieldNumber();

	      switch (field) {
	        case 1:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setJwt(value);
	          break;

	        case 2:
	          var value = new field_mask_pb.FieldMask();
	          reader.readMessage(value, field_mask_pb.FieldMask.deserializeBinaryFromReader);
	          msg.setPmask(value);
	          break;

	        case 3:
	          var value = new field_mask_pb.FieldMask();
	          reader.readMessage(value, field_mask_pb.FieldMask.deserializeBinaryFromReader);
	          msg.setRmask(value);
	          break;

	        case 4:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setObjtype(value);
	          break;

	        case 5:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.addId(value);
	          break;

	        case 6:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setXfname(value);
	          break;

	        case 7:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setType(value);
	          break;

	        case 8:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setKey(value);
	          break;

	        case 9:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setSfname(value);
	          break;

	        case 10:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.setLoid(value);
	          break;

	        case 11:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setMaxcount(value);
	          break;

	        case 12:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setObfname(value);
	          break;

	        case 13:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setScondition(value);
	          break;

	        case 14:
	          var value =
	          /** @type {boolean} */
	          reader.readBool();
	          msg.setAsc(value);
	          break;

	        default:
	          reader.skipField();
	          break;
	      }
	    }

	    return msg;
	  };
	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.aitmed.ecos.v1beta1.rxReq.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };
	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.aitmed.ecos.v1beta1.rxReq} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getJwt();

	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }

	    f = message.getPmask();

	    if (f != null) {
	      writer.writeMessage(2, f, field_mask_pb.FieldMask.serializeBinaryToWriter);
	    }

	    f = message.getRmask();

	    if (f != null) {
	      writer.writeMessage(3, f, field_mask_pb.FieldMask.serializeBinaryToWriter);
	    }

	    f = message.getObjtype();

	    if (f !== 0) {
	      writer.writeInt32(4, f);
	    }

	    f = message.getIdList_asU8();

	    if (f.length > 0) {
	      writer.writeRepeatedBytes(5, f);
	    }

	    f = message.getXfname();

	    if (f.length > 0) {
	      writer.writeString(6, f);
	    }

	    f = message.getType();

	    if (f !== 0) {
	      writer.writeInt32(7, f);
	    }

	    f = message.getKey();

	    if (f.length > 0) {
	      writer.writeString(8, f);
	    }

	    f = message.getSfname();

	    if (f.length > 0) {
	      writer.writeString(9, f);
	    }

	    f = message.getLoid_asU8();

	    if (f.length > 0) {
	      writer.writeBytes(10, f);
	    }

	    f = message.getMaxcount();

	    if (f !== 0) {
	      writer.writeInt32(11, f);
	    }

	    f = message.getObfname();

	    if (f.length > 0) {
	      writer.writeString(12, f);
	    }

	    f = message.getScondition();

	    if (f.length > 0) {
	      writer.writeString(13, f);
	    }

	    f = message.getAsc();

	    if (f) {
	      writer.writeBool(14, f);
	    }
	  };
	  /**
	   * optional string jwt = 1;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getJwt = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.setJwt = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 1, value);
	  };
	  /**
	   * optional google.protobuf.FieldMask pmask = 2;
	   * @return {?proto.google.protobuf.FieldMask}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getPmask = function () {
	    return (
	      /** @type{?proto.google.protobuf.FieldMask} */
	      googleProtobuf.Message.getWrapperField(this, field_mask_pb.FieldMask, 2)
	    );
	  };
	  /** @param {?proto.google.protobuf.FieldMask|undefined} value */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.setPmask = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 2, value);
	  };
	  /**
	   * Clears the message field making it undefined.
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.clearPmask = function () {
	    this.setPmask(undefined);
	  };
	  /**
	   * Returns whether this field is set.
	   * @return {boolean}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.hasPmask = function () {
	    return googleProtobuf.Message.getField(this, 2) != null;
	  };
	  /**
	   * optional google.protobuf.FieldMask rmask = 3;
	   * @return {?proto.google.protobuf.FieldMask}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getRmask = function () {
	    return (
	      /** @type{?proto.google.protobuf.FieldMask} */
	      googleProtobuf.Message.getWrapperField(this, field_mask_pb.FieldMask, 3)
	    );
	  };
	  /** @param {?proto.google.protobuf.FieldMask|undefined} value */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.setRmask = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 3, value);
	  };
	  /**
	   * Clears the message field making it undefined.
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.clearRmask = function () {
	    this.setRmask(undefined);
	  };
	  /**
	   * Returns whether this field is set.
	   * @return {boolean}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.hasRmask = function () {
	    return googleProtobuf.Message.getField(this, 3) != null;
	  };
	  /**
	   * optional int32 ObjType = 4;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getObjtype = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 4, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.setObjtype = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 4, value);
	  };
	  /**
	   * repeated bytes id = 5;
	   * @return {!Array<string>}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getIdList = function () {
	    return (
	      /** @type {!Array<string>} */
	      googleProtobuf.Message.getRepeatedField(this, 5)
	    );
	  };
	  /**
	   * repeated bytes id = 5;
	   * This is a type-conversion wrapper around `getIdList()`
	   * @return {!Array<string>}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getIdList_asB64 = function () {
	    return (
	      /** @type {!Array<string>} */
	      googleProtobuf.Message.bytesListAsB64(this.getIdList())
	    );
	  };
	  /**
	   * repeated bytes id = 5;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getIdList()`
	   * @return {!Array<!Uint8Array>}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getIdList_asU8 = function () {
	    return (
	      /** @type {!Array<!Uint8Array>} */
	      googleProtobuf.Message.bytesListAsU8(this.getIdList())
	    );
	  };
	  /** @param {!(Array<!Uint8Array>|Array<string>)} value */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.setIdList = function (value) {
	    googleProtobuf.Message.setField(this, 5, value || []);
	  };
	  /**
	   * @param {!(string|Uint8Array)} value
	   * @param {number=} opt_index
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.addId = function (value, opt_index) {
	    googleProtobuf.Message.addToRepeatedField(this, 5, value, opt_index);
	  };
	  /**
	   * Clears the list making it empty but non-null.
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.clearIdList = function () {
	    this.setIdList([]);
	  };
	  /**
	   * optional string xfname = 6;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getXfname = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 6, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.setXfname = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 6, value);
	  };
	  /**
	   * optional int32 type = 7;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getType = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 7, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.setType = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 7, value);
	  };
	  /**
	   * optional string key = 8;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getKey = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 8, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.setKey = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 8, value);
	  };
	  /**
	   * optional string sfname = 9;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getSfname = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 9, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.setSfname = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 9, value);
	  };
	  /**
	   * optional bytes loid = 10;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getLoid = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 10, "")
	    );
	  };
	  /**
	   * optional bytes loid = 10;
	   * This is a type-conversion wrapper around `getLoid()`
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getLoid_asB64 = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.bytesAsB64(this.getLoid())
	    );
	  };
	  /**
	   * optional bytes loid = 10;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getLoid()`
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getLoid_asU8 = function () {
	    return (
	      /** @type {!Uint8Array} */
	      googleProtobuf.Message.bytesAsU8(this.getLoid())
	    );
	  };
	  /** @param {!(string|Uint8Array)} value */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.setLoid = function (value) {
	    googleProtobuf.Message.setProto3BytesField(this, 10, value);
	  };
	  /**
	   * optional int32 maxcount = 11;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getMaxcount = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 11, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.setMaxcount = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 11, value);
	  };
	  /**
	   * optional string obfname = 12;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getObfname = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 12, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.setObfname = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 12, value);
	  };
	  /**
	   * optional string sCondition = 13;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getScondition = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 13, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.setScondition = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 13, value);
	  };
	  /**
	   * optional bool asc = 14;
	   * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
	   * You should avoid comparisons like {@code val === true/false} in those cases.
	   * @return {boolean}
	   */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.getAsc = function () {
	    return (
	      /** @type {boolean} */
	      googleProtobuf.Message.getFieldWithDefault(this, 14, false)
	    );
	  };
	  /** @param {boolean} value */


	  proto.aitmed.ecos.v1beta1.rxReq.prototype.setAsc = function (value) {
	    googleProtobuf.Message.setProto3BooleanField(this, 14, value);
	  };
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */


	  proto.aitmed.ecos.v1beta1.reResp.repeatedFields_ = [4];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.aitmed.ecos.v1beta1.reResp.prototype.toObject = function (opt_includeInstance) {
	      return proto.aitmed.ecos.v1beta1.reResp.toObject(opt_includeInstance, this);
	    };
	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.aitmed.ecos.v1beta1.reResp} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */


	    proto.aitmed.ecos.v1beta1.reResp.toObject = function (includeInstance, msg) {
	      var obj = {
	        jwt: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        code: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        error: googleProtobuf.Message.getFieldWithDefault(msg, 3, ""),
	        edgeList: googleProtobuf.Message.toObjectList(msg.getEdgeList(), types_pb.Edge.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }

	      return obj;
	    };
	  }
	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.aitmed.ecos.v1beta1.reResp}
	   */


	  proto.aitmed.ecos.v1beta1.reResp.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.aitmed.ecos.v1beta1.reResp();
	    return proto.aitmed.ecos.v1beta1.reResp.deserializeBinaryFromReader(msg, reader);
	  };
	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.aitmed.ecos.v1beta1.reResp} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.aitmed.ecos.v1beta1.reResp}
	   */


	  proto.aitmed.ecos.v1beta1.reResp.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }

	      var field = reader.getFieldNumber();

	      switch (field) {
	        case 1:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setJwt(value);
	          break;

	        case 2:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setCode(value);
	          break;

	        case 3:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setError(value);
	          break;

	        case 4:
	          var value = new types_pb.Edge();
	          reader.readMessage(value, types_pb.Edge.deserializeBinaryFromReader);
	          msg.addEdge(value);
	          break;

	        default:
	          reader.skipField();
	          break;
	      }
	    }

	    return msg;
	  };
	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.reResp.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.aitmed.ecos.v1beta1.reResp.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };
	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.aitmed.ecos.v1beta1.reResp} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */


	  proto.aitmed.ecos.v1beta1.reResp.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getJwt();

	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }

	    f = message.getCode();

	    if (f !== 0) {
	      writer.writeInt32(2, f);
	    }

	    f = message.getError();

	    if (f.length > 0) {
	      writer.writeString(3, f);
	    }

	    f = message.getEdgeList();

	    if (f.length > 0) {
	      writer.writeRepeatedMessage(4, f, types_pb.Edge.serializeBinaryToWriter);
	    }
	  };
	  /**
	   * optional string jwt = 1;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.reResp.prototype.getJwt = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.reResp.prototype.setJwt = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 1, value);
	  };
	  /**
	   * optional int32 code = 2;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.reResp.prototype.getCode = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.reResp.prototype.setCode = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 2, value);
	  };
	  /**
	   * optional string error = 3;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.reResp.prototype.getError = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.reResp.prototype.setError = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 3, value);
	  };
	  /**
	   * repeated Edge edge = 4;
	   * @return {!Array<!proto.aitmed.ecos.v1beta1.Edge>}
	   */


	  proto.aitmed.ecos.v1beta1.reResp.prototype.getEdgeList = function () {
	    return (
	      /** @type{!Array<!proto.aitmed.ecos.v1beta1.Edge>} */
	      googleProtobuf.Message.getRepeatedWrapperField(this, types_pb.Edge, 4)
	    );
	  };
	  /** @param {!Array<!proto.aitmed.ecos.v1beta1.Edge>} value */


	  proto.aitmed.ecos.v1beta1.reResp.prototype.setEdgeList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 4, value);
	  };
	  /**
	   * @param {!proto.aitmed.ecos.v1beta1.Edge=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.aitmed.ecos.v1beta1.Edge}
	   */


	  proto.aitmed.ecos.v1beta1.reResp.prototype.addEdge = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.aitmed.ecos.v1beta1.Edge, opt_index);
	  };
	  /**
	   * Clears the list making it empty but non-null.
	   */


	  proto.aitmed.ecos.v1beta1.reResp.prototype.clearEdgeList = function () {
	    this.setEdgeList([]);
	  };
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */


	  proto.aitmed.ecos.v1beta1.rvResp.repeatedFields_ = [4];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.aitmed.ecos.v1beta1.rvResp.prototype.toObject = function (opt_includeInstance) {
	      return proto.aitmed.ecos.v1beta1.rvResp.toObject(opt_includeInstance, this);
	    };
	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.aitmed.ecos.v1beta1.rvResp} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */


	    proto.aitmed.ecos.v1beta1.rvResp.toObject = function (includeInstance, msg) {
	      var obj = {
	        jwt: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        code: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        error: googleProtobuf.Message.getFieldWithDefault(msg, 3, ""),
	        vertexList: googleProtobuf.Message.toObjectList(msg.getVertexList(), types_pb.Vertex.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }

	      return obj;
	    };
	  }
	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.aitmed.ecos.v1beta1.rvResp}
	   */


	  proto.aitmed.ecos.v1beta1.rvResp.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.aitmed.ecos.v1beta1.rvResp();
	    return proto.aitmed.ecos.v1beta1.rvResp.deserializeBinaryFromReader(msg, reader);
	  };
	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.aitmed.ecos.v1beta1.rvResp} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.aitmed.ecos.v1beta1.rvResp}
	   */


	  proto.aitmed.ecos.v1beta1.rvResp.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }

	      var field = reader.getFieldNumber();

	      switch (field) {
	        case 1:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setJwt(value);
	          break;

	        case 2:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setCode(value);
	          break;

	        case 3:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setError(value);
	          break;

	        case 4:
	          var value = new types_pb.Vertex();
	          reader.readMessage(value, types_pb.Vertex.deserializeBinaryFromReader);
	          msg.addVertex(value);
	          break;

	        default:
	          reader.skipField();
	          break;
	      }
	    }

	    return msg;
	  };
	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.rvResp.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.aitmed.ecos.v1beta1.rvResp.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };
	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.aitmed.ecos.v1beta1.rvResp} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */


	  proto.aitmed.ecos.v1beta1.rvResp.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getJwt();

	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }

	    f = message.getCode();

	    if (f !== 0) {
	      writer.writeInt32(2, f);
	    }

	    f = message.getError();

	    if (f.length > 0) {
	      writer.writeString(3, f);
	    }

	    f = message.getVertexList();

	    if (f.length > 0) {
	      writer.writeRepeatedMessage(4, f, types_pb.Vertex.serializeBinaryToWriter);
	    }
	  };
	  /**
	   * optional string jwt = 1;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.rvResp.prototype.getJwt = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.rvResp.prototype.setJwt = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 1, value);
	  };
	  /**
	   * optional int32 code = 2;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.rvResp.prototype.getCode = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.rvResp.prototype.setCode = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 2, value);
	  };
	  /**
	   * optional string error = 3;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.rvResp.prototype.getError = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.rvResp.prototype.setError = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 3, value);
	  };
	  /**
	   * repeated Vertex vertex = 4;
	   * @return {!Array<!proto.aitmed.ecos.v1beta1.Vertex>}
	   */


	  proto.aitmed.ecos.v1beta1.rvResp.prototype.getVertexList = function () {
	    return (
	      /** @type{!Array<!proto.aitmed.ecos.v1beta1.Vertex>} */
	      googleProtobuf.Message.getRepeatedWrapperField(this, types_pb.Vertex, 4)
	    );
	  };
	  /** @param {!Array<!proto.aitmed.ecos.v1beta1.Vertex>} value */


	  proto.aitmed.ecos.v1beta1.rvResp.prototype.setVertexList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 4, value);
	  };
	  /**
	   * @param {!proto.aitmed.ecos.v1beta1.Vertex=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.aitmed.ecos.v1beta1.Vertex}
	   */


	  proto.aitmed.ecos.v1beta1.rvResp.prototype.addVertex = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.aitmed.ecos.v1beta1.Vertex, opt_index);
	  };
	  /**
	   * Clears the list making it empty but non-null.
	   */


	  proto.aitmed.ecos.v1beta1.rvResp.prototype.clearVertexList = function () {
	    this.setVertexList([]);
	  };
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */


	  proto.aitmed.ecos.v1beta1.rdResp.repeatedFields_ = [4];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.aitmed.ecos.v1beta1.rdResp.prototype.toObject = function (opt_includeInstance) {
	      return proto.aitmed.ecos.v1beta1.rdResp.toObject(opt_includeInstance, this);
	    };
	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.aitmed.ecos.v1beta1.rdResp} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */


	    proto.aitmed.ecos.v1beta1.rdResp.toObject = function (includeInstance, msg) {
	      var obj = {
	        jwt: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        code: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        error: googleProtobuf.Message.getFieldWithDefault(msg, 3, ""),
	        docList: googleProtobuf.Message.toObjectList(msg.getDocList(), types_pb.Doc.toObject, includeInstance)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }

	      return obj;
	    };
	  }
	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.aitmed.ecos.v1beta1.rdResp}
	   */


	  proto.aitmed.ecos.v1beta1.rdResp.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.aitmed.ecos.v1beta1.rdResp();
	    return proto.aitmed.ecos.v1beta1.rdResp.deserializeBinaryFromReader(msg, reader);
	  };
	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.aitmed.ecos.v1beta1.rdResp} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.aitmed.ecos.v1beta1.rdResp}
	   */


	  proto.aitmed.ecos.v1beta1.rdResp.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }

	      var field = reader.getFieldNumber();

	      switch (field) {
	        case 1:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setJwt(value);
	          break;

	        case 2:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setCode(value);
	          break;

	        case 3:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setError(value);
	          break;

	        case 4:
	          var value = new types_pb.Doc();
	          reader.readMessage(value, types_pb.Doc.deserializeBinaryFromReader);
	          msg.addDoc(value);
	          break;

	        default:
	          reader.skipField();
	          break;
	      }
	    }

	    return msg;
	  };
	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.rdResp.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.aitmed.ecos.v1beta1.rdResp.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };
	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.aitmed.ecos.v1beta1.rdResp} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */


	  proto.aitmed.ecos.v1beta1.rdResp.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getJwt();

	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }

	    f = message.getCode();

	    if (f !== 0) {
	      writer.writeInt32(2, f);
	    }

	    f = message.getError();

	    if (f.length > 0) {
	      writer.writeString(3, f);
	    }

	    f = message.getDocList();

	    if (f.length > 0) {
	      writer.writeRepeatedMessage(4, f, types_pb.Doc.serializeBinaryToWriter);
	    }
	  };
	  /**
	   * optional string jwt = 1;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.rdResp.prototype.getJwt = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.rdResp.prototype.setJwt = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 1, value);
	  };
	  /**
	   * optional int32 code = 2;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.rdResp.prototype.getCode = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.rdResp.prototype.setCode = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 2, value);
	  };
	  /**
	   * optional string error = 3;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.rdResp.prototype.getError = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.rdResp.prototype.setError = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 3, value);
	  };
	  /**
	   * repeated Doc doc = 4;
	   * @return {!Array<!proto.aitmed.ecos.v1beta1.Doc>}
	   */


	  proto.aitmed.ecos.v1beta1.rdResp.prototype.getDocList = function () {
	    return (
	      /** @type{!Array<!proto.aitmed.ecos.v1beta1.Doc>} */
	      googleProtobuf.Message.getRepeatedWrapperField(this, types_pb.Doc, 4)
	    );
	  };
	  /** @param {!Array<!proto.aitmed.ecos.v1beta1.Doc>} value */


	  proto.aitmed.ecos.v1beta1.rdResp.prototype.setDocList = function (value) {
	    googleProtobuf.Message.setRepeatedWrapperField(this, 4, value);
	  };
	  /**
	   * @param {!proto.aitmed.ecos.v1beta1.Doc=} opt_value
	   * @param {number=} opt_index
	   * @return {!proto.aitmed.ecos.v1beta1.Doc}
	   */


	  proto.aitmed.ecos.v1beta1.rdResp.prototype.addDoc = function (opt_value, opt_index) {
	    return googleProtobuf.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.aitmed.ecos.v1beta1.Doc, opt_index);
	  };
	  /**
	   * Clears the list making it empty but non-null.
	   */


	  proto.aitmed.ecos.v1beta1.rdResp.prototype.clearDocList = function () {
	    this.setDocList([]);
	  };
	  /**
	   * List of repeated fields within this message type.
	   * @private {!Array<number>}
	   * @const
	   */


	  proto.aitmed.ecos.v1beta1.dxReq.repeatedFields_ = [2];

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.aitmed.ecos.v1beta1.dxReq.prototype.toObject = function (opt_includeInstance) {
	      return proto.aitmed.ecos.v1beta1.dxReq.toObject(opt_includeInstance, this);
	    };
	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.aitmed.ecos.v1beta1.dxReq} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */


	    proto.aitmed.ecos.v1beta1.dxReq.toObject = function (includeInstance, msg) {
	      var obj = {
	        jwt: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        idList: msg.getIdList_asB64()
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }

	      return obj;
	    };
	  }
	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.aitmed.ecos.v1beta1.dxReq}
	   */


	  proto.aitmed.ecos.v1beta1.dxReq.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.aitmed.ecos.v1beta1.dxReq();
	    return proto.aitmed.ecos.v1beta1.dxReq.deserializeBinaryFromReader(msg, reader);
	  };
	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.aitmed.ecos.v1beta1.dxReq} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.aitmed.ecos.v1beta1.dxReq}
	   */


	  proto.aitmed.ecos.v1beta1.dxReq.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }

	      var field = reader.getFieldNumber();

	      switch (field) {
	        case 1:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setJwt(value);
	          break;

	        case 2:
	          var value =
	          /** @type {!Uint8Array} */
	          reader.readBytes();
	          msg.addId(value);
	          break;

	        default:
	          reader.skipField();
	          break;
	      }
	    }

	    return msg;
	  };
	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.dxReq.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.aitmed.ecos.v1beta1.dxReq.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };
	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.aitmed.ecos.v1beta1.dxReq} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */


	  proto.aitmed.ecos.v1beta1.dxReq.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getJwt();

	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }

	    f = message.getIdList_asU8();

	    if (f.length > 0) {
	      writer.writeRepeatedBytes(2, f);
	    }
	  };
	  /**
	   * optional string jwt = 1;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.dxReq.prototype.getJwt = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.dxReq.prototype.setJwt = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 1, value);
	  };
	  /**
	   * repeated bytes id = 2;
	   * @return {!Array<string>}
	   */


	  proto.aitmed.ecos.v1beta1.dxReq.prototype.getIdList = function () {
	    return (
	      /** @type {!Array<string>} */
	      googleProtobuf.Message.getRepeatedField(this, 2)
	    );
	  };
	  /**
	   * repeated bytes id = 2;
	   * This is a type-conversion wrapper around `getIdList()`
	   * @return {!Array<string>}
	   */


	  proto.aitmed.ecos.v1beta1.dxReq.prototype.getIdList_asB64 = function () {
	    return (
	      /** @type {!Array<string>} */
	      googleProtobuf.Message.bytesListAsB64(this.getIdList())
	    );
	  };
	  /**
	   * repeated bytes id = 2;
	   * Note that Uint8Array is not supported on all browsers.
	   * @see http://caniuse.com/Uint8Array
	   * This is a type-conversion wrapper around `getIdList()`
	   * @return {!Array<!Uint8Array>}
	   */


	  proto.aitmed.ecos.v1beta1.dxReq.prototype.getIdList_asU8 = function () {
	    return (
	      /** @type {!Array<!Uint8Array>} */
	      googleProtobuf.Message.bytesListAsU8(this.getIdList())
	    );
	  };
	  /** @param {!(Array<!Uint8Array>|Array<string>)} value */


	  proto.aitmed.ecos.v1beta1.dxReq.prototype.setIdList = function (value) {
	    googleProtobuf.Message.setField(this, 2, value || []);
	  };
	  /**
	   * @param {!(string|Uint8Array)} value
	   * @param {number=} opt_index
	   */


	  proto.aitmed.ecos.v1beta1.dxReq.prototype.addId = function (value, opt_index) {
	    googleProtobuf.Message.addToRepeatedField(this, 2, value, opt_index);
	  };
	  /**
	   * Clears the list making it empty but non-null.
	   */


	  proto.aitmed.ecos.v1beta1.dxReq.prototype.clearIdList = function () {
	    this.setIdList([]);
	  };

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.aitmed.ecos.v1beta1.dxResp.prototype.toObject = function (opt_includeInstance) {
	      return proto.aitmed.ecos.v1beta1.dxResp.toObject(opt_includeInstance, this);
	    };
	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.aitmed.ecos.v1beta1.dxResp} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */


	    proto.aitmed.ecos.v1beta1.dxResp.toObject = function (includeInstance, msg) {
	      var obj = {
	        jwt: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        code: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        error: googleProtobuf.Message.getFieldWithDefault(msg, 3, "")
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }

	      return obj;
	    };
	  }
	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.aitmed.ecos.v1beta1.dxResp}
	   */


	  proto.aitmed.ecos.v1beta1.dxResp.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.aitmed.ecos.v1beta1.dxResp();
	    return proto.aitmed.ecos.v1beta1.dxResp.deserializeBinaryFromReader(msg, reader);
	  };
	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.aitmed.ecos.v1beta1.dxResp} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.aitmed.ecos.v1beta1.dxResp}
	   */


	  proto.aitmed.ecos.v1beta1.dxResp.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }

	      var field = reader.getFieldNumber();

	      switch (field) {
	        case 1:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setJwt(value);
	          break;

	        case 2:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setCode(value);
	          break;

	        case 3:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setError(value);
	          break;

	        default:
	          reader.skipField();
	          break;
	      }
	    }

	    return msg;
	  };
	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.dxResp.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.aitmed.ecos.v1beta1.dxResp.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };
	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.aitmed.ecos.v1beta1.dxResp} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */


	  proto.aitmed.ecos.v1beta1.dxResp.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getJwt();

	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }

	    f = message.getCode();

	    if (f !== 0) {
	      writer.writeInt32(2, f);
	    }

	    f = message.getError();

	    if (f.length > 0) {
	      writer.writeString(3, f);
	    }
	  };
	  /**
	   * optional string jwt = 1;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.dxResp.prototype.getJwt = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.dxResp.prototype.setJwt = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 1, value);
	  };
	  /**
	   * optional int32 code = 2;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.dxResp.prototype.getCode = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.dxResp.prototype.setCode = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 2, value);
	  };
	  /**
	   * optional string error = 3;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.dxResp.prototype.getError = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.dxResp.prototype.setError = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 3, value);
	  };

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.aitmed.ecos.v1beta1.cvReq.prototype.toObject = function (opt_includeInstance) {
	      return proto.aitmed.ecos.v1beta1.cvReq.toObject(opt_includeInstance, this);
	    };
	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.aitmed.ecos.v1beta1.cvReq} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */


	    proto.aitmed.ecos.v1beta1.cvReq.toObject = function (includeInstance, msg) {
	      var f,
	          obj = {
	        jwt: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        pmask: (f = msg.getPmask()) && field_mask_pb.FieldMask.toObject(includeInstance, f),
	        rmask: (f = msg.getRmask()) && field_mask_pb.FieldMask.toObject(includeInstance, f),
	        vertex: (f = msg.getVertex()) && types_pb.Vertex.toObject(includeInstance, f)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }

	      return obj;
	    };
	  }
	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.aitmed.ecos.v1beta1.cvReq}
	   */


	  proto.aitmed.ecos.v1beta1.cvReq.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.aitmed.ecos.v1beta1.cvReq();
	    return proto.aitmed.ecos.v1beta1.cvReq.deserializeBinaryFromReader(msg, reader);
	  };
	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.aitmed.ecos.v1beta1.cvReq} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.aitmed.ecos.v1beta1.cvReq}
	   */


	  proto.aitmed.ecos.v1beta1.cvReq.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }

	      var field = reader.getFieldNumber();

	      switch (field) {
	        case 1:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setJwt(value);
	          break;

	        case 2:
	          var value = new field_mask_pb.FieldMask();
	          reader.readMessage(value, field_mask_pb.FieldMask.deserializeBinaryFromReader);
	          msg.setPmask(value);
	          break;

	        case 3:
	          var value = new field_mask_pb.FieldMask();
	          reader.readMessage(value, field_mask_pb.FieldMask.deserializeBinaryFromReader);
	          msg.setRmask(value);
	          break;

	        case 4:
	          var value = new types_pb.Vertex();
	          reader.readMessage(value, types_pb.Vertex.deserializeBinaryFromReader);
	          msg.setVertex(value);
	          break;

	        default:
	          reader.skipField();
	          break;
	      }
	    }

	    return msg;
	  };
	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.cvReq.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.aitmed.ecos.v1beta1.cvReq.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };
	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.aitmed.ecos.v1beta1.cvReq} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */


	  proto.aitmed.ecos.v1beta1.cvReq.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getJwt();

	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }

	    f = message.getPmask();

	    if (f != null) {
	      writer.writeMessage(2, f, field_mask_pb.FieldMask.serializeBinaryToWriter);
	    }

	    f = message.getRmask();

	    if (f != null) {
	      writer.writeMessage(3, f, field_mask_pb.FieldMask.serializeBinaryToWriter);
	    }

	    f = message.getVertex();

	    if (f != null) {
	      writer.writeMessage(4, f, types_pb.Vertex.serializeBinaryToWriter);
	    }
	  };
	  /**
	   * optional string jwt = 1;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.cvReq.prototype.getJwt = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.cvReq.prototype.setJwt = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 1, value);
	  };
	  /**
	   * optional google.protobuf.FieldMask pmask = 2;
	   * @return {?proto.google.protobuf.FieldMask}
	   */


	  proto.aitmed.ecos.v1beta1.cvReq.prototype.getPmask = function () {
	    return (
	      /** @type{?proto.google.protobuf.FieldMask} */
	      googleProtobuf.Message.getWrapperField(this, field_mask_pb.FieldMask, 2)
	    );
	  };
	  /** @param {?proto.google.protobuf.FieldMask|undefined} value */


	  proto.aitmed.ecos.v1beta1.cvReq.prototype.setPmask = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 2, value);
	  };
	  /**
	   * Clears the message field making it undefined.
	   */


	  proto.aitmed.ecos.v1beta1.cvReq.prototype.clearPmask = function () {
	    this.setPmask(undefined);
	  };
	  /**
	   * Returns whether this field is set.
	   * @return {boolean}
	   */


	  proto.aitmed.ecos.v1beta1.cvReq.prototype.hasPmask = function () {
	    return googleProtobuf.Message.getField(this, 2) != null;
	  };
	  /**
	   * optional google.protobuf.FieldMask rmask = 3;
	   * @return {?proto.google.protobuf.FieldMask}
	   */


	  proto.aitmed.ecos.v1beta1.cvReq.prototype.getRmask = function () {
	    return (
	      /** @type{?proto.google.protobuf.FieldMask} */
	      googleProtobuf.Message.getWrapperField(this, field_mask_pb.FieldMask, 3)
	    );
	  };
	  /** @param {?proto.google.protobuf.FieldMask|undefined} value */


	  proto.aitmed.ecos.v1beta1.cvReq.prototype.setRmask = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 3, value);
	  };
	  /**
	   * Clears the message field making it undefined.
	   */


	  proto.aitmed.ecos.v1beta1.cvReq.prototype.clearRmask = function () {
	    this.setRmask(undefined);
	  };
	  /**
	   * Returns whether this field is set.
	   * @return {boolean}
	   */


	  proto.aitmed.ecos.v1beta1.cvReq.prototype.hasRmask = function () {
	    return googleProtobuf.Message.getField(this, 3) != null;
	  };
	  /**
	   * optional Vertex vertex = 4;
	   * @return {?proto.aitmed.ecos.v1beta1.Vertex}
	   */


	  proto.aitmed.ecos.v1beta1.cvReq.prototype.getVertex = function () {
	    return (
	      /** @type{?proto.aitmed.ecos.v1beta1.Vertex} */
	      googleProtobuf.Message.getWrapperField(this, types_pb.Vertex, 4)
	    );
	  };
	  /** @param {?proto.aitmed.ecos.v1beta1.Vertex|undefined} value */


	  proto.aitmed.ecos.v1beta1.cvReq.prototype.setVertex = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 4, value);
	  };
	  /**
	   * Clears the message field making it undefined.
	   */


	  proto.aitmed.ecos.v1beta1.cvReq.prototype.clearVertex = function () {
	    this.setVertex(undefined);
	  };
	  /**
	   * Returns whether this field is set.
	   * @return {boolean}
	   */


	  proto.aitmed.ecos.v1beta1.cvReq.prototype.hasVertex = function () {
	    return googleProtobuf.Message.getField(this, 4) != null;
	  };

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.aitmed.ecos.v1beta1.cvResp.prototype.toObject = function (opt_includeInstance) {
	      return proto.aitmed.ecos.v1beta1.cvResp.toObject(opt_includeInstance, this);
	    };
	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.aitmed.ecos.v1beta1.cvResp} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */


	    proto.aitmed.ecos.v1beta1.cvResp.toObject = function (includeInstance, msg) {
	      var f,
	          obj = {
	        jwt: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        code: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        error: googleProtobuf.Message.getFieldWithDefault(msg, 3, ""),
	        vertex: (f = msg.getVertex()) && types_pb.Vertex.toObject(includeInstance, f)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }

	      return obj;
	    };
	  }
	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.aitmed.ecos.v1beta1.cvResp}
	   */


	  proto.aitmed.ecos.v1beta1.cvResp.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.aitmed.ecos.v1beta1.cvResp();
	    return proto.aitmed.ecos.v1beta1.cvResp.deserializeBinaryFromReader(msg, reader);
	  };
	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.aitmed.ecos.v1beta1.cvResp} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.aitmed.ecos.v1beta1.cvResp}
	   */


	  proto.aitmed.ecos.v1beta1.cvResp.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }

	      var field = reader.getFieldNumber();

	      switch (field) {
	        case 1:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setJwt(value);
	          break;

	        case 2:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setCode(value);
	          break;

	        case 3:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setError(value);
	          break;

	        case 4:
	          var value = new types_pb.Vertex();
	          reader.readMessage(value, types_pb.Vertex.deserializeBinaryFromReader);
	          msg.setVertex(value);
	          break;

	        default:
	          reader.skipField();
	          break;
	      }
	    }

	    return msg;
	  };
	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.cvResp.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.aitmed.ecos.v1beta1.cvResp.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };
	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.aitmed.ecos.v1beta1.cvResp} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */


	  proto.aitmed.ecos.v1beta1.cvResp.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getJwt();

	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }

	    f = message.getCode();

	    if (f !== 0) {
	      writer.writeInt32(2, f);
	    }

	    f = message.getError();

	    if (f.length > 0) {
	      writer.writeString(3, f);
	    }

	    f = message.getVertex();

	    if (f != null) {
	      writer.writeMessage(4, f, types_pb.Vertex.serializeBinaryToWriter);
	    }
	  };
	  /**
	   * optional string jwt = 1;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.cvResp.prototype.getJwt = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.cvResp.prototype.setJwt = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 1, value);
	  };
	  /**
	   * optional int32 code = 2;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.cvResp.prototype.getCode = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.cvResp.prototype.setCode = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 2, value);
	  };
	  /**
	   * optional string error = 3;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.cvResp.prototype.getError = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.cvResp.prototype.setError = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 3, value);
	  };
	  /**
	   * optional Vertex vertex = 4;
	   * @return {?proto.aitmed.ecos.v1beta1.Vertex}
	   */


	  proto.aitmed.ecos.v1beta1.cvResp.prototype.getVertex = function () {
	    return (
	      /** @type{?proto.aitmed.ecos.v1beta1.Vertex} */
	      googleProtobuf.Message.getWrapperField(this, types_pb.Vertex, 4)
	    );
	  };
	  /** @param {?proto.aitmed.ecos.v1beta1.Vertex|undefined} value */


	  proto.aitmed.ecos.v1beta1.cvResp.prototype.setVertex = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 4, value);
	  };
	  /**
	   * Clears the message field making it undefined.
	   */


	  proto.aitmed.ecos.v1beta1.cvResp.prototype.clearVertex = function () {
	    this.setVertex(undefined);
	  };
	  /**
	   * Returns whether this field is set.
	   * @return {boolean}
	   */


	  proto.aitmed.ecos.v1beta1.cvResp.prototype.hasVertex = function () {
	    return googleProtobuf.Message.getField(this, 4) != null;
	  };

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.aitmed.ecos.v1beta1.cdReq.prototype.toObject = function (opt_includeInstance) {
	      return proto.aitmed.ecos.v1beta1.cdReq.toObject(opt_includeInstance, this);
	    };
	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.aitmed.ecos.v1beta1.cdReq} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */


	    proto.aitmed.ecos.v1beta1.cdReq.toObject = function (includeInstance, msg) {
	      var f,
	          obj = {
	        jwt: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        pmask: (f = msg.getPmask()) && field_mask_pb.FieldMask.toObject(includeInstance, f),
	        rmask: (f = msg.getRmask()) && field_mask_pb.FieldMask.toObject(includeInstance, f),
	        doc: (f = msg.getDoc()) && types_pb.Doc.toObject(includeInstance, f)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }

	      return obj;
	    };
	  }
	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.aitmed.ecos.v1beta1.cdReq}
	   */


	  proto.aitmed.ecos.v1beta1.cdReq.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.aitmed.ecos.v1beta1.cdReq();
	    return proto.aitmed.ecos.v1beta1.cdReq.deserializeBinaryFromReader(msg, reader);
	  };
	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.aitmed.ecos.v1beta1.cdReq} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.aitmed.ecos.v1beta1.cdReq}
	   */


	  proto.aitmed.ecos.v1beta1.cdReq.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }

	      var field = reader.getFieldNumber();

	      switch (field) {
	        case 1:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setJwt(value);
	          break;

	        case 2:
	          var value = new field_mask_pb.FieldMask();
	          reader.readMessage(value, field_mask_pb.FieldMask.deserializeBinaryFromReader);
	          msg.setPmask(value);
	          break;

	        case 3:
	          var value = new field_mask_pb.FieldMask();
	          reader.readMessage(value, field_mask_pb.FieldMask.deserializeBinaryFromReader);
	          msg.setRmask(value);
	          break;

	        case 4:
	          var value = new types_pb.Doc();
	          reader.readMessage(value, types_pb.Doc.deserializeBinaryFromReader);
	          msg.setDoc(value);
	          break;

	        default:
	          reader.skipField();
	          break;
	      }
	    }

	    return msg;
	  };
	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.cdReq.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.aitmed.ecos.v1beta1.cdReq.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };
	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.aitmed.ecos.v1beta1.cdReq} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */


	  proto.aitmed.ecos.v1beta1.cdReq.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getJwt();

	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }

	    f = message.getPmask();

	    if (f != null) {
	      writer.writeMessage(2, f, field_mask_pb.FieldMask.serializeBinaryToWriter);
	    }

	    f = message.getRmask();

	    if (f != null) {
	      writer.writeMessage(3, f, field_mask_pb.FieldMask.serializeBinaryToWriter);
	    }

	    f = message.getDoc();

	    if (f != null) {
	      writer.writeMessage(4, f, types_pb.Doc.serializeBinaryToWriter);
	    }
	  };
	  /**
	   * optional string jwt = 1;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.cdReq.prototype.getJwt = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.cdReq.prototype.setJwt = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 1, value);
	  };
	  /**
	   * optional google.protobuf.FieldMask pmask = 2;
	   * @return {?proto.google.protobuf.FieldMask}
	   */


	  proto.aitmed.ecos.v1beta1.cdReq.prototype.getPmask = function () {
	    return (
	      /** @type{?proto.google.protobuf.FieldMask} */
	      googleProtobuf.Message.getWrapperField(this, field_mask_pb.FieldMask, 2)
	    );
	  };
	  /** @param {?proto.google.protobuf.FieldMask|undefined} value */


	  proto.aitmed.ecos.v1beta1.cdReq.prototype.setPmask = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 2, value);
	  };
	  /**
	   * Clears the message field making it undefined.
	   */


	  proto.aitmed.ecos.v1beta1.cdReq.prototype.clearPmask = function () {
	    this.setPmask(undefined);
	  };
	  /**
	   * Returns whether this field is set.
	   * @return {boolean}
	   */


	  proto.aitmed.ecos.v1beta1.cdReq.prototype.hasPmask = function () {
	    return googleProtobuf.Message.getField(this, 2) != null;
	  };
	  /**
	   * optional google.protobuf.FieldMask rmask = 3;
	   * @return {?proto.google.protobuf.FieldMask}
	   */


	  proto.aitmed.ecos.v1beta1.cdReq.prototype.getRmask = function () {
	    return (
	      /** @type{?proto.google.protobuf.FieldMask} */
	      googleProtobuf.Message.getWrapperField(this, field_mask_pb.FieldMask, 3)
	    );
	  };
	  /** @param {?proto.google.protobuf.FieldMask|undefined} value */


	  proto.aitmed.ecos.v1beta1.cdReq.prototype.setRmask = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 3, value);
	  };
	  /**
	   * Clears the message field making it undefined.
	   */


	  proto.aitmed.ecos.v1beta1.cdReq.prototype.clearRmask = function () {
	    this.setRmask(undefined);
	  };
	  /**
	   * Returns whether this field is set.
	   * @return {boolean}
	   */


	  proto.aitmed.ecos.v1beta1.cdReq.prototype.hasRmask = function () {
	    return googleProtobuf.Message.getField(this, 3) != null;
	  };
	  /**
	   * optional Doc doc = 4;
	   * @return {?proto.aitmed.ecos.v1beta1.Doc}
	   */


	  proto.aitmed.ecos.v1beta1.cdReq.prototype.getDoc = function () {
	    return (
	      /** @type{?proto.aitmed.ecos.v1beta1.Doc} */
	      googleProtobuf.Message.getWrapperField(this, types_pb.Doc, 4)
	    );
	  };
	  /** @param {?proto.aitmed.ecos.v1beta1.Doc|undefined} value */


	  proto.aitmed.ecos.v1beta1.cdReq.prototype.setDoc = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 4, value);
	  };
	  /**
	   * Clears the message field making it undefined.
	   */


	  proto.aitmed.ecos.v1beta1.cdReq.prototype.clearDoc = function () {
	    this.setDoc(undefined);
	  };
	  /**
	   * Returns whether this field is set.
	   * @return {boolean}
	   */


	  proto.aitmed.ecos.v1beta1.cdReq.prototype.hasDoc = function () {
	    return googleProtobuf.Message.getField(this, 4) != null;
	  };

	  if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
	    /**
	     * Creates an object representation of this proto suitable for use in Soy templates.
	     * Field names that are reserved in JavaScript and will be renamed to pb_name.
	     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	     * For the list of reserved names please see:
	     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	     *     for transitional soy proto support: http://goto/soy-param-migration
	     * @return {!Object}
	     */
	    proto.aitmed.ecos.v1beta1.cdResp.prototype.toObject = function (opt_includeInstance) {
	      return proto.aitmed.ecos.v1beta1.cdResp.toObject(opt_includeInstance, this);
	    };
	    /**
	     * Static version of the {@see toObject} method.
	     * @param {boolean|undefined} includeInstance Whether to include the JSPB
	     *     instance for transitional soy proto support:
	     *     http://goto/soy-param-migration
	     * @param {!proto.aitmed.ecos.v1beta1.cdResp} msg The msg instance to transform.
	     * @return {!Object}
	     * @suppress {unusedLocalVariables} f is only used for nested messages
	     */


	    proto.aitmed.ecos.v1beta1.cdResp.toObject = function (includeInstance, msg) {
	      var f,
	          obj = {
	        jwt: googleProtobuf.Message.getFieldWithDefault(msg, 1, ""),
	        code: googleProtobuf.Message.getFieldWithDefault(msg, 2, 0),
	        error: googleProtobuf.Message.getFieldWithDefault(msg, 3, ""),
	        doc: (f = msg.getDoc()) && types_pb.Doc.toObject(includeInstance, f)
	      };

	      if (includeInstance) {
	        obj.$jspbMessageInstance = msg;
	      }

	      return obj;
	    };
	  }
	  /**
	   * Deserializes binary data (in protobuf wire format).
	   * @param {jspb.ByteSource} bytes The bytes to deserialize.
	   * @return {!proto.aitmed.ecos.v1beta1.cdResp}
	   */


	  proto.aitmed.ecos.v1beta1.cdResp.deserializeBinary = function (bytes) {
	    var reader = new googleProtobuf.BinaryReader(bytes);
	    var msg = new proto.aitmed.ecos.v1beta1.cdResp();
	    return proto.aitmed.ecos.v1beta1.cdResp.deserializeBinaryFromReader(msg, reader);
	  };
	  /**
	   * Deserializes binary data (in protobuf wire format) from the
	   * given reader into the given message object.
	   * @param {!proto.aitmed.ecos.v1beta1.cdResp} msg The message object to deserialize into.
	   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	   * @return {!proto.aitmed.ecos.v1beta1.cdResp}
	   */


	  proto.aitmed.ecos.v1beta1.cdResp.deserializeBinaryFromReader = function (msg, reader) {
	    while (reader.nextField()) {
	      if (reader.isEndGroup()) {
	        break;
	      }

	      var field = reader.getFieldNumber();

	      switch (field) {
	        case 1:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setJwt(value);
	          break;

	        case 2:
	          var value =
	          /** @type {number} */
	          reader.readInt32();
	          msg.setCode(value);
	          break;

	        case 3:
	          var value =
	          /** @type {string} */
	          reader.readString();
	          msg.setError(value);
	          break;

	        case 4:
	          var value = new types_pb.Doc();
	          reader.readMessage(value, types_pb.Doc.deserializeBinaryFromReader);
	          msg.setDoc(value);
	          break;

	        default:
	          reader.skipField();
	          break;
	      }
	    }

	    return msg;
	  };
	  /**
	   * Serializes the message to binary data (in protobuf wire format).
	   * @return {!Uint8Array}
	   */


	  proto.aitmed.ecos.v1beta1.cdResp.prototype.serializeBinary = function () {
	    var writer = new googleProtobuf.BinaryWriter();
	    proto.aitmed.ecos.v1beta1.cdResp.serializeBinaryToWriter(this, writer);
	    return writer.getResultBuffer();
	  };
	  /**
	   * Serializes the given message to binary data (in protobuf wire
	   * format), writing to the given BinaryWriter.
	   * @param {!proto.aitmed.ecos.v1beta1.cdResp} message
	   * @param {!jspb.BinaryWriter} writer
	   * @suppress {unusedLocalVariables} f is only used for nested messages
	   */


	  proto.aitmed.ecos.v1beta1.cdResp.serializeBinaryToWriter = function (message, writer) {
	    var f = undefined;
	    f = message.getJwt();

	    if (f.length > 0) {
	      writer.writeString(1, f);
	    }

	    f = message.getCode();

	    if (f !== 0) {
	      writer.writeInt32(2, f);
	    }

	    f = message.getError();

	    if (f.length > 0) {
	      writer.writeString(3, f);
	    }

	    f = message.getDoc();

	    if (f != null) {
	      writer.writeMessage(4, f, types_pb.Doc.serializeBinaryToWriter);
	    }
	  };
	  /**
	   * optional string jwt = 1;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.cdResp.prototype.getJwt = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 1, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.cdResp.prototype.setJwt = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 1, value);
	  };
	  /**
	   * optional int32 code = 2;
	   * @return {number}
	   */


	  proto.aitmed.ecos.v1beta1.cdResp.prototype.getCode = function () {
	    return (
	      /** @type {number} */
	      googleProtobuf.Message.getFieldWithDefault(this, 2, 0)
	    );
	  };
	  /** @param {number} value */


	  proto.aitmed.ecos.v1beta1.cdResp.prototype.setCode = function (value) {
	    googleProtobuf.Message.setProto3IntField(this, 2, value);
	  };
	  /**
	   * optional string error = 3;
	   * @return {string}
	   */


	  proto.aitmed.ecos.v1beta1.cdResp.prototype.getError = function () {
	    return (
	      /** @type {string} */
	      googleProtobuf.Message.getFieldWithDefault(this, 3, "")
	    );
	  };
	  /** @param {string} value */


	  proto.aitmed.ecos.v1beta1.cdResp.prototype.setError = function (value) {
	    googleProtobuf.Message.setProto3StringField(this, 3, value);
	  };
	  /**
	   * optional Doc doc = 4;
	   * @return {?proto.aitmed.ecos.v1beta1.Doc}
	   */


	  proto.aitmed.ecos.v1beta1.cdResp.prototype.getDoc = function () {
	    return (
	      /** @type{?proto.aitmed.ecos.v1beta1.Doc} */
	      googleProtobuf.Message.getWrapperField(this, types_pb.Doc, 4)
	    );
	  };
	  /** @param {?proto.aitmed.ecos.v1beta1.Doc|undefined} value */


	  proto.aitmed.ecos.v1beta1.cdResp.prototype.setDoc = function (value) {
	    googleProtobuf.Message.setWrapperField(this, 4, value);
	  };
	  /**
	   * Clears the message field making it undefined.
	   */


	  proto.aitmed.ecos.v1beta1.cdResp.prototype.clearDoc = function () {
	    this.setDoc(undefined);
	  };
	  /**
	   * Returns whether this field is set.
	   * @return {boolean}
	   */


	  proto.aitmed.ecos.v1beta1.cdResp.prototype.hasDoc = function () {
	    return googleProtobuf.Message.getField(this, 4) != null;
	  };

	  goog.object.extend(exports, proto.aitmed.ecos.v1beta1);
	});
	var ecos_api_pb_1 = ecos_api_pb.cdReq;
	var ecos_api_pb_2 = ecos_api_pb.cdResp;
	var ecos_api_pb_3 = ecos_api_pb.ceReq;
	var ecos_api_pb_4 = ecos_api_pb.ceResp;
	var ecos_api_pb_5 = ecos_api_pb.cvReq;
	var ecos_api_pb_6 = ecos_api_pb.cvResp;
	var ecos_api_pb_7 = ecos_api_pb.dxReq;
	var ecos_api_pb_8 = ecos_api_pb.dxResp;
	var ecos_api_pb_9 = ecos_api_pb.rdResp;
	var ecos_api_pb_10 = ecos_api_pb.reResp;
	var ecos_api_pb_11 = ecos_api_pb.rvResp;
	var ecos_api_pb_12 = ecos_api_pb.rxReq;

	var EcosAPIClient =
	/*#__PURE__*/
	function () {
	  function EcosAPIClient(hostname, credentials, options) {
	    _classCallCheck$1$1(this, EcosAPIClient);

	    _defineProperty$1$1(this, "client_", void 0);

	    _defineProperty$1$1(this, "hostname_", void 0);

	    _defineProperty$1$1(this, "credentials_", void 0);

	    _defineProperty$1$1(this, "options_", void 0);

	    _defineProperty$1$1(this, "methodInfoce", new grpcWeb_1.MethodInfo(ecos_api_pb_4, function (request) {
	      return request.serializeBinary();
	    }, ecos_api_pb_4.deserializeBinary));

	    _defineProperty$1$1(this, "methodInfore", new grpcWeb_1.MethodInfo(ecos_api_pb_10, function (request) {
	      return request.serializeBinary();
	    }, ecos_api_pb_10.deserializeBinary));

	    _defineProperty$1$1(this, "methodInfodx", new grpcWeb_1.MethodInfo(ecos_api_pb_8, function (request) {
	      return request.serializeBinary();
	    }, ecos_api_pb_8.deserializeBinary));

	    _defineProperty$1$1(this, "methodInfocv", new grpcWeb_1.MethodInfo(ecos_api_pb_6, function (request) {
	      return request.serializeBinary();
	    }, ecos_api_pb_6.deserializeBinary));

	    _defineProperty$1$1(this, "methodInforv", new grpcWeb_1.MethodInfo(ecos_api_pb_11, function (request) {
	      return request.serializeBinary();
	    }, ecos_api_pb_11.deserializeBinary));

	    _defineProperty$1$1(this, "methodInfocd", new grpcWeb_1.MethodInfo(ecos_api_pb_2, function (request) {
	      return request.serializeBinary();
	    }, ecos_api_pb_2.deserializeBinary));

	    _defineProperty$1$1(this, "methodInford", new grpcWeb_1.MethodInfo(ecos_api_pb_9, function (request) {
	      return request.serializeBinary();
	    }, ecos_api_pb_9.deserializeBinary));

	    if (!options) options = {};
	    if (!credentials) credentials = {};
	    options['format'] = 'text';
	    this.client_ = new grpcWeb_2(options);
	    this.hostname_ = hostname;
	    this.credentials_ = credentials;
	    this.options_ = options;
	  }

	  _createClass$1$1(EcosAPIClient, [{
	    key: "ce",
	    value: function ce(request, metadata, callback) {
	      return this.client_.rpcCall(this.hostname_ + '/aitmed.ecos.v1beta1.EcosAPI/ce', request, metadata || {}, this.methodInfoce, callback);
	    }
	  }, {
	    key: "re",
	    value: function re(request, metadata, callback) {
	      return this.client_.rpcCall(this.hostname_ + '/aitmed.ecos.v1beta1.EcosAPI/re', request, metadata || {}, this.methodInfore, callback);
	    }
	  }, {
	    key: "dx",
	    value: function dx(request, metadata, callback) {
	      return this.client_.rpcCall(this.hostname_ + '/aitmed.ecos.v1beta1.EcosAPI/dx', request, metadata || {}, this.methodInfodx, callback);
	    }
	  }, {
	    key: "cv",
	    value: function cv(request, metadata, callback) {
	      return this.client_.rpcCall(this.hostname_ + '/aitmed.ecos.v1beta1.EcosAPI/cv', request, metadata || {}, this.methodInfocv, callback);
	    }
	  }, {
	    key: "rv",
	    value: function rv(request, metadata, callback) {
	      return this.client_.rpcCall(this.hostname_ + '/aitmed.ecos.v1beta1.EcosAPI/rv', request, metadata || {}, this.methodInforv, callback);
	    }
	  }, {
	    key: "cd",
	    value: function cd(request, metadata, callback) {
	      return this.client_.rpcCall(this.hostname_ + '/aitmed.ecos.v1beta1.EcosAPI/cd', request, metadata || {}, this.methodInfocd, callback);
	    }
	  }, {
	    key: "rd",
	    value: function rd(request, metadata, callback) {
	      return this.client_.rpcCall(this.hostname_ + '/aitmed.ecos.v1beta1.EcosAPI/rd', request, metadata || {}, this.methodInford, callback);
	    }
	  }]);

	  return EcosAPIClient;
	}();

	var getEcosAPIClient = function getEcosAPIClient(_ref) {
	  var url = _ref.url,
	      credentials = _ref.credentials,
	      options = _ref.options,
	      _ref$apiVersion = _ref.apiVersion,
	      apiVersion = _ref$apiVersion === void 0 ? 'v1beta1' : _ref$apiVersion;

	  switch (apiVersion.trim().toLowerCase()) {
	    case 'v1beta1':
	      return new EcosAPIClient(url, credentials, options);

	    default:
	      return null;
	  }
	};

	var defaultConfig = {
	  env: 'development',
	  configUrl: 'https://public.aitmed.com/config'
	};

	function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(source, true).forEach(function (key) { defineProperty$e(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
	var CONFIG_NAME = 'config';

	var Store =
	/*#__PURE__*/
	function () {
	  function Store(_ref) {
	    var apiVersion = _ref.apiVersion,
	        apiHost = _ref.apiHost,
	        env = _ref.env,
	        configUrl = _ref.configUrl;

	    classCallCheck$1(this, Store);

	    defineProperty$e(this, "apiPort", '443');

	    defineProperty$e(this, "_apiHost", void 0);

	    defineProperty$e(this, "_apiVersion", void 0);

	    defineProperty$e(this, "_env", void 0);

	    defineProperty$e(this, "_configUrl", void 0);

	    defineProperty$e(this, "grpcClient", void 0);

	    this.env = env;
	    this.configUrl = configUrl;
	    if (apiHost) this.apiHost = apiHost;
	    if (apiVersion) this.apiVersion = apiVersion;
	    var config = this.getConfig();

	    if (config) {
	      if (config.webApiHost && config.webApiHost !== 'apiHost') {
	        this.apiHost = config.webApiHost;
	      } else {
	        this.apiHost = config.apiHost;
	      }

	      this.apiPort = config.apiPort;
	    }

	    this.generateGrpcCLient();
	  }

	  createClass$1(Store, [{
	    key: "generateGrpcCLient",
	    value: function generateGrpcCLient() {
	      var url = "https://".concat(this.apiHost);
	      this.grpcClient = getEcosAPIClient({
	        url: url,
	        apiVersion: this.apiVersion
	      });
	    }
	  }, {
	    key: "getConfig",
	    value: function getConfig() {
	      if (typeof window !== 'undefined') {
	        try {
	          var config = localStorage.getItem(CONFIG_NAME);
	          if (config === null) return null;
	          var configData = browser$1$1.parse(config);
	          return configData;
	        } catch (error) {
	          console.error(error);
	        }
	      }

	      return null;
	    }
	  }, {
	    key: "loadConfig",
	    value: function () {
	      var _loadConfig = asyncToGenerator$1(
	      /*#__PURE__*/
	      regenerator$1.mark(function _callee2(appName) {
	        var _this = this;

	        var hostname, splits, configData, config, configJSON;
	        return regenerator$1.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                if (!(typeof window === 'undefined')) {
	                  _context2.next = 2;
	                  break;
	                }

	                return _context2.abrupt("return", {
	                  apiHost: this.apiHost,
	                  apiPort: this.apiPort
	                });

	              case 2:
	                // Getting app name from hostname
	                appName = appName ? appName : 'aitmed';

	                if (window && window.location && window.location.hostname) {
	                  hostname = window.location.hostname;

	                  if (hostname !== 'localhost' && hostname !== '127.0.0.1') {
	                    splits = hostname.split('.');

	                    if (splits[1] === 'aitmed') {
	                      appName = splits[0];
	                    } else {
	                      appName = splits.slice(0, splits.length - 1).join('.');
	                    }
	                  }
	                } // Getting config data from {appName}.yml


	                _context2.next = 6;
	                return axios$1$1.get("".concat(this.configUrl, "/").concat(appName, ".yml")).then(function (_ref2) {
	                  var data = _ref2.data;
	                  return data;
	                })["catch"](
	                /*#__PURE__*/
	                asyncToGenerator$1(
	                /*#__PURE__*/
	                regenerator$1.mark(function _callee() {
	                  var aitmedConfig;
	                  return regenerator$1.wrap(function _callee$(_context) {
	                    while (1) {
	                      switch (_context.prev = _context.next) {
	                        case 0:
	                          _context.next = 2;
	                          return axios$1$1.get("".concat(_this.configUrl, "/aitmed.yml")).then(function (_ref4) {
	                            var data = _ref4.data;
	                            return data;
	                          });

	                        case 2:
	                          aitmedConfig = _context.sent;
	                          return _context.abrupt("return", aitmedConfig);

	                        case 4:
	                        case "end":
	                          return _context.stop();
	                      }
	                    }
	                  }, _callee);
	                })));

	              case 6:
	                configData = _context2.sent;

	                try {
	                  config = browser$1$1.parse(configData);
	                  configJSON = JSON.stringify(config);
	                  localStorage.setItem(CONFIG_NAME, configJSON);
	                } catch (error) {
	                  console.error(error);
	                }

	                if (config) {
	                  if (config.webApiHost && config.webApiHost !== 'apiHost') {
	                    this.apiHost = config.webApiHost;
	                  } else {
	                    this.apiHost = config.apiHost;
	                  }

	                  this.apiPort = config.apiPort;
	                }

	                this.generateGrpcCLient();
	                return _context2.abrupt("return", config);

	              case 11:
	              case "end":
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function loadConfig(_x) {
	        return _loadConfig.apply(this, arguments);
	      }

	      return loadConfig;
	    }()
	  }, {
	    key: "cleanConfig",
	    value: function cleanConfig() {
	      if (typeof window !== 'undefined') {
	        var config = localStorage.getItem(CONFIG_NAME);

	        if (config !== null) {
	          localStorage.removeItem(CONFIG_NAME);
	        }
	      }
	    }
	  }, {
	    key: "apiVersion",
	    set: function set(newApiVersion) {
	      this._apiVersion = newApiVersion;
	      this.generateGrpcCLient();
	    },
	    get: function get() {
	      return this._apiVersion;
	    }
	  }, {
	    key: "env",
	    set: function set(value) {
	      this._env = value;
	    },
	    get: function get() {
	      return this._env;
	    }
	  }, {
	    key: "apiHost",
	    get: function get() {
	      return this._apiHost;
	    },
	    set: function set(value) {
	      this._apiHost = value;
	      this.generateGrpcCLient();
	    }
	  }, {
	    key: "configUrl",
	    get: function get() {
	      return this._configUrl;
	    },
	    set: function set(value) {
	      this._configUrl = value;
	    }
	  }]);

	  return Store;
	}();

	var store$2 = new Store(_objectSpread({}, defaultConfig));

	var _extends_1 = createCommonjsModule$1(function (module) {
	function _extends() {
	  module.exports = _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends.apply(this, arguments);
	}

	module.exports = _extends;
	});

	var Codes;

	(function (Codes) {
	  Codes[Codes["SUCCESS"] = 0] = "SUCCESS";
	  Codes[Codes["PERMISSION_DENIED"] = 1] = "PERMISSION_DENIED";
	  Codes[Codes["UNREGISTERED"] = 2] = "UNREGISTERED";
	  Codes[Codes["REGISTERED"] = 3] = "REGISTERED";
	  Codes[Codes["INVALID_API_VERSION"] = 4] = "INVALID_API_VERSION";
	  Codes[Codes["ERROR_UPLOADING_TO_AWS_S3"] = 5] = "ERROR_UPLOADING_TO_AWS_S3";
	  Codes[Codes["ERROR_DOWNLOADING_FROM_AWS_S3"] = 6] = "ERROR_DOWNLOADING_FROM_AWS_S3";
	  Codes[Codes["ERROR_CREATING_ESAK"] = 7] = "ERROR_CREATING_ESAK";
	  Codes[Codes["PHONE_NUMBER_INVALID"] = 1000] = "PHONE_NUMBER_INVALID";
	  Codes[Codes["PASSWORD_INVALID"] = 1001] = "PASSWORD_INVALID";
	  Codes[Codes["VERIFICATION_CODE_INVALID"] = 1002] = "VERIFICATION_CODE_INVALID";
	  Codes[Codes["REQUIRED_VERIFICATION_CODE"] = 1003] = "REQUIRED_VERIFICATION_CODE";
	  Codes[Codes["REQUIRED_PASSWORD"] = 1004] = "REQUIRED_PASSWORD";
	  Codes[Codes["REQUIRED_PHONE_NUMBER_AND_VERIFICATION_CODE"] = 1005] = "REQUIRED_PHONE_NUMBER_AND_VERIFICATION_CODE";
	  Codes[Codes["ERROR_CLEARING_CREDENTIALS"] = 1006] = "ERROR_CLEARING_CREDENTIALS";
	  Codes[Codes["LOGIN_REQUIRED"] = 1007] = "LOGIN_REQUIRED";
	  Codes[Codes["OBJECT_TYPE_INVALID"] = 2000] = "OBJECT_TYPE_INVALID";
	  Codes[Codes["NUll_INPUT_OBJECT"] = 2001] = "NUll_INPUT_OBJECT";
	  Codes[Codes["INVALID_NAME_JSON"] = 2002] = "INVALID_NAME_JSON";
	  Codes[Codes["JWT_OBJECT_TYPE_ERROR"] = 2003] = "JWT_OBJECT_TYPE_ERROR";
	  Codes[Codes["JWT_NOT_FOUND"] = 2004] = "JWT_NOT_FOUND";
	  Codes[Codes["JWT_V_CODE_ERROR"] = 2005] = "JWT_V_CODE_ERROR";
	  Codes[Codes["JWT_EXPIRED"] = 2006] = "JWT_EXPIRED";
	  Codes[Codes["JWT_PERMISSION_DENY"] = 2007] = "JWT_PERMISSION_DENY";
	  Codes[Codes["DB_CONNECTION_ERROR"] = 2008] = "DB_CONNECTION_ERROR";
	  Codes[Codes["SQL_EXEC_ERROR"] = 2009] = "SQL_EXEC_ERROR";
	  Codes[Codes["SQL_BEGIN_ERROR"] = 2010] = "SQL_BEGIN_ERROR";
	  Codes[Codes["SQL_COMMIT_ERROR"] = 2011] = "SQL_COMMIT_ERROR";
	  Codes[Codes["SQL_RESULT_ERROR"] = 2012] = "SQL_RESULT_ERROR";
	  Codes[Codes["SQL_STATEMENT_GEN_ERROR"] = 2013] = "SQL_STATEMENT_GEN_ERROR";
	  Codes[Codes["SQL_UPDATE_WITHOUT_ID"] = 2014] = "SQL_UPDATE_WITHOUT_ID";
	  Codes[Codes["TWILIO_CONNECTION_ERROR"] = 2015] = "TWILIO_CONNECTION_ERROR";
	  Codes[Codes["TWILIO_RESPONSE_ERROR"] = 2016] = "TWILIO_RESPONSE_ERROR";
	  Codes[Codes["NOT_IMPLEMENTED_MULTIPLE_DELETE"] = 2017] = "NOT_IMPLEMENTED_MULTIPLE_DELETE";
	  Codes[Codes["JSON_STRINGIFY_FAILED"] = 2018] = "JSON_STRINGIFY_FAILED";
	  Codes[Codes["ERROR_DECRYPTING_DATA"] = 2019] = "ERROR_DECRYPTING_DATA";
	  Codes[Codes["JSON_PARSE_FAILED"] = 2020] = "JSON_PARSE_FAILED";
	  Codes[Codes["CREATE_VERTEX_WRONG_ID"] = 3000] = "CREATE_VERTEX_WRONG_ID";
	  Codes[Codes["INVALID_USER_ID"] = 3001] = "INVALID_USER_ID";
	  Codes[Codes["CANNOT_FIND_UID"] = 3002] = "CANNOT_FIND_UID";
	  Codes[Codes["DELETE_ID_NOT_FOUND"] = 3003] = "DELETE_ID_NOT_FOUND";
	  Codes[Codes["CANNOT_FIND_USER_ID"] = 3004] = "CANNOT_FIND_USER_ID";
	  Codes[Codes["UID_HAS_BEEN_USED"] = 3005] = "UID_HAS_BEEN_USED";
	  Codes[Codes["USER_ID_NOT_MATCH"] = 3006] = "USER_ID_NOT_MATCH";
	  Codes[Codes["UID_IS_EMPTY"] = 3007] = "UID_IS_EMPTY";
	  Codes[Codes["INVALID_PUBLIC_KEY_LENGTH"] = 3008] = "INVALID_PUBLIC_KEY_LENGTH";
	  Codes[Codes["INVALID_SECRET_KEY_LENGTH"] = 3009] = "INVALID_SECRET_KEY_LENGTH";
	  Codes[Codes["CANNOT_FIND_HOST_EDGE"] = 3010] = "CANNOT_FIND_HOST_EDGE";
	  Codes[Codes["DELETE_HOST_ID_NOT_FOUND"] = 3011] = "DELETE_HOST_ID_NOT_FOUND";
	  Codes[Codes["VERTEX_IS_UNDEFINED"] = 3012] = "VERTEX_IS_UNDEFINED";
	  Codes[Codes["CREATE_EDGE_WRONG_ID"] = 4000] = "CREATE_EDGE_WRONG_ID";
	  Codes[Codes["UPDATE_EDGE_ID_NOT_FOUND"] = 4001] = "UPDATE_EDGE_ID_NOT_FOUND";
	  Codes[Codes["INVALID_E_TYPE"] = 4002] = "INVALID_E_TYPE";
	  Codes[Codes["DELETE_OBJ_HAS_CHILD"] = 4003] = "DELETE_OBJ_HAS_CHILD";
	  Codes[Codes["NO_VERIFICATION_CODE"] = 4004] = "NO_VERIFICATION_CODE";
	  Codes[Codes["EDGE_IS_UNDEFINED"] = 4005] = "EDGE_IS_UNDEFINED";
	  Codes[Codes["ERROR_CREATING_BESAK"] = 4006] = "ERROR_CREATING_BESAK";
	  Codes[Codes["CREATE_DOC_WRONG_ID"] = 5000] = "CREATE_DOC_WRONG_ID";
	  Codes[Codes["UPDATE_DOC_ID_NOT_FOUND"] = 5001] = "UPDATE_DOC_ID_NOT_FOUND";
	  Codes[Codes["CREATE_DOC_INVALID_EID"] = 5002] = "CREATE_DOC_INVALID_EID";
	  Codes[Codes["DOCUMENT_IS_UNDEFINED"] = 5003] = "DOCUMENT_IS_UNDEFINED";
	  Codes[Codes["YAML_PARSE_FAILED"] = 6000] = "YAML_PARSE_FAILED";
	  Codes[Codes["REACT_YAML_PARSE_FAILED"] = 6001] = "REACT_YAML_PARSE_FAILED";
	  Codes[Codes["INVALID_TARGET_OPTION"] = 6002] = "INVALID_TARGET_OPTION";
	})(Codes || (Codes = {}));

	var defaultMessages = {
	  UNKNOWN_ERROR: 'error occurred',
	  SUCCESS: 'success',
	  PERMISSION_DENIED: 'permission denied',
	  UNREGISTERED: 'account is not registered',
	  REGISTERED: 'account is already registered',
	  INVALID_API_VERSION: 'Invalid apiVersion',
	  ERROR_UPLOADING_TO_AWS_S3: 'Error uploading document to aws S3',
	  ERROR_DOWNLOADING_FROM_AWS_S3: 'Error downloading document from aws S3',
	  ERROR_CREATING_ESAK: 'Please provide a public key',

	  /* Account    - 1000 */
	  PHONE_NUMBER_INVALID: 'phone number is invalid',
	  PASSWORD_INVALID: 'password is invalid',
	  VERIFICATION_CODE_INVALID: 'verification code is invalid',
	  REQUIRED_VERIFICATION_CODE: 'verification code is required',
	  REQUIRED_PASSWORD: 'password is required',
	  REQUIRED_PHONE_NUMBER_AND_VERIFICATION_CODE: 'phone number and verification are required',
	  ERROR_CLEARING_CREDENTIALS: "There was an error clearing out the localStorage.",

	  /* common     - 2000 */
	  OBJECT_TYPE_INVALID: 'Object type is invalid',
	  NUll_INPUT_OBJECT: "Nil Input Object",
	  INVALID_NAME_JSON: "Invalid name Json",
	  JWT_OBJECT_TYPE_ERROR: "Mismatched JWT object type",
	  JWT_NOT_FOUND: "JWT is not found, may have been expired",
	  JWT_V_CODE_ERROR: "JWT Verification Code Error",
	  JWT_EXPIRED: "JWT Expired",
	  JWT_PERMISSION_DENY: "JWT Permission Deny",
	  DB_CONNECTION_ERROR: "Cannot connect to DB",
	  SQL_EXEC_ERROR: "SQL Execution Error",
	  SQL_BEGIN_ERROR: "SQL Begin Transaction Error",
	  SQL_COMMIT_ERROR: "SQL Commit Transaction Error",
	  SQL_RESULT_ERROR: "SQL Result Processing Error",
	  SQL_STATEMENT_GEN_ERROR: "SQL Error When Generate Statement",
	  SQL_UPDATE_WITHOUT_ID: "Update Without ID",
	  TWILIO_CONNECTION_ERROR: "Twilio Http Connection Error",
	  TWILIO_RESPONSE_ERROR: "Twilio Http Response Error",
	  NOT_IMPLEMENTED_MULTIPLE_DELETE: "Multiple id deletion has not implemented",
	  JSON_STRINGIFY_FAILED: "Failed attempt to stringify value.",
	  ERROR_DECRYPTING_DATA: "Error in decrypting data.",
	  JSON_PARSE_FAILED: "Failed attempt to parse JSON",

	  /* Vertex     - 3000 */
	  CREATE_VERTEX_WRONG_ID: "Create Vertex With a Wrong Id",
	  INVALID_USER_ID: "Invalid user_id",
	  CANNOT_FIND_UID: "Cannot Find user_id",
	  DELETE_ID_NOT_FOUND: "Delete ID not found",
	  CANNOT_FIND_USER_ID: "Cannot Find user_id",
	  UID_HAS_BEEN_USED: "Uid Has Been Used",
	  USER_ID_NOT_MATCH: "UserId not match",
	  UID_IS_EMPTY: "Uid Is Empty",
	  INVALID_PUBLIC_KEY_LENGTH: "Invalid Public Key Length, expected 32",
	  INVALID_SECRET_KEY_LENGTH: "Invalid Encrypted Secret Key Length, expected 72",
	  CANNOT_FIND_HOST_EDGE: "Create Doc Cannot Find Host Edge",
	  DELETE_HOST_ID_NOT_FOUND: "Cannot find the host ID of a Delete item",
	  VERTEX_IS_UNDEFINED: "Vertex is undefined",

	  /* Edge       - 4000 */
	  CREATE_EDGE_WRONG_ID: "Create Edge With a Wrong Id",
	  UPDATE_EDGE_ID_NOT_FOUND: "Update Edge, ID is not found",
	  INVALID_E_TYPE: "Invalid etype, not implemented yet",
	  DELETE_OBJ_HAS_CHILD: "Cannot Delete Item which has child(ren)",
	  NO_VERIFICATION_CODE: "No Verication Code in name of edge",
	  EDGE_IS_UNDEFINED: "The edge is undefined.",
	  ERROR_CREATING_BESAK: "There was an error creating the edge besak",

	  /* Document   - 5000 */
	  CREATE_DOC_WRONG_ID: "Create Doc With a Wrong Id",
	  UPDATE_DOC_ID_NOT_FOUND: "Update Doc, ID is not found",
	  CREATE_DOC_INVALID_EID: "Create Doc with Invalid Edge Id",
	  DOCUMENT_IS_UNDEFINED: "Document is undefined",

	  /* UIDL   - 6000 */
	  YAML_PARSE_FAILED: 'Failed to parse yaml',
	  REACT_YAML_PARSE_FAILED: 'Something went wrong while attempting to use react yaml parser',
	  INVALID_TARGET_OPTION: 'Please enter a valid target option'
	};

	var AitmedError =
	/*#__PURE__*/
	function (_Error) {
	  inherits$1(AitmedError, _Error);

	  function AitmedError(_ref) {
	    var _this;

	    var code = _ref.code,
	        message = _ref.message,
	        source = _ref.source,
	        name = _ref.name;

	    classCallCheck$1(this, AitmedError);

	    _this = possibleConstructorReturn$1(this, getPrototypeOf$1(AitmedError).call(this));

	    defineProperty$e(assertThisInitialized$1(_this), "code", void 0);

	    defineProperty$e(assertThisInitialized$1(_this), "name", void 0);

	    defineProperty$e(assertThisInitialized$1(_this), "message", void 0);

	    defineProperty$e(assertThisInitialized$1(_this), "source", void 0);

	    if (code === undefined && name) {
	      _this.code = Codes[name] === undefined ? -1 : Codes[name];
	      _this.name = name;
	      _this.message = message === undefined ? defaultMessages[name] : message;
	    } else if (name === undefined && code) {
	      _this.name = Codes[code] === undefined ? 'UNKNOWN_ERROR' : Codes[code];
	      _this.code = code;
	      _this.message = message === undefined ? defaultMessages[code] : message;
	    } else {
	      _this.code = -1;
	      _this.name = 'UNKNOWN_ERROR';
	    }

	    if (source === undefined) {
	      _this.source = 'lvl-2';
	    } else {
	      _this.source = source;
	    }

	    return _this;
	  }

	  return AitmedError;
	}(wrapNativeSuper$1(Error));
	var translateErrorCode = function translateErrorCode(code) {
	  switch (code) {
	    //common - 2000
	    case 10:
	      return 2001;

	    case 20:
	      return 2002;

	    case 110:
	      return 2003;

	    case 111:
	      return 2004;

	    case 112:
	      return 2005;

	    case 113:
	      return 2006;

	    case 114:
	      return 2007;

	    case 120:
	      return 2008;

	    case 200:
	      return 2009;

	    case 201:
	      return 2010;

	    case 202:
	      return 2011;

	    case 205:
	      return 2012;

	    case 210:
	      return 2013;

	    case 240:
	      return 2014;

	    case 300:
	      return 2015;

	    case 310:
	      return 2016;

	    case 400:
	      return 2017;
	    // Vertex

	    case 1060:
	      return 3000;

	    case 1000:
	      return 3001;

	    case 1020:
	      return 3002;

	    case 1072:
	      return 3003;

	    case 1010:
	      return 3004;

	    case 1030:
	      return 3005;

	    case 1030:
	      return 3005;

	    case 1040:
	      return 3006;

	    case 1050:
	      return 3007;

	    case 1070:
	      return 3008;

	    case 1071:
	      return 3009;

	    case 2010:
	      return 3010;

	    case 2072:
	      return 3011;
	    // Edge

	    case 3060:
	      return 4000;

	    case 3070:
	      return 4001;

	    case 3000:
	      return 4002;

	    case 3001:
	      return 4003;

	    case 3010:
	      return 4004;
	    //Document

	    case 2060:
	      return 5000;

	    case 2070:
	      return 5001;

	    case 2000:
	      return 5002;

	    default:
	      return -1;
	  }
	};

	var Response$1 = function Response(_ref) {
	  var code = _ref.code,
	      message = _ref.message,
	      data = _ref.data;

	  classCallCheck$1(this, Response);

	  defineProperty$e(this, "code", void 0);

	  defineProperty$e(this, "name", void 0);

	  defineProperty$e(this, "message", void 0);

	  defineProperty$e(this, "data", void 0);

	  var name = Codes[code];

	  if (data !== undefined) {
	    this.data = data;
	  }

	  if (name === undefined) {
	    this.code = -1;
	    this.name = 'UNKNOWN_ERROR';
	  } else {
	    this.code = code;
	    this.name = name;
	  }

	  this.message = message === undefined ? defaultMessages[name] : message;
	};

	var $jscomp$1=$jscomp$1||{};$jscomp$1.scope={};$jscomp$1.findInternal=function(a,b,c){a instanceof String&&(a=String(a));for(var d=a.length,e=0;e<d;e++){var f=a[e];if(b.call(c,f,e,a))return {i:e,v:f}}return {i:-1,v:void 0}};$jscomp$1.ASSUME_ES5=!1;$jscomp$1.ASSUME_NO_NATIVE_MAP=!1;$jscomp$1.ASSUME_NO_NATIVE_SET=!1;$jscomp$1.SIMPLE_FROUND_POLYFILL=!1;
	$jscomp$1.defineProperty=$jscomp$1.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value);};$jscomp$1.getGlobal=function(a){return "undefined"!=typeof window&&window===a?a:"undefined"!=typeof commonjsGlobal$1&&null!=commonjsGlobal$1?commonjsGlobal$1:a};$jscomp$1.global=$jscomp$1.getGlobal(commonjsGlobal$1);
	$jscomp$1.polyfill=function(a,b,c,d){if(b){c=$jscomp$1.global;a=a.split(".");for(d=0;d<a.length-1;d++){var e=a[d];e in c||(c[e]={});c=c[e];}a=a[a.length-1];d=c[a];b=b(d);b!=d&&null!=b&&$jscomp$1.defineProperty(c,a,{configurable:!0,writable:!0,value:b});}};$jscomp$1.polyfill("Array.prototype.findIndex",function(a){return a?a:function(a,c){return $jscomp$1.findInternal(this,a,c).i}},"es6","es3");
	$jscomp$1.checkStringArgs=function(a,b,c){if(null==a)throw new TypeError("The 'this' value for String.prototype."+c+" must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype."+c+" must not be a regular expression");return a+""};
	$jscomp$1.polyfill("String.prototype.endsWith",function(a){return a?a:function(a,c){var b=$jscomp$1.checkStringArgs(this,a,"endsWith");a+="";void 0===c&&(c=b.length);c=Math.max(0,Math.min(c|0,b.length));for(var e=a.length;0<e&&0<c;)if(b[--c]!=a[--e])return !1;return 0>=e}},"es6","es3");$jscomp$1.polyfill("Array.prototype.find",function(a){return a?a:function(a,c){return $jscomp$1.findInternal(this,a,c).v}},"es6","es3");
	$jscomp$1.polyfill("String.prototype.startsWith",function(a){return a?a:function(a,c){var b=$jscomp$1.checkStringArgs(this,a,"startsWith");a+="";var e=b.length,f=a.length;c=Math.max(0,Math.min(c|0,b.length));for(var g=0;g<f&&c<e;)if(b[c++]!=a[g++])return !1;return g>=f}},"es6","es3");
	$jscomp$1.polyfill("String.prototype.repeat",function(a){return a?a:function(a){var b=$jscomp$1.checkStringArgs(this,null,"repeat");if(0>a||1342177279<a)throw new RangeError("Invalid count value");a|=0;for(var d="";a;)if(a&1&&(d+=b),a>>>=1)b+=b;return d}},"es6","es3");var COMPILED$1=!0,goog$1=goog$1||{};goog$1.global=commonjsGlobal$1||self;goog$1.isDef=function(a){return void 0!==a};goog$1.isString=function(a){return "string"==typeof a};goog$1.isBoolean=function(a){return "boolean"==typeof a};
	goog$1.isNumber=function(a){return "number"==typeof a};goog$1.exportPath_=function(a,b,c){a=a.split(".");c=c||goog$1.global;a[0]in c||"undefined"==typeof c.execScript||c.execScript("var "+a[0]);for(var d;a.length&&(d=a.shift());)!a.length&&goog$1.isDef(b)?c[d]=b:c=c[d]&&c[d]!==Object.prototype[d]?c[d]:c[d]={};};
	goog$1.define=function(a,b){return b};goog$1.FEATURESET_YEAR=2012;goog$1.DEBUG=!0;goog$1.LOCALE="en";goog$1.TRUSTED_SITE=!0;goog$1.STRICT_MODE_COMPATIBLE=!1;goog$1.DISALLOW_TEST_ONLY_CODE=!goog$1.DEBUG;goog$1.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING=!1;
	goog$1.provide=function(a){if(goog$1.isInModuleLoader_())throw Error("goog.provide cannot be used within a module.");goog$1.constructNamespace_(a);};goog$1.constructNamespace_=function(a,b){goog$1.exportPath_(a,b);};
	goog$1.getScriptNonce=function(a){if(a&&a!=goog$1.global)return goog$1.getScriptNonce_(a.document);null===goog$1.cspNonce_&&(goog$1.cspNonce_=goog$1.getScriptNonce_(goog$1.global.document));return goog$1.cspNonce_};goog$1.NONCE_PATTERN_=/^[\w+/_-]+[=]{0,2}$/;goog$1.cspNonce_=null;goog$1.getScriptNonce_=function(a){return (a=a.querySelector&&a.querySelector("script[nonce]"))&&(a=a.nonce||a.getAttribute("nonce"))&&goog$1.NONCE_PATTERN_.test(a)?a:""};goog$1.VALID_MODULE_RE_=/^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
	goog$1.module=function(a){if(!goog$1.isString(a)||!a||-1==a.search(goog$1.VALID_MODULE_RE_))throw Error("Invalid module identifier");if(!goog$1.isInGoogModuleLoader_())throw Error("Module "+a+" has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");
	if(goog$1.moduleLoaderState_.moduleName)throw Error("goog.module may only be called once per module.");goog$1.moduleLoaderState_.moduleName=a;};goog$1.module.get=function(a){return goog$1.module.getInternal_(a)};
	goog$1.module.getInternal_=function(a){return null};goog$1.ModuleType={ES6:"es6",GOOG:"goog"};goog$1.moduleLoaderState_=null;goog$1.isInModuleLoader_=function(){return goog$1.isInGoogModuleLoader_()||goog$1.isInEs6ModuleLoader_()};goog$1.isInGoogModuleLoader_=function(){return !!goog$1.moduleLoaderState_&&goog$1.moduleLoaderState_.type==goog$1.ModuleType.GOOG};
	goog$1.isInEs6ModuleLoader_=function(){if(goog$1.moduleLoaderState_&&goog$1.moduleLoaderState_.type==goog$1.ModuleType.ES6)return !0;var a=goog$1.global.$jscomp;return a?"function"!=typeof a.getCurrentModulePath?!1:!!a.getCurrentModulePath():!1};
	goog$1.module.declareLegacyNamespace=function(){goog$1.moduleLoaderState_.declareLegacyNamespace=!0;};
	goog$1.declareModuleId=function(a){if(goog$1.moduleLoaderState_)goog$1.moduleLoaderState_.moduleName=a;else {var b=goog$1.global.$jscomp;if(!b||"function"!=typeof b.getCurrentModulePath)throw Error('Module with namespace "'+
	a+'" has been loaded incorrectly.');b=b.require(b.getCurrentModulePath());goog$1.loadedModules_[a]={exports:b,type:goog$1.ModuleType.ES6,moduleId:a};}};goog$1.setTestOnly=function(a){if(goog$1.DISALLOW_TEST_ONLY_CODE)throw a=a||"",Error("Importing test-only code into non-debug environment"+(a?": "+a:"."));};goog$1.forwardDeclare=function(a){};
	goog$1.getObjectByName=function(a,b){a=a.split(".");b=b||goog$1.global;for(var c=0;c<a.length;c++)if(b=b[a[c]],!goog$1.isDefAndNotNull(b))return null;return b};goog$1.globalize=function(a,b){b=b||goog$1.global;for(var c in a)b[c]=a[c];};
	goog$1.addDependency=function(a,b,c,d){};goog$1.ENABLE_DEBUG_LOADER=!0;goog$1.logToConsole_=function(a){goog$1.global.console&&goog$1.global.console.error(a);};
	goog$1.require=function(a){};goog$1.requireType=function(a){return {}};goog$1.basePath="";goog$1.nullFunction=function(){};
	goog$1.abstractMethod=function(){throw Error("unimplemented abstract method");};goog$1.addSingletonGetter=function(a){a.instance_=void 0;a.getInstance=function(){if(a.instance_)return a.instance_;goog$1.DEBUG&&(goog$1.instantiatedSingletons_[goog$1.instantiatedSingletons_.length]=a);return a.instance_=new a};};goog$1.instantiatedSingletons_=[];goog$1.LOAD_MODULE_USING_EVAL=!0;goog$1.SEAL_MODULE_EXPORTS=goog$1.DEBUG;goog$1.loadedModules_={};goog$1.DEPENDENCIES_ENABLED=!COMPILED$1;goog$1.TRANSPILE="detect";
	goog$1.ASSUME_ES_MODULES_TRANSPILED=!1;goog$1.TRANSPILE_TO_LANGUAGE="";goog$1.TRANSPILER="transpile.js";goog$1.hasBadLetScoping=null;goog$1.useSafari10Workaround=function(){if(null==goog$1.hasBadLetScoping){try{var a=!eval('"use strict";let x = 1; function f() { return typeof x; };f() == "number";');}catch(b){a=!1;}goog$1.hasBadLetScoping=a;}return goog$1.hasBadLetScoping};goog$1.workaroundSafari10EvalBug=function(a){return "(function(){"+a+"\n;})();\n"};
	goog$1.loadModule=function(a){var b=goog$1.moduleLoaderState_;try{goog$1.moduleLoaderState_={moduleName:"",declareLegacyNamespace:!1,type:goog$1.ModuleType.GOOG};if(goog$1.isFunction(a))var c=a.call(void 0,{});else if(goog$1.isString(a))goog$1.useSafari10Workaround()&&(a=goog$1.workaroundSafari10EvalBug(a)),c=goog$1.loadModuleFromSource_.call(void 0,a);else throw Error("Invalid module definition");var d=goog$1.moduleLoaderState_.moduleName;if(goog$1.isString(d)&&d)goog$1.moduleLoaderState_.declareLegacyNamespace?goog$1.constructNamespace_(d,
	c):goog$1.SEAL_MODULE_EXPORTS&&Object.seal&&"object"==typeof c&&null!=c&&Object.seal(c),goog$1.loadedModules_[d]={exports:c,type:goog$1.ModuleType.GOOG,moduleId:goog$1.moduleLoaderState_.moduleName};else throw Error('Invalid module name "'+d+'"');}finally{goog$1.moduleLoaderState_=b;}};goog$1.loadModuleFromSource_=function(a){eval(a);return {}};goog$1.normalizePath_=function(a){a=a.split("/");for(var b=0;b<a.length;)"."==a[b]?a.splice(b,1):b&&".."==a[b]&&a[b-1]&&".."!=a[b-1]?a.splice(--b,2):b++;return a.join("/")};
	goog$1.loadFileSync_=function(a){if(goog$1.global.CLOSURE_LOAD_FILE_SYNC)return goog$1.global.CLOSURE_LOAD_FILE_SYNC(a);try{var b=new goog$1.global.XMLHttpRequest;b.open("get",a,!1);b.send();return 0==b.status||200==b.status?b.responseText:null}catch(c){return null}};
	goog$1.transpile_=function(a,b,c){var d=goog$1.global.$jscomp;d||(goog$1.global.$jscomp=d={});var e=d.transpile;if(!e){var f=goog$1.basePath+goog$1.TRANSPILER,g=goog$1.loadFileSync_(f);if(g){(function(){(0, eval)(g+"\n//# sourceURL="+f);}).call(goog$1.global);if(goog$1.global.$gwtExport&&goog$1.global.$gwtExport.$jscomp&&!goog$1.global.$gwtExport.$jscomp.transpile)throw Error('The transpiler did not properly export the "transpile" method. $gwtExport: '+JSON.stringify(goog$1.global.$gwtExport));goog$1.global.$jscomp.transpile=
	goog$1.global.$gwtExport.$jscomp.transpile;d=goog$1.global.$jscomp;e=d.transpile;}}e||(e=d.transpile=function(a,b){goog$1.logToConsole_(b+" requires transpilation but no transpiler was found.");return a});return e(a,b,c)};
	goog$1.typeOf=function(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return "array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return "object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return "array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return "function"}else return "null";
	else if("function"==b&&"undefined"==typeof a.call)return "object";return b};goog$1.isNull=function(a){return null===a};goog$1.isDefAndNotNull=function(a){return null!=a};goog$1.isArray=function(a){return "array"==goog$1.typeOf(a)};goog$1.isArrayLike=function(a){var b=goog$1.typeOf(a);return "array"==b||"object"==b&&"number"==typeof a.length};goog$1.isDateLike=function(a){return goog$1.isObject(a)&&"function"==typeof a.getFullYear};goog$1.isFunction=function(a){return "function"==goog$1.typeOf(a)};
	goog$1.isObject=function(a){var b=typeof a;return "object"==b&&null!=a||"function"==b};goog$1.getUid=function(a){return a[goog$1.UID_PROPERTY_]||(a[goog$1.UID_PROPERTY_]=++goog$1.uidCounter_)};goog$1.hasUid=function(a){return !!a[goog$1.UID_PROPERTY_]};goog$1.removeUid=function(a){null!==a&&"removeAttribute"in a&&a.removeAttribute(goog$1.UID_PROPERTY_);try{delete a[goog$1.UID_PROPERTY_];}catch(b){}};goog$1.UID_PROPERTY_="closure_uid_"+(1E9*Math.random()>>>0);goog$1.uidCounter_=0;goog$1.getHashCode=goog$1.getUid;
	goog$1.removeHashCode=goog$1.removeUid;goog$1.cloneObject=function(a){var b=goog$1.typeOf(a);if("object"==b||"array"==b){if("function"===typeof a.clone)return a.clone();b="array"==b?[]:{};for(var c in a)b[c]=goog$1.cloneObject(a[c]);return b}return a};goog$1.bindNative_=function(a,b,c){return a.call.apply(a.bind,arguments)};
	goog$1.bindJs_=function(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}};goog$1.bind=function(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?goog$1.bind=goog$1.bindNative_:goog$1.bind=goog$1.bindJs_;return goog$1.bind.apply(null,arguments)};
	goog$1.partial=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}};goog$1.mixin=function(a,b){for(var c in b)a[c]=b[c];};goog$1.now=goog$1.TRUSTED_SITE&&Date.now||function(){return +new Date};
	goog$1.globalEval=function(a){if(goog$1.global.execScript)goog$1.global.execScript(a,"JavaScript");else if(goog$1.global.eval){if(null==goog$1.evalWorksForGlobals_){try{goog$1.global.eval("var _evalTest_ = 1;");}catch(d){}if("undefined"!=typeof goog$1.global._evalTest_){try{delete goog$1.global._evalTest_;}catch(d){}goog$1.evalWorksForGlobals_=!0;}else goog$1.evalWorksForGlobals_=!1;}if(goog$1.evalWorksForGlobals_)goog$1.global.eval(a);else {var b=goog$1.global.document,c=b.createElement("SCRIPT");c.type="text/javascript";c.defer=
	!1;c.appendChild(b.createTextNode(a));b.head.appendChild(c);b.head.removeChild(c);}}else throw Error("goog.globalEval not available");};goog$1.evalWorksForGlobals_=null;
	goog$1.getCssName=function(a,b){if("."==String(a).charAt(0))throw Error('className passed in goog.getCssName must not start with ".". You passed: '+a);var c=function(a){return goog$1.cssNameMapping_[a]||a},d=function(a){a=a.split("-");for(var b=[],d=0;d<a.length;d++)b.push(c(a[d]));return b.join("-")};d=goog$1.cssNameMapping_?"BY_WHOLE"==goog$1.cssNameMappingStyle_?c:d:function(a){return a};a=b?a+"-"+d(b):d(a);return goog$1.global.CLOSURE_CSS_NAME_MAP_FN?goog$1.global.CLOSURE_CSS_NAME_MAP_FN(a):a};
	goog$1.setCssNameMapping=function(a,b){goog$1.cssNameMapping_=a;goog$1.cssNameMappingStyle_=b;};goog$1.getMsg=function(a,b,c){c&&c.html&&(a=a.replace(/</g,"&lt;"));b&&(a=a.replace(/\{\$([^}]+)}/g,function(a,c){return null!=b&&c in b?b[c]:a}));return a};goog$1.getMsgWithFallback=function(a,b){return a};goog$1.exportSymbol=function(a,b,c){goog$1.exportPath_(a,b,c);};
	goog$1.exportProperty=function(a,b,c){a[b]=c;};goog$1.inherits=function(a,b){function c(){}c.prototype=b.prototype;a.superClass_=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.base=function(a,c,f){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)};};
	goog$1.base=function(a,b,c){var d=arguments.callee.caller;if(goog$1.STRICT_MODE_COMPATIBLE||goog$1.DEBUG&&!d)throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");if("undefined"!==typeof d.superClass_){for(var e=Array(arguments.length-1),f=1;f<arguments.length;f++)e[f-1]=arguments[f];return d.superClass_.constructor.apply(a,e)}if("string"!=typeof b&&"symbol"!=typeof b)throw Error("method names provided to goog.base must be a string or a symbol");
	e=Array(arguments.length-2);for(f=2;f<arguments.length;f++)e[f-2]=arguments[f];f=!1;for(var g=a.constructor.prototype;g;g=Object.getPrototypeOf(g))if(g[b]===d)f=!0;else if(f)return g[b].apply(a,e);if(a[b]===d)return a.constructor.prototype[b].apply(a,e);throw Error("goog.base called from a method of one name to a method of a different name");};goog$1.scope=function(a){if(goog$1.isInModuleLoader_())throw Error("goog.scope is not supported within a module.");a.call(goog$1.global);};
	goog$1.defineClass=function(a,b){var c=b.constructor,d=b.statics;c&&c!=Object.prototype.constructor||(c=function(){throw Error("cannot instantiate an interface (no constructor defined).");});c=goog$1.defineClass.createSealingConstructor_(c,a);a&&goog$1.inherits(c,a);delete b.constructor;delete b.statics;goog$1.defineClass.applyProperties_(c.prototype,b);null!=d&&(d instanceof Function?d(c):goog$1.defineClass.applyProperties_(c,d));return c};
	goog$1.defineClass.SEAL_CLASS_INSTANCES=goog$1.DEBUG;goog$1.defineClass.createSealingConstructor_=function(a,b){if(!goog$1.defineClass.SEAL_CLASS_INSTANCES)return a;var c=!goog$1.defineClass.isUnsealable_(b),d=function(){var b=a.apply(this,arguments)||this;b[goog$1.UID_PROPERTY_]=b[goog$1.UID_PROPERTY_];this.constructor===d&&c&&Object.seal instanceof Function&&Object.seal(b);return b};return d};goog$1.defineClass.isUnsealable_=function(a){return a&&a.prototype&&a.prototype[goog$1.UNSEALABLE_CONSTRUCTOR_PROPERTY_]};
	goog$1.defineClass.OBJECT_PROTOTYPE_FIELDS_="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");goog$1.defineClass.applyProperties_=function(a,b){for(var c in b)Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c]);for(var d=0;d<goog$1.defineClass.OBJECT_PROTOTYPE_FIELDS_.length;d++)c=goog$1.defineClass.OBJECT_PROTOTYPE_FIELDS_[d],Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c]);};
	goog$1.tagUnsealableClass=function(a){};goog$1.UNSEALABLE_CONSTRUCTOR_PROPERTY_="goog_defineClass_legacy_unsealable";
	goog$1.TRUSTED_TYPES_POLICY_NAME="";goog$1.identity_=function(a){return a};goog$1.createTrustedTypesPolicy=function(a){var b=null;if("undefined"===typeof TrustedTypes||!TrustedTypes.createPolicy)return b;try{b=TrustedTypes.createPolicy(a,{createHTML:goog$1.identity_,createScript:goog$1.identity_,createScriptURL:goog$1.identity_,createURL:goog$1.identity_});}catch(c){goog$1.logToConsole_(c.message);}return b};
	goog$1.TRUSTED_TYPES_POLICY_=goog$1.TRUSTED_TYPES_POLICY_NAME?goog$1.createTrustedTypesPolicy(goog$1.TRUSTED_TYPES_POLICY_NAME+"#base"):null;var jspb$1={BinaryConstants:{},ConstBinaryMessage:function(){},BinaryMessage:function(){}};jspb$1.BinaryConstants.FieldType={INVALID:-1,DOUBLE:1,FLOAT:2,INT64:3,UINT64:4,INT32:5,FIXED64:6,FIXED32:7,BOOL:8,STRING:9,GROUP:10,MESSAGE:11,BYTES:12,UINT32:13,ENUM:14,SFIXED32:15,SFIXED64:16,SINT32:17,SINT64:18,FHASH64:30,VHASH64:31};jspb$1.BinaryConstants.WireType={INVALID:-1,VARINT:0,FIXED64:1,DELIMITED:2,START_GROUP:3,END_GROUP:4,FIXED32:5};
	jspb$1.BinaryConstants.FieldTypeToWireType=function(a){var b=jspb$1.BinaryConstants.FieldType,c=jspb$1.BinaryConstants.WireType;switch(a){case b.INT32:case b.INT64:case b.UINT32:case b.UINT64:case b.SINT32:case b.SINT64:case b.BOOL:case b.ENUM:case b.VHASH64:return c.VARINT;case b.DOUBLE:case b.FIXED64:case b.SFIXED64:case b.FHASH64:return c.FIXED64;case b.STRING:case b.MESSAGE:case b.BYTES:return c.DELIMITED;case b.FLOAT:case b.FIXED32:case b.SFIXED32:return c.FIXED32;default:return c.INVALID}};
	jspb$1.BinaryConstants.INVALID_FIELD_NUMBER=-1;jspb$1.BinaryConstants.FLOAT32_EPS=1.401298464324817E-45;jspb$1.BinaryConstants.FLOAT32_MIN=1.1754943508222875E-38;jspb$1.BinaryConstants.FLOAT32_MAX=3.4028234663852886E38;jspb$1.BinaryConstants.FLOAT64_EPS=4.9E-324;jspb$1.BinaryConstants.FLOAT64_MIN=2.2250738585072014E-308;jspb$1.BinaryConstants.FLOAT64_MAX=1.7976931348623157E308;jspb$1.BinaryConstants.TWO_TO_20=1048576;jspb$1.BinaryConstants.TWO_TO_23=8388608;jspb$1.BinaryConstants.TWO_TO_31=2147483648;
	jspb$1.BinaryConstants.TWO_TO_32=4294967296;jspb$1.BinaryConstants.TWO_TO_52=4503599627370496;jspb$1.BinaryConstants.TWO_TO_63=0x7fffffffffffffff;jspb$1.BinaryConstants.TWO_TO_64=1.8446744073709552E19;jspb$1.BinaryConstants.ZERO_HASH="\x00\x00\x00\x00\x00\x00\x00\x00";goog$1.dom={};goog$1.dom.NodeType={ELEMENT:1,ATTRIBUTE:2,TEXT:3,CDATA_SECTION:4,ENTITY_REFERENCE:5,ENTITY:6,PROCESSING_INSTRUCTION:7,COMMENT:8,DOCUMENT:9,DOCUMENT_TYPE:10,DOCUMENT_FRAGMENT:11,NOTATION:12};goog$1.debug={};goog$1.debug.Error=function(a){if(Error.captureStackTrace)Error.captureStackTrace(this,goog$1.debug.Error);else {var b=Error().stack;b&&(this.stack=b);}a&&(this.message=String(a));this.reportErrorToServer=!0;};goog$1.inherits(goog$1.debug.Error,Error);goog$1.debug.Error.prototype.name="CustomError";goog$1.asserts={};goog$1.asserts.ENABLE_ASSERTS=goog$1.DEBUG;goog$1.asserts.AssertionError=function(a,b){goog$1.debug.Error.call(this,goog$1.asserts.subs_(a,b));this.messagePattern=a;};goog$1.inherits(goog$1.asserts.AssertionError,goog$1.debug.Error);goog$1.asserts.AssertionError.prototype.name="AssertionError";goog$1.asserts.DEFAULT_ERROR_HANDLER=function(a){throw a;};goog$1.asserts.errorHandler_=goog$1.asserts.DEFAULT_ERROR_HANDLER;
	goog$1.asserts.subs_=function(a,b){a=a.split("%s");for(var c="",d=a.length-1,e=0;e<d;e++)c+=a[e]+(e<b.length?b[e]:"%s");return c+a[d]};goog$1.asserts.doAssertFailure_=function(a,b,c,d){var e="Assertion failed";if(c){e+=": "+c;var f=d;}else a&&(e+=": "+a,f=b);a=new goog$1.asserts.AssertionError(""+e,f||[]);goog$1.asserts.errorHandler_(a);};goog$1.asserts.setErrorHandler=function(a){goog$1.asserts.ENABLE_ASSERTS&&(goog$1.asserts.errorHandler_=a);};
	goog$1.asserts.assert=function(a,b,c){goog$1.asserts.ENABLE_ASSERTS&&!a&&goog$1.asserts.doAssertFailure_("",null,b,Array.prototype.slice.call(arguments,2));return a};goog$1.asserts.assertExists=function(a,b,c){goog$1.asserts.ENABLE_ASSERTS&&null==a&&goog$1.asserts.doAssertFailure_("Expected to exist: %s.",[a],b,Array.prototype.slice.call(arguments,2));return a};
	goog$1.asserts.fail=function(a,b){goog$1.asserts.ENABLE_ASSERTS&&goog$1.asserts.errorHandler_(new goog$1.asserts.AssertionError("Failure"+(a?": "+a:""),Array.prototype.slice.call(arguments,1)));};goog$1.asserts.assertNumber=function(a,b,c){goog$1.asserts.ENABLE_ASSERTS&&!goog$1.isNumber(a)&&goog$1.asserts.doAssertFailure_("Expected number but got %s: %s.",[goog$1.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
	goog$1.asserts.assertString=function(a,b,c){goog$1.asserts.ENABLE_ASSERTS&&!goog$1.isString(a)&&goog$1.asserts.doAssertFailure_("Expected string but got %s: %s.",[goog$1.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog$1.asserts.assertFunction=function(a,b,c){goog$1.asserts.ENABLE_ASSERTS&&!goog$1.isFunction(a)&&goog$1.asserts.doAssertFailure_("Expected function but got %s: %s.",[goog$1.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
	goog$1.asserts.assertObject=function(a,b,c){goog$1.asserts.ENABLE_ASSERTS&&!goog$1.isObject(a)&&goog$1.asserts.doAssertFailure_("Expected object but got %s: %s.",[goog$1.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog$1.asserts.assertArray=function(a,b,c){goog$1.asserts.ENABLE_ASSERTS&&!goog$1.isArray(a)&&goog$1.asserts.doAssertFailure_("Expected array but got %s: %s.",[goog$1.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
	goog$1.asserts.assertBoolean=function(a,b,c){goog$1.asserts.ENABLE_ASSERTS&&!goog$1.isBoolean(a)&&goog$1.asserts.doAssertFailure_("Expected boolean but got %s: %s.",[goog$1.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog$1.asserts.assertElement=function(a,b,c){!goog$1.asserts.ENABLE_ASSERTS||goog$1.isObject(a)&&a.nodeType==goog$1.dom.NodeType.ELEMENT||goog$1.asserts.doAssertFailure_("Expected Element but got %s: %s.",[goog$1.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
	goog$1.asserts.assertInstanceof=function(a,b,c,d){!goog$1.asserts.ENABLE_ASSERTS||a instanceof b||goog$1.asserts.doAssertFailure_("Expected instanceof %s but got %s.",[goog$1.asserts.getType_(b),goog$1.asserts.getType_(a)],c,Array.prototype.slice.call(arguments,3));return a};goog$1.asserts.assertFinite=function(a,b,c){!goog$1.asserts.ENABLE_ASSERTS||"number"==typeof a&&isFinite(a)||goog$1.asserts.doAssertFailure_("Expected %s to be a finite number but it is not.",[a],b,Array.prototype.slice.call(arguments,2));return a};
	goog$1.asserts.assertObjectPrototypeIsIntact=function(){for(var a in Object.prototype)goog$1.asserts.fail(a+" should not be enumerable in Object.prototype.");};goog$1.asserts.getType_=function(a){return a instanceof Function?a.displayName||a.name||"unknown type name":a instanceof Object?a.constructor.displayName||a.constructor.name||Object.prototype.toString.call(a):null===a?"null":typeof a};goog$1.array={};goog$1.NATIVE_ARRAY_PROTOTYPES=goog$1.TRUSTED_SITE;goog$1.array.ASSUME_NATIVE_FUNCTIONS=2012<goog$1.FEATURESET_YEAR;goog$1.array.peek=function(a){return a[a.length-1]};goog$1.array.last=goog$1.array.peek;
	goog$1.array.indexOf=goog$1.NATIVE_ARRAY_PROTOTYPES&&(goog$1.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.indexOf)?function(a,b,c){goog$1.asserts.assert(null!=a.length);return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(goog$1.isString(a))return goog$1.isString(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return -1};
	goog$1.array.lastIndexOf=goog$1.NATIVE_ARRAY_PROTOTYPES&&(goog$1.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.lastIndexOf)?function(a,b,c){goog$1.asserts.assert(null!=a.length);return Array.prototype.lastIndexOf.call(a,b,null==c?a.length-1:c)}:function(a,b,c){c=null==c?a.length-1:c;0>c&&(c=Math.max(0,a.length+c));if(goog$1.isString(a))return goog$1.isString(b)&&1==b.length?a.lastIndexOf(b,c):-1;for(;0<=c;c--)if(c in a&&a[c]===b)return c;return -1};
	goog$1.array.forEach=goog$1.NATIVE_ARRAY_PROTOTYPES&&(goog$1.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.forEach)?function(a,b,c){goog$1.asserts.assert(null!=a.length);Array.prototype.forEach.call(a,b,c);}:function(a,b,c){for(var d=a.length,e=goog$1.isString(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a);};goog$1.array.forEachRight=function(a,b,c){var d=a.length,e=goog$1.isString(a)?a.split(""):a;for(--d;0<=d;--d)d in e&&b.call(c,e[d],d,a);};
	goog$1.array.filter=goog$1.NATIVE_ARRAY_PROTOTYPES&&(goog$1.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.filter)?function(a,b,c){goog$1.asserts.assert(null!=a.length);return Array.prototype.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,g=goog$1.isString(a)?a.split(""):a,h=0;h<d;h++)if(h in g){var k=g[h];b.call(c,k,h,a)&&(e[f++]=k);}return e};
	goog$1.array.map=goog$1.NATIVE_ARRAY_PROTOTYPES&&(goog$1.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.map)?function(a,b,c){goog$1.asserts.assert(null!=a.length);return Array.prototype.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=goog$1.isString(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e};
	goog$1.array.reduce=goog$1.NATIVE_ARRAY_PROTOTYPES&&(goog$1.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.reduce)?function(a,b,c,d){goog$1.asserts.assert(null!=a.length);d&&(b=goog$1.bind(b,d));return Array.prototype.reduce.call(a,b,c)}:function(a,b,c,d){var e=c;goog$1.array.forEach(a,function(c,g){e=b.call(d,e,c,g,a);});return e};
	goog$1.array.reduceRight=goog$1.NATIVE_ARRAY_PROTOTYPES&&(goog$1.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.reduceRight)?function(a,b,c,d){goog$1.asserts.assert(null!=a.length);goog$1.asserts.assert(null!=b);d&&(b=goog$1.bind(b,d));return Array.prototype.reduceRight.call(a,b,c)}:function(a,b,c,d){var e=c;goog$1.array.forEachRight(a,function(c,g){e=b.call(d,e,c,g,a);});return e};
	goog$1.array.some=goog$1.NATIVE_ARRAY_PROTOTYPES&&(goog$1.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.some)?function(a,b,c){goog$1.asserts.assert(null!=a.length);return Array.prototype.some.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog$1.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return !0;return !1};
	goog$1.array.every=goog$1.NATIVE_ARRAY_PROTOTYPES&&(goog$1.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.every)?function(a,b,c){goog$1.asserts.assert(null!=a.length);return Array.prototype.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog$1.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return !1;return !0};goog$1.array.count=function(a,b,c){var d=0;goog$1.array.forEach(a,function(a,f,g){b.call(c,a,f,g)&&++d;},c);return d};
	goog$1.array.find=function(a,b,c){b=goog$1.array.findIndex(a,b,c);return 0>b?null:goog$1.isString(a)?a.charAt(b):a[b]};goog$1.array.findIndex=function(a,b,c){for(var d=a.length,e=goog$1.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return f;return -1};goog$1.array.findRight=function(a,b,c){b=goog$1.array.findIndexRight(a,b,c);return 0>b?null:goog$1.isString(a)?a.charAt(b):a[b]};
	goog$1.array.findIndexRight=function(a,b,c){var d=a.length,e=goog$1.isString(a)?a.split(""):a;for(--d;0<=d;d--)if(d in e&&b.call(c,e[d],d,a))return d;return -1};goog$1.array.contains=function(a,b){return 0<=goog$1.array.indexOf(a,b)};goog$1.array.isEmpty=function(a){return 0==a.length};goog$1.array.clear=function(a){if(!goog$1.isArray(a))for(var b=a.length-1;0<=b;b--)delete a[b];a.length=0;};goog$1.array.insert=function(a,b){goog$1.array.contains(a,b)||a.push(b);};
	goog$1.array.insertAt=function(a,b,c){goog$1.array.splice(a,c,0,b);};goog$1.array.insertArrayAt=function(a,b,c){goog$1.partial(goog$1.array.splice,a,c,0).apply(null,b);};goog$1.array.insertBefore=function(a,b,c){var d;2==arguments.length||0>(d=goog$1.array.indexOf(a,c))?a.push(b):goog$1.array.insertAt(a,b,d);};goog$1.array.remove=function(a,b){b=goog$1.array.indexOf(a,b);var c;(c=0<=b)&&goog$1.array.removeAt(a,b);return c};
	goog$1.array.removeLast=function(a,b){b=goog$1.array.lastIndexOf(a,b);return 0<=b?(goog$1.array.removeAt(a,b),!0):!1};goog$1.array.removeAt=function(a,b){goog$1.asserts.assert(null!=a.length);return 1==Array.prototype.splice.call(a,b,1).length};goog$1.array.removeIf=function(a,b,c){b=goog$1.array.findIndex(a,b,c);return 0<=b?(goog$1.array.removeAt(a,b),!0):!1};goog$1.array.removeAllIf=function(a,b,c){var d=0;goog$1.array.forEachRight(a,function(e,f){b.call(c,e,f,a)&&goog$1.array.removeAt(a,f)&&d++;});return d};
	goog$1.array.concat=function(a){return Array.prototype.concat.apply([],arguments)};goog$1.array.join=function(a){return Array.prototype.concat.apply([],arguments)};goog$1.array.toArray=function(a){var b=a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return []};goog$1.array.clone=goog$1.array.toArray;goog$1.array.extend=function(a,b){for(var c=1;c<arguments.length;c++){var d=arguments[c];if(goog$1.isArrayLike(d)){var e=a.length||0,f=d.length||0;a.length=e+f;for(var g=0;g<f;g++)a[e+g]=d[g];}else a.push(d);}};
	goog$1.array.splice=function(a,b,c,d){goog$1.asserts.assert(null!=a.length);return Array.prototype.splice.apply(a,goog$1.array.slice(arguments,1))};goog$1.array.slice=function(a,b,c){goog$1.asserts.assert(null!=a.length);return 2>=arguments.length?Array.prototype.slice.call(a,b):Array.prototype.slice.call(a,b,c)};
	goog$1.array.removeDuplicates=function(a,b,c){b=b||a;var d=function(a){return goog$1.isObject(a)?"o"+goog$1.getUid(a):(typeof a).charAt(0)+a};c=c||d;d={};for(var e=0,f=0;f<a.length;){var g=a[f++],h=c(g);Object.prototype.hasOwnProperty.call(d,h)||(d[h]=!0,b[e++]=g);}b.length=e;};goog$1.array.binarySearch=function(a,b,c){return goog$1.array.binarySearch_(a,c||goog$1.array.defaultCompare,!1,b)};goog$1.array.binarySelect=function(a,b,c){return goog$1.array.binarySearch_(a,b,!0,void 0,c)};
	goog$1.array.binarySearch_=function(a,b,c,d,e){for(var f=0,g=a.length,h;f<g;){var k=f+g>>1;var l=c?b.call(e,a[k],k,a):b(d,a[k]);0<l?f=k+1:(g=k,h=!l);}return h?f:~f};goog$1.array.sort=function(a,b){a.sort(b||goog$1.array.defaultCompare);};goog$1.array.stableSort=function(a,b){for(var c=Array(a.length),d=0;d<a.length;d++)c[d]={index:d,value:a[d]};var e=b||goog$1.array.defaultCompare;goog$1.array.sort(c,function(a,b){return e(a.value,b.value)||a.index-b.index});for(d=0;d<a.length;d++)a[d]=c[d].value;};
	goog$1.array.sortByKey=function(a,b,c){var d=c||goog$1.array.defaultCompare;goog$1.array.sort(a,function(a,c){return d(b(a),b(c))});};goog$1.array.sortObjectsByKey=function(a,b,c){goog$1.array.sortByKey(a,function(a){return a[b]},c);};goog$1.array.isSorted=function(a,b,c){b=b||goog$1.array.defaultCompare;for(var d=1;d<a.length;d++){var e=b(a[d-1],a[d]);if(0<e||0==e&&c)return !1}return !0};
	goog$1.array.equals=function(a,b,c){if(!goog$1.isArrayLike(a)||!goog$1.isArrayLike(b)||a.length!=b.length)return !1;var d=a.length;c=c||goog$1.array.defaultCompareEquality;for(var e=0;e<d;e++)if(!c(a[e],b[e]))return !1;return !0};goog$1.array.compare3=function(a,b,c){c=c||goog$1.array.defaultCompare;for(var d=Math.min(a.length,b.length),e=0;e<d;e++){var f=c(a[e],b[e]);if(0!=f)return f}return goog$1.array.defaultCompare(a.length,b.length)};goog$1.array.defaultCompare=function(a,b){return a>b?1:a<b?-1:0};
	goog$1.array.inverseDefaultCompare=function(a,b){return -goog$1.array.defaultCompare(a,b)};goog$1.array.defaultCompareEquality=function(a,b){return a===b};goog$1.array.binaryInsert=function(a,b,c){c=goog$1.array.binarySearch(a,b,c);return 0>c?(goog$1.array.insertAt(a,b,-(c+1)),!0):!1};goog$1.array.binaryRemove=function(a,b,c){b=goog$1.array.binarySearch(a,b,c);return 0<=b?goog$1.array.removeAt(a,b):!1};
	goog$1.array.bucket=function(a,b,c){for(var d={},e=0;e<a.length;e++){var f=a[e],g=b.call(c,f,e,a);goog$1.isDef(g)&&(d[g]||(d[g]=[])).push(f);}return d};goog$1.array.toObject=function(a,b,c){var d={};goog$1.array.forEach(a,function(e,f){d[b.call(c,e,f,a)]=e;});return d};goog$1.array.range=function(a,b,c){var d=[],e=0,f=a;c=c||1;void 0!==b&&(e=a,f=b);if(0>c*(f-e))return [];if(0<c)for(a=e;a<f;a+=c)d.push(a);else for(a=e;a>f;a+=c)d.push(a);return d};
	goog$1.array.repeat=function(a,b){for(var c=[],d=0;d<b;d++)c[d]=a;return c};goog$1.array.flatten=function(a){for(var b=[],c=0;c<arguments.length;c++){var d=arguments[c];if(goog$1.isArray(d))for(var e=0;e<d.length;e+=8192){var f=goog$1.array.slice(d,e,e+8192);f=goog$1.array.flatten.apply(null,f);for(var g=0;g<f.length;g++)b.push(f[g]);}else b.push(d);}return b};
	goog$1.array.rotate=function(a,b){goog$1.asserts.assert(null!=a.length);a.length&&(b%=a.length,0<b?Array.prototype.unshift.apply(a,a.splice(-b,b)):0>b&&Array.prototype.push.apply(a,a.splice(0,-b)));return a};goog$1.array.moveItem=function(a,b,c){goog$1.asserts.assert(0<=b&&b<a.length);goog$1.asserts.assert(0<=c&&c<a.length);b=Array.prototype.splice.call(a,b,1);Array.prototype.splice.call(a,c,0,b[0]);};
	goog$1.array.zip=function(a){if(!arguments.length)return [];for(var b=[],c=arguments[0].length,d=1;d<arguments.length;d++)arguments[d].length<c&&(c=arguments[d].length);for(d=0;d<c;d++){for(var e=[],f=0;f<arguments.length;f++)e.push(arguments[f][d]);b.push(e);}return b};goog$1.array.shuffle=function(a,b){b=b||Math.random;for(var c=a.length-1;0<c;c--){var d=Math.floor(b()*(c+1)),e=a[c];a[c]=a[d];a[d]=e;}};goog$1.array.copyByIndex=function(a,b){var c=[];goog$1.array.forEach(b,function(b){c.push(a[b]);});return c};
	goog$1.array.concatMap=function(a,b,c){return goog$1.array.concat.apply([],goog$1.array.map(a,b,c))};goog$1.crypt={};goog$1.crypt.stringToByteArray=function(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);255<e&&(b[c++]=e&255,e>>=8);b[c++]=e;}return b};goog$1.crypt.byteArrayToString=function(a){if(8192>=a.length)return String.fromCharCode.apply(null,a);for(var b="",c=0;c<a.length;c+=8192){var d=goog$1.array.slice(a,c,c+8192);b+=String.fromCharCode.apply(null,d);}return b};
	goog$1.crypt.byteArrayToHex=function(a,b){return goog$1.array.map(a,function(a){a=a.toString(16);return 1<a.length?a:"0"+a}).join(b||"")};goog$1.crypt.hexToByteArray=function(a){goog$1.asserts.assert(0==a.length%2,"Key string length must be multiple of 2");for(var b=[],c=0;c<a.length;c+=2)b.push(parseInt(a.substring(c,c+2),16));return b};
	goog$1.crypt.stringToUtf8ByteArray=function(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);128>e?b[c++]=e:(2048>e?b[c++]=e>>6|192:(55296==(e&64512)&&d+1<a.length&&56320==(a.charCodeAt(d+1)&64512)?(e=65536+((e&1023)<<10)+(a.charCodeAt(++d)&1023),b[c++]=e>>18|240,b[c++]=e>>12&63|128):b[c++]=e>>12|224,b[c++]=e>>6&63|128),b[c++]=e&63|128);}return b};
	goog$1.crypt.utf8ByteArrayToString=function(a){for(var b=[],c=0,d=0;c<a.length;){var e=a[c++];if(128>e)b[d++]=String.fromCharCode(e);else if(191<e&&224>e){var f=a[c++];b[d++]=String.fromCharCode((e&31)<<6|f&63);}else if(239<e&&365>e){f=a[c++];var g=a[c++],h=a[c++];e=((e&7)<<18|(f&63)<<12|(g&63)<<6|h&63)-65536;b[d++]=String.fromCharCode(55296+(e>>10));b[d++]=String.fromCharCode(56320+(e&1023));}else f=a[c++],g=a[c++],b[d++]=String.fromCharCode((e&15)<<12|(f&63)<<6|g&63);}return b.join("")};
	goog$1.crypt.xorByteArray=function(a,b){goog$1.asserts.assert(a.length==b.length,"XOR array lengths must match");for(var c=[],d=0;d<a.length;d++)c.push(a[d]^b[d]);return c};goog$1.string={};goog$1.string.internal={};goog$1.string.internal.startsWith=function(a,b){return 0==a.lastIndexOf(b,0)};goog$1.string.internal.endsWith=function(a,b){var c=a.length-b.length;return 0<=c&&a.indexOf(b,c)==c};goog$1.string.internal.caseInsensitiveStartsWith=function(a,b){return 0==goog$1.string.internal.caseInsensitiveCompare(b,a.substr(0,b.length))};goog$1.string.internal.caseInsensitiveEndsWith=function(a,b){return 0==goog$1.string.internal.caseInsensitiveCompare(b,a.substr(a.length-b.length,b.length))};
	goog$1.string.internal.caseInsensitiveEquals=function(a,b){return a.toLowerCase()==b.toLowerCase()};goog$1.string.internal.isEmptyOrWhitespace=function(a){return /^[\s\xa0]*$/.test(a)};goog$1.string.internal.trim=goog$1.TRUSTED_SITE&&String.prototype.trim?function(a){return a.trim()}:function(a){return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1]};goog$1.string.internal.caseInsensitiveCompare=function(a,b){a=String(a).toLowerCase();b=String(b).toLowerCase();return a<b?-1:a==b?0:1};
	goog$1.string.internal.newLineToBr=function(a,b){return a.replace(/(\r\n|\r|\n)/g,b?"<br />":"<br>")};
	goog$1.string.internal.htmlEscape=function(a,b){if(b)a=a.replace(goog$1.string.internal.AMP_RE_,"&amp;").replace(goog$1.string.internal.LT_RE_,"&lt;").replace(goog$1.string.internal.GT_RE_,"&gt;").replace(goog$1.string.internal.QUOT_RE_,"&quot;").replace(goog$1.string.internal.SINGLE_QUOTE_RE_,"&#39;").replace(goog$1.string.internal.NULL_RE_,"&#0;");else {if(!goog$1.string.internal.ALL_RE_.test(a))return a;-1!=a.indexOf("&")&&(a=a.replace(goog$1.string.internal.AMP_RE_,"&amp;"));-1!=a.indexOf("<")&&(a=a.replace(goog$1.string.internal.LT_RE_,
	"&lt;"));-1!=a.indexOf(">")&&(a=a.replace(goog$1.string.internal.GT_RE_,"&gt;"));-1!=a.indexOf('"')&&(a=a.replace(goog$1.string.internal.QUOT_RE_,"&quot;"));-1!=a.indexOf("'")&&(a=a.replace(goog$1.string.internal.SINGLE_QUOTE_RE_,"&#39;"));-1!=a.indexOf("\x00")&&(a=a.replace(goog$1.string.internal.NULL_RE_,"&#0;"));}return a};goog$1.string.internal.AMP_RE_=/&/g;goog$1.string.internal.LT_RE_=/</g;goog$1.string.internal.GT_RE_=/>/g;goog$1.string.internal.QUOT_RE_=/"/g;goog$1.string.internal.SINGLE_QUOTE_RE_=/'/g;
	goog$1.string.internal.NULL_RE_=/\x00/g;goog$1.string.internal.ALL_RE_=/[\x00&<>"']/;goog$1.string.internal.whitespaceEscape=function(a,b){return goog$1.string.internal.newLineToBr(a.replace(/  /g," &#160;"),b)};goog$1.string.internal.contains=function(a,b){return -1!=a.indexOf(b)};goog$1.string.internal.caseInsensitiveContains=function(a,b){return goog$1.string.internal.contains(a.toLowerCase(),b.toLowerCase())};
	goog$1.string.internal.compareVersions=function(a,b){var c=0;a=goog$1.string.internal.trim(String(a)).split(".");b=goog$1.string.internal.trim(String(b)).split(".");for(var d=Math.max(a.length,b.length),e=0;0==c&&e<d;e++){var f=a[e]||"",g=b[e]||"";do{f=/(\d*)(\D*)(.*)/.exec(f)||["","","",""];g=/(\d*)(\D*)(.*)/.exec(g)||["","","",""];if(0==f[0].length&&0==g[0].length)break;c=0==f[1].length?0:parseInt(f[1],10);var h=0==g[1].length?0:parseInt(g[1],10);c=goog$1.string.internal.compareElements_(c,h)||goog$1.string.internal.compareElements_(0==
	f[2].length,0==g[2].length)||goog$1.string.internal.compareElements_(f[2],g[2]);f=f[3];g=g[3];}while(0==c)}return c};goog$1.string.internal.compareElements_=function(a,b){return a<b?-1:a>b?1:0};goog$1.string.TypedString=function(){};goog$1.string.Const=function(a,b){this.stringConstValueWithSecurityContract__googStringSecurityPrivate_=a===goog$1.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_&&b||"";this.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_=goog$1.string.Const.TYPE_MARKER_;};goog$1.string.Const.prototype.implementsGoogStringTypedString=!0;goog$1.string.Const.prototype.getTypedStringValue=function(){return this.stringConstValueWithSecurityContract__googStringSecurityPrivate_};
	goog$1.string.Const.prototype.toString=function(){return "Const{"+this.stringConstValueWithSecurityContract__googStringSecurityPrivate_+"}"};goog$1.string.Const.unwrap=function(a){if(a instanceof goog$1.string.Const&&a.constructor===goog$1.string.Const&&a.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_===goog$1.string.Const.TYPE_MARKER_)return a.stringConstValueWithSecurityContract__googStringSecurityPrivate_;goog$1.asserts.fail("expected object of type Const, got '"+a+"'");return "type_error:Const"};
	goog$1.string.Const.from=function(a){return new goog$1.string.Const(goog$1.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_,a)};goog$1.string.Const.TYPE_MARKER_={};goog$1.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_={};goog$1.string.Const.EMPTY=goog$1.string.Const.from("");goog$1.fs={};goog$1.fs.url={};goog$1.fs.url.createObjectUrl=function(a){return goog$1.fs.url.getUrlObject_().createObjectURL(a)};goog$1.fs.url.revokeObjectUrl=function(a){goog$1.fs.url.getUrlObject_().revokeObjectURL(a);};goog$1.fs.url.getUrlObject_=function(){var a=goog$1.fs.url.findUrlObject_();if(null!=a)return a;throw Error("This browser doesn't seem to support blob URLs");};
	goog$1.fs.url.findUrlObject_=function(){return goog$1.isDef(goog$1.global.URL)&&goog$1.isDef(goog$1.global.URL.createObjectURL)?goog$1.global.URL:goog$1.isDef(goog$1.global.webkitURL)&&goog$1.isDef(goog$1.global.webkitURL.createObjectURL)?goog$1.global.webkitURL:goog$1.isDef(goog$1.global.createObjectURL)?goog$1.global:null};goog$1.fs.url.browserSupportsObjectUrls=function(){return null!=goog$1.fs.url.findUrlObject_()};goog$1.html={};goog$1.html.trustedtypes={};goog$1.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY=goog$1.TRUSTED_TYPES_POLICY_NAME?goog$1.createTrustedTypesPolicy(goog$1.TRUSTED_TYPES_POLICY_NAME+"#html"):null;goog$1.i18n={};goog$1.i18n.bidi={};goog$1.i18n.bidi.FORCE_RTL=!1;
	goog$1.i18n.bidi.IS_RTL=goog$1.i18n.bidi.FORCE_RTL||("ar"==goog$1.LOCALE.substring(0,2).toLowerCase()||"fa"==goog$1.LOCALE.substring(0,2).toLowerCase()||"he"==goog$1.LOCALE.substring(0,2).toLowerCase()||"iw"==goog$1.LOCALE.substring(0,2).toLowerCase()||"ps"==goog$1.LOCALE.substring(0,2).toLowerCase()||"sd"==goog$1.LOCALE.substring(0,2).toLowerCase()||"ug"==goog$1.LOCALE.substring(0,2).toLowerCase()||"ur"==goog$1.LOCALE.substring(0,2).toLowerCase()||"yi"==goog$1.LOCALE.substring(0,2).toLowerCase())&&(2==goog$1.LOCALE.length||
	"-"==goog$1.LOCALE.substring(2,3)||"_"==goog$1.LOCALE.substring(2,3))||3<=goog$1.LOCALE.length&&"ckb"==goog$1.LOCALE.substring(0,3).toLowerCase()&&(3==goog$1.LOCALE.length||"-"==goog$1.LOCALE.substring(3,4)||"_"==goog$1.LOCALE.substring(3,4))||7<=goog$1.LOCALE.length&&("-"==goog$1.LOCALE.substring(2,3)||"_"==goog$1.LOCALE.substring(2,3))&&("adlm"==goog$1.LOCALE.substring(3,7).toLowerCase()||"arab"==goog$1.LOCALE.substring(3,7).toLowerCase()||"hebr"==goog$1.LOCALE.substring(3,7).toLowerCase()||"nkoo"==goog$1.LOCALE.substring(3,
	7).toLowerCase()||"rohg"==goog$1.LOCALE.substring(3,7).toLowerCase()||"thaa"==goog$1.LOCALE.substring(3,7).toLowerCase())||8<=goog$1.LOCALE.length&&("-"==goog$1.LOCALE.substring(3,4)||"_"==goog$1.LOCALE.substring(3,4))&&("adlm"==goog$1.LOCALE.substring(4,8).toLowerCase()||"arab"==goog$1.LOCALE.substring(4,8).toLowerCase()||"hebr"==goog$1.LOCALE.substring(4,8).toLowerCase()||"nkoo"==goog$1.LOCALE.substring(4,8).toLowerCase()||"rohg"==goog$1.LOCALE.substring(4,8).toLowerCase()||"thaa"==goog$1.LOCALE.substring(4,8).toLowerCase());
	goog$1.i18n.bidi.Format={LRE:"\u202a",RLE:"\u202b",PDF:"\u202c",LRM:"\u200e",RLM:"\u200f"};goog$1.i18n.bidi.Dir={LTR:1,RTL:-1,NEUTRAL:0};goog$1.i18n.bidi.RIGHT="right";goog$1.i18n.bidi.LEFT="left";goog$1.i18n.bidi.I18N_RIGHT=goog$1.i18n.bidi.IS_RTL?goog$1.i18n.bidi.LEFT:goog$1.i18n.bidi.RIGHT;goog$1.i18n.bidi.I18N_LEFT=goog$1.i18n.bidi.IS_RTL?goog$1.i18n.bidi.RIGHT:goog$1.i18n.bidi.LEFT;
	goog$1.i18n.bidi.toDir=function(a,b){return "number"==typeof a?0<a?goog$1.i18n.bidi.Dir.LTR:0>a?goog$1.i18n.bidi.Dir.RTL:b?null:goog$1.i18n.bidi.Dir.NEUTRAL:null==a?null:a?goog$1.i18n.bidi.Dir.RTL:goog$1.i18n.bidi.Dir.LTR};goog$1.i18n.bidi.ltrChars_="A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0900-\u1fff\u200e\u2c00-\ud801\ud804-\ud839\ud83c-\udbff\uf900-\ufb1c\ufe00-\ufe6f\ufefd-\uffff";goog$1.i18n.bidi.rtlChars_="\u0591-\u06ef\u06fa-\u08ff\u200f\ud802-\ud803\ud83a-\ud83b\ufb1d-\ufdff\ufe70-\ufefc";
	goog$1.i18n.bidi.htmlSkipReg_=/<[^>]*>|&[^;]+;/g;goog$1.i18n.bidi.stripHtmlIfNeeded_=function(a,b){return b?a.replace(goog$1.i18n.bidi.htmlSkipReg_,""):a};goog$1.i18n.bidi.rtlCharReg_=new RegExp("["+goog$1.i18n.bidi.rtlChars_+"]");goog$1.i18n.bidi.ltrCharReg_=new RegExp("["+goog$1.i18n.bidi.ltrChars_+"]");goog$1.i18n.bidi.hasAnyRtl=function(a,b){return goog$1.i18n.bidi.rtlCharReg_.test(goog$1.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog$1.i18n.bidi.hasRtlChar=goog$1.i18n.bidi.hasAnyRtl;
	goog$1.i18n.bidi.hasAnyLtr=function(a,b){return goog$1.i18n.bidi.ltrCharReg_.test(goog$1.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog$1.i18n.bidi.ltrRe_=new RegExp("^["+goog$1.i18n.bidi.ltrChars_+"]");goog$1.i18n.bidi.rtlRe_=new RegExp("^["+goog$1.i18n.bidi.rtlChars_+"]");goog$1.i18n.bidi.isRtlChar=function(a){return goog$1.i18n.bidi.rtlRe_.test(a)};goog$1.i18n.bidi.isLtrChar=function(a){return goog$1.i18n.bidi.ltrRe_.test(a)};goog$1.i18n.bidi.isNeutralChar=function(a){return !goog$1.i18n.bidi.isLtrChar(a)&&!goog$1.i18n.bidi.isRtlChar(a)};
	goog$1.i18n.bidi.ltrDirCheckRe_=new RegExp("^[^"+goog$1.i18n.bidi.rtlChars_+"]*["+goog$1.i18n.bidi.ltrChars_+"]");goog$1.i18n.bidi.rtlDirCheckRe_=new RegExp("^[^"+goog$1.i18n.bidi.ltrChars_+"]*["+goog$1.i18n.bidi.rtlChars_+"]");goog$1.i18n.bidi.startsWithRtl=function(a,b){return goog$1.i18n.bidi.rtlDirCheckRe_.test(goog$1.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog$1.i18n.bidi.isRtlText=goog$1.i18n.bidi.startsWithRtl;
	goog$1.i18n.bidi.startsWithLtr=function(a,b){return goog$1.i18n.bidi.ltrDirCheckRe_.test(goog$1.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog$1.i18n.bidi.isLtrText=goog$1.i18n.bidi.startsWithLtr;goog$1.i18n.bidi.isRequiredLtrRe_=/^http:\/\/.*/;goog$1.i18n.bidi.isNeutralText=function(a,b){a=goog$1.i18n.bidi.stripHtmlIfNeeded_(a,b);return goog$1.i18n.bidi.isRequiredLtrRe_.test(a)||!goog$1.i18n.bidi.hasAnyLtr(a)&&!goog$1.i18n.bidi.hasAnyRtl(a)};
	goog$1.i18n.bidi.ltrExitDirCheckRe_=new RegExp("["+goog$1.i18n.bidi.ltrChars_+"][^"+goog$1.i18n.bidi.rtlChars_+"]*$");goog$1.i18n.bidi.rtlExitDirCheckRe_=new RegExp("["+goog$1.i18n.bidi.rtlChars_+"][^"+goog$1.i18n.bidi.ltrChars_+"]*$");goog$1.i18n.bidi.endsWithLtr=function(a,b){return goog$1.i18n.bidi.ltrExitDirCheckRe_.test(goog$1.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog$1.i18n.bidi.isLtrExitText=goog$1.i18n.bidi.endsWithLtr;
	goog$1.i18n.bidi.endsWithRtl=function(a,b){return goog$1.i18n.bidi.rtlExitDirCheckRe_.test(goog$1.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog$1.i18n.bidi.isRtlExitText=goog$1.i18n.bidi.endsWithRtl;goog$1.i18n.bidi.rtlLocalesRe_=/^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;goog$1.i18n.bidi.isRtlLanguage=function(a){return goog$1.i18n.bidi.rtlLocalesRe_.test(a)};goog$1.i18n.bidi.bracketGuardTextRe_=/(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g;
	goog$1.i18n.bidi.guardBracketInText=function(a,b){b=(void 0===b?goog$1.i18n.bidi.hasAnyRtl(a):b)?goog$1.i18n.bidi.Format.RLM:goog$1.i18n.bidi.Format.LRM;return a.replace(goog$1.i18n.bidi.bracketGuardTextRe_,b+"$&"+b)};goog$1.i18n.bidi.enforceRtlInHtml=function(a){return "<"==a.charAt(0)?a.replace(/<\w+/,"$& dir=rtl"):"\n<span dir=rtl>"+a+"</span>"};goog$1.i18n.bidi.enforceRtlInText=function(a){return goog$1.i18n.bidi.Format.RLE+a+goog$1.i18n.bidi.Format.PDF};
	goog$1.i18n.bidi.enforceLtrInHtml=function(a){return "<"==a.charAt(0)?a.replace(/<\w+/,"$& dir=ltr"):"\n<span dir=ltr>"+a+"</span>"};goog$1.i18n.bidi.enforceLtrInText=function(a){return goog$1.i18n.bidi.Format.LRE+a+goog$1.i18n.bidi.Format.PDF};goog$1.i18n.bidi.dimensionsRe_=/:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g;goog$1.i18n.bidi.leftRe_=/left/gi;goog$1.i18n.bidi.rightRe_=/right/gi;goog$1.i18n.bidi.tempRe_=/%%%%/g;
	goog$1.i18n.bidi.mirrorCSS=function(a){return a.replace(goog$1.i18n.bidi.dimensionsRe_,":$1 $4 $3 $2").replace(goog$1.i18n.bidi.leftRe_,"%%%%").replace(goog$1.i18n.bidi.rightRe_,goog$1.i18n.bidi.LEFT).replace(goog$1.i18n.bidi.tempRe_,goog$1.i18n.bidi.RIGHT)};goog$1.i18n.bidi.doubleQuoteSubstituteRe_=/([\u0591-\u05f2])"/g;goog$1.i18n.bidi.singleQuoteSubstituteRe_=/([\u0591-\u05f2])'/g;
	goog$1.i18n.bidi.normalizeHebrewQuote=function(a){return a.replace(goog$1.i18n.bidi.doubleQuoteSubstituteRe_,"$1\u05f4").replace(goog$1.i18n.bidi.singleQuoteSubstituteRe_,"$1\u05f3")};goog$1.i18n.bidi.wordSeparatorRe_=/\s+/;goog$1.i18n.bidi.hasNumeralsRe_=/[\d\u06f0-\u06f9]/;goog$1.i18n.bidi.rtlDetectionThreshold_=.4;
	goog$1.i18n.bidi.estimateDirection=function(a,b){var c=0,d=0,e=!1;a=goog$1.i18n.bidi.stripHtmlIfNeeded_(a,b).split(goog$1.i18n.bidi.wordSeparatorRe_);for(b=0;b<a.length;b++){var f=a[b];goog$1.i18n.bidi.startsWithRtl(f)?(c++,d++):goog$1.i18n.bidi.isRequiredLtrRe_.test(f)?e=!0:goog$1.i18n.bidi.hasAnyLtr(f)?d++:goog$1.i18n.bidi.hasNumeralsRe_.test(f)&&(e=!0);}return 0==d?e?goog$1.i18n.bidi.Dir.LTR:goog$1.i18n.bidi.Dir.NEUTRAL:c/d>goog$1.i18n.bidi.rtlDetectionThreshold_?goog$1.i18n.bidi.Dir.RTL:goog$1.i18n.bidi.Dir.LTR};
	goog$1.i18n.bidi.detectRtlDirectionality=function(a,b){return goog$1.i18n.bidi.estimateDirection(a,b)==goog$1.i18n.bidi.Dir.RTL};goog$1.i18n.bidi.setElementDirAndAlign=function(a,b){a&&(b=goog$1.i18n.bidi.toDir(b))&&(a.style.textAlign=b==goog$1.i18n.bidi.Dir.RTL?goog$1.i18n.bidi.RIGHT:goog$1.i18n.bidi.LEFT,a.dir=b==goog$1.i18n.bidi.Dir.RTL?"rtl":"ltr");};
	goog$1.i18n.bidi.setElementDirByTextDirectionality=function(a,b){switch(goog$1.i18n.bidi.estimateDirection(b)){case goog$1.i18n.bidi.Dir.LTR:a.dir="ltr";break;case goog$1.i18n.bidi.Dir.RTL:a.dir="rtl";break;default:a.removeAttribute("dir");}};goog$1.i18n.bidi.DirectionalString=function(){};goog$1.html.TrustedResourceUrl=function(){this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_="";this.trustedURL_=null;this.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog$1.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;};goog$1.html.TrustedResourceUrl.prototype.implementsGoogStringTypedString=!0;goog$1.html.TrustedResourceUrl.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_.toString()};
	goog$1.html.TrustedResourceUrl.prototype.implementsGoogI18nBidiDirectionalString=!0;goog$1.html.TrustedResourceUrl.prototype.getDirection=function(){return goog$1.i18n.bidi.Dir.LTR};
	goog$1.html.TrustedResourceUrl.prototype.cloneWithParams=function(a,b){var c=goog$1.html.TrustedResourceUrl.unwrap(this);c=goog$1.html.TrustedResourceUrl.URL_PARAM_PARSER_.exec(c);var d=c[3]||"";return goog$1.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(c[1]+goog$1.html.TrustedResourceUrl.stringifyParams_("?",c[2]||"",a)+goog$1.html.TrustedResourceUrl.stringifyParams_("#",d,b))};
	goog$1.DEBUG&&(goog$1.html.TrustedResourceUrl.prototype.toString=function(){return "TrustedResourceUrl{"+this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_+"}"});goog$1.html.TrustedResourceUrl.unwrap=function(a){return goog$1.html.TrustedResourceUrl.unwrapTrustedScriptURL(a).toString()};
	goog$1.html.TrustedResourceUrl.unwrapTrustedScriptURL=function(a){if(a instanceof goog$1.html.TrustedResourceUrl&&a.constructor===goog$1.html.TrustedResourceUrl&&a.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog$1.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_;goog$1.asserts.fail("expected object of type TrustedResourceUrl, got '"+a+"' of type "+goog$1.typeOf(a));return "type_error:TrustedResourceUrl"};
	goog$1.html.TrustedResourceUrl.unwrapTrustedURL=function(a){return a.trustedURL_?a.trustedURL_:goog$1.html.TrustedResourceUrl.unwrap(a)};
	goog$1.html.TrustedResourceUrl.format=function(a,b){var c=goog$1.string.Const.unwrap(a);if(!goog$1.html.TrustedResourceUrl.BASE_URL_.test(c))throw Error("Invalid TrustedResourceUrl format: "+c);a=c.replace(goog$1.html.TrustedResourceUrl.FORMAT_MARKER_,function(a,e){if(!Object.prototype.hasOwnProperty.call(b,e))throw Error('Found marker, "'+e+'", in format string, "'+c+'", but no valid label mapping found in args: '+JSON.stringify(b));a=b[e];return a instanceof goog$1.string.Const?goog$1.string.Const.unwrap(a):
	encodeURIComponent(String(a))});return goog$1.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(a)};goog$1.html.TrustedResourceUrl.FORMAT_MARKER_=/%{(\w+)}/g;goog$1.html.TrustedResourceUrl.BASE_URL_=/^((https:)?\/\/[0-9a-z.:[\]-]+\/|\/[^/\\]|[^:/\\%]+\/|[^:/\\%]*[?#]|about:blank#)/i;goog$1.html.TrustedResourceUrl.URL_PARAM_PARSER_=/^([^?#]*)(\?[^#]*)?(#[\s\S]*)?/;
	goog$1.html.TrustedResourceUrl.formatWithParams=function(a,b,c,d){return goog$1.html.TrustedResourceUrl.format(a,b).cloneWithParams(c,d)};goog$1.html.TrustedResourceUrl.fromConstant=function(a){return goog$1.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(goog$1.string.Const.unwrap(a))};goog$1.html.TrustedResourceUrl.fromConstants=function(a){for(var b="",c=0;c<a.length;c++)b+=goog$1.string.Const.unwrap(a[c]);return goog$1.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(b)};
	goog$1.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
	goog$1.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse=function(a){var b=new goog$1.html.TrustedResourceUrl;b.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_=goog$1.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog$1.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScriptURL(a):a;goog$1.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY&&(b.trustedURL_=goog$1.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createURL(a));return b};
	goog$1.html.TrustedResourceUrl.stringifyParams_=function(a,b,c){if(null==c)return b;if(goog$1.isString(c))return c?a+encodeURIComponent(c):"";for(var d in c){var e=c[d];e=goog$1.isArray(e)?e:[e];for(var f=0;f<e.length;f++){var g=e[f];null!=g&&(b||(b=a),b+=(b.length>a.length?"&":"")+encodeURIComponent(d)+"="+encodeURIComponent(String(g)));}}return b};goog$1.html.SafeUrl=function(){this.privateDoNotAccessOrElseSafeUrlWrappedValue_="";this.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog$1.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;};goog$1.html.SafeUrl.INNOCUOUS_STRING="about:invalid#zClosurez";goog$1.html.SafeUrl.prototype.implementsGoogStringTypedString=!0;goog$1.html.SafeUrl.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeUrlWrappedValue_.toString()};
	goog$1.html.SafeUrl.prototype.implementsGoogI18nBidiDirectionalString=!0;goog$1.html.SafeUrl.prototype.getDirection=function(){return goog$1.i18n.bidi.Dir.LTR};goog$1.DEBUG&&(goog$1.html.SafeUrl.prototype.toString=function(){return "SafeUrl{"+this.privateDoNotAccessOrElseSafeUrlWrappedValue_+"}"});goog$1.html.SafeUrl.unwrap=function(a){return goog$1.html.SafeUrl.unwrapTrustedURL(a).toString()};
	goog$1.html.SafeUrl.unwrapTrustedURL=function(a){if(a instanceof goog$1.html.SafeUrl&&a.constructor===goog$1.html.SafeUrl&&a.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog$1.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeUrlWrappedValue_;goog$1.asserts.fail("expected object of type SafeUrl, got '"+a+"' of type "+goog$1.typeOf(a));return "type_error:SafeUrl"};goog$1.html.SafeUrl.fromConstant=function(a){return goog$1.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog$1.string.Const.unwrap(a))};
	goog$1.html.SAFE_MIME_TYPE_PATTERN_=/^(?:audio\/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-wav|wav|webm)|image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon)|text\/csv|video\/(?:mpeg|mp4|ogg|webm|quicktime))(?:;\w+=(?:\w+|"[\w;=]+"))*$/i;goog$1.html.SafeUrl.isSafeMimeType=function(a){return goog$1.html.SAFE_MIME_TYPE_PATTERN_.test(a)};goog$1.html.SafeUrl.fromBlob=function(a){a=goog$1.html.SAFE_MIME_TYPE_PATTERN_.test(a.type)?goog$1.fs.url.createObjectUrl(a):goog$1.html.SafeUrl.INNOCUOUS_STRING;return goog$1.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
	goog$1.html.DATA_URL_PATTERN_=/^data:([^,]*);base64,[a-z0-9+\/]+=*$/i;goog$1.html.SafeUrl.fromDataUrl=function(a){a=a.replace(/(%0A|%0D)/g,"");var b=a.match(goog$1.html.DATA_URL_PATTERN_);b=b&&goog$1.html.SAFE_MIME_TYPE_PATTERN_.test(b[1]);return goog$1.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b?a:goog$1.html.SafeUrl.INNOCUOUS_STRING)};goog$1.html.SafeUrl.fromTelUrl=function(a){goog$1.string.internal.caseInsensitiveStartsWith(a,"tel:")||(a=goog$1.html.SafeUrl.INNOCUOUS_STRING);return goog$1.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
	goog$1.html.SIP_URL_PATTERN_=/^sip[s]?:[+a-z0-9_.!$%&'*\/=^`{|}~-]+@([a-z0-9-]+\.)+[a-z0-9]{2,63}$/i;goog$1.html.SafeUrl.fromSipUrl=function(a){goog$1.html.SIP_URL_PATTERN_.test(decodeURIComponent(a))||(a=goog$1.html.SafeUrl.INNOCUOUS_STRING);return goog$1.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};goog$1.html.SafeUrl.fromFacebookMessengerUrl=function(a){goog$1.string.internal.caseInsensitiveStartsWith(a,"fb-messenger://share")||(a=goog$1.html.SafeUrl.INNOCUOUS_STRING);return goog$1.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
	goog$1.html.SafeUrl.fromWhatsAppUrl=function(a){goog$1.string.internal.caseInsensitiveStartsWith(a,"whatsapp://send")||(a=goog$1.html.SafeUrl.INNOCUOUS_STRING);return goog$1.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};goog$1.html.SafeUrl.fromSmsUrl=function(a){goog$1.string.internal.caseInsensitiveStartsWith(a,"sms:")&&goog$1.html.SafeUrl.isSmsUrlBodyValid_(a)||(a=goog$1.html.SafeUrl.INNOCUOUS_STRING);return goog$1.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
	goog$1.html.SafeUrl.isSmsUrlBodyValid_=function(a){var b=a.indexOf("#");0<b&&(a=a.substring(0,b));b=a.match(/[?&]body=/gi);if(!b)return !0;if(1<b.length)return !1;a=a.match(/[?&]body=([^&]*)/)[1];if(!a)return !0;try{decodeURIComponent(a);}catch(c){return !1}return /^(?:[a-z0-9\-_.~]|%[0-9a-f]{2})+$/i.test(a)};goog$1.html.SafeUrl.fromSshUrl=function(a){goog$1.string.internal.caseInsensitiveStartsWith(a,"ssh://")||(a=goog$1.html.SafeUrl.INNOCUOUS_STRING);return goog$1.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
	goog$1.html.SafeUrl.sanitizeChromeExtensionUrl=function(a,b){return goog$1.html.SafeUrl.sanitizeExtensionUrl_(/^chrome-extension:\/\/([^\/]+)\//,a,b)};goog$1.html.SafeUrl.sanitizeFirefoxExtensionUrl=function(a,b){return goog$1.html.SafeUrl.sanitizeExtensionUrl_(/^moz-extension:\/\/([^\/]+)\//,a,b)};goog$1.html.SafeUrl.sanitizeEdgeExtensionUrl=function(a,b){return goog$1.html.SafeUrl.sanitizeExtensionUrl_(/^ms-browser-extension:\/\/([^\/]+)\//,a,b)};
	goog$1.html.SafeUrl.sanitizeExtensionUrl_=function(a,b,c){(a=a.exec(b))?(a=a[1],-1==(c instanceof goog$1.string.Const?[goog$1.string.Const.unwrap(c)]:c.map(function(a){return goog$1.string.Const.unwrap(a)})).indexOf(a)&&(b=goog$1.html.SafeUrl.INNOCUOUS_STRING)):b=goog$1.html.SafeUrl.INNOCUOUS_STRING;return goog$1.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b)};goog$1.html.SafeUrl.fromTrustedResourceUrl=function(a){return goog$1.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog$1.html.TrustedResourceUrl.unwrap(a))};
	goog$1.html.SAFE_URL_PATTERN_=/^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;goog$1.html.SafeUrl.SAFE_URL_PATTERN=goog$1.html.SAFE_URL_PATTERN_;goog$1.html.SafeUrl.sanitize=function(a){if(a instanceof goog$1.html.SafeUrl)return a;a="object"==typeof a&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);goog$1.html.SAFE_URL_PATTERN_.test(a)||(a=goog$1.html.SafeUrl.INNOCUOUS_STRING);return goog$1.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
	goog$1.html.SafeUrl.sanitizeAssertUnchanged=function(a,b){if(a instanceof goog$1.html.SafeUrl)return a;a="object"==typeof a&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);if(b&&/^data:/i.test(a)&&(b=goog$1.html.SafeUrl.fromDataUrl(a),b.getTypedStringValue()==a))return b;goog$1.asserts.assert(goog$1.html.SAFE_URL_PATTERN_.test(a),"%s does not match the safe URL pattern",a)||(a=goog$1.html.SafeUrl.INNOCUOUS_STRING);return goog$1.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
	goog$1.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog$1.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse=function(a){var b=new goog$1.html.SafeUrl;b.privateDoNotAccessOrElseSafeUrlWrappedValue_=goog$1.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog$1.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createURL(a):a;return b};goog$1.html.SafeUrl.ABOUT_BLANK=goog$1.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse("about:blank");goog$1.html.SafeStyle=function(){this.privateDoNotAccessOrElseSafeStyleWrappedValue_="";this.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog$1.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;};goog$1.html.SafeStyle.prototype.implementsGoogStringTypedString=!0;goog$1.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
	goog$1.html.SafeStyle.fromConstant=function(a){a=goog$1.string.Const.unwrap(a);if(0===a.length)return goog$1.html.SafeStyle.EMPTY;goog$1.asserts.assert(goog$1.string.internal.endsWith(a,";"),"Last character of style string is not ';': "+a);goog$1.asserts.assert(goog$1.string.internal.contains(a,":"),"Style string must contain at least one ':', to specify a \"name: value\" pair: "+a);return goog$1.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(a)};
	goog$1.html.SafeStyle.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeStyleWrappedValue_};goog$1.DEBUG&&(goog$1.html.SafeStyle.prototype.toString=function(){return "SafeStyle{"+this.privateDoNotAccessOrElseSafeStyleWrappedValue_+"}"});
	goog$1.html.SafeStyle.unwrap=function(a){if(a instanceof goog$1.html.SafeStyle&&a.constructor===goog$1.html.SafeStyle&&a.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog$1.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeStyleWrappedValue_;goog$1.asserts.fail("expected object of type SafeStyle, got '"+a+"' of type "+goog$1.typeOf(a));return "type_error:SafeStyle"};goog$1.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse=function(a){return (new goog$1.html.SafeStyle).initSecurityPrivateDoNotAccessOrElse_(a)};
	goog$1.html.SafeStyle.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeStyleWrappedValue_=a;return this};goog$1.html.SafeStyle.EMPTY=goog$1.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse("");goog$1.html.SafeStyle.INNOCUOUS_STRING="zClosurez";
	goog$1.html.SafeStyle.create=function(a){var b="",c;for(c in a){if(!/^[-_a-zA-Z0-9]+$/.test(c))throw Error("Name allows only [-_a-zA-Z0-9], got: "+c);var d=a[c];null!=d&&(d=goog$1.isArray(d)?goog$1.array.map(d,goog$1.html.SafeStyle.sanitizePropertyValue_).join(" "):goog$1.html.SafeStyle.sanitizePropertyValue_(d),b+=c+":"+d+";");}return b?goog$1.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b):goog$1.html.SafeStyle.EMPTY};
	goog$1.html.SafeStyle.sanitizePropertyValue_=function(a){if(a instanceof goog$1.html.SafeUrl)return 'url("'+goog$1.html.SafeUrl.unwrap(a).replace(/</g,"%3c").replace(/[\\"]/g,"\\$&")+'")';a=a instanceof goog$1.string.Const?goog$1.string.Const.unwrap(a):goog$1.html.SafeStyle.sanitizePropertyValueString_(String(a));if(/[{;}]/.test(a))throw new goog$1.asserts.AssertionError("Value does not allow [{;}], got: %s.",[a]);return a};
	goog$1.html.SafeStyle.sanitizePropertyValueString_=function(a){var b=a.replace(goog$1.html.SafeStyle.FUNCTIONS_RE_,"$1").replace(goog$1.html.SafeStyle.FUNCTIONS_RE_,"$1").replace(goog$1.html.SafeStyle.URL_RE_,"url");if(goog$1.html.SafeStyle.VALUE_RE_.test(b)){if(goog$1.html.SafeStyle.COMMENT_RE_.test(a))return goog$1.asserts.fail("String value disallows comments, got: "+a),goog$1.html.SafeStyle.INNOCUOUS_STRING;if(!goog$1.html.SafeStyle.hasBalancedQuotes_(a))return goog$1.asserts.fail("String value requires balanced quotes, got: "+
	a),goog$1.html.SafeStyle.INNOCUOUS_STRING;if(!goog$1.html.SafeStyle.hasBalancedSquareBrackets_(a))return goog$1.asserts.fail("String value requires balanced square brackets and one identifier per pair of brackets, got: "+a),goog$1.html.SafeStyle.INNOCUOUS_STRING}else return goog$1.asserts.fail("String value allows only "+goog$1.html.SafeStyle.VALUE_ALLOWED_CHARS_+" and simple functions, got: "+a),goog$1.html.SafeStyle.INNOCUOUS_STRING;return goog$1.html.SafeStyle.sanitizeUrl_(a)};
	goog$1.html.SafeStyle.hasBalancedQuotes_=function(a){for(var b=!0,c=!0,d=0;d<a.length;d++){var e=a.charAt(d);"'"==e&&c?b=!b:'"'==e&&b&&(c=!c);}return b&&c};goog$1.html.SafeStyle.hasBalancedSquareBrackets_=function(a){for(var b=!0,c=/^[-_a-zA-Z0-9]$/,d=0;d<a.length;d++){var e=a.charAt(d);if("]"==e){if(b)return !1;b=!0;}else if("["==e){if(!b)return !1;b=!1;}else if(!b&&!c.test(e))return !1}return b};goog$1.html.SafeStyle.VALUE_ALLOWED_CHARS_="[-,.\"'%_!# a-zA-Z0-9\\[\\]]";
	goog$1.html.SafeStyle.VALUE_RE_=new RegExp("^"+goog$1.html.SafeStyle.VALUE_ALLOWED_CHARS_+"+$");goog$1.html.SafeStyle.URL_RE_=/\b(url\([ \t\n]*)('[ -&(-\[\]-~]*'|"[ !#-\[\]-~]*"|[!#-&*-\[\]-~]*)([ \t\n]*\))/g;goog$1.html.SafeStyle.FUNCTIONS_RE_=/\b(hsl|hsla|rgb|rgba|matrix|calc|minmax|fit-content|repeat|(rotate|scale|translate)(X|Y|Z|3d)?)\([-+*/0-9a-z.%\[\], ]+\)/g;goog$1.html.SafeStyle.COMMENT_RE_=/\/\*/;
	goog$1.html.SafeStyle.sanitizeUrl_=function(a){return a.replace(goog$1.html.SafeStyle.URL_RE_,function(a,c,d,e){var b="";d=d.replace(/^(['"])(.*)\1$/,function(a,c,d){b=c;return d});a=goog$1.html.SafeUrl.sanitize(d).getTypedStringValue();return c+b+a+b+e})};goog$1.html.SafeStyle.concat=function(a){var b="",c=function(a){goog$1.isArray(a)?goog$1.array.forEach(a,c):b+=goog$1.html.SafeStyle.unwrap(a);};goog$1.array.forEach(arguments,c);return b?goog$1.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b):goog$1.html.SafeStyle.EMPTY};goog$1.html.SafeScript=function(){this.privateDoNotAccessOrElseSafeScriptWrappedValue_="";this.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog$1.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;};goog$1.html.SafeScript.prototype.implementsGoogStringTypedString=!0;goog$1.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog$1.html.SafeScript.fromConstant=function(a){a=goog$1.string.Const.unwrap(a);return 0===a.length?goog$1.html.SafeScript.EMPTY:goog$1.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(a)};
	goog$1.html.SafeScript.fromConstantAndArgs=function(a,b){for(var c=[],d=1;d<arguments.length;d++)c.push(goog$1.html.SafeScript.stringify_(arguments[d]));return goog$1.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("("+goog$1.string.Const.unwrap(a)+")("+c.join(", ")+");")};goog$1.html.SafeScript.fromJson=function(a){return goog$1.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(goog$1.html.SafeScript.stringify_(a))};goog$1.html.SafeScript.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeScriptWrappedValue_.toString()};
	goog$1.DEBUG&&(goog$1.html.SafeScript.prototype.toString=function(){return "SafeScript{"+this.privateDoNotAccessOrElseSafeScriptWrappedValue_+"}"});goog$1.html.SafeScript.unwrap=function(a){return goog$1.html.SafeScript.unwrapTrustedScript(a).toString()};
	goog$1.html.SafeScript.unwrapTrustedScript=function(a){if(a instanceof goog$1.html.SafeScript&&a.constructor===goog$1.html.SafeScript&&a.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog$1.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeScriptWrappedValue_;goog$1.asserts.fail("expected object of type SafeScript, got '"+a+"' of type "+goog$1.typeOf(a));return "type_error:SafeScript"};
	goog$1.html.SafeScript.stringify_=function(a){return JSON.stringify(a).replace(/</g,"\\x3c")};goog$1.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse=function(a){return (new goog$1.html.SafeScript).initSecurityPrivateDoNotAccessOrElse_(a)};
	goog$1.html.SafeScript.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeScriptWrappedValue_=goog$1.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog$1.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScript(a):a;return this};goog$1.html.SafeScript.EMPTY=goog$1.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("");goog$1.object={};goog$1.object.is=function(a,b){return a===b?0!==a||1/a===1/b:a!==a&&b!==b};goog$1.object.forEach=function(a,b,c){for(var d in a)b.call(c,a[d],d,a);};goog$1.object.filter=function(a,b,c){var d={},e;for(e in a)b.call(c,a[e],e,a)&&(d[e]=a[e]);return d};goog$1.object.map=function(a,b,c){var d={},e;for(e in a)d[e]=b.call(c,a[e],e,a);return d};goog$1.object.some=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return !0;return !1};
	goog$1.object.every=function(a,b,c){for(var d in a)if(!b.call(c,a[d],d,a))return !1;return !0};goog$1.object.getCount=function(a){var b=0,c;for(c in a)b++;return b};goog$1.object.getAnyKey=function(a){for(var b in a)return b};goog$1.object.getAnyValue=function(a){for(var b in a)return a[b]};goog$1.object.contains=function(a,b){return goog$1.object.containsValue(a,b)};goog$1.object.getValues=function(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b};
	goog$1.object.getKeys=function(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b};goog$1.object.getValueByKeys=function(a,b){var c=goog$1.isArrayLike(b),d=c?b:arguments;for(c=c?0:1;c<d.length;c++){if(null==a)return;a=a[d[c]];}return a};goog$1.object.containsKey=function(a,b){return null!==a&&b in a};goog$1.object.containsValue=function(a,b){for(var c in a)if(a[c]==b)return !0;return !1};goog$1.object.findKey=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return d};
	goog$1.object.findValue=function(a,b,c){return (b=goog$1.object.findKey(a,b,c))&&a[b]};goog$1.object.isEmpty=function(a){for(var b in a)return !1;return !0};goog$1.object.clear=function(a){for(var b in a)delete a[b];};goog$1.object.remove=function(a,b){var c;(c=b in a)&&delete a[b];return c};goog$1.object.add=function(a,b,c){if(null!==a&&b in a)throw Error('The object already contains the key "'+b+'"');goog$1.object.set(a,b,c);};goog$1.object.get=function(a,b,c){return null!==a&&b in a?a[b]:c};
	goog$1.object.set=function(a,b,c){a[b]=c;};goog$1.object.setIfUndefined=function(a,b,c){return b in a?a[b]:a[b]=c};goog$1.object.setWithReturnValueIfNotSet=function(a,b,c){if(b in a)return a[b];c=c();return a[b]=c};goog$1.object.equals=function(a,b){for(var c in a)if(!(c in b)||a[c]!==b[c])return !1;for(var d in b)if(!(d in a))return !1;return !0};goog$1.object.clone=function(a){var b={},c;for(c in a)b[c]=a[c];return b};
	goog$1.object.unsafeClone=function(a){var b=goog$1.typeOf(a);if("object"==b||"array"==b){if(goog$1.isFunction(a.clone))return a.clone();b="array"==b?[]:{};for(var c in a)b[c]=goog$1.object.unsafeClone(a[c]);return b}return a};goog$1.object.transpose=function(a){var b={},c;for(c in a)b[a[c]]=c;return b};goog$1.object.PROTOTYPE_FIELDS_="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
	goog$1.object.extend=function(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<goog$1.object.PROTOTYPE_FIELDS_.length;f++)c=goog$1.object.PROTOTYPE_FIELDS_[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c]);}};
	goog$1.object.create=function(a){var b=arguments.length;if(1==b&&goog$1.isArray(arguments[0]))return goog$1.object.create.apply(null,arguments[0]);if(b%2)throw Error("Uneven number of arguments");for(var c={},d=0;d<b;d+=2)c[arguments[d]]=arguments[d+1];return c};goog$1.object.createSet=function(a){var b=arguments.length;if(1==b&&goog$1.isArray(arguments[0]))return goog$1.object.createSet.apply(null,arguments[0]);for(var c={},d=0;d<b;d++)c[arguments[d]]=!0;return c};
	goog$1.object.createImmutableView=function(a){var b=a;Object.isFrozen&&!Object.isFrozen(a)&&(b=Object.create(a),Object.freeze(b));return b};goog$1.object.isImmutableView=function(a){return !!Object.isFrozen&&Object.isFrozen(a)};
	goog$1.object.getAllPropertyNames=function(a,b,c){if(!a)return [];if(!Object.getOwnPropertyNames||!Object.getPrototypeOf)return goog$1.object.getKeys(a);for(var d={};a&&(a!==Object.prototype||b)&&(a!==Function.prototype||c);){for(var e=Object.getOwnPropertyNames(a),f=0;f<e.length;f++)d[e[f]]=!0;a=Object.getPrototypeOf(a);}return goog$1.object.getKeys(d)};goog$1.object.getSuperClass=function(a){return (a=Object.getPrototypeOf(a.prototype))&&a.constructor};goog$1.html.SafeStyleSheet=function(){this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_="";this.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog$1.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;};goog$1.html.SafeStyleSheet.prototype.implementsGoogStringTypedString=!0;goog$1.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
	goog$1.html.SafeStyleSheet.createRule=function(a,b){if(goog$1.string.internal.contains(a,"<"))throw Error("Selector does not allow '<', got: "+a);var c=a.replace(/('|")((?!\1)[^\r\n\f\\]|\\[\s\S])*\1/g,"");if(!/^[-_a-zA-Z0-9#.:* ,>+~[\]()=^$|]+$/.test(c))throw Error("Selector allows only [-_a-zA-Z0-9#.:* ,>+~[\\]()=^$|] and strings, got: "+a);if(!goog$1.html.SafeStyleSheet.hasBalancedBrackets_(c))throw Error("() and [] in selector must be balanced, got: "+a);b instanceof goog$1.html.SafeStyle||(b=goog$1.html.SafeStyle.create(b));
	a=a+"{"+goog$1.html.SafeStyle.unwrap(b).replace(/</g,"\\3C ")+"}";return goog$1.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(a)};goog$1.html.SafeStyleSheet.hasBalancedBrackets_=function(a){for(var b={"(":")","[":"]"},c=[],d=0;d<a.length;d++){var e=a[d];if(b[e])c.push(b[e]);else if(goog$1.object.contains(b,e)&&c.pop()!=e)return !1}return 0==c.length};
	goog$1.html.SafeStyleSheet.concat=function(a){var b="",c=function(a){goog$1.isArray(a)?goog$1.array.forEach(a,c):b+=goog$1.html.SafeStyleSheet.unwrap(a);};goog$1.array.forEach(arguments,c);return goog$1.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(b)};
	goog$1.html.SafeStyleSheet.fromConstant=function(a){a=goog$1.string.Const.unwrap(a);if(0===a.length)return goog$1.html.SafeStyleSheet.EMPTY;goog$1.asserts.assert(!goog$1.string.internal.contains(a,"<"),"Forbidden '<' character in style sheet string: "+a);return goog$1.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(a)};goog$1.html.SafeStyleSheet.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_};
	goog$1.DEBUG&&(goog$1.html.SafeStyleSheet.prototype.toString=function(){return "SafeStyleSheet{"+this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_+"}"});
	goog$1.html.SafeStyleSheet.unwrap=function(a){if(a instanceof goog$1.html.SafeStyleSheet&&a.constructor===goog$1.html.SafeStyleSheet&&a.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog$1.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;goog$1.asserts.fail("expected object of type SafeStyleSheet, got '"+a+"' of type "+goog$1.typeOf(a));return "type_error:SafeStyleSheet"};
	goog$1.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse=function(a){return (new goog$1.html.SafeStyleSheet).initSecurityPrivateDoNotAccessOrElse_(a)};goog$1.html.SafeStyleSheet.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_=a;return this};goog$1.html.SafeStyleSheet.EMPTY=goog$1.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse("");goog$1.dom.tags={};goog$1.dom.tags.VOID_TAGS_={area:!0,base:!0,br:!0,col:!0,command:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0};goog$1.dom.tags.isVoidTag=function(a){return !0===goog$1.dom.tags.VOID_TAGS_[a]};goog$1.dom.HtmlElement=function(){};goog$1.dom.TagName=function(a){this.tagName_=a;};goog$1.dom.TagName.prototype.toString=function(){return this.tagName_};goog$1.dom.TagName.A=new goog$1.dom.TagName("A");goog$1.dom.TagName.ABBR=new goog$1.dom.TagName("ABBR");goog$1.dom.TagName.ACRONYM=new goog$1.dom.TagName("ACRONYM");goog$1.dom.TagName.ADDRESS=new goog$1.dom.TagName("ADDRESS");goog$1.dom.TagName.APPLET=new goog$1.dom.TagName("APPLET");goog$1.dom.TagName.AREA=new goog$1.dom.TagName("AREA");goog$1.dom.TagName.ARTICLE=new goog$1.dom.TagName("ARTICLE");
	goog$1.dom.TagName.ASIDE=new goog$1.dom.TagName("ASIDE");goog$1.dom.TagName.AUDIO=new goog$1.dom.TagName("AUDIO");goog$1.dom.TagName.B=new goog$1.dom.TagName("B");goog$1.dom.TagName.BASE=new goog$1.dom.TagName("BASE");goog$1.dom.TagName.BASEFONT=new goog$1.dom.TagName("BASEFONT");goog$1.dom.TagName.BDI=new goog$1.dom.TagName("BDI");goog$1.dom.TagName.BDO=new goog$1.dom.TagName("BDO");goog$1.dom.TagName.BIG=new goog$1.dom.TagName("BIG");goog$1.dom.TagName.BLOCKQUOTE=new goog$1.dom.TagName("BLOCKQUOTE");goog$1.dom.TagName.BODY=new goog$1.dom.TagName("BODY");
	goog$1.dom.TagName.BR=new goog$1.dom.TagName("BR");goog$1.dom.TagName.BUTTON=new goog$1.dom.TagName("BUTTON");goog$1.dom.TagName.CANVAS=new goog$1.dom.TagName("CANVAS");goog$1.dom.TagName.CAPTION=new goog$1.dom.TagName("CAPTION");goog$1.dom.TagName.CENTER=new goog$1.dom.TagName("CENTER");goog$1.dom.TagName.CITE=new goog$1.dom.TagName("CITE");goog$1.dom.TagName.CODE=new goog$1.dom.TagName("CODE");goog$1.dom.TagName.COL=new goog$1.dom.TagName("COL");goog$1.dom.TagName.COLGROUP=new goog$1.dom.TagName("COLGROUP");
	goog$1.dom.TagName.COMMAND=new goog$1.dom.TagName("COMMAND");goog$1.dom.TagName.DATA=new goog$1.dom.TagName("DATA");goog$1.dom.TagName.DATALIST=new goog$1.dom.TagName("DATALIST");goog$1.dom.TagName.DD=new goog$1.dom.TagName("DD");goog$1.dom.TagName.DEL=new goog$1.dom.TagName("DEL");goog$1.dom.TagName.DETAILS=new goog$1.dom.TagName("DETAILS");goog$1.dom.TagName.DFN=new goog$1.dom.TagName("DFN");goog$1.dom.TagName.DIALOG=new goog$1.dom.TagName("DIALOG");goog$1.dom.TagName.DIR=new goog$1.dom.TagName("DIR");goog$1.dom.TagName.DIV=new goog$1.dom.TagName("DIV");
	goog$1.dom.TagName.DL=new goog$1.dom.TagName("DL");goog$1.dom.TagName.DT=new goog$1.dom.TagName("DT");goog$1.dom.TagName.EM=new goog$1.dom.TagName("EM");goog$1.dom.TagName.EMBED=new goog$1.dom.TagName("EMBED");goog$1.dom.TagName.FIELDSET=new goog$1.dom.TagName("FIELDSET");goog$1.dom.TagName.FIGCAPTION=new goog$1.dom.TagName("FIGCAPTION");goog$1.dom.TagName.FIGURE=new goog$1.dom.TagName("FIGURE");goog$1.dom.TagName.FONT=new goog$1.dom.TagName("FONT");goog$1.dom.TagName.FOOTER=new goog$1.dom.TagName("FOOTER");goog$1.dom.TagName.FORM=new goog$1.dom.TagName("FORM");
	goog$1.dom.TagName.FRAME=new goog$1.dom.TagName("FRAME");goog$1.dom.TagName.FRAMESET=new goog$1.dom.TagName("FRAMESET");goog$1.dom.TagName.H1=new goog$1.dom.TagName("H1");goog$1.dom.TagName.H2=new goog$1.dom.TagName("H2");goog$1.dom.TagName.H3=new goog$1.dom.TagName("H3");goog$1.dom.TagName.H4=new goog$1.dom.TagName("H4");goog$1.dom.TagName.H5=new goog$1.dom.TagName("H5");goog$1.dom.TagName.H6=new goog$1.dom.TagName("H6");goog$1.dom.TagName.HEAD=new goog$1.dom.TagName("HEAD");goog$1.dom.TagName.HEADER=new goog$1.dom.TagName("HEADER");
	goog$1.dom.TagName.HGROUP=new goog$1.dom.TagName("HGROUP");goog$1.dom.TagName.HR=new goog$1.dom.TagName("HR");goog$1.dom.TagName.HTML=new goog$1.dom.TagName("HTML");goog$1.dom.TagName.I=new goog$1.dom.TagName("I");goog$1.dom.TagName.IFRAME=new goog$1.dom.TagName("IFRAME");goog$1.dom.TagName.IMG=new goog$1.dom.TagName("IMG");goog$1.dom.TagName.INPUT=new goog$1.dom.TagName("INPUT");goog$1.dom.TagName.INS=new goog$1.dom.TagName("INS");goog$1.dom.TagName.ISINDEX=new goog$1.dom.TagName("ISINDEX");goog$1.dom.TagName.KBD=new goog$1.dom.TagName("KBD");
	goog$1.dom.TagName.KEYGEN=new goog$1.dom.TagName("KEYGEN");goog$1.dom.TagName.LABEL=new goog$1.dom.TagName("LABEL");goog$1.dom.TagName.LEGEND=new goog$1.dom.TagName("LEGEND");goog$1.dom.TagName.LI=new goog$1.dom.TagName("LI");goog$1.dom.TagName.LINK=new goog$1.dom.TagName("LINK");goog$1.dom.TagName.MAIN=new goog$1.dom.TagName("MAIN");goog$1.dom.TagName.MAP=new goog$1.dom.TagName("MAP");goog$1.dom.TagName.MARK=new goog$1.dom.TagName("MARK");goog$1.dom.TagName.MATH=new goog$1.dom.TagName("MATH");goog$1.dom.TagName.MENU=new goog$1.dom.TagName("MENU");
	goog$1.dom.TagName.MENUITEM=new goog$1.dom.TagName("MENUITEM");goog$1.dom.TagName.META=new goog$1.dom.TagName("META");goog$1.dom.TagName.METER=new goog$1.dom.TagName("METER");goog$1.dom.TagName.NAV=new goog$1.dom.TagName("NAV");goog$1.dom.TagName.NOFRAMES=new goog$1.dom.TagName("NOFRAMES");goog$1.dom.TagName.NOSCRIPT=new goog$1.dom.TagName("NOSCRIPT");goog$1.dom.TagName.OBJECT=new goog$1.dom.TagName("OBJECT");goog$1.dom.TagName.OL=new goog$1.dom.TagName("OL");goog$1.dom.TagName.OPTGROUP=new goog$1.dom.TagName("OPTGROUP");
	goog$1.dom.TagName.OPTION=new goog$1.dom.TagName("OPTION");goog$1.dom.TagName.OUTPUT=new goog$1.dom.TagName("OUTPUT");goog$1.dom.TagName.P=new goog$1.dom.TagName("P");goog$1.dom.TagName.PARAM=new goog$1.dom.TagName("PARAM");goog$1.dom.TagName.PICTURE=new goog$1.dom.TagName("PICTURE");goog$1.dom.TagName.PRE=new goog$1.dom.TagName("PRE");goog$1.dom.TagName.PROGRESS=new goog$1.dom.TagName("PROGRESS");goog$1.dom.TagName.Q=new goog$1.dom.TagName("Q");goog$1.dom.TagName.RP=new goog$1.dom.TagName("RP");goog$1.dom.TagName.RT=new goog$1.dom.TagName("RT");
	goog$1.dom.TagName.RTC=new goog$1.dom.TagName("RTC");goog$1.dom.TagName.RUBY=new goog$1.dom.TagName("RUBY");goog$1.dom.TagName.S=new goog$1.dom.TagName("S");goog$1.dom.TagName.SAMP=new goog$1.dom.TagName("SAMP");goog$1.dom.TagName.SCRIPT=new goog$1.dom.TagName("SCRIPT");goog$1.dom.TagName.SECTION=new goog$1.dom.TagName("SECTION");goog$1.dom.TagName.SELECT=new goog$1.dom.TagName("SELECT");goog$1.dom.TagName.SMALL=new goog$1.dom.TagName("SMALL");goog$1.dom.TagName.SOURCE=new goog$1.dom.TagName("SOURCE");goog$1.dom.TagName.SPAN=new goog$1.dom.TagName("SPAN");
	goog$1.dom.TagName.STRIKE=new goog$1.dom.TagName("STRIKE");goog$1.dom.TagName.STRONG=new goog$1.dom.TagName("STRONG");goog$1.dom.TagName.STYLE=new goog$1.dom.TagName("STYLE");goog$1.dom.TagName.SUB=new goog$1.dom.TagName("SUB");goog$1.dom.TagName.SUMMARY=new goog$1.dom.TagName("SUMMARY");goog$1.dom.TagName.SUP=new goog$1.dom.TagName("SUP");goog$1.dom.TagName.SVG=new goog$1.dom.TagName("SVG");goog$1.dom.TagName.TABLE=new goog$1.dom.TagName("TABLE");goog$1.dom.TagName.TBODY=new goog$1.dom.TagName("TBODY");goog$1.dom.TagName.TD=new goog$1.dom.TagName("TD");
	goog$1.dom.TagName.TEMPLATE=new goog$1.dom.TagName("TEMPLATE");goog$1.dom.TagName.TEXTAREA=new goog$1.dom.TagName("TEXTAREA");goog$1.dom.TagName.TFOOT=new goog$1.dom.TagName("TFOOT");goog$1.dom.TagName.TH=new goog$1.dom.TagName("TH");goog$1.dom.TagName.THEAD=new goog$1.dom.TagName("THEAD");goog$1.dom.TagName.TIME=new goog$1.dom.TagName("TIME");goog$1.dom.TagName.TITLE=new goog$1.dom.TagName("TITLE");goog$1.dom.TagName.TR=new goog$1.dom.TagName("TR");goog$1.dom.TagName.TRACK=new goog$1.dom.TagName("TRACK");goog$1.dom.TagName.TT=new goog$1.dom.TagName("TT");
	goog$1.dom.TagName.U=new goog$1.dom.TagName("U");goog$1.dom.TagName.UL=new goog$1.dom.TagName("UL");goog$1.dom.TagName.VAR=new goog$1.dom.TagName("VAR");goog$1.dom.TagName.VIDEO=new goog$1.dom.TagName("VIDEO");goog$1.dom.TagName.WBR=new goog$1.dom.TagName("WBR");goog$1.labs={};goog$1.labs.userAgent={};goog$1.labs.userAgent.util={};goog$1.labs.userAgent.util.getNativeUserAgentString_=function(){var a=goog$1.labs.userAgent.util.getNavigator_();return a&&(a=a.userAgent)?a:""};goog$1.labs.userAgent.util.getNavigator_=function(){return goog$1.global.navigator};goog$1.labs.userAgent.util.userAgent_=goog$1.labs.userAgent.util.getNativeUserAgentString_();goog$1.labs.userAgent.util.setUserAgent=function(a){goog$1.labs.userAgent.util.userAgent_=a||goog$1.labs.userAgent.util.getNativeUserAgentString_();};
	goog$1.labs.userAgent.util.getUserAgent=function(){return goog$1.labs.userAgent.util.userAgent_};goog$1.labs.userAgent.util.matchUserAgent=function(a){var b=goog$1.labs.userAgent.util.getUserAgent();return goog$1.string.internal.contains(b,a)};goog$1.labs.userAgent.util.matchUserAgentIgnoreCase=function(a){var b=goog$1.labs.userAgent.util.getUserAgent();return goog$1.string.internal.caseInsensitiveContains(b,a)};
	goog$1.labs.userAgent.util.extractVersionTuples=function(a){for(var b=/(\w[\w ]+)\/([^\s]+)\s*(?:\((.*?)\))?/g,c=[],d;d=b.exec(a);)c.push([d[1],d[2],d[3]||void 0]);return c};goog$1.labs.userAgent.browser={};goog$1.labs.userAgent.browser.matchOpera_=function(){return goog$1.labs.userAgent.util.matchUserAgent("Opera")};goog$1.labs.userAgent.browser.matchIE_=function(){return goog$1.labs.userAgent.util.matchUserAgent("Trident")||goog$1.labs.userAgent.util.matchUserAgent("MSIE")};goog$1.labs.userAgent.browser.matchEdgeHtml_=function(){return goog$1.labs.userAgent.util.matchUserAgent("Edge")};goog$1.labs.userAgent.browser.matchEdgeChromium_=function(){return goog$1.labs.userAgent.util.matchUserAgent("Edg/")};
	goog$1.labs.userAgent.browser.matchOperaChromium_=function(){return goog$1.labs.userAgent.util.matchUserAgent("OPR")};goog$1.labs.userAgent.browser.matchFirefox_=function(){return goog$1.labs.userAgent.util.matchUserAgent("Firefox")||goog$1.labs.userAgent.util.matchUserAgent("FxiOS")};
	goog$1.labs.userAgent.browser.matchSafari_=function(){return goog$1.labs.userAgent.util.matchUserAgent("Safari")&&!(goog$1.labs.userAgent.browser.matchChrome_()||goog$1.labs.userAgent.browser.matchCoast_()||goog$1.labs.userAgent.browser.matchOpera_()||goog$1.labs.userAgent.browser.matchEdgeHtml_()||goog$1.labs.userAgent.browser.matchEdgeChromium_()||goog$1.labs.userAgent.browser.matchOperaChromium_()||goog$1.labs.userAgent.browser.matchFirefox_()||goog$1.labs.userAgent.browser.isSilk()||goog$1.labs.userAgent.util.matchUserAgent("Android"))};
	goog$1.labs.userAgent.browser.matchCoast_=function(){return goog$1.labs.userAgent.util.matchUserAgent("Coast")};goog$1.labs.userAgent.browser.matchIosWebview_=function(){return (goog$1.labs.userAgent.util.matchUserAgent("iPad")||goog$1.labs.userAgent.util.matchUserAgent("iPhone"))&&!goog$1.labs.userAgent.browser.matchSafari_()&&!goog$1.labs.userAgent.browser.matchChrome_()&&!goog$1.labs.userAgent.browser.matchCoast_()&&!goog$1.labs.userAgent.browser.matchFirefox_()&&goog$1.labs.userAgent.util.matchUserAgent("AppleWebKit")};
	goog$1.labs.userAgent.browser.matchChrome_=function(){return (goog$1.labs.userAgent.util.matchUserAgent("Chrome")||goog$1.labs.userAgent.util.matchUserAgent("CriOS"))&&!goog$1.labs.userAgent.browser.matchEdgeHtml_()};goog$1.labs.userAgent.browser.matchAndroidBrowser_=function(){return goog$1.labs.userAgent.util.matchUserAgent("Android")&&!(goog$1.labs.userAgent.browser.isChrome()||goog$1.labs.userAgent.browser.isFirefox()||goog$1.labs.userAgent.browser.isOpera()||goog$1.labs.userAgent.browser.isSilk())};
	goog$1.labs.userAgent.browser.isOpera=goog$1.labs.userAgent.browser.matchOpera_;goog$1.labs.userAgent.browser.isIE=goog$1.labs.userAgent.browser.matchIE_;goog$1.labs.userAgent.browser.isEdge=goog$1.labs.userAgent.browser.matchEdgeHtml_;goog$1.labs.userAgent.browser.isEdgeChromium=goog$1.labs.userAgent.browser.matchEdgeChromium_;goog$1.labs.userAgent.browser.isOperaChromium=goog$1.labs.userAgent.browser.matchOperaChromium_;goog$1.labs.userAgent.browser.isFirefox=goog$1.labs.userAgent.browser.matchFirefox_;
	goog$1.labs.userAgent.browser.isSafari=goog$1.labs.userAgent.browser.matchSafari_;goog$1.labs.userAgent.browser.isCoast=goog$1.labs.userAgent.browser.matchCoast_;goog$1.labs.userAgent.browser.isIosWebview=goog$1.labs.userAgent.browser.matchIosWebview_;goog$1.labs.userAgent.browser.isChrome=goog$1.labs.userAgent.browser.matchChrome_;goog$1.labs.userAgent.browser.isAndroidBrowser=goog$1.labs.userAgent.browser.matchAndroidBrowser_;goog$1.labs.userAgent.browser.isSilk=function(){return goog$1.labs.userAgent.util.matchUserAgent("Silk")};
	goog$1.labs.userAgent.browser.getVersion=function(){function a(a){a=goog$1.array.find(a,d);return c[a]||""}var b=goog$1.labs.userAgent.util.getUserAgent();if(goog$1.labs.userAgent.browser.isIE())return goog$1.labs.userAgent.browser.getIEVersion_(b);b=goog$1.labs.userAgent.util.extractVersionTuples(b);var c={};goog$1.array.forEach(b,function(a){c[a[0]]=a[1];});var d=goog$1.partial(goog$1.object.containsKey,c);return goog$1.labs.userAgent.browser.isOpera()?a(["Version","Opera"]):goog$1.labs.userAgent.browser.isEdge()?a(["Edge"]):
	goog$1.labs.userAgent.browser.isEdgeChromium()?a(["Edg"]):goog$1.labs.userAgent.browser.isChrome()?a(["Chrome","CriOS"]):(b=b[2])&&b[1]||""};goog$1.labs.userAgent.browser.isVersionOrHigher=function(a){return 0<=goog$1.string.internal.compareVersions(goog$1.labs.userAgent.browser.getVersion(),a)};
	goog$1.labs.userAgent.browser.getIEVersion_=function(a){var b=/rv: *([\d\.]*)/.exec(a);if(b&&b[1])return b[1];b="";var c=/MSIE +([\d\.]+)/.exec(a);if(c&&c[1])if(a=/Trident\/(\d.\d)/.exec(a),"7.0"==c[1])if(a&&a[1])switch(a[1]){case "4.0":b="8.0";break;case "5.0":b="9.0";break;case "6.0":b="10.0";break;case "7.0":b="11.0";}else b="7.0";else b=c[1];return b};goog$1.html.SafeHtml=function(){this.privateDoNotAccessOrElseSafeHtmlWrappedValue_="";this.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog$1.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;this.dir_=null;};goog$1.html.SafeHtml.prototype.implementsGoogI18nBidiDirectionalString=!0;goog$1.html.SafeHtml.prototype.getDirection=function(){return this.dir_};goog$1.html.SafeHtml.prototype.implementsGoogStringTypedString=!0;goog$1.html.SafeHtml.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_.toString()};
	goog$1.DEBUG&&(goog$1.html.SafeHtml.prototype.toString=function(){return "SafeHtml{"+this.privateDoNotAccessOrElseSafeHtmlWrappedValue_+"}"});goog$1.html.SafeHtml.unwrap=function(a){return goog$1.html.SafeHtml.unwrapTrustedHTML(a).toString()};
	goog$1.html.SafeHtml.unwrapTrustedHTML=function(a){if(a instanceof goog$1.html.SafeHtml&&a.constructor===goog$1.html.SafeHtml&&a.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog$1.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeHtmlWrappedValue_;goog$1.asserts.fail("expected object of type SafeHtml, got '"+a+"' of type "+goog$1.typeOf(a));return "type_error:SafeHtml"};
	goog$1.html.SafeHtml.htmlEscape=function(a){if(a instanceof goog$1.html.SafeHtml)return a;var b="object"==typeof a,c=null;b&&a.implementsGoogI18nBidiDirectionalString&&(c=a.getDirection());a=b&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);return goog$1.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog$1.string.internal.htmlEscape(a),c)};
	goog$1.html.SafeHtml.htmlEscapePreservingNewlines=function(a){if(a instanceof goog$1.html.SafeHtml)return a;a=goog$1.html.SafeHtml.htmlEscape(a);return goog$1.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog$1.string.internal.newLineToBr(goog$1.html.SafeHtml.unwrap(a)),a.getDirection())};
	goog$1.html.SafeHtml.htmlEscapePreservingNewlinesAndSpaces=function(a){if(a instanceof goog$1.html.SafeHtml)return a;a=goog$1.html.SafeHtml.htmlEscape(a);return goog$1.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog$1.string.internal.whitespaceEscape(goog$1.html.SafeHtml.unwrap(a)),a.getDirection())};goog$1.html.SafeHtml.from=goog$1.html.SafeHtml.htmlEscape;goog$1.html.SafeHtml.VALID_NAMES_IN_TAG_=/^[a-zA-Z0-9-]+$/;
	goog$1.html.SafeHtml.URL_ATTRIBUTES_={action:!0,cite:!0,data:!0,formaction:!0,href:!0,manifest:!0,poster:!0,src:!0};goog$1.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_={APPLET:!0,BASE:!0,EMBED:!0,IFRAME:!0,LINK:!0,MATH:!0,META:!0,OBJECT:!0,SCRIPT:!0,STYLE:!0,SVG:!0,TEMPLATE:!0};goog$1.html.SafeHtml.create=function(a,b,c){goog$1.html.SafeHtml.verifyTagName(String(a));return goog$1.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(String(a),b,c)};
	goog$1.html.SafeHtml.verifyTagName=function(a){if(!goog$1.html.SafeHtml.VALID_NAMES_IN_TAG_.test(a))throw Error("Invalid tag name <"+a+">.");if(a.toUpperCase()in goog$1.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_)throw Error("Tag name <"+a+"> is not allowed for SafeHtml.");};
	goog$1.html.SafeHtml.createIframe=function(a,b,c,d){a&&goog$1.html.TrustedResourceUrl.unwrap(a);var e={};e.src=a||null;e.srcdoc=b&&goog$1.html.SafeHtml.unwrap(b);a=goog$1.html.SafeHtml.combineAttributes(e,{sandbox:""},c);return goog$1.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe",a,d)};
	goog$1.html.SafeHtml.createSandboxIframe=function(a,b,c,d){if(!goog$1.html.SafeHtml.canUseSandboxIframe())throw Error("The browser does not support sandboxed iframes.");var e={};e.src=a?goog$1.html.SafeUrl.unwrap(goog$1.html.SafeUrl.sanitize(a)):null;e.srcdoc=b||null;e.sandbox="";a=goog$1.html.SafeHtml.combineAttributes(e,{},c);return goog$1.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe",a,d)};
	goog$1.html.SafeHtml.canUseSandboxIframe=function(){return goog$1.global.HTMLIFrameElement&&"sandbox"in goog$1.global.HTMLIFrameElement.prototype};goog$1.html.SafeHtml.createScriptSrc=function(a,b){goog$1.html.TrustedResourceUrl.unwrap(a);a=goog$1.html.SafeHtml.combineAttributes({src:a},{},b);return goog$1.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script",a)};
	goog$1.html.SafeHtml.createScript=function(a,b){for(var c in b){var d=c.toLowerCase();if("language"==d||"src"==d||"text"==d||"type"==d)throw Error('Cannot set "'+d+'" attribute');}c="";a=goog$1.array.concat(a);for(d=0;d<a.length;d++)c+=goog$1.html.SafeScript.unwrap(a[d]);a=goog$1.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(c,goog$1.i18n.bidi.Dir.NEUTRAL);return goog$1.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script",b,a)};
	goog$1.html.SafeHtml.createStyle=function(a,b){b=goog$1.html.SafeHtml.combineAttributes({type:"text/css"},{},b);var c="";a=goog$1.array.concat(a);for(var d=0;d<a.length;d++)c+=goog$1.html.SafeStyleSheet.unwrap(a[d]);a=goog$1.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(c,goog$1.i18n.bidi.Dir.NEUTRAL);return goog$1.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("style",b,a)};
	goog$1.html.SafeHtml.createMetaRefresh=function(a,b){a=goog$1.html.SafeUrl.unwrap(goog$1.html.SafeUrl.sanitize(a));(goog$1.labs.userAgent.browser.isIE()||goog$1.labs.userAgent.browser.isEdge())&&goog$1.string.internal.contains(a,";")&&(a="'"+a.replace(/'/g,"%27")+"'");return goog$1.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("meta",{"http-equiv":"refresh",content:(b||0)+"; url="+a})};
	goog$1.html.SafeHtml.getAttrNameAndValue_=function(a,b,c){if(c instanceof goog$1.string.Const)c=goog$1.string.Const.unwrap(c);else if("style"==b.toLowerCase())c=goog$1.html.SafeHtml.getStyleValue_(c);else {if(/^on/i.test(b))throw Error('Attribute "'+b+'" requires goog.string.Const value, "'+c+'" given.');if(b.toLowerCase()in goog$1.html.SafeHtml.URL_ATTRIBUTES_)if(c instanceof goog$1.html.TrustedResourceUrl)c=goog$1.html.TrustedResourceUrl.unwrap(c);else if(c instanceof goog$1.html.SafeUrl)c=goog$1.html.SafeUrl.unwrap(c);
	else if(goog$1.isString(c))c=goog$1.html.SafeUrl.sanitize(c).getTypedStringValue();else throw Error('Attribute "'+b+'" on tag "'+a+'" requires goog.html.SafeUrl, goog.string.Const, or string, value "'+c+'" given.');}c.implementsGoogStringTypedString&&(c=c.getTypedStringValue());goog$1.asserts.assert(goog$1.isString(c)||goog$1.isNumber(c),"String or number value expected, got "+typeof c+" with value: "+c);return b+'="'+goog$1.string.internal.htmlEscape(String(c))+'"'};
	goog$1.html.SafeHtml.getStyleValue_=function(a){if(!goog$1.isObject(a))throw Error('The "style" attribute requires goog.html.SafeStyle or map of style properties, '+typeof a+" given: "+a);a instanceof goog$1.html.SafeStyle||(a=goog$1.html.SafeStyle.create(a));return goog$1.html.SafeStyle.unwrap(a)};goog$1.html.SafeHtml.createWithDir=function(a,b,c,d){b=goog$1.html.SafeHtml.create(b,c,d);b.dir_=a;return b};
	goog$1.html.SafeHtml.join=function(a,b){a=goog$1.html.SafeHtml.htmlEscape(a);var c=a.getDirection(),d=[],e=function(a){goog$1.isArray(a)?goog$1.array.forEach(a,e):(a=goog$1.html.SafeHtml.htmlEscape(a),d.push(goog$1.html.SafeHtml.unwrap(a)),a=a.getDirection(),c==goog$1.i18n.bidi.Dir.NEUTRAL?c=a:a!=goog$1.i18n.bidi.Dir.NEUTRAL&&c!=a&&(c=null));};goog$1.array.forEach(b,e);return goog$1.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(d.join(goog$1.html.SafeHtml.unwrap(a)),c)};
	goog$1.html.SafeHtml.concat=function(a){return goog$1.html.SafeHtml.join(goog$1.html.SafeHtml.EMPTY,Array.prototype.slice.call(arguments))};goog$1.html.SafeHtml.concatWithDir=function(a,b){var c=goog$1.html.SafeHtml.concat(goog$1.array.slice(arguments,1));c.dir_=a;return c};goog$1.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog$1.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse=function(a,b){return (new goog$1.html.SafeHtml).initSecurityPrivateDoNotAccessOrElse_(a,b)};
	goog$1.html.SafeHtml.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a,b){this.privateDoNotAccessOrElseSafeHtmlWrappedValue_=goog$1.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog$1.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createHTML(a):a;this.dir_=b;return this};
	goog$1.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse=function(a,b,c){var d=null;var e="<"+a+goog$1.html.SafeHtml.stringifyAttributes(a,b);goog$1.isDefAndNotNull(c)?goog$1.isArray(c)||(c=[c]):c=[];goog$1.dom.tags.isVoidTag(a.toLowerCase())?(goog$1.asserts.assert(!c.length,"Void tag <"+a+"> does not allow content."),e+=">"):(d=goog$1.html.SafeHtml.concat(c),e+=">"+goog$1.html.SafeHtml.unwrap(d)+"</"+a+">",d=d.getDirection());(a=b&&b.dir)&&(d=/^(ltr|rtl|auto)$/i.test(a)?goog$1.i18n.bidi.Dir.NEUTRAL:
	null);return goog$1.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(e,d)};goog$1.html.SafeHtml.stringifyAttributes=function(a,b){var c="";if(b)for(var d in b){if(!goog$1.html.SafeHtml.VALID_NAMES_IN_TAG_.test(d))throw Error('Invalid attribute name "'+d+'".');var e=b[d];goog$1.isDefAndNotNull(e)&&(c+=" "+goog$1.html.SafeHtml.getAttrNameAndValue_(a,d,e));}return c};
	goog$1.html.SafeHtml.combineAttributes=function(a,b,c){var d={},e;for(e in a)goog$1.asserts.assert(e.toLowerCase()==e,"Must be lower case"),d[e]=a[e];for(e in b)goog$1.asserts.assert(e.toLowerCase()==e,"Must be lower case"),d[e]=b[e];for(e in c){var f=e.toLowerCase();if(f in a)throw Error('Cannot override "'+f+'" attribute, got "'+e+'" with value "'+c[e]+'"');f in b&&delete d[f];d[e]=c[e];}return d};
	goog$1.html.SafeHtml.DOCTYPE_HTML=goog$1.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<!DOCTYPE html>",goog$1.i18n.bidi.Dir.NEUTRAL);goog$1.html.SafeHtml.EMPTY=goog$1.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("",goog$1.i18n.bidi.Dir.NEUTRAL);goog$1.html.SafeHtml.BR=goog$1.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<br>",goog$1.i18n.bidi.Dir.NEUTRAL);goog$1.html.uncheckedconversions={};goog$1.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract=function(a,b,c){goog$1.asserts.assertString(goog$1.string.Const.unwrap(a),"must provide justification");goog$1.asserts.assert(!goog$1.string.internal.isEmptyOrWhitespace(goog$1.string.Const.unwrap(a)),"must provide non-empty justification");return goog$1.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(b,c||null)};
	goog$1.html.uncheckedconversions.safeScriptFromStringKnownToSatisfyTypeContract=function(a,b){goog$1.asserts.assertString(goog$1.string.Const.unwrap(a),"must provide justification");goog$1.asserts.assert(!goog$1.string.internal.isEmptyOrWhitespace(goog$1.string.Const.unwrap(a)),"must provide non-empty justification");return goog$1.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(b)};
	goog$1.html.uncheckedconversions.safeStyleFromStringKnownToSatisfyTypeContract=function(a,b){goog$1.asserts.assertString(goog$1.string.Const.unwrap(a),"must provide justification");goog$1.asserts.assert(!goog$1.string.internal.isEmptyOrWhitespace(goog$1.string.Const.unwrap(a)),"must provide non-empty justification");return goog$1.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b)};
	goog$1.html.uncheckedconversions.safeStyleSheetFromStringKnownToSatisfyTypeContract=function(a,b){goog$1.asserts.assertString(goog$1.string.Const.unwrap(a),"must provide justification");goog$1.asserts.assert(!goog$1.string.internal.isEmptyOrWhitespace(goog$1.string.Const.unwrap(a)),"must provide non-empty justification");return goog$1.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(b)};
	goog$1.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract=function(a,b){goog$1.asserts.assertString(goog$1.string.Const.unwrap(a),"must provide justification");goog$1.asserts.assert(!goog$1.string.internal.isEmptyOrWhitespace(goog$1.string.Const.unwrap(a)),"must provide non-empty justification");return goog$1.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b)};
	goog$1.html.uncheckedconversions.trustedResourceUrlFromStringKnownToSatisfyTypeContract=function(a,b){goog$1.asserts.assertString(goog$1.string.Const.unwrap(a),"must provide justification");goog$1.asserts.assert(!goog$1.string.internal.isEmptyOrWhitespace(goog$1.string.Const.unwrap(a)),"must provide non-empty justification");return goog$1.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(b)};goog$1.dom.asserts={};goog$1.dom.asserts.assertIsLocation=function(a){if(goog$1.asserts.ENABLE_ASSERTS){var b=goog$1.dom.asserts.getWindow_(a);b&&(!a||!(a instanceof b.Location)&&a instanceof b.Element)&&goog$1.asserts.fail("Argument is not a Location (or a non-Element mock); got: %s",goog$1.dom.asserts.debugStringForType_(a));}return a};
	goog$1.dom.asserts.assertIsElementType_=function(a,b){if(goog$1.asserts.ENABLE_ASSERTS){var c=goog$1.dom.asserts.getWindow_(a);c&&"undefined"!=typeof c[b]&&(a&&(a instanceof c[b]||!(a instanceof c.Location||a instanceof c.Element))||goog$1.asserts.fail("Argument is not a %s (or a non-Element, non-Location mock); got: %s",b,goog$1.dom.asserts.debugStringForType_(a)));}return a};goog$1.dom.asserts.assertIsHTMLAnchorElement=function(a){return goog$1.dom.asserts.assertIsElementType_(a,"HTMLAnchorElement")};
	goog$1.dom.asserts.assertIsHTMLButtonElement=function(a){return goog$1.dom.asserts.assertIsElementType_(a,"HTMLButtonElement")};goog$1.dom.asserts.assertIsHTMLLinkElement=function(a){return goog$1.dom.asserts.assertIsElementType_(a,"HTMLLinkElement")};goog$1.dom.asserts.assertIsHTMLImageElement=function(a){return goog$1.dom.asserts.assertIsElementType_(a,"HTMLImageElement")};goog$1.dom.asserts.assertIsHTMLAudioElement=function(a){return goog$1.dom.asserts.assertIsElementType_(a,"HTMLAudioElement")};
	goog$1.dom.asserts.assertIsHTMLVideoElement=function(a){return goog$1.dom.asserts.assertIsElementType_(a,"HTMLVideoElement")};goog$1.dom.asserts.assertIsHTMLInputElement=function(a){return goog$1.dom.asserts.assertIsElementType_(a,"HTMLInputElement")};goog$1.dom.asserts.assertIsHTMLTextAreaElement=function(a){return goog$1.dom.asserts.assertIsElementType_(a,"HTMLTextAreaElement")};goog$1.dom.asserts.assertIsHTMLCanvasElement=function(a){return goog$1.dom.asserts.assertIsElementType_(a,"HTMLCanvasElement")};
	goog$1.dom.asserts.assertIsHTMLEmbedElement=function(a){return goog$1.dom.asserts.assertIsElementType_(a,"HTMLEmbedElement")};goog$1.dom.asserts.assertIsHTMLFormElement=function(a){return goog$1.dom.asserts.assertIsElementType_(a,"HTMLFormElement")};goog$1.dom.asserts.assertIsHTMLFrameElement=function(a){return goog$1.dom.asserts.assertIsElementType_(a,"HTMLFrameElement")};goog$1.dom.asserts.assertIsHTMLIFrameElement=function(a){return goog$1.dom.asserts.assertIsElementType_(a,"HTMLIFrameElement")};
	goog$1.dom.asserts.assertIsHTMLObjectElement=function(a){return goog$1.dom.asserts.assertIsElementType_(a,"HTMLObjectElement")};goog$1.dom.asserts.assertIsHTMLScriptElement=function(a){return goog$1.dom.asserts.assertIsElementType_(a,"HTMLScriptElement")};
	goog$1.dom.asserts.debugStringForType_=function(a){if(goog$1.isObject(a))try{return a.constructor.displayName||a.constructor.name||Object.prototype.toString.call(a)}catch(b){return "<object could not be stringified>"}else return void 0===a?"undefined":null===a?"null":typeof a};goog$1.dom.asserts.getWindow_=function(a){try{var b=a&&a.ownerDocument,c=b&&(b.defaultView||b.parentWindow);c=c||goog$1.global;if(c.Element&&c.Location)return c}catch(d){}return null};goog$1.functions={};goog$1.functions.constant=function(a){return function(){return a}};goog$1.functions.FALSE=function(){return !1};goog$1.functions.TRUE=function(){return !0};goog$1.functions.NULL=function(){return null};goog$1.functions.identity=function(a,b){return a};goog$1.functions.error=function(a){return function(){throw Error(a);}};goog$1.functions.fail=function(a){return function(){throw a;}};
	goog$1.functions.lock=function(a,b){b=b||0;return function(){return a.apply(this,Array.prototype.slice.call(arguments,0,b))}};goog$1.functions.nth=function(a){return function(){return arguments[a]}};goog$1.functions.partialRight=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=Array.prototype.slice.call(arguments);b.push.apply(b,c);return a.apply(this,b)}};goog$1.functions.withReturnValue=function(a,b){return goog$1.functions.sequence(a,goog$1.functions.constant(b))};
	goog$1.functions.equalTo=function(a,b){return function(c){return b?a==c:a===c}};goog$1.functions.compose=function(a,b){var c=arguments,d=c.length;return function(){var a;d&&(a=c[d-1].apply(this,arguments));for(var b=d-2;0<=b;b--)a=c[b].call(this,a);return a}};goog$1.functions.sequence=function(a){var b=arguments,c=b.length;return function(){for(var a,e=0;e<c;e++)a=b[e].apply(this,arguments);return a}};
	goog$1.functions.and=function(a){var b=arguments,c=b.length;return function(){for(var a=0;a<c;a++)if(!b[a].apply(this,arguments))return !1;return !0}};goog$1.functions.or=function(a){var b=arguments,c=b.length;return function(){for(var a=0;a<c;a++)if(b[a].apply(this,arguments))return !0;return !1}};goog$1.functions.not=function(a){return function(){return !a.apply(this,arguments)}};
	goog$1.functions.create=function(a,b){var c=function(){};c.prototype=a.prototype;c=new c;a.apply(c,Array.prototype.slice.call(arguments,1));return c};goog$1.functions.CACHE_RETURN_VALUE=!0;goog$1.functions.cacheReturnValue=function(a){var b=!1,c;return function(){if(!goog$1.functions.CACHE_RETURN_VALUE)return a();b||(c=a(),b=!0);return c}};goog$1.functions.once=function(a){var b=a;return function(){if(b){var a=b;b=null;a();}}};
	goog$1.functions.debounce=function(a,b,c){var d=0;return function(e){goog$1.global.clearTimeout(d);var f=arguments;d=goog$1.global.setTimeout(function(){a.apply(c,f);},b);}};goog$1.functions.throttle=function(a,b,c){var d=0,e=!1,f=[],g=function(){d=0;e&&(e=!1,h());},h=function(){d=goog$1.global.setTimeout(g,b);a.apply(c,f);};return function(a){f=arguments;d?e=!0:h();}};goog$1.functions.rateLimit=function(a,b,c){var d=0,e=function(){d=0;};return function(f){d||(d=goog$1.global.setTimeout(e,b),a.apply(c,arguments));}};goog$1.dom.safe={};goog$1.dom.safe.InsertAdjacentHtmlPosition={AFTERBEGIN:"afterbegin",AFTEREND:"afterend",BEFOREBEGIN:"beforebegin",BEFOREEND:"beforeend"};goog$1.dom.safe.insertAdjacentHtml=function(a,b,c){a.insertAdjacentHTML(b,goog$1.html.SafeHtml.unwrapTrustedHTML(c));};goog$1.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_={MATH:!0,SCRIPT:!0,STYLE:!0,SVG:!0,TEMPLATE:!0};
	goog$1.dom.safe.isInnerHtmlCleanupRecursive_=goog$1.functions.cacheReturnValue(function(){if(goog$1.DEBUG&&"undefined"===typeof document)return !1;var a=document.createElement("div"),b=document.createElement("div");b.appendChild(document.createElement("div"));a.appendChild(b);if(goog$1.DEBUG&&!a.firstChild)return !1;b=a.firstChild.firstChild;a.innerHTML=goog$1.html.SafeHtml.unwrapTrustedHTML(goog$1.html.SafeHtml.EMPTY);return !b.parentElement});
	goog$1.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse=function(a,b){if(goog$1.dom.safe.isInnerHtmlCleanupRecursive_())for(;a.lastChild;)a.removeChild(a.lastChild);a.innerHTML=goog$1.html.SafeHtml.unwrapTrustedHTML(b);};
	goog$1.dom.safe.setInnerHtml=function(a,b){if(goog$1.asserts.ENABLE_ASSERTS){var c=a.tagName.toUpperCase();if(goog$1.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_[c])throw Error("goog.dom.safe.setInnerHtml cannot be used to set content of "+a.tagName+".");}goog$1.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse(a,b);};goog$1.dom.safe.setOuterHtml=function(a,b){a.outerHTML=goog$1.html.SafeHtml.unwrapTrustedHTML(b);};
	goog$1.dom.safe.setFormElementAction=function(a,b){b=b instanceof goog$1.html.SafeUrl?b:goog$1.html.SafeUrl.sanitizeAssertUnchanged(b);goog$1.dom.asserts.assertIsHTMLFormElement(a).action=goog$1.html.SafeUrl.unwrapTrustedURL(b);};goog$1.dom.safe.setButtonFormAction=function(a,b){b=b instanceof goog$1.html.SafeUrl?b:goog$1.html.SafeUrl.sanitizeAssertUnchanged(b);goog$1.dom.asserts.assertIsHTMLButtonElement(a).formAction=goog$1.html.SafeUrl.unwrapTrustedURL(b);};
	goog$1.dom.safe.setInputFormAction=function(a,b){b=b instanceof goog$1.html.SafeUrl?b:goog$1.html.SafeUrl.sanitizeAssertUnchanged(b);goog$1.dom.asserts.assertIsHTMLInputElement(a).formAction=goog$1.html.SafeUrl.unwrapTrustedURL(b);};goog$1.dom.safe.setStyle=function(a,b){a.style.cssText=goog$1.html.SafeStyle.unwrap(b);};goog$1.dom.safe.documentWrite=function(a,b){a.write(goog$1.html.SafeHtml.unwrapTrustedHTML(b));};
	goog$1.dom.safe.setAnchorHref=function(a,b){goog$1.dom.asserts.assertIsHTMLAnchorElement(a);b=b instanceof goog$1.html.SafeUrl?b:goog$1.html.SafeUrl.sanitizeAssertUnchanged(b);a.href=goog$1.html.SafeUrl.unwrapTrustedURL(b);};goog$1.dom.safe.setImageSrc=function(a,b){goog$1.dom.asserts.assertIsHTMLImageElement(a);if(!(b instanceof goog$1.html.SafeUrl)){var c=/^data:image\//i.test(b);b=goog$1.html.SafeUrl.sanitizeAssertUnchanged(b,c);}a.src=goog$1.html.SafeUrl.unwrapTrustedURL(b);};
	goog$1.dom.safe.setAudioSrc=function(a,b){goog$1.dom.asserts.assertIsHTMLAudioElement(a);if(!(b instanceof goog$1.html.SafeUrl)){var c=/^data:audio\//i.test(b);b=goog$1.html.SafeUrl.sanitizeAssertUnchanged(b,c);}a.src=goog$1.html.SafeUrl.unwrapTrustedURL(b);};goog$1.dom.safe.setVideoSrc=function(a,b){goog$1.dom.asserts.assertIsHTMLVideoElement(a);if(!(b instanceof goog$1.html.SafeUrl)){var c=/^data:video\//i.test(b);b=goog$1.html.SafeUrl.sanitizeAssertUnchanged(b,c);}a.src=goog$1.html.SafeUrl.unwrapTrustedURL(b);};
	goog$1.dom.safe.setEmbedSrc=function(a,b){goog$1.dom.asserts.assertIsHTMLEmbedElement(a);a.src=goog$1.html.TrustedResourceUrl.unwrapTrustedScriptURL(b);};goog$1.dom.safe.setFrameSrc=function(a,b){goog$1.dom.asserts.assertIsHTMLFrameElement(a);a.src=goog$1.html.TrustedResourceUrl.unwrapTrustedURL(b);};goog$1.dom.safe.setIframeSrc=function(a,b){goog$1.dom.asserts.assertIsHTMLIFrameElement(a);a.src=goog$1.html.TrustedResourceUrl.unwrapTrustedURL(b);};
	goog$1.dom.safe.setIframeSrcdoc=function(a,b){goog$1.dom.asserts.assertIsHTMLIFrameElement(a);a.srcdoc=goog$1.html.SafeHtml.unwrapTrustedHTML(b);};
	goog$1.dom.safe.setLinkHrefAndRel=function(a,b,c){goog$1.dom.asserts.assertIsHTMLLinkElement(a);a.rel=c;goog$1.string.internal.caseInsensitiveContains(c,"stylesheet")?(goog$1.asserts.assert(b instanceof goog$1.html.TrustedResourceUrl,'URL must be TrustedResourceUrl because "rel" contains "stylesheet"'),a.href=goog$1.html.TrustedResourceUrl.unwrapTrustedURL(b)):a.href=b instanceof goog$1.html.TrustedResourceUrl?goog$1.html.TrustedResourceUrl.unwrapTrustedURL(b):b instanceof goog$1.html.SafeUrl?goog$1.html.SafeUrl.unwrapTrustedURL(b):
	goog$1.html.SafeUrl.unwrapTrustedURL(goog$1.html.SafeUrl.sanitizeAssertUnchanged(b));};goog$1.dom.safe.setObjectData=function(a,b){goog$1.dom.asserts.assertIsHTMLObjectElement(a);a.data=goog$1.html.TrustedResourceUrl.unwrapTrustedScriptURL(b);};goog$1.dom.safe.setScriptSrc=function(a,b){goog$1.dom.asserts.assertIsHTMLScriptElement(a);a.src=goog$1.html.TrustedResourceUrl.unwrapTrustedScriptURL(b);(b=goog$1.getScriptNonce())&&a.setAttribute("nonce",b);};
	goog$1.dom.safe.setScriptContent=function(a,b){goog$1.dom.asserts.assertIsHTMLScriptElement(a);a.text=goog$1.html.SafeScript.unwrapTrustedScript(b);(b=goog$1.getScriptNonce())&&a.setAttribute("nonce",b);};goog$1.dom.safe.setLocationHref=function(a,b){goog$1.dom.asserts.assertIsLocation(a);b=b instanceof goog$1.html.SafeUrl?b:goog$1.html.SafeUrl.sanitizeAssertUnchanged(b);a.href=goog$1.html.SafeUrl.unwrapTrustedURL(b);};
	goog$1.dom.safe.assignLocation=function(a,b){goog$1.dom.asserts.assertIsLocation(a);b=b instanceof goog$1.html.SafeUrl?b:goog$1.html.SafeUrl.sanitizeAssertUnchanged(b);a.assign(goog$1.html.SafeUrl.unwrapTrustedURL(b));};goog$1.dom.safe.replaceLocation=function(a,b){goog$1.dom.asserts.assertIsLocation(a);b=b instanceof goog$1.html.SafeUrl?b:goog$1.html.SafeUrl.sanitizeAssertUnchanged(b);a.replace(goog$1.html.SafeUrl.unwrapTrustedURL(b));};
	goog$1.dom.safe.openInWindow=function(a,b,c,d,e){a=a instanceof goog$1.html.SafeUrl?a:goog$1.html.SafeUrl.sanitizeAssertUnchanged(a);return (b||goog$1.global).open(goog$1.html.SafeUrl.unwrapTrustedURL(a),c?goog$1.string.Const.unwrap(c):"",d,e)};goog$1.dom.safe.parseFromStringHtml=function(a,b){return goog$1.dom.safe.parseFromString(a,b,"text/html")};goog$1.dom.safe.parseFromString=function(a,b,c){return a.parseFromString(goog$1.html.SafeHtml.unwrapTrustedHTML(b),c)};
	goog$1.dom.safe.createImageFromBlob=function(a){if(!/^image\/.*/g.test(a.type))throw Error("goog.dom.safe.createImageFromBlob only accepts MIME type image/.*.");var b=goog$1.global.URL.createObjectURL(a);a=new goog$1.global.Image;a.onload=function(){goog$1.global.URL.revokeObjectURL(b);};goog$1.dom.safe.setImageSrc(a,goog$1.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract(goog$1.string.Const.from("Image blob URL."),b));return a};goog$1.string.DETECT_DOUBLE_ESCAPING=!1;goog$1.string.FORCE_NON_DOM_HTML_UNESCAPING=!1;goog$1.string.Unicode={NBSP:"\u00a0"};goog$1.string.startsWith=goog$1.string.internal.startsWith;goog$1.string.endsWith=goog$1.string.internal.endsWith;goog$1.string.caseInsensitiveStartsWith=goog$1.string.internal.caseInsensitiveStartsWith;goog$1.string.caseInsensitiveEndsWith=goog$1.string.internal.caseInsensitiveEndsWith;goog$1.string.caseInsensitiveEquals=goog$1.string.internal.caseInsensitiveEquals;
	goog$1.string.subs=function(a,b){for(var c=a.split("%s"),d="",e=Array.prototype.slice.call(arguments,1);e.length&&1<c.length;)d+=c.shift()+e.shift();return d+c.join("%s")};goog$1.string.collapseWhitespace=function(a){return a.replace(/[\s\xa0]+/g," ").replace(/^\s+|\s+$/g,"")};goog$1.string.isEmptyOrWhitespace=goog$1.string.internal.isEmptyOrWhitespace;goog$1.string.isEmptyString=function(a){return 0==a.length};goog$1.string.isEmpty=goog$1.string.isEmptyOrWhitespace;goog$1.string.isEmptyOrWhitespaceSafe=function(a){return goog$1.string.isEmptyOrWhitespace(goog$1.string.makeSafe(a))};
	goog$1.string.isEmptySafe=goog$1.string.isEmptyOrWhitespaceSafe;goog$1.string.isBreakingWhitespace=function(a){return !/[^\t\n\r ]/.test(a)};goog$1.string.isAlpha=function(a){return !/[^a-zA-Z]/.test(a)};goog$1.string.isNumeric=function(a){return !/[^0-9]/.test(a)};goog$1.string.isAlphaNumeric=function(a){return !/[^a-zA-Z0-9]/.test(a)};goog$1.string.isSpace=function(a){return " "==a};goog$1.string.isUnicodeChar=function(a){return 1==a.length&&" "<=a&&"~">=a||"\u0080"<=a&&"\ufffd">=a};
	goog$1.string.stripNewlines=function(a){return a.replace(/(\r\n|\r|\n)+/g," ")};goog$1.string.canonicalizeNewlines=function(a){return a.replace(/(\r\n|\r|\n)/g,"\n")};goog$1.string.normalizeWhitespace=function(a){return a.replace(/\xa0|\s/g," ")};goog$1.string.normalizeSpaces=function(a){return a.replace(/\xa0|[ \t]+/g," ")};goog$1.string.collapseBreakingSpaces=function(a){return a.replace(/[\t\r\n ]+/g," ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g,"")};goog$1.string.trim=goog$1.string.internal.trim;
	goog$1.string.trimLeft=function(a){return a.replace(/^[\s\xa0]+/,"")};goog$1.string.trimRight=function(a){return a.replace(/[\s\xa0]+$/,"")};goog$1.string.caseInsensitiveCompare=goog$1.string.internal.caseInsensitiveCompare;
	goog$1.string.numberAwareCompare_=function(a,b,c){if(a==b)return 0;if(!a)return -1;if(!b)return 1;for(var d=a.toLowerCase().match(c),e=b.toLowerCase().match(c),f=Math.min(d.length,e.length),g=0;g<f;g++){c=d[g];var h=e[g];if(c!=h)return a=parseInt(c,10),!isNaN(a)&&(b=parseInt(h,10),!isNaN(b)&&a-b)?a-b:c<h?-1:1}return d.length!=e.length?d.length-e.length:a<b?-1:1};goog$1.string.intAwareCompare=function(a,b){return goog$1.string.numberAwareCompare_(a,b,/\d+|\D+/g)};
	goog$1.string.floatAwareCompare=function(a,b){return goog$1.string.numberAwareCompare_(a,b,/\d+|\.\d+|\D+/g)};goog$1.string.numerateCompare=goog$1.string.floatAwareCompare;goog$1.string.urlEncode=function(a){return encodeURIComponent(String(a))};goog$1.string.urlDecode=function(a){return decodeURIComponent(a.replace(/\+/g," "))};goog$1.string.newLineToBr=goog$1.string.internal.newLineToBr;
	goog$1.string.htmlEscape=function(a,b){a=goog$1.string.internal.htmlEscape(a,b);goog$1.string.DETECT_DOUBLE_ESCAPING&&(a=a.replace(goog$1.string.E_RE_,"&#101;"));return a};goog$1.string.E_RE_=/e/g;goog$1.string.unescapeEntities=function(a){return goog$1.string.contains(a,"&")?!goog$1.string.FORCE_NON_DOM_HTML_UNESCAPING&&"document"in goog$1.global?goog$1.string.unescapeEntitiesUsingDom_(a):goog$1.string.unescapePureXmlEntities_(a):a};
	goog$1.string.unescapeEntitiesWithDocument=function(a,b){return goog$1.string.contains(a,"&")?goog$1.string.unescapeEntitiesUsingDom_(a,b):a};
	goog$1.string.unescapeEntitiesUsingDom_=function(a,b){var c={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"'};var d=b?b.createElement("div"):goog$1.global.document.createElement("div");return a.replace(goog$1.string.HTML_ENTITY_PATTERN_,function(a,b){var e=c[a];if(e)return e;"#"==b.charAt(0)&&(b=Number("0"+b.substr(1)),isNaN(b)||(e=String.fromCharCode(b)));e||(goog$1.dom.safe.setInnerHtml(d,goog$1.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(goog$1.string.Const.from("Single HTML entity."),
	a+" ")),e=d.firstChild.nodeValue.slice(0,-1));return c[a]=e})};goog$1.string.unescapePureXmlEntities_=function(a){return a.replace(/&([^;]+);/g,function(a,c){switch(c){case "amp":return "&";case "lt":return "<";case "gt":return ">";case "quot":return '"';default:return "#"!=c.charAt(0)||(c=Number("0"+c.substr(1)),isNaN(c))?a:String.fromCharCode(c)}})};goog$1.string.HTML_ENTITY_PATTERN_=/&([^;\s<&]+);?/g;goog$1.string.whitespaceEscape=function(a,b){return goog$1.string.newLineToBr(a.replace(/  /g," &#160;"),b)};
	goog$1.string.preserveSpaces=function(a){return a.replace(/(^|[\n ]) /g,"$1"+goog$1.string.Unicode.NBSP)};goog$1.string.stripQuotes=function(a,b){for(var c=b.length,d=0;d<c;d++){var e=1==c?b:b.charAt(d);if(a.charAt(0)==e&&a.charAt(a.length-1)==e)return a.substring(1,a.length-1)}return a};goog$1.string.truncate=function(a,b,c){c&&(a=goog$1.string.unescapeEntities(a));a.length>b&&(a=a.substring(0,b-3)+"...");c&&(a=goog$1.string.htmlEscape(a));return a};
	goog$1.string.truncateMiddle=function(a,b,c,d){c&&(a=goog$1.string.unescapeEntities(a));if(d&&a.length>b){d>b&&(d=b);var e=a.length-d;a=a.substring(0,b-d)+"..."+a.substring(e);}else a.length>b&&(d=Math.floor(b/2),e=a.length-d,a=a.substring(0,d+b%2)+"..."+a.substring(e));c&&(a=goog$1.string.htmlEscape(a));return a};goog$1.string.specialEscapeChars_={"\x00":"\\0","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\x0B",'"':'\\"',"\\":"\\\\","<":"\\u003C"};goog$1.string.jsEscapeCache_={"'":"\\'"};
	goog$1.string.quote=function(a){a=String(a);for(var b=['"'],c=0;c<a.length;c++){var d=a.charAt(c),e=d.charCodeAt(0);b[c+1]=goog$1.string.specialEscapeChars_[d]||(31<e&&127>e?d:goog$1.string.escapeChar(d));}b.push('"');return b.join("")};goog$1.string.escapeString=function(a){for(var b=[],c=0;c<a.length;c++)b[c]=goog$1.string.escapeChar(a.charAt(c));return b.join("")};
	goog$1.string.escapeChar=function(a){if(a in goog$1.string.jsEscapeCache_)return goog$1.string.jsEscapeCache_[a];if(a in goog$1.string.specialEscapeChars_)return goog$1.string.jsEscapeCache_[a]=goog$1.string.specialEscapeChars_[a];var b=a.charCodeAt(0);if(31<b&&127>b)var c=a;else {if(256>b){if(c="\\x",16>b||256<b)c+="0";}else c="\\u",4096>b&&(c+="0");c+=b.toString(16).toUpperCase();}return goog$1.string.jsEscapeCache_[a]=c};goog$1.string.contains=goog$1.string.internal.contains;goog$1.string.caseInsensitiveContains=goog$1.string.internal.caseInsensitiveContains;
	goog$1.string.countOf=function(a,b){return a&&b?a.split(b).length-1:0};goog$1.string.removeAt=function(a,b,c){var d=a;0<=b&&b<a.length&&0<c&&(d=a.substr(0,b)+a.substr(b+c,a.length-b-c));return d};goog$1.string.remove=function(a,b){return a.replace(b,"")};goog$1.string.removeAll=function(a,b){b=new RegExp(goog$1.string.regExpEscape(b),"g");return a.replace(b,"")};goog$1.string.replaceAll=function(a,b,c){b=new RegExp(goog$1.string.regExpEscape(b),"g");return a.replace(b,c.replace(/\$/g,"$$$$"))};
	goog$1.string.regExpEscape=function(a){return String(a).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")};goog$1.string.repeat=String.prototype.repeat?function(a,b){return a.repeat(b)}:function(a,b){return Array(b+1).join(a)};goog$1.string.padNumber=function(a,b,c){a=goog$1.isDef(c)?a.toFixed(c):String(a);c=a.indexOf(".");-1==c&&(c=a.length);return goog$1.string.repeat("0",Math.max(0,b-c))+a};goog$1.string.makeSafe=function(a){return null==a?"":String(a)};
	goog$1.string.buildString=function(a){return Array.prototype.join.call(arguments,"")};goog$1.string.getRandomString=function(){return Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^goog$1.now()).toString(36)};goog$1.string.compareVersions=goog$1.string.internal.compareVersions;goog$1.string.hashCode=function(a){for(var b=0,c=0;c<a.length;++c)b=31*b+a.charCodeAt(c)>>>0;return b};goog$1.string.uniqueStringCounter_=2147483648*Math.random()|0;
	goog$1.string.createUniqueString=function(){return "goog_"+goog$1.string.uniqueStringCounter_++};goog$1.string.toNumber=function(a){var b=Number(a);return 0==b&&goog$1.string.isEmptyOrWhitespace(a)?NaN:b};goog$1.string.isLowerCamelCase=function(a){return /^[a-z]+([A-Z][a-z]*)*$/.test(a)};goog$1.string.isUpperCamelCase=function(a){return /^([A-Z][a-z]*)+$/.test(a)};goog$1.string.toCamelCase=function(a){return String(a).replace(/\-([a-z])/g,function(a,c){return c.toUpperCase()})};
	goog$1.string.toSelectorCase=function(a){return String(a).replace(/([A-Z])/g,"-$1").toLowerCase()};goog$1.string.toTitleCase=function(a,b){b=goog$1.isString(b)?goog$1.string.regExpEscape(b):"\\s";return a.replace(new RegExp("(^"+(b?"|["+b+"]+":"")+")([a-z])","g"),function(a,b,e){return b+e.toUpperCase()})};goog$1.string.capitalize=function(a){return String(a.charAt(0)).toUpperCase()+String(a.substr(1)).toLowerCase()};
	goog$1.string.parseInt=function(a){isFinite(a)&&(a=String(a));return goog$1.isString(a)?/^\s*-?0x/i.test(a)?parseInt(a,16):parseInt(a,10):NaN};goog$1.string.splitLimit=function(a,b,c){a=a.split(b);for(var d=[];0<c&&a.length;)d.push(a.shift()),c--;a.length&&d.push(a.join(b));return d};goog$1.string.lastComponent=function(a,b){if(b)"string"==typeof b&&(b=[b]);else return a;for(var c=-1,d=0;d<b.length;d++)if(""!=b[d]){var e=a.lastIndexOf(b[d]);e>c&&(c=e);}return -1==c?a:a.slice(c+1)};
	goog$1.string.editDistance=function(a,b){var c=[],d=[];if(a==b)return 0;if(!a.length||!b.length)return Math.max(a.length,b.length);for(var e=0;e<b.length+1;e++)c[e]=e;for(e=0;e<a.length;e++){d[0]=e+1;for(var f=0;f<b.length;f++)d[f+1]=Math.min(d[f]+1,c[f+1]+1,c[f]+Number(a[e]!=b[f]));for(f=0;f<c.length;f++)c[f]=d[f];}return d[b.length]};goog$1.labs.userAgent.platform={};goog$1.labs.userAgent.platform.isAndroid=function(){return goog$1.labs.userAgent.util.matchUserAgent("Android")};goog$1.labs.userAgent.platform.isIpod=function(){return goog$1.labs.userAgent.util.matchUserAgent("iPod")};goog$1.labs.userAgent.platform.isIphone=function(){return goog$1.labs.userAgent.util.matchUserAgent("iPhone")&&!goog$1.labs.userAgent.util.matchUserAgent("iPod")&&!goog$1.labs.userAgent.util.matchUserAgent("iPad")};goog$1.labs.userAgent.platform.isIpad=function(){return goog$1.labs.userAgent.util.matchUserAgent("iPad")};
	goog$1.labs.userAgent.platform.isIos=function(){return goog$1.labs.userAgent.platform.isIphone()||goog$1.labs.userAgent.platform.isIpad()||goog$1.labs.userAgent.platform.isIpod()};goog$1.labs.userAgent.platform.isMacintosh=function(){return goog$1.labs.userAgent.util.matchUserAgent("Macintosh")};goog$1.labs.userAgent.platform.isLinux=function(){return goog$1.labs.userAgent.util.matchUserAgent("Linux")};goog$1.labs.userAgent.platform.isWindows=function(){return goog$1.labs.userAgent.util.matchUserAgent("Windows")};
	goog$1.labs.userAgent.platform.isChromeOS=function(){return goog$1.labs.userAgent.util.matchUserAgent("CrOS")};goog$1.labs.userAgent.platform.isChromecast=function(){return goog$1.labs.userAgent.util.matchUserAgent("CrKey")};goog$1.labs.userAgent.platform.isKaiOS=function(){return goog$1.labs.userAgent.util.matchUserAgentIgnoreCase("KaiOS")};goog$1.labs.userAgent.platform.isGo2Phone=function(){return goog$1.labs.userAgent.util.matchUserAgentIgnoreCase("GAFP")};
	goog$1.labs.userAgent.platform.getVersion=function(){var a=goog$1.labs.userAgent.util.getUserAgent(),b="";goog$1.labs.userAgent.platform.isWindows()?(b=/Windows (?:NT|Phone) ([0-9.]+)/,b=(a=b.exec(a))?a[1]:"0.0"):goog$1.labs.userAgent.platform.isIos()?(b=/(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/,b=(a=b.exec(a))&&a[1].replace(/_/g,".")):goog$1.labs.userAgent.platform.isMacintosh()?(b=/Mac OS X ([0-9_.]+)/,b=(a=b.exec(a))?a[1].replace(/_/g,"."):"10"):goog$1.labs.userAgent.platform.isKaiOS()?(b=/(?:KaiOS)\/(\S+)/i,
	b=(a=b.exec(a))&&a[1]):goog$1.labs.userAgent.platform.isAndroid()?(b=/Android\s+([^\);]+)(\)|;)/,b=(a=b.exec(a))&&a[1]):goog$1.labs.userAgent.platform.isChromeOS()&&(b=/(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/,b=(a=b.exec(a))&&a[1]);return b||""};goog$1.labs.userAgent.platform.isVersionOrHigher=function(a){return 0<=goog$1.string.compareVersions(goog$1.labs.userAgent.platform.getVersion(),a)};goog$1.reflect={};goog$1.reflect.object=function(a,b){return b};goog$1.reflect.objectProperty=function(a,b){return a};goog$1.reflect.sinkValue=function(a){goog$1.reflect.sinkValue[" "](a);return a};goog$1.reflect.sinkValue[" "]=goog$1.nullFunction;goog$1.reflect.canAccessProperty=function(a,b){try{return goog$1.reflect.sinkValue(a[b]),!0}catch(c){}return !1};goog$1.reflect.cache=function(a,b,c,d){d=d?d(b):b;return Object.prototype.hasOwnProperty.call(a,d)?a[d]:a[d]=c(b)};goog$1.labs.userAgent.engine={};goog$1.labs.userAgent.engine.isPresto=function(){return goog$1.labs.userAgent.util.matchUserAgent("Presto")};goog$1.labs.userAgent.engine.isTrident=function(){return goog$1.labs.userAgent.util.matchUserAgent("Trident")||goog$1.labs.userAgent.util.matchUserAgent("MSIE")};goog$1.labs.userAgent.engine.isEdge=function(){return goog$1.labs.userAgent.util.matchUserAgent("Edge")};
	goog$1.labs.userAgent.engine.isWebKit=function(){return goog$1.labs.userAgent.util.matchUserAgentIgnoreCase("WebKit")&&!goog$1.labs.userAgent.engine.isEdge()};goog$1.labs.userAgent.engine.isGecko=function(){return goog$1.labs.userAgent.util.matchUserAgent("Gecko")&&!goog$1.labs.userAgent.engine.isWebKit()&&!goog$1.labs.userAgent.engine.isTrident()&&!goog$1.labs.userAgent.engine.isEdge()};
	goog$1.labs.userAgent.engine.getVersion=function(){var a=goog$1.labs.userAgent.util.getUserAgent();if(a){a=goog$1.labs.userAgent.util.extractVersionTuples(a);var b=goog$1.labs.userAgent.engine.getEngineTuple_(a);if(b)return "Gecko"==b[0]?goog$1.labs.userAgent.engine.getVersionForKey_(a,"Firefox"):b[1];a=a[0];var c;if(a&&(c=a[2])&&(c=/Trident\/([^\s;]+)/.exec(c)))return c[1]}return ""};
	goog$1.labs.userAgent.engine.getEngineTuple_=function(a){if(!goog$1.labs.userAgent.engine.isEdge())return a[1];for(var b=0;b<a.length;b++){var c=a[b];if("Edge"==c[0])return c}};goog$1.labs.userAgent.engine.isVersionOrHigher=function(a){return 0<=goog$1.string.compareVersions(goog$1.labs.userAgent.engine.getVersion(),a)};goog$1.labs.userAgent.engine.getVersionForKey_=function(a,b){return (a=goog$1.array.find(a,function(a){return b==a[0]}))&&a[1]||""};goog$1.userAgent={};goog$1.userAgent.ASSUME_IE=!1;goog$1.userAgent.ASSUME_EDGE=!1;goog$1.userAgent.ASSUME_GECKO=!1;goog$1.userAgent.ASSUME_WEBKIT=!1;goog$1.userAgent.ASSUME_MOBILE_WEBKIT=!1;goog$1.userAgent.ASSUME_OPERA=!1;goog$1.userAgent.ASSUME_ANY_VERSION=!1;goog$1.userAgent.BROWSER_KNOWN_=goog$1.userAgent.ASSUME_IE||goog$1.userAgent.ASSUME_EDGE||goog$1.userAgent.ASSUME_GECKO||goog$1.userAgent.ASSUME_MOBILE_WEBKIT||goog$1.userAgent.ASSUME_WEBKIT||goog$1.userAgent.ASSUME_OPERA;goog$1.userAgent.getUserAgentString=function(){return goog$1.labs.userAgent.util.getUserAgent()};
	goog$1.userAgent.getNavigatorTyped=function(){return goog$1.global.navigator||null};goog$1.userAgent.getNavigator=function(){return goog$1.userAgent.getNavigatorTyped()};goog$1.userAgent.OPERA=goog$1.userAgent.BROWSER_KNOWN_?goog$1.userAgent.ASSUME_OPERA:goog$1.labs.userAgent.browser.isOpera();goog$1.userAgent.IE=goog$1.userAgent.BROWSER_KNOWN_?goog$1.userAgent.ASSUME_IE:goog$1.labs.userAgent.browser.isIE();goog$1.userAgent.EDGE=goog$1.userAgent.BROWSER_KNOWN_?goog$1.userAgent.ASSUME_EDGE:goog$1.labs.userAgent.engine.isEdge();
	goog$1.userAgent.EDGE_OR_IE=goog$1.userAgent.EDGE||goog$1.userAgent.IE;goog$1.userAgent.GECKO=goog$1.userAgent.BROWSER_KNOWN_?goog$1.userAgent.ASSUME_GECKO:goog$1.labs.userAgent.engine.isGecko();goog$1.userAgent.WEBKIT=goog$1.userAgent.BROWSER_KNOWN_?goog$1.userAgent.ASSUME_WEBKIT||goog$1.userAgent.ASSUME_MOBILE_WEBKIT:goog$1.labs.userAgent.engine.isWebKit();goog$1.userAgent.isMobile_=function(){return goog$1.userAgent.WEBKIT&&goog$1.labs.userAgent.util.matchUserAgent("Mobile")};
	goog$1.userAgent.MOBILE=goog$1.userAgent.ASSUME_MOBILE_WEBKIT||goog$1.userAgent.isMobile_();goog$1.userAgent.SAFARI=goog$1.userAgent.WEBKIT;goog$1.userAgent.determinePlatform_=function(){var a=goog$1.userAgent.getNavigatorTyped();return a&&a.platform||""};goog$1.userAgent.PLATFORM=goog$1.userAgent.determinePlatform_();goog$1.userAgent.ASSUME_MAC=!1;goog$1.userAgent.ASSUME_WINDOWS=!1;goog$1.userAgent.ASSUME_LINUX=!1;goog$1.userAgent.ASSUME_X11=!1;goog$1.userAgent.ASSUME_ANDROID=!1;goog$1.userAgent.ASSUME_IPHONE=!1;
	goog$1.userAgent.ASSUME_IPAD=!1;goog$1.userAgent.ASSUME_IPOD=!1;goog$1.userAgent.ASSUME_KAIOS=!1;goog$1.userAgent.ASSUME_GO2PHONE=!1;goog$1.userAgent.PLATFORM_KNOWN_=goog$1.userAgent.ASSUME_MAC||goog$1.userAgent.ASSUME_WINDOWS||goog$1.userAgent.ASSUME_LINUX||goog$1.userAgent.ASSUME_X11||goog$1.userAgent.ASSUME_ANDROID||goog$1.userAgent.ASSUME_IPHONE||goog$1.userAgent.ASSUME_IPAD||goog$1.userAgent.ASSUME_IPOD;goog$1.userAgent.MAC=goog$1.userAgent.PLATFORM_KNOWN_?goog$1.userAgent.ASSUME_MAC:goog$1.labs.userAgent.platform.isMacintosh();
	goog$1.userAgent.WINDOWS=goog$1.userAgent.PLATFORM_KNOWN_?goog$1.userAgent.ASSUME_WINDOWS:goog$1.labs.userAgent.platform.isWindows();goog$1.userAgent.isLegacyLinux_=function(){return goog$1.labs.userAgent.platform.isLinux()||goog$1.labs.userAgent.platform.isChromeOS()};goog$1.userAgent.LINUX=goog$1.userAgent.PLATFORM_KNOWN_?goog$1.userAgent.ASSUME_LINUX:goog$1.userAgent.isLegacyLinux_();goog$1.userAgent.isX11_=function(){var a=goog$1.userAgent.getNavigatorTyped();return !!a&&goog$1.string.contains(a.appVersion||"","X11")};
	goog$1.userAgent.X11=goog$1.userAgent.PLATFORM_KNOWN_?goog$1.userAgent.ASSUME_X11:goog$1.userAgent.isX11_();goog$1.userAgent.ANDROID=goog$1.userAgent.PLATFORM_KNOWN_?goog$1.userAgent.ASSUME_ANDROID:goog$1.labs.userAgent.platform.isAndroid();goog$1.userAgent.IPHONE=goog$1.userAgent.PLATFORM_KNOWN_?goog$1.userAgent.ASSUME_IPHONE:goog$1.labs.userAgent.platform.isIphone();goog$1.userAgent.IPAD=goog$1.userAgent.PLATFORM_KNOWN_?goog$1.userAgent.ASSUME_IPAD:goog$1.labs.userAgent.platform.isIpad();
	goog$1.userAgent.IPOD=goog$1.userAgent.PLATFORM_KNOWN_?goog$1.userAgent.ASSUME_IPOD:goog$1.labs.userAgent.platform.isIpod();goog$1.userAgent.IOS=goog$1.userAgent.PLATFORM_KNOWN_?goog$1.userAgent.ASSUME_IPHONE||goog$1.userAgent.ASSUME_IPAD||goog$1.userAgent.ASSUME_IPOD:goog$1.labs.userAgent.platform.isIos();goog$1.userAgent.KAIOS=goog$1.userAgent.PLATFORM_KNOWN_?goog$1.userAgent.ASSUME_KAIOS:goog$1.labs.userAgent.platform.isKaiOS();goog$1.userAgent.GO2PHONE=goog$1.userAgent.PLATFORM_KNOWN_?goog$1.userAgent.ASSUME_GO2PHONE:goog$1.labs.userAgent.platform.isGo2Phone();
	goog$1.userAgent.determineVersion_=function(){var a="",b=goog$1.userAgent.getVersionRegexResult_();b&&(a=b?b[1]:"");return goog$1.userAgent.IE&&(b=goog$1.userAgent.getDocumentMode_(),null!=b&&b>parseFloat(a))?String(b):a};
	goog$1.userAgent.getVersionRegexResult_=function(){var a=goog$1.userAgent.getUserAgentString();if(goog$1.userAgent.GECKO)return /rv:([^\);]+)(\)|;)/.exec(a);if(goog$1.userAgent.EDGE)return /Edge\/([\d\.]+)/.exec(a);if(goog$1.userAgent.IE)return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(goog$1.userAgent.WEBKIT)return /WebKit\/(\S+)/.exec(a);if(goog$1.userAgent.OPERA)return /(?:Version)[ \/]?(\S+)/.exec(a)};goog$1.userAgent.getDocumentMode_=function(){var a=goog$1.global.document;return a?a.documentMode:void 0};
	goog$1.userAgent.VERSION=goog$1.userAgent.determineVersion_();goog$1.userAgent.compare=function(a,b){return goog$1.string.compareVersions(a,b)};goog$1.userAgent.isVersionOrHigherCache_={};goog$1.userAgent.isVersionOrHigher=function(a){return goog$1.userAgent.ASSUME_ANY_VERSION||goog$1.reflect.cache(goog$1.userAgent.isVersionOrHigherCache_,a,function(){return 0<=goog$1.string.compareVersions(goog$1.userAgent.VERSION,a)})};goog$1.userAgent.isVersion=goog$1.userAgent.isVersionOrHigher;
	goog$1.userAgent.isDocumentModeOrHigher=function(a){return Number(goog$1.userAgent.DOCUMENT_MODE)>=a};goog$1.userAgent.isDocumentMode=goog$1.userAgent.isDocumentModeOrHigher;goog$1.userAgent.DOCUMENT_MODE=function(){if(goog$1.global.document&&goog$1.userAgent.IE)return goog$1.userAgent.getDocumentMode_()}();goog$1.userAgent.product={};goog$1.userAgent.product.ASSUME_FIREFOX=!1;goog$1.userAgent.product.ASSUME_IPHONE=!1;goog$1.userAgent.product.ASSUME_IPAD=!1;goog$1.userAgent.product.ASSUME_ANDROID=!1;goog$1.userAgent.product.ASSUME_CHROME=!1;goog$1.userAgent.product.ASSUME_SAFARI=!1;
	goog$1.userAgent.product.PRODUCT_KNOWN_=goog$1.userAgent.ASSUME_IE||goog$1.userAgent.ASSUME_EDGE||goog$1.userAgent.ASSUME_OPERA||goog$1.userAgent.product.ASSUME_FIREFOX||goog$1.userAgent.product.ASSUME_IPHONE||goog$1.userAgent.product.ASSUME_IPAD||goog$1.userAgent.product.ASSUME_ANDROID||goog$1.userAgent.product.ASSUME_CHROME||goog$1.userAgent.product.ASSUME_SAFARI;goog$1.userAgent.product.OPERA=goog$1.userAgent.OPERA;goog$1.userAgent.product.IE=goog$1.userAgent.IE;goog$1.userAgent.product.EDGE=goog$1.userAgent.EDGE;
	goog$1.userAgent.product.FIREFOX=goog$1.userAgent.product.PRODUCT_KNOWN_?goog$1.userAgent.product.ASSUME_FIREFOX:goog$1.labs.userAgent.browser.isFirefox();goog$1.userAgent.product.isIphoneOrIpod_=function(){return goog$1.labs.userAgent.platform.isIphone()||goog$1.labs.userAgent.platform.isIpod()};goog$1.userAgent.product.IPHONE=goog$1.userAgent.product.PRODUCT_KNOWN_?goog$1.userAgent.product.ASSUME_IPHONE:goog$1.userAgent.product.isIphoneOrIpod_();
	goog$1.userAgent.product.IPAD=goog$1.userAgent.product.PRODUCT_KNOWN_?goog$1.userAgent.product.ASSUME_IPAD:goog$1.labs.userAgent.platform.isIpad();goog$1.userAgent.product.ANDROID=goog$1.userAgent.product.PRODUCT_KNOWN_?goog$1.userAgent.product.ASSUME_ANDROID:goog$1.labs.userAgent.browser.isAndroidBrowser();goog$1.userAgent.product.CHROME=goog$1.userAgent.product.PRODUCT_KNOWN_?goog$1.userAgent.product.ASSUME_CHROME:goog$1.labs.userAgent.browser.isChrome();
	goog$1.userAgent.product.isSafariDesktop_=function(){return goog$1.labs.userAgent.browser.isSafari()&&!goog$1.labs.userAgent.platform.isIos()};goog$1.userAgent.product.SAFARI=goog$1.userAgent.product.PRODUCT_KNOWN_?goog$1.userAgent.product.ASSUME_SAFARI:goog$1.userAgent.product.isSafariDesktop_();goog$1.crypt.base64={};goog$1.crypt.base64.DEFAULT_ALPHABET_COMMON_="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";goog$1.crypt.base64.ENCODED_VALS=goog$1.crypt.base64.DEFAULT_ALPHABET_COMMON_+"+/=";goog$1.crypt.base64.ENCODED_VALS_WEBSAFE=goog$1.crypt.base64.DEFAULT_ALPHABET_COMMON_+"-_.";goog$1.crypt.base64.Alphabet={DEFAULT:0,NO_PADDING:1,WEBSAFE:2,WEBSAFE_DOT_PADDING:3,WEBSAFE_NO_PADDING:4};goog$1.crypt.base64.paddingChars_="=.";
	goog$1.crypt.base64.isPadding_=function(a){return goog$1.string.contains(goog$1.crypt.base64.paddingChars_,a)};goog$1.crypt.base64.byteToCharMaps_={};goog$1.crypt.base64.charToByteMap_=null;goog$1.crypt.base64.ASSUME_NATIVE_SUPPORT_=goog$1.userAgent.GECKO||goog$1.userAgent.WEBKIT&&!goog$1.userAgent.product.SAFARI||goog$1.userAgent.OPERA;goog$1.crypt.base64.HAS_NATIVE_ENCODE_=goog$1.crypt.base64.ASSUME_NATIVE_SUPPORT_||"function"==typeof goog$1.global.btoa;
	goog$1.crypt.base64.HAS_NATIVE_DECODE_=goog$1.crypt.base64.ASSUME_NATIVE_SUPPORT_||!goog$1.userAgent.product.SAFARI&&!goog$1.userAgent.IE&&"function"==typeof goog$1.global.atob;
	goog$1.crypt.base64.encodeByteArray=function(a,b){goog$1.asserts.assert(goog$1.isArrayLike(a),"encodeByteArray takes an array as a parameter");void 0===b&&(b=goog$1.crypt.base64.Alphabet.DEFAULT);goog$1.crypt.base64.init_();b=goog$1.crypt.base64.byteToCharMaps_[b];for(var c=[],d=0;d<a.length;d+=3){var e=a[d],f=d+1<a.length,g=f?a[d+1]:0,h=d+2<a.length,k=h?a[d+2]:0,l=e>>2;e=(e&3)<<4|g>>4;g=(g&15)<<2|k>>6;k&=63;h||(k=64,f||(g=64));c.push(b[l],b[e],b[g]||"",b[k]||"");}return c.join("")};
	goog$1.crypt.base64.encodeString=function(a,b){return goog$1.crypt.base64.HAS_NATIVE_ENCODE_&&!b?goog$1.global.btoa(a):goog$1.crypt.base64.encodeByteArray(goog$1.crypt.stringToByteArray(a),b)};goog$1.crypt.base64.decodeString=function(a,b){if(goog$1.crypt.base64.HAS_NATIVE_DECODE_&&!b)return goog$1.global.atob(a);var c="";goog$1.crypt.base64.decodeStringInternal_(a,function(a){c+=String.fromCharCode(a);});return c};
	goog$1.crypt.base64.decodeStringToByteArray=function(a,b){var c=[];goog$1.crypt.base64.decodeStringInternal_(a,function(a){c.push(a);});return c};
	goog$1.crypt.base64.decodeStringToUint8Array=function(a){goog$1.asserts.assert(!goog$1.userAgent.IE||goog$1.userAgent.isVersionOrHigher("10"),"Browser does not support typed arrays");var b=a.length,c=3*b/4;c%3?c=Math.floor(c):goog$1.crypt.base64.isPadding_(a[b-1])&&(c=goog$1.crypt.base64.isPadding_(a[b-2])?c-2:c-1);var d=new Uint8Array(c),e=0;goog$1.crypt.base64.decodeStringInternal_(a,function(a){d[e++]=a;});return d.subarray(0,e)};
	goog$1.crypt.base64.decodeStringInternal_=function(a,b){function c(b){for(;d<a.length;){var c=a.charAt(d++),e=goog$1.crypt.base64.charToByteMap_[c];if(null!=e)return e;if(!goog$1.string.isEmptyOrWhitespace(c))throw Error("Unknown base64 encoding at char: "+c);}return b}goog$1.crypt.base64.init_();for(var d=0;;){var e=c(-1),f=c(0),g=c(64),h=c(64);if(64===h&&-1===e)break;b(e<<2|f>>4);64!=g&&(b(f<<4&240|g>>2),64!=h&&b(g<<6&192|h));}};
	goog$1.crypt.base64.init_=function(){if(!goog$1.crypt.base64.charToByteMap_){goog$1.crypt.base64.charToByteMap_={};for(var a=goog$1.crypt.base64.DEFAULT_ALPHABET_COMMON_.split(""),b=["+/=","+/","-_=","-_.","-_"],c=0;5>c;c++){var d=a.concat(b[c].split(""));goog$1.crypt.base64.byteToCharMaps_[c]=d;for(var e=0;e<d.length;e++){var f=d[e],g=goog$1.crypt.base64.charToByteMap_[f];void 0===g?goog$1.crypt.base64.charToByteMap_[f]=e:goog$1.asserts.assert(g===e);}}}};jspb$1.utils={};jspb$1.utils.split64Low=0;jspb$1.utils.split64High=0;jspb$1.utils.splitUint64=function(a){var b=a>>>0;a=Math.floor((a-b)/jspb$1.BinaryConstants.TWO_TO_32)>>>0;jspb$1.utils.split64Low=b;jspb$1.utils.split64High=a;};jspb$1.utils.splitInt64=function(a){var b=0>a;a=Math.abs(a);var c=a>>>0;a=Math.floor((a-c)/jspb$1.BinaryConstants.TWO_TO_32);a>>>=0;b&&(a=~a>>>0,c=(~c>>>0)+1,4294967295<c&&(c=0,a++,4294967295<a&&(a=0)));jspb$1.utils.split64Low=c;jspb$1.utils.split64High=a;};
	jspb$1.utils.splitZigzag64=function(a){var b=0>a;a=2*Math.abs(a);jspb$1.utils.splitUint64(a);a=jspb$1.utils.split64Low;var c=jspb$1.utils.split64High;b&&(0==a?0==c?c=a=4294967295:(c--,a=4294967295):a--);jspb$1.utils.split64Low=a;jspb$1.utils.split64High=c;};
	jspb$1.utils.splitFloat32=function(a){var b=0>a?1:0;a=b?-a:a;if(0===a)0<1/a?(jspb$1.utils.split64High=0,jspb$1.utils.split64Low=0):(jspb$1.utils.split64High=0,jspb$1.utils.split64Low=2147483648);else if(isNaN(a))jspb$1.utils.split64High=0,jspb$1.utils.split64Low=2147483647;else if(a>jspb$1.BinaryConstants.FLOAT32_MAX)jspb$1.utils.split64High=0,jspb$1.utils.split64Low=(b<<31|2139095040)>>>0;else if(a<jspb$1.BinaryConstants.FLOAT32_MIN)a=Math.round(a/Math.pow(2,-149)),jspb$1.utils.split64High=0,jspb$1.utils.split64Low=(b<<31|
	a)>>>0;else {var c=Math.floor(Math.log(a)/Math.LN2);a*=Math.pow(2,-c);a=Math.round(a*jspb$1.BinaryConstants.TWO_TO_23)&8388607;jspb$1.utils.split64High=0;jspb$1.utils.split64Low=(b<<31|c+127<<23|a)>>>0;}};
	jspb$1.utils.splitFloat64=function(a){var b=0>a?1:0;a=b?-a:a;if(0===a)jspb$1.utils.split64High=0<1/a?0:2147483648,jspb$1.utils.split64Low=0;else if(isNaN(a))jspb$1.utils.split64High=2147483647,jspb$1.utils.split64Low=4294967295;else if(a>jspb$1.BinaryConstants.FLOAT64_MAX)jspb$1.utils.split64High=(b<<31|2146435072)>>>0,jspb$1.utils.split64Low=0;else if(a<jspb$1.BinaryConstants.FLOAT64_MIN){var c=a/Math.pow(2,-1074);a=c/jspb$1.BinaryConstants.TWO_TO_32;jspb$1.utils.split64High=(b<<31|a)>>>0;jspb$1.utils.split64Low=c>>>0;}else {var d=
	Math.floor(Math.log(a)/Math.LN2);1024==d&&(d=1023);c=a*Math.pow(2,-d);a=c*jspb$1.BinaryConstants.TWO_TO_20&1048575;c=c*jspb$1.BinaryConstants.TWO_TO_52>>>0;jspb$1.utils.split64High=(b<<31|d+1023<<20|a)>>>0;jspb$1.utils.split64Low=c;}};
	jspb$1.utils.splitHash64=function(a){var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=a.charCodeAt(4),g=a.charCodeAt(5),h=a.charCodeAt(6);a=a.charCodeAt(7);jspb$1.utils.split64Low=b+(c<<8)+(d<<16)+(e<<24)>>>0;jspb$1.utils.split64High=f+(g<<8)+(h<<16)+(a<<24)>>>0;};jspb$1.utils.joinUint64=function(a,b){return b*jspb$1.BinaryConstants.TWO_TO_32+(a>>>0)};
	jspb$1.utils.joinInt64=function(a,b){var c=b&2147483648;c&&(a=~a+1>>>0,b=~b>>>0,0==a&&(b=b+1>>>0));a=jspb$1.utils.joinUint64(a,b);return c?-a:a};jspb$1.utils.toZigzag64=function(a,b,c){var d=b>>31;return c(a<<1^d,(b<<1|a>>>31)^d)};jspb$1.utils.joinZigzag64=function(a,b){return jspb$1.utils.fromZigzag64(a,b,jspb$1.utils.joinInt64)};jspb$1.utils.fromZigzag64=function(a,b,c){var d=-(a&1);return c((a>>>1|b<<31)^d,b>>>1^d)};
	jspb$1.utils.joinFloat32=function(a,b){b=2*(a>>31)+1;var c=a>>>23&255;a&=8388607;return 255==c?a?NaN:Infinity*b:0==c?b*Math.pow(2,-149)*a:b*Math.pow(2,c-150)*(a+Math.pow(2,23))};jspb$1.utils.joinFloat64=function(a,b){var c=2*(b>>31)+1,d=b>>>20&2047;a=jspb$1.BinaryConstants.TWO_TO_32*(b&1048575)+a;return 2047==d?a?NaN:Infinity*c:0==d?c*Math.pow(2,-1074)*a:c*Math.pow(2,d-1075)*(a+jspb$1.BinaryConstants.TWO_TO_52)};
	jspb$1.utils.joinHash64=function(a,b){return String.fromCharCode(a>>>0&255,a>>>8&255,a>>>16&255,a>>>24&255,b>>>0&255,b>>>8&255,b>>>16&255,b>>>24&255)};jspb$1.utils.DIGITS="0123456789abcdef".split("");jspb$1.utils.ZERO_CHAR_CODE_=48;jspb$1.utils.A_CHAR_CODE_=97;
	jspb$1.utils.joinUnsignedDecimalString=function(a,b){function c(a,b){a=a?String(a):"";return b?"0000000".slice(a.length)+a:a}if(2097151>=b)return ""+(jspb$1.BinaryConstants.TWO_TO_32*b+a);var d=(a>>>24|b<<8)>>>0&16777215;b=b>>16&65535;a=(a&16777215)+6777216*d+6710656*b;d+=8147497*b;b*=2;1E7<=a&&(d+=Math.floor(a/1E7),a%=1E7);1E7<=d&&(b+=Math.floor(d/1E7),d%=1E7);return c(b,0)+c(d,b)+c(a,1)};
	jspb$1.utils.joinSignedDecimalString=function(a,b){var c=b&2147483648;c&&(a=~a+1>>>0,b=~b+(0==a?1:0)>>>0);a=jspb$1.utils.joinUnsignedDecimalString(a,b);return c?"-"+a:a};jspb$1.utils.hash64ToDecimalString=function(a,b){jspb$1.utils.splitHash64(a);a=jspb$1.utils.split64Low;var c=jspb$1.utils.split64High;return b?jspb$1.utils.joinSignedDecimalString(a,c):jspb$1.utils.joinUnsignedDecimalString(a,c)};
	jspb$1.utils.hash64ArrayToDecimalStrings=function(a,b){for(var c=Array(a.length),d=0;d<a.length;d++)c[d]=jspb$1.utils.hash64ToDecimalString(a[d],b);return c};
	jspb$1.utils.decimalStringToHash64=function(a){function b(a,b){for(var c=0;8>c&&(1!==a||0<b);c++)b=a*e[c]+b,e[c]=b&255,b>>>=8;}function c(){for(var a=0;8>a;a++)e[a]=~e[a]&255;}goog$1.asserts.assert(0<a.length);var d=!1;"-"===a[0]&&(d=!0,a=a.slice(1));for(var e=[0,0,0,0,0,0,0,0],f=0;f<a.length;f++)b(10,a.charCodeAt(f)-jspb$1.utils.ZERO_CHAR_CODE_);d&&(c(),b(1,1));return goog$1.crypt.byteArrayToString(e)};jspb$1.utils.splitDecimalString=function(a){jspb$1.utils.splitHash64(jspb$1.utils.decimalStringToHash64(a));};
	jspb$1.utils.toHexDigit_=function(a){return String.fromCharCode(10>a?jspb$1.utils.ZERO_CHAR_CODE_+a:jspb$1.utils.A_CHAR_CODE_-10+a)};jspb$1.utils.fromHexCharCode_=function(a){return a>=jspb$1.utils.A_CHAR_CODE_?a-jspb$1.utils.A_CHAR_CODE_+10:a-jspb$1.utils.ZERO_CHAR_CODE_};jspb$1.utils.hash64ToHexString=function(a){var b=Array(18);b[0]="0";b[1]="x";for(var c=0;8>c;c++){var d=a.charCodeAt(7-c);b[2*c+2]=jspb$1.utils.toHexDigit_(d>>4);b[2*c+3]=jspb$1.utils.toHexDigit_(d&15);}return b.join("")};
	jspb$1.utils.hexStringToHash64=function(a){a=a.toLowerCase();goog$1.asserts.assert(18==a.length);goog$1.asserts.assert("0"==a[0]);goog$1.asserts.assert("x"==a[1]);for(var b="",c=0;8>c;c++){var d=jspb$1.utils.fromHexCharCode_(a.charCodeAt(2*c+2)),e=jspb$1.utils.fromHexCharCode_(a.charCodeAt(2*c+3));b=String.fromCharCode(16*d+e)+b;}return b};
	jspb$1.utils.hash64ToNumber=function(a,b){jspb$1.utils.splitHash64(a);a=jspb$1.utils.split64Low;var c=jspb$1.utils.split64High;return b?jspb$1.utils.joinInt64(a,c):jspb$1.utils.joinUint64(a,c)};jspb$1.utils.numberToHash64=function(a){jspb$1.utils.splitInt64(a);return jspb$1.utils.joinHash64(jspb$1.utils.split64Low,jspb$1.utils.split64High)};jspb$1.utils.countVarints=function(a,b,c){for(var d=0,e=b;e<c;e++)d+=a[e]>>7;return c-b-d};
	jspb$1.utils.countVarintFields=function(a,b,c,d){var e=0;d=8*d+jspb$1.BinaryConstants.WireType.VARINT;if(128>d)for(;b<c&&a[b++]==d;)for(e++;;){var f=a[b++];if(0==(f&128))break}else for(;b<c;){for(f=d;128<f;){if(a[b]!=(f&127|128))return e;b++;f>>=7;}if(a[b++]!=f)break;for(e++;f=a[b++],0!=(f&128););}return e};jspb$1.utils.countFixedFields_=function(a,b,c,d,e){var f=0;if(128>d)for(;b<c&&a[b++]==d;)f++,b+=e;else for(;b<c;){for(var g=d;128<g;){if(a[b++]!=(g&127|128))return f;g>>=7;}if(a[b++]!=g)break;f++;b+=e;}return f};
	jspb$1.utils.countFixed32Fields=function(a,b,c,d){return jspb$1.utils.countFixedFields_(a,b,c,8*d+jspb$1.BinaryConstants.WireType.FIXED32,4)};jspb$1.utils.countFixed64Fields=function(a,b,c,d){return jspb$1.utils.countFixedFields_(a,b,c,8*d+jspb$1.BinaryConstants.WireType.FIXED64,8)};
	jspb$1.utils.countDelimitedFields=function(a,b,c,d){var e=0;for(d=8*d+jspb$1.BinaryConstants.WireType.DELIMITED;b<c;){for(var f=d;128<f;){if(a[b++]!=(f&127|128))return e;f>>=7;}if(a[b++]!=f)break;e++;for(var g=0,h=1;f=a[b++],g+=(f&127)*h,h*=128,0!=(f&128););b+=g;}return e};jspb$1.utils.debugBytesToTextFormat=function(a){var b='"';if(a){a=jspb$1.utils.byteSourceToUint8Array(a);for(var c=0;c<a.length;c++)b+="\\x",16>a[c]&&(b+="0"),b+=a[c].toString(16);}return b+'"'};
	jspb$1.utils.debugScalarToTextFormat=function(a){return goog$1.isString(a)?goog$1.string.quote(a):a.toString()};jspb$1.utils.stringToByteArray=function(a){for(var b=new Uint8Array(a.length),c=0;c<a.length;c++){var d=a.charCodeAt(c);if(255<d)throw Error("Conversion error: string contains codepoint outside of byte range");b[c]=d;}return b};
	jspb$1.utils.byteSourceToUint8Array=function(a){if(a.constructor===Uint8Array)return a;if(a.constructor===ArrayBuffer||"undefined"!=typeof Buffer$1&&a.constructor===Buffer$1||a.constructor===Array)return new Uint8Array(a);if(a.constructor===String)return goog$1.crypt.base64.decodeStringToUint8Array(a);goog$1.asserts.fail("Type not convertible to Uint8Array.");return new Uint8Array(0)};jspb$1.BinaryDecoder=function(a,b,c){this.bytes_=null;this.cursor_=this.end_=this.start_=0;this.error_=!1;a&&this.setBlock(a,b,c);};jspb$1.BinaryDecoder.instanceCache_=[];jspb$1.BinaryDecoder.alloc=function(a,b,c){if(jspb$1.BinaryDecoder.instanceCache_.length){var d=jspb$1.BinaryDecoder.instanceCache_.pop();a&&d.setBlock(a,b,c);return d}return new jspb$1.BinaryDecoder(a,b,c)};jspb$1.BinaryDecoder.prototype.free=function(){this.clear();100>jspb$1.BinaryDecoder.instanceCache_.length&&jspb$1.BinaryDecoder.instanceCache_.push(this);};
	jspb$1.BinaryDecoder.prototype.clone=function(){return jspb$1.BinaryDecoder.alloc(this.bytes_,this.start_,this.end_-this.start_)};jspb$1.BinaryDecoder.prototype.clear=function(){this.bytes_=null;this.cursor_=this.end_=this.start_=0;this.error_=!1;};jspb$1.BinaryDecoder.prototype.getBuffer=function(){return this.bytes_};
	jspb$1.BinaryDecoder.prototype.setBlock=function(a,b,c){this.bytes_=jspb$1.utils.byteSourceToUint8Array(a);this.start_=goog$1.isDef(b)?b:0;this.end_=goog$1.isDef(c)?this.start_+c:this.bytes_.length;this.cursor_=this.start_;};jspb$1.BinaryDecoder.prototype.getEnd=function(){return this.end_};jspb$1.BinaryDecoder.prototype.setEnd=function(a){this.end_=a;};jspb$1.BinaryDecoder.prototype.reset=function(){this.cursor_=this.start_;};jspb$1.BinaryDecoder.prototype.getCursor=function(){return this.cursor_};
	jspb$1.BinaryDecoder.prototype.setCursor=function(a){this.cursor_=a;};jspb$1.BinaryDecoder.prototype.advance=function(a){this.cursor_+=a;goog$1.asserts.assert(this.cursor_<=this.end_);};jspb$1.BinaryDecoder.prototype.atEnd=function(){return this.cursor_==this.end_};jspb$1.BinaryDecoder.prototype.pastEnd=function(){return this.cursor_>this.end_};jspb$1.BinaryDecoder.prototype.getError=function(){return this.error_||0>this.cursor_||this.cursor_>this.end_};
	jspb$1.BinaryDecoder.prototype.readSplitVarint64=function(a){for(var b=128,c=0,d=0,e=0;4>e&&128<=b;e++)b=this.bytes_[this.cursor_++],c|=(b&127)<<7*e;128<=b&&(b=this.bytes_[this.cursor_++],c|=(b&127)<<28,d|=(b&127)>>4);if(128<=b)for(e=0;5>e&&128<=b;e++)b=this.bytes_[this.cursor_++],d|=(b&127)<<7*e+3;if(128>b)return a(c>>>0,d>>>0);goog$1.asserts.fail("Failed to read varint, encoding is invalid.");this.error_=!0;};
	jspb$1.BinaryDecoder.prototype.readSplitZigzagVarint64=function(a){return this.readSplitVarint64(function(b,c){return jspb$1.utils.fromZigzag64(b,c,a)})};jspb$1.BinaryDecoder.prototype.readSplitFixed64=function(a){var b=this.bytes_,c=this.cursor_;this.cursor_+=8;for(var d=0,e=0,f=c+7;f>=c;f--)d=d<<8|b[f],e=e<<8|b[f+4];return a(d,e)};jspb$1.BinaryDecoder.prototype.skipVarint=function(){for(;this.bytes_[this.cursor_]&128;)this.cursor_++;this.cursor_++;};
	jspb$1.BinaryDecoder.prototype.unskipVarint=function(a){for(;128<a;)this.cursor_--,a>>>=7;this.cursor_--;};
	jspb$1.BinaryDecoder.prototype.readUnsignedVarint32=function(){var a=this.bytes_;var b=a[this.cursor_+0];var c=b&127;if(128>b)return this.cursor_+=1,goog$1.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+1];c|=(b&127)<<7;if(128>b)return this.cursor_+=2,goog$1.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+2];c|=(b&127)<<14;if(128>b)return this.cursor_+=3,goog$1.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+3];c|=(b&127)<<21;if(128>b)return this.cursor_+=4,goog$1.asserts.assert(this.cursor_<=
	this.end_),c;b=a[this.cursor_+4];c|=(b&15)<<28;if(128>b)return this.cursor_+=5,goog$1.asserts.assert(this.cursor_<=this.end_),c>>>0;this.cursor_+=5;128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&goog$1.asserts.assert(!1);goog$1.asserts.assert(this.cursor_<=this.end_);return c};jspb$1.BinaryDecoder.prototype.readSignedVarint32=jspb$1.BinaryDecoder.prototype.readUnsignedVarint32;jspb$1.BinaryDecoder.prototype.readUnsignedVarint32String=function(){return this.readUnsignedVarint32().toString()};
	jspb$1.BinaryDecoder.prototype.readSignedVarint32String=function(){return this.readSignedVarint32().toString()};jspb$1.BinaryDecoder.prototype.readZigzagVarint32=function(){var a=this.readUnsignedVarint32();return a>>>1^-(a&1)};jspb$1.BinaryDecoder.prototype.readUnsignedVarint64=function(){return this.readSplitVarint64(jspb$1.utils.joinUint64)};jspb$1.BinaryDecoder.prototype.readUnsignedVarint64String=function(){return this.readSplitVarint64(jspb$1.utils.joinUnsignedDecimalString)};
	jspb$1.BinaryDecoder.prototype.readSignedVarint64=function(){return this.readSplitVarint64(jspb$1.utils.joinInt64)};jspb$1.BinaryDecoder.prototype.readSignedVarint64String=function(){return this.readSplitVarint64(jspb$1.utils.joinSignedDecimalString)};jspb$1.BinaryDecoder.prototype.readZigzagVarint64=function(){return this.readSplitVarint64(jspb$1.utils.joinZigzag64)};jspb$1.BinaryDecoder.prototype.readZigzagVarintHash64=function(){return this.readSplitZigzagVarint64(jspb$1.utils.joinHash64)};
	jspb$1.BinaryDecoder.prototype.readZigzagVarint64String=function(){return this.readSplitZigzagVarint64(jspb$1.utils.joinSignedDecimalString)};jspb$1.BinaryDecoder.prototype.readUint8=function(){var a=this.bytes_[this.cursor_+0];this.cursor_+=1;goog$1.asserts.assert(this.cursor_<=this.end_);return a};jspb$1.BinaryDecoder.prototype.readUint16=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1];this.cursor_+=2;goog$1.asserts.assert(this.cursor_<=this.end_);return a<<0|b<<8};
	jspb$1.BinaryDecoder.prototype.readUint32=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1],c=this.bytes_[this.cursor_+2],d=this.bytes_[this.cursor_+3];this.cursor_+=4;goog$1.asserts.assert(this.cursor_<=this.end_);return (a<<0|b<<8|c<<16|d<<24)>>>0};jspb$1.BinaryDecoder.prototype.readUint64=function(){var a=this.readUint32(),b=this.readUint32();return jspb$1.utils.joinUint64(a,b)};
	jspb$1.BinaryDecoder.prototype.readUint64String=function(){var a=this.readUint32(),b=this.readUint32();return jspb$1.utils.joinUnsignedDecimalString(a,b)};jspb$1.BinaryDecoder.prototype.readInt8=function(){var a=this.bytes_[this.cursor_+0];this.cursor_+=1;goog$1.asserts.assert(this.cursor_<=this.end_);return a<<24>>24};
	jspb$1.BinaryDecoder.prototype.readInt16=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1];this.cursor_+=2;goog$1.asserts.assert(this.cursor_<=this.end_);return (a<<0|b<<8)<<16>>16};jspb$1.BinaryDecoder.prototype.readInt32=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1],c=this.bytes_[this.cursor_+2],d=this.bytes_[this.cursor_+3];this.cursor_+=4;goog$1.asserts.assert(this.cursor_<=this.end_);return a<<0|b<<8|c<<16|d<<24};
	jspb$1.BinaryDecoder.prototype.readInt64=function(){var a=this.readUint32(),b=this.readUint32();return jspb$1.utils.joinInt64(a,b)};jspb$1.BinaryDecoder.prototype.readInt64String=function(){var a=this.readUint32(),b=this.readUint32();return jspb$1.utils.joinSignedDecimalString(a,b)};jspb$1.BinaryDecoder.prototype.readFloat=function(){var a=this.readUint32();return jspb$1.utils.joinFloat32(a,0)};
	jspb$1.BinaryDecoder.prototype.readDouble=function(){var a=this.readUint32(),b=this.readUint32();return jspb$1.utils.joinFloat64(a,b)};jspb$1.BinaryDecoder.prototype.readBool=function(){return !!this.bytes_[this.cursor_++]};jspb$1.BinaryDecoder.prototype.readEnum=function(){return this.readSignedVarint32()};
	jspb$1.BinaryDecoder.prototype.readString=function(a){var b=this.bytes_,c=this.cursor_;a=c+a;for(var d=[],e="";c<a;){var f=b[c++];if(128>f)d.push(f);else if(192>f)continue;else if(224>f){var g=b[c++];d.push((f&31)<<6|g&63);}else if(240>f){g=b[c++];var h=b[c++];d.push((f&15)<<12|(g&63)<<6|h&63);}else if(248>f){g=b[c++];h=b[c++];var k=b[c++];f=(f&7)<<18|(g&63)<<12|(h&63)<<6|k&63;f-=65536;d.push((f>>10&1023)+55296,(f&1023)+56320);}8192<=d.length&&(e+=String.fromCharCode.apply(null,d),d.length=0);}e+=goog$1.crypt.byteArrayToString(d);
	this.cursor_=c;return e};jspb$1.BinaryDecoder.prototype.readStringWithLength=function(){var a=this.readUnsignedVarint32();return this.readString(a)};jspb$1.BinaryDecoder.prototype.readBytes=function(a){if(0>a||this.cursor_+a>this.bytes_.length)return this.error_=!0,goog$1.asserts.fail("Invalid byte length!"),new Uint8Array(0);var b=this.bytes_.subarray(this.cursor_,this.cursor_+a);this.cursor_+=a;goog$1.asserts.assert(this.cursor_<=this.end_);return b};jspb$1.BinaryDecoder.prototype.readVarintHash64=function(){return this.readSplitVarint64(jspb$1.utils.joinHash64)};
	jspb$1.BinaryDecoder.prototype.readFixedHash64=function(){var a=this.bytes_,b=this.cursor_,c=a[b+0],d=a[b+1],e=a[b+2],f=a[b+3],g=a[b+4],h=a[b+5],k=a[b+6];a=a[b+7];this.cursor_+=8;return String.fromCharCode(c,d,e,f,g,h,k,a)};jspb$1.BinaryReader=function(a,b,c){this.decoder_=jspb$1.BinaryDecoder.alloc(a,b,c);this.fieldCursor_=this.decoder_.getCursor();this.nextField_=jspb$1.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb$1.BinaryConstants.WireType.INVALID;this.error_=!1;this.readCallbacks_=null;};jspb$1.BinaryReader.instanceCache_=[];
	jspb$1.BinaryReader.alloc=function(a,b,c){if(jspb$1.BinaryReader.instanceCache_.length){var d=jspb$1.BinaryReader.instanceCache_.pop();a&&d.decoder_.setBlock(a,b,c);return d}return new jspb$1.BinaryReader(a,b,c)};jspb$1.BinaryReader.prototype.alloc=jspb$1.BinaryReader.alloc;
	jspb$1.BinaryReader.prototype.free=function(){this.decoder_.clear();this.nextField_=jspb$1.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb$1.BinaryConstants.WireType.INVALID;this.error_=!1;this.readCallbacks_=null;100>jspb$1.BinaryReader.instanceCache_.length&&jspb$1.BinaryReader.instanceCache_.push(this);};jspb$1.BinaryReader.prototype.getFieldCursor=function(){return this.fieldCursor_};jspb$1.BinaryReader.prototype.getCursor=function(){return this.decoder_.getCursor()};
	jspb$1.BinaryReader.prototype.getBuffer=function(){return this.decoder_.getBuffer()};jspb$1.BinaryReader.prototype.getFieldNumber=function(){return this.nextField_};jspb$1.BinaryReader.prototype.getWireType=function(){return this.nextWireType_};jspb$1.BinaryReader.prototype.isEndGroup=function(){return this.nextWireType_==jspb$1.BinaryConstants.WireType.END_GROUP};jspb$1.BinaryReader.prototype.getError=function(){return this.error_||this.decoder_.getError()};
	jspb$1.BinaryReader.prototype.setBlock=function(a,b,c){this.decoder_.setBlock(a,b,c);this.nextField_=jspb$1.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb$1.BinaryConstants.WireType.INVALID;};jspb$1.BinaryReader.prototype.reset=function(){this.decoder_.reset();this.nextField_=jspb$1.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb$1.BinaryConstants.WireType.INVALID;};jspb$1.BinaryReader.prototype.advance=function(a){this.decoder_.advance(a);};
	jspb$1.BinaryReader.prototype.nextField=function(){if(this.decoder_.atEnd())return !1;if(this.getError())return goog$1.asserts.fail("Decoder hit an error"),!1;this.fieldCursor_=this.decoder_.getCursor();var a=this.decoder_.readUnsignedVarint32(),b=a>>>3;a&=7;if(a!=jspb$1.BinaryConstants.WireType.VARINT&&a!=jspb$1.BinaryConstants.WireType.FIXED32&&a!=jspb$1.BinaryConstants.WireType.FIXED64&&a!=jspb$1.BinaryConstants.WireType.DELIMITED&&a!=jspb$1.BinaryConstants.WireType.START_GROUP&&a!=jspb$1.BinaryConstants.WireType.END_GROUP)return goog$1.asserts.fail("Invalid wire type: %s (at position %s)",
	a,this.fieldCursor_),this.error_=!0,!1;this.nextField_=b;this.nextWireType_=a;return !0};jspb$1.BinaryReader.prototype.unskipHeader=function(){this.decoder_.unskipVarint(this.nextField_<<3|this.nextWireType_);};jspb$1.BinaryReader.prototype.skipMatchingFields=function(){var a=this.nextField_;for(this.unskipHeader();this.nextField()&&this.getFieldNumber()==a;)this.skipField();this.decoder_.atEnd()||this.unskipHeader();};
	jspb$1.BinaryReader.prototype.skipVarintField=function(){this.nextWireType_!=jspb$1.BinaryConstants.WireType.VARINT?(goog$1.asserts.fail("Invalid wire type for skipVarintField"),this.skipField()):this.decoder_.skipVarint();};jspb$1.BinaryReader.prototype.skipDelimitedField=function(){if(this.nextWireType_!=jspb$1.BinaryConstants.WireType.DELIMITED)goog$1.asserts.fail("Invalid wire type for skipDelimitedField"),this.skipField();else {var a=this.decoder_.readUnsignedVarint32();this.decoder_.advance(a);}};
	jspb$1.BinaryReader.prototype.skipFixed32Field=function(){this.nextWireType_!=jspb$1.BinaryConstants.WireType.FIXED32?(goog$1.asserts.fail("Invalid wire type for skipFixed32Field"),this.skipField()):this.decoder_.advance(4);};jspb$1.BinaryReader.prototype.skipFixed64Field=function(){this.nextWireType_!=jspb$1.BinaryConstants.WireType.FIXED64?(goog$1.asserts.fail("Invalid wire type for skipFixed64Field"),this.skipField()):this.decoder_.advance(8);};
	jspb$1.BinaryReader.prototype.skipGroup=function(){var a=this.nextField_;do{if(!this.nextField()){goog$1.asserts.fail("Unmatched start-group tag: stream EOF");this.error_=!0;break}if(this.nextWireType_==jspb$1.BinaryConstants.WireType.END_GROUP){this.nextField_!=a&&(goog$1.asserts.fail("Unmatched end-group tag"),this.error_=!0);break}this.skipField();}while(1)};
	jspb$1.BinaryReader.prototype.skipField=function(){switch(this.nextWireType_){case jspb$1.BinaryConstants.WireType.VARINT:this.skipVarintField();break;case jspb$1.BinaryConstants.WireType.FIXED64:this.skipFixed64Field();break;case jspb$1.BinaryConstants.WireType.DELIMITED:this.skipDelimitedField();break;case jspb$1.BinaryConstants.WireType.FIXED32:this.skipFixed32Field();break;case jspb$1.BinaryConstants.WireType.START_GROUP:this.skipGroup();break;default:goog$1.asserts.fail("Invalid wire encoding for field.");}};
	jspb$1.BinaryReader.prototype.registerReadCallback=function(a,b){goog$1.isNull(this.readCallbacks_)&&(this.readCallbacks_={});goog$1.asserts.assert(!this.readCallbacks_[a]);this.readCallbacks_[a]=b;};jspb$1.BinaryReader.prototype.runReadCallback=function(a){goog$1.asserts.assert(!goog$1.isNull(this.readCallbacks_));a=this.readCallbacks_[a];goog$1.asserts.assert(a);return a(this)};
	jspb$1.BinaryReader.prototype.readAny=function(a){this.nextWireType_=jspb$1.BinaryConstants.FieldTypeToWireType(a);var b=jspb$1.BinaryConstants.FieldType;switch(a){case b.DOUBLE:return this.readDouble();case b.FLOAT:return this.readFloat();case b.INT64:return this.readInt64();case b.UINT64:return this.readUint64();case b.INT32:return this.readInt32();case b.FIXED64:return this.readFixed64();case b.FIXED32:return this.readFixed32();case b.BOOL:return this.readBool();case b.STRING:return this.readString();
	case b.GROUP:goog$1.asserts.fail("Group field type not supported in readAny()");case b.MESSAGE:goog$1.asserts.fail("Message field type not supported in readAny()");case b.BYTES:return this.readBytes();case b.UINT32:return this.readUint32();case b.ENUM:return this.readEnum();case b.SFIXED32:return this.readSfixed32();case b.SFIXED64:return this.readSfixed64();case b.SINT32:return this.readSint32();case b.SINT64:return this.readSint64();case b.FHASH64:return this.readFixedHash64();case b.VHASH64:return this.readVarintHash64();
	default:goog$1.asserts.fail("Invalid field type in readAny()");}return 0};jspb$1.BinaryReader.prototype.readMessage=function(a,b){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.DELIMITED);var c=this.decoder_.getEnd(),d=this.decoder_.readUnsignedVarint32();d=this.decoder_.getCursor()+d;this.decoder_.setEnd(d);b(a,this);this.decoder_.setCursor(d);this.decoder_.setEnd(c);};
	jspb$1.BinaryReader.prototype.readGroup=function(a,b,c){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.START_GROUP);goog$1.asserts.assert(this.nextField_==a);c(b,this);this.error_||this.nextWireType_==jspb$1.BinaryConstants.WireType.END_GROUP||(goog$1.asserts.fail("Group submessage did not end with an END_GROUP tag"),this.error_=!0);};
	jspb$1.BinaryReader.prototype.getFieldDecoder=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32(),b=this.decoder_.getCursor(),c=b+a;a=jspb$1.BinaryDecoder.alloc(this.decoder_.getBuffer(),b,a);this.decoder_.setCursor(c);return a};jspb$1.BinaryReader.prototype.readInt32=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint32()};
	jspb$1.BinaryReader.prototype.readInt32String=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint32String()};jspb$1.BinaryReader.prototype.readInt64=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64()};jspb$1.BinaryReader.prototype.readInt64String=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64String()};
	jspb$1.BinaryReader.prototype.readUint32=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint32()};jspb$1.BinaryReader.prototype.readUint32String=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint32String()};jspb$1.BinaryReader.prototype.readUint64=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint64()};
	jspb$1.BinaryReader.prototype.readUint64String=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint64String()};jspb$1.BinaryReader.prototype.readSint32=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint32()};jspb$1.BinaryReader.prototype.readSint64=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint64()};
	jspb$1.BinaryReader.prototype.readSint64String=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint64String()};jspb$1.BinaryReader.prototype.readFixed32=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.FIXED32);return this.decoder_.readUint32()};jspb$1.BinaryReader.prototype.readFixed64=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.FIXED64);return this.decoder_.readUint64()};
	jspb$1.BinaryReader.prototype.readFixed64String=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.FIXED64);return this.decoder_.readUint64String()};jspb$1.BinaryReader.prototype.readSfixed32=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.FIXED32);return this.decoder_.readInt32()};jspb$1.BinaryReader.prototype.readSfixed32String=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.FIXED32);return this.decoder_.readInt32().toString()};
	jspb$1.BinaryReader.prototype.readSfixed64=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.FIXED64);return this.decoder_.readInt64()};jspb$1.BinaryReader.prototype.readSfixed64String=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.FIXED64);return this.decoder_.readInt64String()};jspb$1.BinaryReader.prototype.readFloat=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.FIXED32);return this.decoder_.readFloat()};
	jspb$1.BinaryReader.prototype.readDouble=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.FIXED64);return this.decoder_.readDouble()};jspb$1.BinaryReader.prototype.readBool=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.VARINT);return !!this.decoder_.readUnsignedVarint32()};jspb$1.BinaryReader.prototype.readEnum=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64()};
	jspb$1.BinaryReader.prototype.readString=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32();return this.decoder_.readString(a)};jspb$1.BinaryReader.prototype.readBytes=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32();return this.decoder_.readBytes(a)};
	jspb$1.BinaryReader.prototype.readVarintHash64=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.VARINT);return this.decoder_.readVarintHash64()};jspb$1.BinaryReader.prototype.readSintHash64=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarintHash64()};jspb$1.BinaryReader.prototype.readSplitVarint64=function(a){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.VARINT);return this.decoder_.readSplitVarint64(a)};
	jspb$1.BinaryReader.prototype.readSplitZigzagVarint64=function(a){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.VARINT);return this.decoder_.readSplitVarint64(function(b,c){return jspb$1.utils.fromZigzag64(b,c,a)})};jspb$1.BinaryReader.prototype.readFixedHash64=function(){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.FIXED64);return this.decoder_.readFixedHash64()};
	jspb$1.BinaryReader.prototype.readSplitFixed64=function(a){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.FIXED64);return this.decoder_.readSplitFixed64(a)};jspb$1.BinaryReader.prototype.readPackedField_=function(a){goog$1.asserts.assert(this.nextWireType_==jspb$1.BinaryConstants.WireType.DELIMITED);var b=this.decoder_.readUnsignedVarint32();b=this.decoder_.getCursor()+b;for(var c=[];this.decoder_.getCursor()<b;)c.push(a.call(this.decoder_));return c};
	jspb$1.BinaryReader.prototype.readPackedInt32=function(){return this.readPackedField_(this.decoder_.readSignedVarint32)};jspb$1.BinaryReader.prototype.readPackedInt32String=function(){return this.readPackedField_(this.decoder_.readSignedVarint32String)};jspb$1.BinaryReader.prototype.readPackedInt64=function(){return this.readPackedField_(this.decoder_.readSignedVarint64)};jspb$1.BinaryReader.prototype.readPackedInt64String=function(){return this.readPackedField_(this.decoder_.readSignedVarint64String)};
	jspb$1.BinaryReader.prototype.readPackedUint32=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint32)};jspb$1.BinaryReader.prototype.readPackedUint32String=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint32String)};jspb$1.BinaryReader.prototype.readPackedUint64=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint64)};jspb$1.BinaryReader.prototype.readPackedUint64String=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint64String)};
	jspb$1.BinaryReader.prototype.readPackedSint32=function(){return this.readPackedField_(this.decoder_.readZigzagVarint32)};jspb$1.BinaryReader.prototype.readPackedSint64=function(){return this.readPackedField_(this.decoder_.readZigzagVarint64)};jspb$1.BinaryReader.prototype.readPackedSint64String=function(){return this.readPackedField_(this.decoder_.readZigzagVarint64String)};jspb$1.BinaryReader.prototype.readPackedFixed32=function(){return this.readPackedField_(this.decoder_.readUint32)};
	jspb$1.BinaryReader.prototype.readPackedFixed64=function(){return this.readPackedField_(this.decoder_.readUint64)};jspb$1.BinaryReader.prototype.readPackedFixed64String=function(){return this.readPackedField_(this.decoder_.readUint64String)};jspb$1.BinaryReader.prototype.readPackedSfixed32=function(){return this.readPackedField_(this.decoder_.readInt32)};jspb$1.BinaryReader.prototype.readPackedSfixed64=function(){return this.readPackedField_(this.decoder_.readInt64)};
	jspb$1.BinaryReader.prototype.readPackedSfixed64String=function(){return this.readPackedField_(this.decoder_.readInt64String)};jspb$1.BinaryReader.prototype.readPackedFloat=function(){return this.readPackedField_(this.decoder_.readFloat)};jspb$1.BinaryReader.prototype.readPackedDouble=function(){return this.readPackedField_(this.decoder_.readDouble)};jspb$1.BinaryReader.prototype.readPackedBool=function(){return this.readPackedField_(this.decoder_.readBool)};jspb$1.BinaryReader.prototype.readPackedEnum=function(){return this.readPackedField_(this.decoder_.readEnum)};
	jspb$1.BinaryReader.prototype.readPackedVarintHash64=function(){return this.readPackedField_(this.decoder_.readVarintHash64)};jspb$1.BinaryReader.prototype.readPackedFixedHash64=function(){return this.readPackedField_(this.decoder_.readFixedHash64)};jspb$1.Map=function(a,b){this.arr_=a;this.valueCtor_=b;this.map_={};this.arrClean=!0;0<this.arr_.length&&this.loadFromArray_();};jspb$1.Map.prototype.loadFromArray_=function(){for(var a=0;a<this.arr_.length;a++){var b=this.arr_[a],c=b[0];this.map_[c.toString()]=new jspb$1.Map.Entry_(c,b[1]);}this.arrClean=!0;};
	jspb$1.Map.prototype.toArray=function(){if(this.arrClean){if(this.valueCtor_){var a=this.map_,b;for(b in a)if(Object.prototype.hasOwnProperty.call(a,b)){var c=a[b].valueWrapper;c&&c.toArray();}}}else {this.arr_.length=0;a=this.stringKeys_();a.sort();for(b=0;b<a.length;b++){var d=this.map_[a[b]];(c=d.valueWrapper)&&c.toArray();this.arr_.push([d.key,d.value]);}this.arrClean=!0;}return this.arr_};
	jspb$1.Map.prototype.toObject=function(a,b){for(var c=this.toArray(),d=[],e=0;e<c.length;e++){var f=this.map_[c[e][0].toString()];this.wrapEntry_(f);var g=f.valueWrapper;g?(goog$1.asserts.assert(b),d.push([f.key,b(a,g)])):d.push([f.key,f.value]);}return d};jspb$1.Map.fromObject=function(a,b,c){b=new jspb$1.Map([],b);for(var d=0;d<a.length;d++){var e=a[d][0],f=c(a[d][1]);b.set(e,f);}return b};jspb$1.Map.ArrayIteratorIterable_=function(a){this.idx_=0;this.arr_=a;};
	jspb$1.Map.ArrayIteratorIterable_.prototype.next=function(){return this.idx_<this.arr_.length?{done:!1,value:this.arr_[this.idx_++]}:{done:!0,value:void 0}};"undefined"!=typeof Symbol&&(jspb$1.Map.ArrayIteratorIterable_.prototype[Symbol.iterator]=function(){return this});jspb$1.Map.prototype.getLength=function(){return this.stringKeys_().length};jspb$1.Map.prototype.clear=function(){this.map_={};this.arrClean=!1;};
	jspb$1.Map.prototype.del=function(a){a=a.toString();var b=this.map_.hasOwnProperty(a);delete this.map_[a];this.arrClean=!1;return b};jspb$1.Map.prototype.getEntryList=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++){var d=this.map_[b[c]];a.push([d.key,d.value]);}return a};jspb$1.Map.prototype.entries=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++){var d=this.map_[b[c]];a.push([d.key,this.wrapEntry_(d)]);}return new jspb$1.Map.ArrayIteratorIterable_(a)};
	jspb$1.Map.prototype.keys=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++)a.push(this.map_[b[c]].key);return new jspb$1.Map.ArrayIteratorIterable_(a)};jspb$1.Map.prototype.values=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++)a.push(this.wrapEntry_(this.map_[b[c]]));return new jspb$1.Map.ArrayIteratorIterable_(a)};
	jspb$1.Map.prototype.forEach=function(a,b){var c=this.stringKeys_();c.sort();for(var d=0;d<c.length;d++){var e=this.map_[c[d]];a.call(b,this.wrapEntry_(e),e.key,this);}};jspb$1.Map.prototype.set=function(a,b){var c=new jspb$1.Map.Entry_(a);this.valueCtor_?(c.valueWrapper=b,c.value=b.toArray()):c.value=b;this.map_[a.toString()]=c;this.arrClean=!1;return this};jspb$1.Map.prototype.wrapEntry_=function(a){return this.valueCtor_?(a.valueWrapper||(a.valueWrapper=new this.valueCtor_(a.value)),a.valueWrapper):a.value};
	jspb$1.Map.prototype.get=function(a){if(a=this.map_[a.toString()])return this.wrapEntry_(a)};jspb$1.Map.prototype.has=function(a){return a.toString()in this.map_};jspb$1.Map.prototype.serializeBinary=function(a,b,c,d,e){var f=this.stringKeys_();f.sort();for(var g=0;g<f.length;g++){var h=this.map_[f[g]];b.beginSubMessage(a);c.call(b,1,h.key);this.valueCtor_?d.call(b,2,this.wrapEntry_(h),e):d.call(b,2,h.value);b.endSubMessage();}};
	jspb$1.Map.deserializeBinary=function(a,b,c,d,e,f,g){for(;b.nextField()&&!b.isEndGroup();){var h=b.getFieldNumber();1==h?f=c.call(b):2==h&&(a.valueCtor_?(goog$1.asserts.assert(e),g||(g=new a.valueCtor_),d.call(b,g,e)):g=d.call(b));}goog$1.asserts.assert(void 0!=f);goog$1.asserts.assert(void 0!=g);a.set(f,g);};jspb$1.Map.prototype.stringKeys_=function(){var a=this.map_,b=[],c;for(c in a)Object.prototype.hasOwnProperty.call(a,c)&&b.push(c);return b};
	jspb$1.Map.Entry_=function(a,b){this.key=a;this.value=b;this.valueWrapper=void 0;};jspb$1.ExtensionFieldInfo=function(a,b,c,d,e){this.fieldIndex=a;this.fieldName=b;this.ctor=c;this.toObjectFn=d;this.isRepeated=e;};jspb$1.ExtensionFieldBinaryInfo=function(a,b,c,d,e,f){this.fieldInfo=a;this.binaryReaderFn=b;this.binaryWriterFn=c;this.binaryMessageSerializeFn=d;this.binaryMessageDeserializeFn=e;this.isPacked=f;};jspb$1.ExtensionFieldInfo.prototype.isMessageType=function(){return !!this.ctor};jspb$1.Message=function(){};jspb$1.Message.GENERATE_TO_OBJECT=!0;jspb$1.Message.GENERATE_FROM_OBJECT=!goog$1.DISALLOW_TEST_ONLY_CODE;
	jspb$1.Message.GENERATE_TO_STRING=!0;jspb$1.Message.ASSUME_LOCAL_ARRAYS=!1;jspb$1.Message.SERIALIZE_EMPTY_TRAILING_FIELDS=!0;jspb$1.Message.SUPPORTS_UINT8ARRAY_="function"==typeof Uint8Array;jspb$1.Message.prototype.getJsPbMessageId=function(){return this.messageId_};jspb$1.Message.getIndex_=function(a,b){return b+a.arrayIndexOffset_};jspb$1.Message.hiddenES6Property_=function(){};jspb$1.Message.getFieldNumber_=function(a,b){return b-a.arrayIndexOffset_};
	jspb$1.Message.initialize=function(a,b,c,d,e,f){a.wrappers_=null;b||(b=c?[c]:[]);a.messageId_=c?String(c):void 0;a.arrayIndexOffset_=0===c?-1:0;a.array=b;jspb$1.Message.initPivotAndExtensionObject_(a,d);a.convertedPrimitiveFields_={};jspb$1.Message.SERIALIZE_EMPTY_TRAILING_FIELDS||(a.repeatedFields=e);if(e)for(b=0;b<e.length;b++)c=e[b],c<a.pivot_?(c=jspb$1.Message.getIndex_(a,c),a.array[c]=a.array[c]||jspb$1.Message.EMPTY_LIST_SENTINEL_):(jspb$1.Message.maybeInitEmptyExtensionObject_(a),a.extensionObject_[c]=
	a.extensionObject_[c]||jspb$1.Message.EMPTY_LIST_SENTINEL_);if(f&&f.length)for(b=0;b<f.length;b++)jspb$1.Message.computeOneofCase(a,f[b]);};jspb$1.Message.EMPTY_LIST_SENTINEL_=goog$1.DEBUG&&Object.freeze?Object.freeze([]):[];jspb$1.Message.isArray_=function(a){return jspb$1.Message.ASSUME_LOCAL_ARRAYS?a instanceof Array:goog$1.isArray(a)};jspb$1.Message.isExtensionObject_=function(a){return null!==a&&"object"==typeof a&&!jspb$1.Message.isArray_(a)&&!(jspb$1.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)};
	jspb$1.Message.initPivotAndExtensionObject_=function(a,b){var c=a.array.length,d=-1;if(c&&(d=c-1,c=a.array[d],jspb$1.Message.isExtensionObject_(c))){a.pivot_=jspb$1.Message.getFieldNumber_(a,d);a.extensionObject_=c;return}-1<b?(a.pivot_=Math.max(b,jspb$1.Message.getFieldNumber_(a,d+1)),a.extensionObject_=null):a.pivot_=Number.MAX_VALUE;};jspb$1.Message.maybeInitEmptyExtensionObject_=function(a){var b=jspb$1.Message.getIndex_(a,a.pivot_);a.array[b]||(a.extensionObject_=a.array[b]={});};
	jspb$1.Message.toObjectList=function(a,b,c){for(var d=[],e=0;e<a.length;e++)d[e]=b.call(a[e],c,a[e]);return d};jspb$1.Message.toObjectExtension=function(a,b,c,d,e){for(var f in c){var g=c[f],h=d.call(a,g);if(null!=h){for(var k in g.fieldName)if(g.fieldName.hasOwnProperty(k))break;b[k]=g.toObjectFn?g.isRepeated?jspb$1.Message.toObjectList(h,g.toObjectFn,e):g.toObjectFn(e,h):h;}}};
	jspb$1.Message.serializeBinaryExtensions=function(a,b,c,d){for(var e in c){var f=c[e],g=f.fieldInfo;if(!f.binaryWriterFn)throw Error("Message extension present that was generated without binary serialization support");var h=d.call(a,g);if(null!=h)if(g.isMessageType())if(f.binaryMessageSerializeFn)f.binaryWriterFn.call(b,g.fieldIndex,h,f.binaryMessageSerializeFn);else throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
	else f.binaryWriterFn.call(b,g.fieldIndex,h);}};jspb$1.Message.readBinaryExtension=function(a,b,c,d,e){var f=c[b.getFieldNumber()];if(f){c=f.fieldInfo;if(!f.binaryReaderFn)throw Error("Deserializing extension whose generated code does not support binary format");if(c.isMessageType()){var g=new c.ctor;f.binaryReaderFn.call(b,g,f.binaryMessageDeserializeFn);}else g=f.binaryReaderFn.call(b);c.isRepeated&&!f.isPacked?(b=d.call(a,c))?b.push(g):e.call(a,c,[g]):e.call(a,c,g);}else b.skipField();};
	jspb$1.Message.getField=function(a,b){if(b<a.pivot_){b=jspb$1.Message.getIndex_(a,b);var c=a.array[b];return c===jspb$1.Message.EMPTY_LIST_SENTINEL_?a.array[b]=[]:c}if(a.extensionObject_)return c=a.extensionObject_[b],c===jspb$1.Message.EMPTY_LIST_SENTINEL_?a.extensionObject_[b]=[]:c};jspb$1.Message.getRepeatedField=function(a,b){return jspb$1.Message.getField(a,b)};jspb$1.Message.getOptionalFloatingPointField=function(a,b){a=jspb$1.Message.getField(a,b);return null==a?a:+a};
	jspb$1.Message.getBooleanField=function(a,b){a=jspb$1.Message.getField(a,b);return null==a?a:!!a};jspb$1.Message.getRepeatedFloatingPointField=function(a,b){var c=jspb$1.Message.getRepeatedField(a,b);a.convertedPrimitiveFields_||(a.convertedPrimitiveFields_={});if(!a.convertedPrimitiveFields_[b]){for(var d=0;d<c.length;d++)c[d]=+c[d];a.convertedPrimitiveFields_[b]=!0;}return c};
	jspb$1.Message.getRepeatedBooleanField=function(a,b){var c=jspb$1.Message.getRepeatedField(a,b);a.convertedPrimitiveFields_||(a.convertedPrimitiveFields_={});if(!a.convertedPrimitiveFields_[b]){for(var d=0;d<c.length;d++)c[d]=!!c[d];a.convertedPrimitiveFields_[b]=!0;}return c};
	jspb$1.Message.bytesAsB64=function(a){if(null==a||goog$1.isString(a))return a;if(jspb$1.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)return goog$1.crypt.base64.encodeByteArray(a);goog$1.asserts.fail("Cannot coerce to b64 string: "+goog$1.typeOf(a));return null};jspb$1.Message.bytesAsU8=function(a){if(null==a||a instanceof Uint8Array)return a;if(goog$1.isString(a))return goog$1.crypt.base64.decodeStringToUint8Array(a);goog$1.asserts.fail("Cannot coerce to Uint8Array: "+goog$1.typeOf(a));return null};
	jspb$1.Message.bytesListAsB64=function(a){jspb$1.Message.assertConsistentTypes_(a);return !a.length||goog$1.isString(a[0])?a:goog$1.array.map(a,jspb$1.Message.bytesAsB64)};jspb$1.Message.bytesListAsU8=function(a){jspb$1.Message.assertConsistentTypes_(a);return !a.length||a[0]instanceof Uint8Array?a:goog$1.array.map(a,jspb$1.Message.bytesAsU8)};
	jspb$1.Message.assertConsistentTypes_=function(a){if(goog$1.DEBUG&&a&&1<a.length){var b=goog$1.typeOf(a[0]);goog$1.array.forEach(a,function(a){goog$1.typeOf(a)!=b&&goog$1.asserts.fail("Inconsistent type in JSPB repeated field array. Got "+goog$1.typeOf(a)+" expected "+b);});}};jspb$1.Message.getFieldWithDefault=function(a,b,c){a=jspb$1.Message.getField(a,b);return null==a?c:a};jspb$1.Message.getBooleanFieldWithDefault=function(a,b,c){a=jspb$1.Message.getBooleanField(a,b);return null==a?c:a};
	jspb$1.Message.getFloatingPointFieldWithDefault=function(a,b,c){a=jspb$1.Message.getOptionalFloatingPointField(a,b);return null==a?c:a};jspb$1.Message.getFieldProto3=jspb$1.Message.getFieldWithDefault;jspb$1.Message.getMapField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});if(b in a.wrappers_)return a.wrappers_[b];var e=jspb$1.Message.getField(a,b);if(!e){if(c)return;e=[];jspb$1.Message.setField(a,b,e);}return a.wrappers_[b]=new jspb$1.Map(e,d)};
	jspb$1.Message.setField=function(a,b,c){goog$1.asserts.assertInstanceof(a,jspb$1.Message);b<a.pivot_?a.array[jspb$1.Message.getIndex_(a,b)]=c:(jspb$1.Message.maybeInitEmptyExtensionObject_(a),a.extensionObject_[b]=c);return a};jspb$1.Message.setProto3IntField=function(a,b,c){return jspb$1.Message.setFieldIgnoringDefault_(a,b,c,0)};jspb$1.Message.setProto3FloatField=function(a,b,c){return jspb$1.Message.setFieldIgnoringDefault_(a,b,c,0)};
	jspb$1.Message.setProto3BooleanField=function(a,b,c){return jspb$1.Message.setFieldIgnoringDefault_(a,b,c,!1)};jspb$1.Message.setProto3StringField=function(a,b,c){return jspb$1.Message.setFieldIgnoringDefault_(a,b,c,"")};jspb$1.Message.setProto3BytesField=function(a,b,c){return jspb$1.Message.setFieldIgnoringDefault_(a,b,c,"")};jspb$1.Message.setProto3EnumField=function(a,b,c){return jspb$1.Message.setFieldIgnoringDefault_(a,b,c,0)};
	jspb$1.Message.setProto3StringIntField=function(a,b,c){return jspb$1.Message.setFieldIgnoringDefault_(a,b,c,"0")};jspb$1.Message.setFieldIgnoringDefault_=function(a,b,c,d){goog$1.asserts.assertInstanceof(a,jspb$1.Message);c!==d?jspb$1.Message.setField(a,b,c):a.array[jspb$1.Message.getIndex_(a,b)]=null;return a};jspb$1.Message.addToRepeatedField=function(a,b,c,d){goog$1.asserts.assertInstanceof(a,jspb$1.Message);b=jspb$1.Message.getRepeatedField(a,b);void 0!=d?b.splice(d,0,c):b.push(c);return a};
	jspb$1.Message.setOneofField=function(a,b,c,d){goog$1.asserts.assertInstanceof(a,jspb$1.Message);(c=jspb$1.Message.computeOneofCase(a,c))&&c!==b&&void 0!==d&&(a.wrappers_&&c in a.wrappers_&&(a.wrappers_[c]=void 0),jspb$1.Message.setField(a,c,void 0));return jspb$1.Message.setField(a,b,d)};jspb$1.Message.computeOneofCase=function(a,b){for(var c,d,e=0;e<b.length;e++){var f=b[e],g=jspb$1.Message.getField(a,f);null!=g&&(c=f,d=g,jspb$1.Message.setField(a,f,void 0));}return c?(jspb$1.Message.setField(a,c,d),c):0};
	jspb$1.Message.getWrapperField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});if(!a.wrappers_[c]){var e=jspb$1.Message.getField(a,c);if(d||e)a.wrappers_[c]=new b(e);}return a.wrappers_[c]};jspb$1.Message.getRepeatedWrapperField=function(a,b,c){jspb$1.Message.wrapRepeatedField_(a,b,c);b=a.wrappers_[c];b==jspb$1.Message.EMPTY_LIST_SENTINEL_&&(b=a.wrappers_[c]=[]);return b};
	jspb$1.Message.wrapRepeatedField_=function(a,b,c){a.wrappers_||(a.wrappers_={});if(!a.wrappers_[c]){for(var d=jspb$1.Message.getRepeatedField(a,c),e=[],f=0;f<d.length;f++)e[f]=new b(d[f]);a.wrappers_[c]=e;}};jspb$1.Message.setWrapperField=function(a,b,c){goog$1.asserts.assertInstanceof(a,jspb$1.Message);a.wrappers_||(a.wrappers_={});var d=c?c.toArray():c;a.wrappers_[b]=c;return jspb$1.Message.setField(a,b,d)};
	jspb$1.Message.setOneofWrapperField=function(a,b,c,d){goog$1.asserts.assertInstanceof(a,jspb$1.Message);a.wrappers_||(a.wrappers_={});var e=d?d.toArray():d;a.wrappers_[b]=d;return jspb$1.Message.setOneofField(a,b,c,e)};jspb$1.Message.setRepeatedWrapperField=function(a,b,c){goog$1.asserts.assertInstanceof(a,jspb$1.Message);a.wrappers_||(a.wrappers_={});c=c||[];for(var d=[],e=0;e<c.length;e++)d[e]=c[e].toArray();a.wrappers_[b]=c;return jspb$1.Message.setField(a,b,d)};
	jspb$1.Message.addToRepeatedWrapperField=function(a,b,c,d,e){jspb$1.Message.wrapRepeatedField_(a,d,b);var f=a.wrappers_[b];f||(f=a.wrappers_[b]=[]);c=c?c:new d;a=jspb$1.Message.getRepeatedField(a,b);void 0!=e?(f.splice(e,0,c),a.splice(e,0,c.toArray())):(f.push(c),a.push(c.toArray()));return c};jspb$1.Message.toMap=function(a,b,c,d){for(var e={},f=0;f<a.length;f++)e[b.call(a[f])]=c?c.call(a[f],d,a[f]):a[f];return e};
	jspb$1.Message.prototype.syncMapFields_=function(){if(this.wrappers_)for(var a in this.wrappers_){var b=this.wrappers_[a];if(goog$1.isArray(b))for(var c=0;c<b.length;c++)b[c]&&b[c].toArray();else b&&b.toArray();}};jspb$1.Message.prototype.toArray=function(){this.syncMapFields_();return this.array};jspb$1.Message.GENERATE_TO_STRING&&(jspb$1.Message.prototype.toString=function(){this.syncMapFields_();return this.array.toString()});
	jspb$1.Message.prototype.getExtension=function(a){if(this.extensionObject_){this.wrappers_||(this.wrappers_={});var b=a.fieldIndex;if(a.isRepeated){if(a.isMessageType())return this.wrappers_[b]||(this.wrappers_[b]=goog$1.array.map(this.extensionObject_[b]||[],function(b){return new a.ctor(b)})),this.wrappers_[b]}else if(a.isMessageType())return !this.wrappers_[b]&&this.extensionObject_[b]&&(this.wrappers_[b]=new a.ctor(this.extensionObject_[b])),this.wrappers_[b];return this.extensionObject_[b]}};
	jspb$1.Message.prototype.setExtension=function(a,b){this.wrappers_||(this.wrappers_={});jspb$1.Message.maybeInitEmptyExtensionObject_(this);var c=a.fieldIndex;a.isRepeated?(b=b||[],a.isMessageType()?(this.wrappers_[c]=b,this.extensionObject_[c]=goog$1.array.map(b,function(a){return a.toArray()})):this.extensionObject_[c]=b):a.isMessageType()?(this.wrappers_[c]=b,this.extensionObject_[c]=b?b.toArray():b):this.extensionObject_[c]=b;return this};
	jspb$1.Message.difference=function(a,b){if(!(a instanceof b.constructor))throw Error("Messages have different types.");var c=a.toArray();b=b.toArray();var d=[],e=0,f=c.length>b.length?c.length:b.length;a.getJsPbMessageId()&&(d[0]=a.getJsPbMessageId(),e=1);for(;e<f;e++)jspb$1.Message.compareFields(c[e],b[e])||(d[e]=b[e]);return new a.constructor(d)};jspb$1.Message.equals=function(a,b){return a==b||!(!a||!b)&&a instanceof b.constructor&&jspb$1.Message.compareFields(a.toArray(),b.toArray())};
	jspb$1.Message.compareExtensions=function(a,b){a=a||{};b=b||{};var c={},d;for(d in a)c[d]=0;for(d in b)c[d]=0;for(d in c)if(!jspb$1.Message.compareFields(a[d],b[d]))return !1;return !0};
	jspb$1.Message.compareFields=function(a,b){if(a==b)return !0;if(!goog$1.isObject(a)||!goog$1.isObject(b))return goog$1.isNumber(a)&&isNaN(a)||goog$1.isNumber(b)&&isNaN(b)?String(a)==String(b):!1;if(a.constructor!=b.constructor)return !1;if(jspb$1.Message.SUPPORTS_UINT8ARRAY_&&a.constructor===Uint8Array){if(a.length!=b.length)return !1;for(var c=0;c<a.length;c++)if(a[c]!=b[c])return !1;return !0}if(a.constructor===Array){var d=void 0,e=void 0,f=Math.max(a.length,b.length);for(c=0;c<f;c++){var g=a[c],h=b[c];g&&g.constructor==
	Object&&(goog$1.asserts.assert(void 0===d),goog$1.asserts.assert(c===a.length-1),d=g,g=void 0);h&&h.constructor==Object&&(goog$1.asserts.assert(void 0===e),goog$1.asserts.assert(c===b.length-1),e=h,h=void 0);if(!jspb$1.Message.compareFields(g,h))return !1}return d||e?(d=d||{},e=e||{},jspb$1.Message.compareExtensions(d,e)):!0}if(a.constructor===Object)return jspb$1.Message.compareExtensions(a,b);throw Error("Invalid type in JSPB array");};jspb$1.Message.prototype.cloneMessage=function(){return jspb$1.Message.cloneMessage(this)};
	jspb$1.Message.prototype.clone=function(){return jspb$1.Message.cloneMessage(this)};jspb$1.Message.clone=function(a){return jspb$1.Message.cloneMessage(a)};jspb$1.Message.cloneMessage=function(a){return new a.constructor(jspb$1.Message.clone_(a.toArray()))};
	jspb$1.Message.copyInto=function(a,b){goog$1.asserts.assertInstanceof(a,jspb$1.Message);goog$1.asserts.assertInstanceof(b,jspb$1.Message);goog$1.asserts.assert(a.constructor==b.constructor,"Copy source and target message should have the same type.");a=jspb$1.Message.clone(a);for(var c=b.toArray(),d=a.toArray(),e=c.length=0;e<d.length;e++)c[e]=d[e];b.wrappers_=a.wrappers_;b.extensionObject_=a.extensionObject_;};
	jspb$1.Message.clone_=function(a){if(goog$1.isArray(a)){for(var b=Array(a.length),c=0;c<a.length;c++){var d=a[c];null!=d&&(b[c]="object"==typeof d?jspb$1.Message.clone_(goog$1.asserts.assert(d)):d);}return b}if(jspb$1.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)return new Uint8Array(a);b={};for(c in a)d=a[c],null!=d&&(b[c]="object"==typeof d?jspb$1.Message.clone_(goog$1.asserts.assert(d)):d);return b};jspb$1.Message.registerMessageType=function(a,b){b.messageId=a;};jspb$1.Message.messageSetExtensions={};
	jspb$1.Message.messageSetExtensionsBinary={};jspb$1.arith={};jspb$1.arith.UInt64=function(a,b){this.lo=a;this.hi=b;};jspb$1.arith.UInt64.prototype.cmp=function(a){return this.hi<a.hi||this.hi==a.hi&&this.lo<a.lo?-1:this.hi==a.hi&&this.lo==a.lo?0:1};jspb$1.arith.UInt64.prototype.rightShift=function(){return new jspb$1.arith.UInt64((this.lo>>>1|(this.hi&1)<<31)>>>0,this.hi>>>1>>>0)};jspb$1.arith.UInt64.prototype.leftShift=function(){return new jspb$1.arith.UInt64(this.lo<<1>>>0,(this.hi<<1|this.lo>>>31)>>>0)};
	jspb$1.arith.UInt64.prototype.msb=function(){return !!(this.hi&2147483648)};jspb$1.arith.UInt64.prototype.lsb=function(){return !!(this.lo&1)};jspb$1.arith.UInt64.prototype.zero=function(){return 0==this.lo&&0==this.hi};jspb$1.arith.UInt64.prototype.add=function(a){return new jspb$1.arith.UInt64((this.lo+a.lo&4294967295)>>>0>>>0,((this.hi+a.hi&4294967295)>>>0)+(4294967296<=this.lo+a.lo?1:0)>>>0)};
	jspb$1.arith.UInt64.prototype.sub=function(a){return new jspb$1.arith.UInt64((this.lo-a.lo&4294967295)>>>0>>>0,((this.hi-a.hi&4294967295)>>>0)-(0>this.lo-a.lo?1:0)>>>0)};jspb$1.arith.UInt64.mul32x32=function(a,b){var c=a&65535;a>>>=16;var d=b&65535,e=b>>>16;b=c*d+65536*(c*e&65535)+65536*(a*d&65535);for(c=a*e+(c*e>>>16)+(a*d>>>16);4294967296<=b;)b-=4294967296,c+=1;return new jspb$1.arith.UInt64(b>>>0,c>>>0)};
	jspb$1.arith.UInt64.prototype.mul=function(a){var b=jspb$1.arith.UInt64.mul32x32(this.lo,a);a=jspb$1.arith.UInt64.mul32x32(this.hi,a);a.hi=a.lo;a.lo=0;return b.add(a)};
	jspb$1.arith.UInt64.prototype.div=function(a){if(0==a)return [];var b=new jspb$1.arith.UInt64(0,0),c=new jspb$1.arith.UInt64(this.lo,this.hi);a=new jspb$1.arith.UInt64(a,0);for(var d=new jspb$1.arith.UInt64(1,0);!a.msb();)a=a.leftShift(),d=d.leftShift();for(;!d.zero();)0>=a.cmp(c)&&(b=b.add(d),c=c.sub(a)),a=a.rightShift(),d=d.rightShift();return [b,c]};jspb$1.arith.UInt64.prototype.toString=function(){for(var a="",b=this;!b.zero();){b=b.div(10);var c=b[0];a=b[1].lo+a;b=c;}""==a&&(a="0");return a};
	jspb$1.arith.UInt64.fromString=function(a){for(var b=new jspb$1.arith.UInt64(0,0),c=new jspb$1.arith.UInt64(0,0),d=0;d<a.length;d++){if("0">a[d]||"9"<a[d])return null;var e=parseInt(a[d],10);c.lo=e;b=b.mul(10).add(c);}return b};jspb$1.arith.UInt64.prototype.clone=function(){return new jspb$1.arith.UInt64(this.lo,this.hi)};jspb$1.arith.Int64=function(a,b){this.lo=a;this.hi=b;};
	jspb$1.arith.Int64.prototype.add=function(a){return new jspb$1.arith.Int64((this.lo+a.lo&4294967295)>>>0>>>0,((this.hi+a.hi&4294967295)>>>0)+(4294967296<=this.lo+a.lo?1:0)>>>0)};jspb$1.arith.Int64.prototype.sub=function(a){return new jspb$1.arith.Int64((this.lo-a.lo&4294967295)>>>0>>>0,((this.hi-a.hi&4294967295)>>>0)-(0>this.lo-a.lo?1:0)>>>0)};jspb$1.arith.Int64.prototype.clone=function(){return new jspb$1.arith.Int64(this.lo,this.hi)};
	jspb$1.arith.Int64.prototype.toString=function(){var a=0!=(this.hi&2147483648),b=new jspb$1.arith.UInt64(this.lo,this.hi);a&&(b=(new jspb$1.arith.UInt64(0,0)).sub(b));return (a?"-":"")+b.toString()};jspb$1.arith.Int64.fromString=function(a){var b=0<a.length&&"-"==a[0];b&&(a=a.substring(1));a=jspb$1.arith.UInt64.fromString(a);if(null===a)return null;b&&(a=(new jspb$1.arith.UInt64(0,0)).sub(a));return new jspb$1.arith.Int64(a.lo,a.hi)};jspb$1.BinaryEncoder=function(){this.buffer_=[];};jspb$1.BinaryEncoder.prototype.length=function(){return this.buffer_.length};jspb$1.BinaryEncoder.prototype.end=function(){var a=this.buffer_;this.buffer_=[];return a};
	jspb$1.BinaryEncoder.prototype.writeSplitVarint64=function(a,b){goog$1.asserts.assert(a==Math.floor(a));goog$1.asserts.assert(b==Math.floor(b));goog$1.asserts.assert(0<=a&&a<jspb$1.BinaryConstants.TWO_TO_32);for(goog$1.asserts.assert(0<=b&&b<jspb$1.BinaryConstants.TWO_TO_32);0<b||127<a;)this.buffer_.push(a&127|128),a=(a>>>7|b<<25)>>>0,b>>>=7;this.buffer_.push(a);};
	jspb$1.BinaryEncoder.prototype.writeSplitFixed64=function(a,b){goog$1.asserts.assert(a==Math.floor(a));goog$1.asserts.assert(b==Math.floor(b));goog$1.asserts.assert(0<=a&&a<jspb$1.BinaryConstants.TWO_TO_32);goog$1.asserts.assert(0<=b&&b<jspb$1.BinaryConstants.TWO_TO_32);this.writeUint32(a);this.writeUint32(b);};
	jspb$1.BinaryEncoder.prototype.writeUnsignedVarint32=function(a){goog$1.asserts.assert(a==Math.floor(a));for(goog$1.asserts.assert(0<=a&&a<jspb$1.BinaryConstants.TWO_TO_32);127<a;)this.buffer_.push(a&127|128),a>>>=7;this.buffer_.push(a);};
	jspb$1.BinaryEncoder.prototype.writeSignedVarint32=function(a){goog$1.asserts.assert(a==Math.floor(a));goog$1.asserts.assert(a>=-jspb$1.BinaryConstants.TWO_TO_31&&a<jspb$1.BinaryConstants.TWO_TO_31);if(0<=a)this.writeUnsignedVarint32(a);else {for(var b=0;9>b;b++)this.buffer_.push(a&127|128),a>>=7;this.buffer_.push(1);}};
	jspb$1.BinaryEncoder.prototype.writeUnsignedVarint64=function(a){goog$1.asserts.assert(a==Math.floor(a));goog$1.asserts.assert(0<=a&&a<jspb$1.BinaryConstants.TWO_TO_64);jspb$1.utils.splitInt64(a);this.writeSplitVarint64(jspb$1.utils.split64Low,jspb$1.utils.split64High);};
	jspb$1.BinaryEncoder.prototype.writeSignedVarint64=function(a){goog$1.asserts.assert(a==Math.floor(a));goog$1.asserts.assert(a>=-jspb$1.BinaryConstants.TWO_TO_63&&a<jspb$1.BinaryConstants.TWO_TO_63);jspb$1.utils.splitInt64(a);this.writeSplitVarint64(jspb$1.utils.split64Low,jspb$1.utils.split64High);};
	jspb$1.BinaryEncoder.prototype.writeZigzagVarint32=function(a){goog$1.asserts.assert(a==Math.floor(a));goog$1.asserts.assert(a>=-jspb$1.BinaryConstants.TWO_TO_31&&a<jspb$1.BinaryConstants.TWO_TO_31);this.writeUnsignedVarint32((a<<1^a>>31)>>>0);};jspb$1.BinaryEncoder.prototype.writeZigzagVarint64=function(a){goog$1.asserts.assert(a==Math.floor(a));goog$1.asserts.assert(a>=-jspb$1.BinaryConstants.TWO_TO_63&&a<jspb$1.BinaryConstants.TWO_TO_63);jspb$1.utils.splitZigzag64(a);this.writeSplitVarint64(jspb$1.utils.split64Low,jspb$1.utils.split64High);};
	jspb$1.BinaryEncoder.prototype.writeZigzagVarint64String=function(a){this.writeZigzagVarintHash64(jspb$1.utils.decimalStringToHash64(a));};jspb$1.BinaryEncoder.prototype.writeZigzagVarintHash64=function(a){var b=this;jspb$1.utils.splitHash64(a);jspb$1.utils.toZigzag64(jspb$1.utils.split64Low,jspb$1.utils.split64High,function(a,d){b.writeSplitVarint64(a>>>0,d>>>0);});};
	jspb$1.BinaryEncoder.prototype.writeUint8=function(a){goog$1.asserts.assert(a==Math.floor(a));goog$1.asserts.assert(0<=a&&256>a);this.buffer_.push(a>>>0&255);};jspb$1.BinaryEncoder.prototype.writeUint16=function(a){goog$1.asserts.assert(a==Math.floor(a));goog$1.asserts.assert(0<=a&&65536>a);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);};
	jspb$1.BinaryEncoder.prototype.writeUint32=function(a){goog$1.asserts.assert(a==Math.floor(a));goog$1.asserts.assert(0<=a&&a<jspb$1.BinaryConstants.TWO_TO_32);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);this.buffer_.push(a>>>16&255);this.buffer_.push(a>>>24&255);};jspb$1.BinaryEncoder.prototype.writeUint64=function(a){goog$1.asserts.assert(a==Math.floor(a));goog$1.asserts.assert(0<=a&&a<jspb$1.BinaryConstants.TWO_TO_64);jspb$1.utils.splitUint64(a);this.writeUint32(jspb$1.utils.split64Low);this.writeUint32(jspb$1.utils.split64High);};
	jspb$1.BinaryEncoder.prototype.writeInt8=function(a){goog$1.asserts.assert(a==Math.floor(a));goog$1.asserts.assert(-128<=a&&128>a);this.buffer_.push(a>>>0&255);};jspb$1.BinaryEncoder.prototype.writeInt16=function(a){goog$1.asserts.assert(a==Math.floor(a));goog$1.asserts.assert(-32768<=a&&32768>a);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);};
	jspb$1.BinaryEncoder.prototype.writeInt32=function(a){goog$1.asserts.assert(a==Math.floor(a));goog$1.asserts.assert(a>=-jspb$1.BinaryConstants.TWO_TO_31&&a<jspb$1.BinaryConstants.TWO_TO_31);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);this.buffer_.push(a>>>16&255);this.buffer_.push(a>>>24&255);};
	jspb$1.BinaryEncoder.prototype.writeInt64=function(a){goog$1.asserts.assert(a==Math.floor(a));goog$1.asserts.assert(a>=-jspb$1.BinaryConstants.TWO_TO_63&&a<jspb$1.BinaryConstants.TWO_TO_63);jspb$1.utils.splitInt64(a);this.writeSplitFixed64(jspb$1.utils.split64Low,jspb$1.utils.split64High);};
	jspb$1.BinaryEncoder.prototype.writeInt64String=function(a){goog$1.asserts.assert(a==Math.floor(a));goog$1.asserts.assert(+a>=-jspb$1.BinaryConstants.TWO_TO_63&&+a<jspb$1.BinaryConstants.TWO_TO_63);jspb$1.utils.splitHash64(jspb$1.utils.decimalStringToHash64(a));this.writeSplitFixed64(jspb$1.utils.split64Low,jspb$1.utils.split64High);};jspb$1.BinaryEncoder.prototype.writeFloat=function(a){goog$1.asserts.assert(a>=-jspb$1.BinaryConstants.FLOAT32_MAX&&a<=jspb$1.BinaryConstants.FLOAT32_MAX);jspb$1.utils.splitFloat32(a);this.writeUint32(jspb$1.utils.split64Low);};
	jspb$1.BinaryEncoder.prototype.writeDouble=function(a){goog$1.asserts.assert(a>=-jspb$1.BinaryConstants.FLOAT64_MAX&&a<=jspb$1.BinaryConstants.FLOAT64_MAX);jspb$1.utils.splitFloat64(a);this.writeUint32(jspb$1.utils.split64Low);this.writeUint32(jspb$1.utils.split64High);};jspb$1.BinaryEncoder.prototype.writeBool=function(a){goog$1.asserts.assert(goog$1.isBoolean(a)||goog$1.isNumber(a));this.buffer_.push(a?1:0);};
	jspb$1.BinaryEncoder.prototype.writeEnum=function(a){goog$1.asserts.assert(a==Math.floor(a));goog$1.asserts.assert(a>=-jspb$1.BinaryConstants.TWO_TO_31&&a<jspb$1.BinaryConstants.TWO_TO_31);this.writeSignedVarint32(a);};jspb$1.BinaryEncoder.prototype.writeBytes=function(a){this.buffer_.push.apply(this.buffer_,a);};jspb$1.BinaryEncoder.prototype.writeVarintHash64=function(a){jspb$1.utils.splitHash64(a);this.writeSplitVarint64(jspb$1.utils.split64Low,jspb$1.utils.split64High);};
	jspb$1.BinaryEncoder.prototype.writeFixedHash64=function(a){jspb$1.utils.splitHash64(a);this.writeUint32(jspb$1.utils.split64Low);this.writeUint32(jspb$1.utils.split64High);};
	jspb$1.BinaryEncoder.prototype.writeString=function(a){for(var b=this.buffer_.length,c=0;c<a.length;c++){var d=a.charCodeAt(c);if(128>d)this.buffer_.push(d);else if(2048>d)this.buffer_.push(d>>6|192),this.buffer_.push(d&63|128);else if(65536>d)if(55296<=d&&56319>=d&&c+1<a.length){var e=a.charCodeAt(c+1);56320<=e&&57343>=e&&(d=1024*(d-55296)+e-56320+65536,this.buffer_.push(d>>18|240),this.buffer_.push(d>>12&63|128),this.buffer_.push(d>>6&63|128),this.buffer_.push(d&63|128),c++);}else this.buffer_.push(d>>
	12|224),this.buffer_.push(d>>6&63|128),this.buffer_.push(d&63|128);}return this.buffer_.length-b};jspb$1.BinaryWriter=function(){this.blocks_=[];this.totalLength_=0;this.encoder_=new jspb$1.BinaryEncoder;this.bookmarks_=[];};jspb$1.BinaryWriter.prototype.appendUint8Array_=function(a){var b=this.encoder_.end();this.blocks_.push(b);this.blocks_.push(a);this.totalLength_+=b.length+a.length;};
	jspb$1.BinaryWriter.prototype.beginDelimited_=function(a){this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.DELIMITED);a=this.encoder_.end();this.blocks_.push(a);this.totalLength_+=a.length;a.push(this.totalLength_);return a};jspb$1.BinaryWriter.prototype.endDelimited_=function(a){var b=a.pop();b=this.totalLength_+this.encoder_.length()-b;for(goog$1.asserts.assert(0<=b);127<b;)a.push(b&127|128),b>>>=7,this.totalLength_++;a.push(b);this.totalLength_++;};
	jspb$1.BinaryWriter.prototype.writeSerializedMessage=function(a,b,c){this.appendUint8Array_(a.subarray(b,c));};jspb$1.BinaryWriter.prototype.maybeWriteSerializedMessage=function(a,b,c){null!=a&&null!=b&&null!=c&&this.writeSerializedMessage(a,b,c);};jspb$1.BinaryWriter.prototype.reset=function(){this.blocks_=[];this.encoder_.end();this.totalLength_=0;this.bookmarks_=[];};
	jspb$1.BinaryWriter.prototype.getResultBuffer=function(){goog$1.asserts.assert(0==this.bookmarks_.length);for(var a=new Uint8Array(this.totalLength_+this.encoder_.length()),b=this.blocks_,c=b.length,d=0,e=0;e<c;e++){var f=b[e];a.set(f,d);d+=f.length;}b=this.encoder_.end();a.set(b,d);d+=b.length;goog$1.asserts.assert(d==a.length);this.blocks_=[a];return a};jspb$1.BinaryWriter.prototype.getResultBase64String=function(a){return goog$1.crypt.base64.encodeByteArray(this.getResultBuffer(),a)};
	jspb$1.BinaryWriter.prototype.beginSubMessage=function(a){this.bookmarks_.push(this.beginDelimited_(a));};jspb$1.BinaryWriter.prototype.endSubMessage=function(){goog$1.asserts.assert(0<=this.bookmarks_.length);this.endDelimited_(this.bookmarks_.pop());};jspb$1.BinaryWriter.prototype.writeFieldHeader_=function(a,b){goog$1.asserts.assert(1<=a&&a==Math.floor(a));this.encoder_.writeUnsignedVarint32(8*a+b);};
	jspb$1.BinaryWriter.prototype.writeAny=function(a,b,c){var d=jspb$1.BinaryConstants.FieldType;switch(a){case d.DOUBLE:this.writeDouble(b,c);break;case d.FLOAT:this.writeFloat(b,c);break;case d.INT64:this.writeInt64(b,c);break;case d.UINT64:this.writeUint64(b,c);break;case d.INT32:this.writeInt32(b,c);break;case d.FIXED64:this.writeFixed64(b,c);break;case d.FIXED32:this.writeFixed32(b,c);break;case d.BOOL:this.writeBool(b,c);break;case d.STRING:this.writeString(b,c);break;case d.GROUP:goog$1.asserts.fail("Group field type not supported in writeAny()");
	break;case d.MESSAGE:goog$1.asserts.fail("Message field type not supported in writeAny()");break;case d.BYTES:this.writeBytes(b,c);break;case d.UINT32:this.writeUint32(b,c);break;case d.ENUM:this.writeEnum(b,c);break;case d.SFIXED32:this.writeSfixed32(b,c);break;case d.SFIXED64:this.writeSfixed64(b,c);break;case d.SINT32:this.writeSint32(b,c);break;case d.SINT64:this.writeSint64(b,c);break;case d.FHASH64:this.writeFixedHash64(b,c);break;case d.VHASH64:this.writeVarintHash64(b,c);break;default:goog$1.asserts.fail("Invalid field type in writeAny()");}};
	jspb$1.BinaryWriter.prototype.writeUnsignedVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.VARINT),this.encoder_.writeUnsignedVarint32(b));};jspb$1.BinaryWriter.prototype.writeSignedVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(b));};jspb$1.BinaryWriter.prototype.writeUnsignedVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.VARINT),this.encoder_.writeUnsignedVarint64(b));};
	jspb$1.BinaryWriter.prototype.writeSignedVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint64(b));};jspb$1.BinaryWriter.prototype.writeZigzagVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint32(b));};jspb$1.BinaryWriter.prototype.writeZigzagVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint64(b));};
	jspb$1.BinaryWriter.prototype.writeZigzagVarint64String_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint64String(b));};jspb$1.BinaryWriter.prototype.writeZigzagVarintHash64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarintHash64(b));};
	jspb$1.BinaryWriter.prototype.writeInt32=function(a,b){null!=b&&(goog$1.asserts.assert(b>=-jspb$1.BinaryConstants.TWO_TO_31&&b<jspb$1.BinaryConstants.TWO_TO_31),this.writeSignedVarint32_(a,b));};jspb$1.BinaryWriter.prototype.writeInt32String=function(a,b){null!=b&&(b=parseInt(b,10),goog$1.asserts.assert(b>=-jspb$1.BinaryConstants.TWO_TO_31&&b<jspb$1.BinaryConstants.TWO_TO_31),this.writeSignedVarint32_(a,b));};
	jspb$1.BinaryWriter.prototype.writeInt64=function(a,b){null!=b&&(goog$1.asserts.assert(b>=-jspb$1.BinaryConstants.TWO_TO_63&&b<jspb$1.BinaryConstants.TWO_TO_63),this.writeSignedVarint64_(a,b));};jspb$1.BinaryWriter.prototype.writeInt64String=function(a,b){null!=b&&(b=jspb$1.arith.Int64.fromString(b),this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.VARINT),this.encoder_.writeSplitVarint64(b.lo,b.hi));};
	jspb$1.BinaryWriter.prototype.writeUint32=function(a,b){null!=b&&(goog$1.asserts.assert(0<=b&&b<jspb$1.BinaryConstants.TWO_TO_32),this.writeUnsignedVarint32_(a,b));};jspb$1.BinaryWriter.prototype.writeUint32String=function(a,b){null!=b&&(b=parseInt(b,10),goog$1.asserts.assert(0<=b&&b<jspb$1.BinaryConstants.TWO_TO_32),this.writeUnsignedVarint32_(a,b));};jspb$1.BinaryWriter.prototype.writeUint64=function(a,b){null!=b&&(goog$1.asserts.assert(0<=b&&b<jspb$1.BinaryConstants.TWO_TO_64),this.writeUnsignedVarint64_(a,b));};
	jspb$1.BinaryWriter.prototype.writeUint64String=function(a,b){null!=b&&(b=jspb$1.arith.UInt64.fromString(b),this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.VARINT),this.encoder_.writeSplitVarint64(b.lo,b.hi));};jspb$1.BinaryWriter.prototype.writeSint32=function(a,b){null!=b&&(goog$1.asserts.assert(b>=-jspb$1.BinaryConstants.TWO_TO_31&&b<jspb$1.BinaryConstants.TWO_TO_31),this.writeZigzagVarint32_(a,b));};
	jspb$1.BinaryWriter.prototype.writeSint64=function(a,b){null!=b&&(goog$1.asserts.assert(b>=-jspb$1.BinaryConstants.TWO_TO_63&&b<jspb$1.BinaryConstants.TWO_TO_63),this.writeZigzagVarint64_(a,b));};jspb$1.BinaryWriter.prototype.writeSintHash64=function(a,b){null!=b&&this.writeZigzagVarintHash64_(a,b);};jspb$1.BinaryWriter.prototype.writeSint64String=function(a,b){null!=b&&this.writeZigzagVarint64String_(a,b);};
	jspb$1.BinaryWriter.prototype.writeFixed32=function(a,b){null!=b&&(goog$1.asserts.assert(0<=b&&b<jspb$1.BinaryConstants.TWO_TO_32),this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.FIXED32),this.encoder_.writeUint32(b));};jspb$1.BinaryWriter.prototype.writeFixed64=function(a,b){null!=b&&(goog$1.asserts.assert(0<=b&&b<jspb$1.BinaryConstants.TWO_TO_64),this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.FIXED64),this.encoder_.writeUint64(b));};
	jspb$1.BinaryWriter.prototype.writeFixed64String=function(a,b){null!=b&&(b=jspb$1.arith.UInt64.fromString(b),this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.FIXED64),this.encoder_.writeSplitFixed64(b.lo,b.hi));};jspb$1.BinaryWriter.prototype.writeSfixed32=function(a,b){null!=b&&(goog$1.asserts.assert(b>=-jspb$1.BinaryConstants.TWO_TO_31&&b<jspb$1.BinaryConstants.TWO_TO_31),this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.FIXED32),this.encoder_.writeInt32(b));};
	jspb$1.BinaryWriter.prototype.writeSfixed64=function(a,b){null!=b&&(goog$1.asserts.assert(b>=-jspb$1.BinaryConstants.TWO_TO_63&&b<jspb$1.BinaryConstants.TWO_TO_63),this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.FIXED64),this.encoder_.writeInt64(b));};jspb$1.BinaryWriter.prototype.writeSfixed64String=function(a,b){null!=b&&(b=jspb$1.arith.Int64.fromString(b),this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.FIXED64),this.encoder_.writeSplitFixed64(b.lo,b.hi));};
	jspb$1.BinaryWriter.prototype.writeFloat=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.FIXED32),this.encoder_.writeFloat(b));};jspb$1.BinaryWriter.prototype.writeDouble=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.FIXED64),this.encoder_.writeDouble(b));};jspb$1.BinaryWriter.prototype.writeBool=function(a,b){null!=b&&(goog$1.asserts.assert(goog$1.isBoolean(b)||goog$1.isNumber(b)),this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.VARINT),this.encoder_.writeBool(b));};
	jspb$1.BinaryWriter.prototype.writeEnum=function(a,b){null!=b&&(goog$1.asserts.assert(b>=-jspb$1.BinaryConstants.TWO_TO_31&&b<jspb$1.BinaryConstants.TWO_TO_31),this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(b));};jspb$1.BinaryWriter.prototype.writeString=function(a,b){null!=b&&(a=this.beginDelimited_(a),this.encoder_.writeString(b),this.endDelimited_(a));};
	jspb$1.BinaryWriter.prototype.writeBytes=function(a,b){null!=b&&(b=jspb$1.utils.byteSourceToUint8Array(b),this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(b.length),this.appendUint8Array_(b));};jspb$1.BinaryWriter.prototype.writeMessage=function(a,b,c){null!=b&&(a=this.beginDelimited_(a),c(b,this),this.endDelimited_(a));};
	jspb$1.BinaryWriter.prototype.writeMessageSet=function(a,b,c){null!=b&&(this.writeFieldHeader_(1,jspb$1.BinaryConstants.WireType.START_GROUP),this.writeFieldHeader_(2,jspb$1.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(a),a=this.beginDelimited_(3),c(b,this),this.endDelimited_(a),this.writeFieldHeader_(1,jspb$1.BinaryConstants.WireType.END_GROUP));};
	jspb$1.BinaryWriter.prototype.writeGroup=function(a,b,c){null!=b&&(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.START_GROUP),c(b,this),this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.END_GROUP));};jspb$1.BinaryWriter.prototype.writeFixedHash64=function(a,b){null!=b&&(goog$1.asserts.assert(8==b.length),this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.FIXED64),this.encoder_.writeFixedHash64(b));};
	jspb$1.BinaryWriter.prototype.writeVarintHash64=function(a,b){null!=b&&(goog$1.asserts.assert(8==b.length),this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.VARINT),this.encoder_.writeVarintHash64(b));};jspb$1.BinaryWriter.prototype.writeSplitFixed64=function(a,b,c){this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.FIXED64);this.encoder_.writeSplitFixed64(b,c);};
	jspb$1.BinaryWriter.prototype.writeSplitVarint64=function(a,b,c){this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.VARINT);this.encoder_.writeSplitVarint64(b,c);};jspb$1.BinaryWriter.prototype.writeSplitZigzagVarint64=function(a,b,c){this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.VARINT);var d=this.encoder_;jspb$1.utils.toZigzag64(b,c,function(a,b){d.writeSplitVarint64(a>>>0,b>>>0);});};
	jspb$1.BinaryWriter.prototype.writeRepeatedInt32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSignedVarint32_(a,b[c]);};jspb$1.BinaryWriter.prototype.writeRepeatedInt32String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeInt32String(a,b[c]);};jspb$1.BinaryWriter.prototype.writeRepeatedInt64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSignedVarint64_(a,b[c]);};
	jspb$1.BinaryWriter.prototype.writeRepeatedSplitFixed64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitFixed64(a,c(b[e]),d(b[e]));};jspb$1.BinaryWriter.prototype.writeRepeatedSplitVarint64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitVarint64(a,c(b[e]),d(b[e]));};jspb$1.BinaryWriter.prototype.writeRepeatedSplitZigzagVarint64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitZigzagVarint64(a,c(b[e]),d(b[e]));};
	jspb$1.BinaryWriter.prototype.writeRepeatedInt64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeInt64String(a,b[c]);};jspb$1.BinaryWriter.prototype.writeRepeatedUint32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUnsignedVarint32_(a,b[c]);};jspb$1.BinaryWriter.prototype.writeRepeatedUint32String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUint32String(a,b[c]);};
	jspb$1.BinaryWriter.prototype.writeRepeatedUint64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUnsignedVarint64_(a,b[c]);};jspb$1.BinaryWriter.prototype.writeRepeatedUint64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUint64String(a,b[c]);};jspb$1.BinaryWriter.prototype.writeRepeatedSint32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint32_(a,b[c]);};
	jspb$1.BinaryWriter.prototype.writeRepeatedSint64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint64_(a,b[c]);};jspb$1.BinaryWriter.prototype.writeRepeatedSint64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint64String_(a,b[c]);};jspb$1.BinaryWriter.prototype.writeRepeatedSintHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarintHash64_(a,b[c]);};
	jspb$1.BinaryWriter.prototype.writeRepeatedFixed32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed32(a,b[c]);};jspb$1.BinaryWriter.prototype.writeRepeatedFixed64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed64(a,b[c]);};jspb$1.BinaryWriter.prototype.writeRepeatedFixed64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed64String(a,b[c]);};
	jspb$1.BinaryWriter.prototype.writeRepeatedSfixed32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed32(a,b[c]);};jspb$1.BinaryWriter.prototype.writeRepeatedSfixed64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed64(a,b[c]);};jspb$1.BinaryWriter.prototype.writeRepeatedSfixed64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed64String(a,b[c]);};
	jspb$1.BinaryWriter.prototype.writeRepeatedFloat=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFloat(a,b[c]);};jspb$1.BinaryWriter.prototype.writeRepeatedDouble=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeDouble(a,b[c]);};jspb$1.BinaryWriter.prototype.writeRepeatedBool=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeBool(a,b[c]);};jspb$1.BinaryWriter.prototype.writeRepeatedEnum=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeEnum(a,b[c]);};
	jspb$1.BinaryWriter.prototype.writeRepeatedString=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeString(a,b[c]);};jspb$1.BinaryWriter.prototype.writeRepeatedBytes=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeBytes(a,b[c]);};jspb$1.BinaryWriter.prototype.writeRepeatedMessage=function(a,b,c){if(null!=b)for(var d=0;d<b.length;d++){var e=this.beginDelimited_(a);c(b[d],this);this.endDelimited_(e);}};
	jspb$1.BinaryWriter.prototype.writeRepeatedGroup=function(a,b,c){if(null!=b)for(var d=0;d<b.length;d++)this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.START_GROUP),c(b[d],this),this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.END_GROUP);};jspb$1.BinaryWriter.prototype.writeRepeatedFixedHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixedHash64(a,b[c]);};
	jspb$1.BinaryWriter.prototype.writeRepeatedVarintHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeVarintHash64(a,b[c]);};jspb$1.BinaryWriter.prototype.writePackedInt32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint32(b[c]);this.endDelimited_(a);}};
	jspb$1.BinaryWriter.prototype.writePackedInt32String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint32(parseInt(b[c],10));this.endDelimited_(a);}};jspb$1.BinaryWriter.prototype.writePackedInt64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint64(b[c]);this.endDelimited_(a);}};
	jspb$1.BinaryWriter.prototype.writePackedSplitFixed64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=0;e<b.length;e++)this.encoder_.writeSplitFixed64(c(b[e]),d(b[e]));this.endDelimited_(a);}};jspb$1.BinaryWriter.prototype.writePackedSplitVarint64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=0;e<b.length;e++)this.encoder_.writeSplitVarint64(c(b[e]),d(b[e]));this.endDelimited_(a);}};
	jspb$1.BinaryWriter.prototype.writePackedSplitZigzagVarint64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=this.encoder_,f=0;f<b.length;f++)jspb$1.utils.toZigzag64(c(b[f]),d(b[f]),function(a,b){e.writeSplitVarint64(a>>>0,b>>>0);});this.endDelimited_(a);}};jspb$1.BinaryWriter.prototype.writePackedInt64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++){var d=jspb$1.arith.Int64.fromString(b[c]);this.encoder_.writeSplitVarint64(d.lo,d.hi);}this.endDelimited_(a);}};
	jspb$1.BinaryWriter.prototype.writePackedUint32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint32(b[c]);this.endDelimited_(a);}};jspb$1.BinaryWriter.prototype.writePackedUint32String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint32(parseInt(b[c],10));this.endDelimited_(a);}};
	jspb$1.BinaryWriter.prototype.writePackedUint64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint64(b[c]);this.endDelimited_(a);}};jspb$1.BinaryWriter.prototype.writePackedUint64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++){var d=jspb$1.arith.UInt64.fromString(b[c]);this.encoder_.writeSplitVarint64(d.lo,d.hi);}this.endDelimited_(a);}};
	jspb$1.BinaryWriter.prototype.writePackedSint32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarint32(b[c]);this.endDelimited_(a);}};jspb$1.BinaryWriter.prototype.writePackedSint64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarint64(b[c]);this.endDelimited_(a);}};
	jspb$1.BinaryWriter.prototype.writePackedSint64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarintHash64(jspb$1.utils.decimalStringToHash64(b[c]));this.endDelimited_(a);}};jspb$1.BinaryWriter.prototype.writePackedSintHash64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarintHash64(b[c]);this.endDelimited_(a);}};
	jspb$1.BinaryWriter.prototype.writePackedFixed32=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeUint32(b[a]);};jspb$1.BinaryWriter.prototype.writePackedFixed64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeUint64(b[a]);};
	jspb$1.BinaryWriter.prototype.writePackedFixed64String=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++){var c=jspb$1.arith.UInt64.fromString(b[a]);this.encoder_.writeSplitFixed64(c.lo,c.hi);}};
	jspb$1.BinaryWriter.prototype.writePackedSfixed32=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeInt32(b[a]);};jspb$1.BinaryWriter.prototype.writePackedSfixed64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeInt64(b[a]);};
	jspb$1.BinaryWriter.prototype.writePackedSfixed64String=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeInt64String(b[a]);};jspb$1.BinaryWriter.prototype.writePackedFloat=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeFloat(b[a]);};
	jspb$1.BinaryWriter.prototype.writePackedDouble=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeDouble(b[a]);};jspb$1.BinaryWriter.prototype.writePackedBool=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(b.length),a=0;a<b.length;a++)this.encoder_.writeBool(b[a]);};
	jspb$1.BinaryWriter.prototype.writePackedEnum=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeEnum(b[c]);this.endDelimited_(a);}};jspb$1.BinaryWriter.prototype.writePackedFixedHash64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb$1.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeFixedHash64(b[a]);};
	jspb$1.BinaryWriter.prototype.writePackedVarintHash64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeVarintHash64(b[c]);this.endDelimited_(a);}};jspb$1.Export={};var Map$2=jspb$1.Map;var Message$1=jspb$1.Message;var BinaryReader$1=jspb$1.BinaryReader;var BinaryWriter$1=jspb$1.BinaryWriter;var ExtensionFieldInfo$1=jspb$1.ExtensionFieldInfo;var ExtensionFieldBinaryInfo$1=jspb$1.ExtensionFieldBinaryInfo;var exportSymbol$1=goog$1.exportSymbol;var inherits$2=goog$1.inherits;var object$1={extend:goog$1.object.extend};var typeOf$1=goog$1.typeOf;

	var googleProtobuf$1 = {
		Map: Map$2,
		Message: Message$1,
		BinaryReader: BinaryReader$1,
		BinaryWriter: BinaryWriter$1,
		ExtensionFieldInfo: ExtensionFieldInfo$1,
		ExtensionFieldBinaryInfo: ExtensionFieldBinaryInfo$1,
		exportSymbol: exportSymbol$1,
		inherits: inherits$2,
		object: object$1,
		typeOf: typeOf$1
	};

	var field_mask_pb$1 = createCommonjsModule$1(function (module, exports) {
	// source: google/protobuf/field_mask.proto
	/**
	 * @fileoverview
	 * @enhanceable
	 * @suppress {messageConventions} JS Compiler reports an error if a variable or
	 *     field starts with 'MSG_' and isn't a translatable message.
	 * @public
	 */
	// GENERATED CODE -- DO NOT EDIT!


	var goog = googleProtobuf$1;
	var global = Function('return this')();

	goog.exportSymbol('proto.google.protobuf.FieldMask', null, global);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.google.protobuf.FieldMask = function(opt_data) {
	  googleProtobuf$1.Message.initialize(this, opt_data, 0, -1, proto.google.protobuf.FieldMask.repeatedFields_, null);
	};
	goog.inherits(proto.google.protobuf.FieldMask, googleProtobuf$1.Message);

	/**
	 * List of repeated fields within this message type.
	 * @private {!Array<number>}
	 * @const
	 */
	proto.google.protobuf.FieldMask.repeatedFields_ = [1];



	if (googleProtobuf$1.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * Optional fields that are not set will be set to undefined.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
	 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
	 *     JSPB instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.google.protobuf.FieldMask.prototype.toObject = function(opt_includeInstance) {
	  return proto.google.protobuf.FieldMask.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
	 *     the JSPB instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.google.protobuf.FieldMask} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.google.protobuf.FieldMask.toObject = function(includeInstance, msg) {
	  var f, obj = {
	    pathsList: (f = googleProtobuf$1.Message.getRepeatedField(msg, 1)) == null ? undefined : f
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.google.protobuf.FieldMask}
	 */
	proto.google.protobuf.FieldMask.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf$1.BinaryReader(bytes);
	  var msg = new proto.google.protobuf.FieldMask;
	  return proto.google.protobuf.FieldMask.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.google.protobuf.FieldMask} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.google.protobuf.FieldMask}
	 */
	proto.google.protobuf.FieldMask.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {string} */ (reader.readString());
	      msg.addPaths(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.google.protobuf.FieldMask.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf$1.BinaryWriter();
	  proto.google.protobuf.FieldMask.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.google.protobuf.FieldMask} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.google.protobuf.FieldMask.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getPathsList();
	  if (f.length > 0) {
	    writer.writeRepeatedString(
	      1,
	      f
	    );
	  }
	};


	/**
	 * repeated string paths = 1;
	 * @return {!Array<string>}
	 */
	proto.google.protobuf.FieldMask.prototype.getPathsList = function() {
	  return /** @type {!Array<string>} */ (googleProtobuf$1.Message.getRepeatedField(this, 1));
	};


	/**
	 * @param {!Array<string>} value
	 * @return {!proto.google.protobuf.FieldMask} returns this
	 */
	proto.google.protobuf.FieldMask.prototype.setPathsList = function(value) {
	  return googleProtobuf$1.Message.setField(this, 1, value || []);
	};


	/**
	 * @param {string} value
	 * @param {number=} opt_index
	 * @return {!proto.google.protobuf.FieldMask} returns this
	 */
	proto.google.protobuf.FieldMask.prototype.addPaths = function(value, opt_index) {
	  return googleProtobuf$1.Message.addToRepeatedField(this, 1, value, opt_index);
	};


	/**
	 * Clears the list making it empty but non-null.
	 * @return {!proto.google.protobuf.FieldMask} returns this
	 */
	proto.google.protobuf.FieldMask.prototype.clearPathsList = function() {
	  return this.setPathsList([]);
	};


	goog.object.extend(exports, proto.google.protobuf);
	});

	var types_pb$1 = createCommonjsModule$1(function (module, exports) {
	/**
	 * @fileoverview
	 * @enhanceable
	 * @suppress {messageConventions} JS Compiler reports an error if a variable or
	 *     field starts with 'MSG_' and isn't a translatable message.
	 * @public
	 */
	// GENERATED CODE -- DO NOT EDIT!


	var goog = googleProtobuf$1;
	var global = Function('return this')();

	goog.exportSymbol('proto.aitmed.ecos.v1beta1.Doc', null, global);
	goog.exportSymbol('proto.aitmed.ecos.v1beta1.Edge', null, global);
	goog.exportSymbol('proto.aitmed.ecos.v1beta1.Vertex', null, global);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.aitmed.ecos.v1beta1.Vertex = function(opt_data) {
	  googleProtobuf$1.Message.initialize(this, opt_data, 0, -1, null, null);
	};
	goog.inherits(proto.aitmed.ecos.v1beta1.Vertex, googleProtobuf$1.Message);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.aitmed.ecos.v1beta1.Edge = function(opt_data) {
	  googleProtobuf$1.Message.initialize(this, opt_data, 0, -1, null, null);
	};
	goog.inherits(proto.aitmed.ecos.v1beta1.Edge, googleProtobuf$1.Message);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.aitmed.ecos.v1beta1.Doc = function(opt_data) {
	  googleProtobuf$1.Message.initialize(this, opt_data, 0, -1, null, null);
	};
	goog.inherits(proto.aitmed.ecos.v1beta1.Doc, googleProtobuf$1.Message);



	if (googleProtobuf$1.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto suitable for use in Soy templates.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	 *     for transitional soy proto support: http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.toObject = function(opt_includeInstance) {
	  return proto.aitmed.ecos.v1beta1.Vertex.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Whether to include the JSPB
	 *     instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.aitmed.ecos.v1beta1.Vertex} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.Vertex.toObject = function(includeInstance, msg) {
	  var obj = {
	    ctime: googleProtobuf$1.Message.getFieldWithDefault(msg, 1, 0),
	    mtime: googleProtobuf$1.Message.getFieldWithDefault(msg, 2, 0),
	    atime: googleProtobuf$1.Message.getFieldWithDefault(msg, 3, 0),
	    atimes: googleProtobuf$1.Message.getFieldWithDefault(msg, 4, 0),
	    tage: googleProtobuf$1.Message.getFieldWithDefault(msg, 5, 0),
	    id: msg.getId_asB64(),
	    type: googleProtobuf$1.Message.getFieldWithDefault(msg, 7, 0),
	    name: googleProtobuf$1.Message.getFieldWithDefault(msg, 8, ""),
	    deat: googleProtobuf$1.Message.getFieldWithDefault(msg, 9, ""),
	    pk: msg.getPk_asB64(),
	    esk: msg.getEsk_asB64(),
	    uid: googleProtobuf$1.Message.getFieldWithDefault(msg, 12, "")
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.aitmed.ecos.v1beta1.Vertex}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf$1.BinaryReader(bytes);
	  var msg = new proto.aitmed.ecos.v1beta1.Vertex;
	  return proto.aitmed.ecos.v1beta1.Vertex.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.aitmed.ecos.v1beta1.Vertex} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.aitmed.ecos.v1beta1.Vertex}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {number} */ (reader.readInt64());
	      msg.setCtime(value);
	      break;
	    case 2:
	      var value = /** @type {number} */ (reader.readInt64());
	      msg.setMtime(value);
	      break;
	    case 3:
	      var value = /** @type {number} */ (reader.readInt64());
	      msg.setAtime(value);
	      break;
	    case 4:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setAtimes(value);
	      break;
	    case 5:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setTage(value);
	      break;
	    case 6:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.setId(value);
	      break;
	    case 7:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setType(value);
	      break;
	    case 8:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setName(value);
	      break;
	    case 9:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setDeat(value);
	      break;
	    case 10:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.setPk(value);
	      break;
	    case 11:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.setEsk(value);
	      break;
	    case 12:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setUid(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf$1.BinaryWriter();
	  proto.aitmed.ecos.v1beta1.Vertex.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.aitmed.ecos.v1beta1.Vertex} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.Vertex.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getCtime();
	  if (f !== 0) {
	    writer.writeInt64(
	      1,
	      f
	    );
	  }
	  f = message.getMtime();
	  if (f !== 0) {
	    writer.writeInt64(
	      2,
	      f
	    );
	  }
	  f = message.getAtime();
	  if (f !== 0) {
	    writer.writeInt64(
	      3,
	      f
	    );
	  }
	  f = message.getAtimes();
	  if (f !== 0) {
	    writer.writeInt32(
	      4,
	      f
	    );
	  }
	  f = message.getTage();
	  if (f !== 0) {
	    writer.writeInt32(
	      5,
	      f
	    );
	  }
	  f = message.getId_asU8();
	  if (f.length > 0) {
	    writer.writeBytes(
	      6,
	      f
	    );
	  }
	  f = message.getType();
	  if (f !== 0) {
	    writer.writeInt32(
	      7,
	      f
	    );
	  }
	  f = message.getName();
	  if (f.length > 0) {
	    writer.writeString(
	      8,
	      f
	    );
	  }
	  f = message.getDeat();
	  if (f.length > 0) {
	    writer.writeString(
	      9,
	      f
	    );
	  }
	  f = message.getPk_asU8();
	  if (f.length > 0) {
	    writer.writeBytes(
	      10,
	      f
	    );
	  }
	  f = message.getEsk_asU8();
	  if (f.length > 0) {
	    writer.writeBytes(
	      11,
	      f
	    );
	  }
	  f = message.getUid();
	  if (f.length > 0) {
	    writer.writeString(
	      12,
	      f
	    );
	  }
	};


	/**
	 * optional int64 ctime = 1;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getCtime = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 1, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.setCtime = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 1, value);
	};


	/**
	 * optional int64 mtime = 2;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getMtime = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 2, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.setMtime = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 2, value);
	};


	/**
	 * optional int64 atime = 3;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getAtime = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 3, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.setAtime = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 3, value);
	};


	/**
	 * optional int32 atimes = 4;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getAtimes = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 4, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.setAtimes = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 4, value);
	};


	/**
	 * optional int32 tage = 5;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getTage = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 5, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.setTage = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 5, value);
	};


	/**
	 * optional bytes id = 6;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getId = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 6, ""));
	};


	/**
	 * optional bytes id = 6;
	 * This is a type-conversion wrapper around `getId()`
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getId_asB64 = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.bytesAsB64(
	      this.getId()));
	};


	/**
	 * optional bytes id = 6;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getId()`
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getId_asU8 = function() {
	  return /** @type {!Uint8Array} */ (googleProtobuf$1.Message.bytesAsU8(
	      this.getId()));
	};


	/** @param {!(string|Uint8Array)} value */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.setId = function(value) {
	  googleProtobuf$1.Message.setProto3BytesField(this, 6, value);
	};


	/**
	 * optional int32 type = 7;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getType = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 7, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.setType = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 7, value);
	};


	/**
	 * optional string name = 8;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getName = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 8, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.setName = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 8, value);
	};


	/**
	 * optional string deat = 9;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getDeat = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 9, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.setDeat = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 9, value);
	};


	/**
	 * optional bytes pk = 10;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getPk = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 10, ""));
	};


	/**
	 * optional bytes pk = 10;
	 * This is a type-conversion wrapper around `getPk()`
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getPk_asB64 = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.bytesAsB64(
	      this.getPk()));
	};


	/**
	 * optional bytes pk = 10;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getPk()`
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getPk_asU8 = function() {
	  return /** @type {!Uint8Array} */ (googleProtobuf$1.Message.bytesAsU8(
	      this.getPk()));
	};


	/** @param {!(string|Uint8Array)} value */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.setPk = function(value) {
	  googleProtobuf$1.Message.setProto3BytesField(this, 10, value);
	};


	/**
	 * optional bytes esk = 11;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getEsk = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 11, ""));
	};


	/**
	 * optional bytes esk = 11;
	 * This is a type-conversion wrapper around `getEsk()`
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getEsk_asB64 = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.bytesAsB64(
	      this.getEsk()));
	};


	/**
	 * optional bytes esk = 11;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getEsk()`
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getEsk_asU8 = function() {
	  return /** @type {!Uint8Array} */ (googleProtobuf$1.Message.bytesAsU8(
	      this.getEsk()));
	};


	/** @param {!(string|Uint8Array)} value */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.setEsk = function(value) {
	  googleProtobuf$1.Message.setProto3BytesField(this, 11, value);
	};


	/**
	 * optional string uid = 12;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.getUid = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 12, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.Vertex.prototype.setUid = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 12, value);
	};





	if (googleProtobuf$1.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto suitable for use in Soy templates.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	 *     for transitional soy proto support: http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.toObject = function(opt_includeInstance) {
	  return proto.aitmed.ecos.v1beta1.Edge.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Whether to include the JSPB
	 *     instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.aitmed.ecos.v1beta1.Edge} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.Edge.toObject = function(includeInstance, msg) {
	  var obj = {
	    ctime: googleProtobuf$1.Message.getFieldWithDefault(msg, 1, 0),
	    mtime: googleProtobuf$1.Message.getFieldWithDefault(msg, 2, 0),
	    atime: googleProtobuf$1.Message.getFieldWithDefault(msg, 3, 0),
	    atimes: googleProtobuf$1.Message.getFieldWithDefault(msg, 4, 0),
	    tage: googleProtobuf$1.Message.getFieldWithDefault(msg, 5, 0),
	    id: msg.getId_asB64(),
	    type: googleProtobuf$1.Message.getFieldWithDefault(msg, 7, 0),
	    name: googleProtobuf$1.Message.getFieldWithDefault(msg, 8, ""),
	    deat: googleProtobuf$1.Message.getFieldWithDefault(msg, 9, ""),
	    subtype: googleProtobuf$1.Message.getFieldWithDefault(msg, 10, 0),
	    bvid: msg.getBvid_asB64(),
	    evid: msg.getEvid_asB64(),
	    stime: googleProtobuf$1.Message.getFieldWithDefault(msg, 13, 0),
	    etime: googleProtobuf$1.Message.getFieldWithDefault(msg, 14, 0),
	    refid: msg.getRefid_asB64(),
	    besak: msg.getBesak_asB64(),
	    eesak: msg.getEesak_asB64(),
	    sig: msg.getSig_asB64()
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.aitmed.ecos.v1beta1.Edge}
	 */
	proto.aitmed.ecos.v1beta1.Edge.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf$1.BinaryReader(bytes);
	  var msg = new proto.aitmed.ecos.v1beta1.Edge;
	  return proto.aitmed.ecos.v1beta1.Edge.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.aitmed.ecos.v1beta1.Edge} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.aitmed.ecos.v1beta1.Edge}
	 */
	proto.aitmed.ecos.v1beta1.Edge.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {number} */ (reader.readInt64());
	      msg.setCtime(value);
	      break;
	    case 2:
	      var value = /** @type {number} */ (reader.readInt64());
	      msg.setMtime(value);
	      break;
	    case 3:
	      var value = /** @type {number} */ (reader.readInt64());
	      msg.setAtime(value);
	      break;
	    case 4:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setAtimes(value);
	      break;
	    case 5:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setTage(value);
	      break;
	    case 6:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.setId(value);
	      break;
	    case 7:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setType(value);
	      break;
	    case 8:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setName(value);
	      break;
	    case 9:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setDeat(value);
	      break;
	    case 10:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setSubtype(value);
	      break;
	    case 11:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.setBvid(value);
	      break;
	    case 12:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.setEvid(value);
	      break;
	    case 13:
	      var value = /** @type {number} */ (reader.readInt64());
	      msg.setStime(value);
	      break;
	    case 14:
	      var value = /** @type {number} */ (reader.readInt64());
	      msg.setEtime(value);
	      break;
	    case 15:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.setRefid(value);
	      break;
	    case 16:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.setBesak(value);
	      break;
	    case 17:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.setEesak(value);
	      break;
	    case 18:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.setSig(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf$1.BinaryWriter();
	  proto.aitmed.ecos.v1beta1.Edge.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.aitmed.ecos.v1beta1.Edge} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.Edge.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getCtime();
	  if (f !== 0) {
	    writer.writeInt64(
	      1,
	      f
	    );
	  }
	  f = message.getMtime();
	  if (f !== 0) {
	    writer.writeInt64(
	      2,
	      f
	    );
	  }
	  f = message.getAtime();
	  if (f !== 0) {
	    writer.writeInt64(
	      3,
	      f
	    );
	  }
	  f = message.getAtimes();
	  if (f !== 0) {
	    writer.writeInt32(
	      4,
	      f
	    );
	  }
	  f = message.getTage();
	  if (f !== 0) {
	    writer.writeInt32(
	      5,
	      f
	    );
	  }
	  f = message.getId_asU8();
	  if (f.length > 0) {
	    writer.writeBytes(
	      6,
	      f
	    );
	  }
	  f = message.getType();
	  if (f !== 0) {
	    writer.writeInt32(
	      7,
	      f
	    );
	  }
	  f = message.getName();
	  if (f.length > 0) {
	    writer.writeString(
	      8,
	      f
	    );
	  }
	  f = message.getDeat();
	  if (f.length > 0) {
	    writer.writeString(
	      9,
	      f
	    );
	  }
	  f = message.getSubtype();
	  if (f !== 0) {
	    writer.writeInt32(
	      10,
	      f
	    );
	  }
	  f = message.getBvid_asU8();
	  if (f.length > 0) {
	    writer.writeBytes(
	      11,
	      f
	    );
	  }
	  f = message.getEvid_asU8();
	  if (f.length > 0) {
	    writer.writeBytes(
	      12,
	      f
	    );
	  }
	  f = message.getStime();
	  if (f !== 0) {
	    writer.writeInt64(
	      13,
	      f
	    );
	  }
	  f = message.getEtime();
	  if (f !== 0) {
	    writer.writeInt64(
	      14,
	      f
	    );
	  }
	  f = message.getRefid_asU8();
	  if (f.length > 0) {
	    writer.writeBytes(
	      15,
	      f
	    );
	  }
	  f = message.getBesak_asU8();
	  if (f.length > 0) {
	    writer.writeBytes(
	      16,
	      f
	    );
	  }
	  f = message.getEesak_asU8();
	  if (f.length > 0) {
	    writer.writeBytes(
	      17,
	      f
	    );
	  }
	  f = message.getSig_asU8();
	  if (f.length > 0) {
	    writer.writeBytes(
	      18,
	      f
	    );
	  }
	};


	/**
	 * optional int64 ctime = 1;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getCtime = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 1, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setCtime = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 1, value);
	};


	/**
	 * optional int64 mtime = 2;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getMtime = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 2, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setMtime = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 2, value);
	};


	/**
	 * optional int64 atime = 3;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getAtime = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 3, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setAtime = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 3, value);
	};


	/**
	 * optional int32 atimes = 4;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getAtimes = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 4, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setAtimes = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 4, value);
	};


	/**
	 * optional int32 tage = 5;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getTage = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 5, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setTage = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 5, value);
	};


	/**
	 * optional bytes id = 6;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getId = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 6, ""));
	};


	/**
	 * optional bytes id = 6;
	 * This is a type-conversion wrapper around `getId()`
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getId_asB64 = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.bytesAsB64(
	      this.getId()));
	};


	/**
	 * optional bytes id = 6;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getId()`
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getId_asU8 = function() {
	  return /** @type {!Uint8Array} */ (googleProtobuf$1.Message.bytesAsU8(
	      this.getId()));
	};


	/** @param {!(string|Uint8Array)} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setId = function(value) {
	  googleProtobuf$1.Message.setProto3BytesField(this, 6, value);
	};


	/**
	 * optional int32 type = 7;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getType = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 7, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setType = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 7, value);
	};


	/**
	 * optional string name = 8;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getName = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 8, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setName = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 8, value);
	};


	/**
	 * optional string deat = 9;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getDeat = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 9, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setDeat = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 9, value);
	};


	/**
	 * optional int32 subtype = 10;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getSubtype = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 10, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setSubtype = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 10, value);
	};


	/**
	 * optional bytes bvid = 11;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getBvid = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 11, ""));
	};


	/**
	 * optional bytes bvid = 11;
	 * This is a type-conversion wrapper around `getBvid()`
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getBvid_asB64 = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.bytesAsB64(
	      this.getBvid()));
	};


	/**
	 * optional bytes bvid = 11;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getBvid()`
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getBvid_asU8 = function() {
	  return /** @type {!Uint8Array} */ (googleProtobuf$1.Message.bytesAsU8(
	      this.getBvid()));
	};


	/** @param {!(string|Uint8Array)} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setBvid = function(value) {
	  googleProtobuf$1.Message.setProto3BytesField(this, 11, value);
	};


	/**
	 * optional bytes evid = 12;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getEvid = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 12, ""));
	};


	/**
	 * optional bytes evid = 12;
	 * This is a type-conversion wrapper around `getEvid()`
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getEvid_asB64 = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.bytesAsB64(
	      this.getEvid()));
	};


	/**
	 * optional bytes evid = 12;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getEvid()`
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getEvid_asU8 = function() {
	  return /** @type {!Uint8Array} */ (googleProtobuf$1.Message.bytesAsU8(
	      this.getEvid()));
	};


	/** @param {!(string|Uint8Array)} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setEvid = function(value) {
	  googleProtobuf$1.Message.setProto3BytesField(this, 12, value);
	};


	/**
	 * optional int64 stime = 13;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getStime = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 13, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setStime = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 13, value);
	};


	/**
	 * optional int64 etime = 14;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getEtime = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 14, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setEtime = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 14, value);
	};


	/**
	 * optional bytes refid = 15;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getRefid = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 15, ""));
	};


	/**
	 * optional bytes refid = 15;
	 * This is a type-conversion wrapper around `getRefid()`
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getRefid_asB64 = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.bytesAsB64(
	      this.getRefid()));
	};


	/**
	 * optional bytes refid = 15;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getRefid()`
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getRefid_asU8 = function() {
	  return /** @type {!Uint8Array} */ (googleProtobuf$1.Message.bytesAsU8(
	      this.getRefid()));
	};


	/** @param {!(string|Uint8Array)} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setRefid = function(value) {
	  googleProtobuf$1.Message.setProto3BytesField(this, 15, value);
	};


	/**
	 * optional bytes besak = 16;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getBesak = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 16, ""));
	};


	/**
	 * optional bytes besak = 16;
	 * This is a type-conversion wrapper around `getBesak()`
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getBesak_asB64 = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.bytesAsB64(
	      this.getBesak()));
	};


	/**
	 * optional bytes besak = 16;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getBesak()`
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getBesak_asU8 = function() {
	  return /** @type {!Uint8Array} */ (googleProtobuf$1.Message.bytesAsU8(
	      this.getBesak()));
	};


	/** @param {!(string|Uint8Array)} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setBesak = function(value) {
	  googleProtobuf$1.Message.setProto3BytesField(this, 16, value);
	};


	/**
	 * optional bytes eesak = 17;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getEesak = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 17, ""));
	};


	/**
	 * optional bytes eesak = 17;
	 * This is a type-conversion wrapper around `getEesak()`
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getEesak_asB64 = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.bytesAsB64(
	      this.getEesak()));
	};


	/**
	 * optional bytes eesak = 17;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getEesak()`
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getEesak_asU8 = function() {
	  return /** @type {!Uint8Array} */ (googleProtobuf$1.Message.bytesAsU8(
	      this.getEesak()));
	};


	/** @param {!(string|Uint8Array)} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setEesak = function(value) {
	  googleProtobuf$1.Message.setProto3BytesField(this, 17, value);
	};


	/**
	 * optional bytes sig = 18;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getSig = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 18, ""));
	};


	/**
	 * optional bytes sig = 18;
	 * This is a type-conversion wrapper around `getSig()`
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getSig_asB64 = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.bytesAsB64(
	      this.getSig()));
	};


	/**
	 * optional bytes sig = 18;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getSig()`
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Edge.prototype.getSig_asU8 = function() {
	  return /** @type {!Uint8Array} */ (googleProtobuf$1.Message.bytesAsU8(
	      this.getSig()));
	};


	/** @param {!(string|Uint8Array)} value */
	proto.aitmed.ecos.v1beta1.Edge.prototype.setSig = function(value) {
	  googleProtobuf$1.Message.setProto3BytesField(this, 18, value);
	};





	if (googleProtobuf$1.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto suitable for use in Soy templates.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	 *     for transitional soy proto support: http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.toObject = function(opt_includeInstance) {
	  return proto.aitmed.ecos.v1beta1.Doc.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Whether to include the JSPB
	 *     instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.aitmed.ecos.v1beta1.Doc} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.Doc.toObject = function(includeInstance, msg) {
	  var obj = {
	    ctime: googleProtobuf$1.Message.getFieldWithDefault(msg, 1, 0),
	    mtime: googleProtobuf$1.Message.getFieldWithDefault(msg, 2, 0),
	    atime: googleProtobuf$1.Message.getFieldWithDefault(msg, 3, 0),
	    atimes: googleProtobuf$1.Message.getFieldWithDefault(msg, 4, 0),
	    tage: googleProtobuf$1.Message.getFieldWithDefault(msg, 5, 0),
	    id: msg.getId_asB64(),
	    type: googleProtobuf$1.Message.getFieldWithDefault(msg, 7, 0),
	    name: googleProtobuf$1.Message.getFieldWithDefault(msg, 8, ""),
	    deat: googleProtobuf$1.Message.getFieldWithDefault(msg, 9, ""),
	    size: googleProtobuf$1.Message.getFieldWithDefault(msg, 10, 0),
	    fid: msg.getFid_asB64(),
	    eid: msg.getEid_asB64(),
	    bsig: msg.getBsig_asB64(),
	    esig: msg.getEsig_asB64()
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.aitmed.ecos.v1beta1.Doc}
	 */
	proto.aitmed.ecos.v1beta1.Doc.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf$1.BinaryReader(bytes);
	  var msg = new proto.aitmed.ecos.v1beta1.Doc;
	  return proto.aitmed.ecos.v1beta1.Doc.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.aitmed.ecos.v1beta1.Doc} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.aitmed.ecos.v1beta1.Doc}
	 */
	proto.aitmed.ecos.v1beta1.Doc.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {number} */ (reader.readInt64());
	      msg.setCtime(value);
	      break;
	    case 2:
	      var value = /** @type {number} */ (reader.readInt64());
	      msg.setMtime(value);
	      break;
	    case 3:
	      var value = /** @type {number} */ (reader.readInt64());
	      msg.setAtime(value);
	      break;
	    case 4:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setAtimes(value);
	      break;
	    case 5:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setTage(value);
	      break;
	    case 6:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.setId(value);
	      break;
	    case 7:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setType(value);
	      break;
	    case 8:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setName(value);
	      break;
	    case 9:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setDeat(value);
	      break;
	    case 10:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setSize(value);
	      break;
	    case 11:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.setFid(value);
	      break;
	    case 12:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.setEid(value);
	      break;
	    case 13:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.setBsig(value);
	      break;
	    case 14:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.setEsig(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf$1.BinaryWriter();
	  proto.aitmed.ecos.v1beta1.Doc.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.aitmed.ecos.v1beta1.Doc} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.Doc.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getCtime();
	  if (f !== 0) {
	    writer.writeInt64(
	      1,
	      f
	    );
	  }
	  f = message.getMtime();
	  if (f !== 0) {
	    writer.writeInt64(
	      2,
	      f
	    );
	  }
	  f = message.getAtime();
	  if (f !== 0) {
	    writer.writeInt64(
	      3,
	      f
	    );
	  }
	  f = message.getAtimes();
	  if (f !== 0) {
	    writer.writeInt32(
	      4,
	      f
	    );
	  }
	  f = message.getTage();
	  if (f !== 0) {
	    writer.writeInt32(
	      5,
	      f
	    );
	  }
	  f = message.getId_asU8();
	  if (f.length > 0) {
	    writer.writeBytes(
	      6,
	      f
	    );
	  }
	  f = message.getType();
	  if (f !== 0) {
	    writer.writeInt32(
	      7,
	      f
	    );
	  }
	  f = message.getName();
	  if (f.length > 0) {
	    writer.writeString(
	      8,
	      f
	    );
	  }
	  f = message.getDeat();
	  if (f.length > 0) {
	    writer.writeString(
	      9,
	      f
	    );
	  }
	  f = message.getSize();
	  if (f !== 0) {
	    writer.writeInt32(
	      10,
	      f
	    );
	  }
	  f = message.getFid_asU8();
	  if (f.length > 0) {
	    writer.writeBytes(
	      11,
	      f
	    );
	  }
	  f = message.getEid_asU8();
	  if (f.length > 0) {
	    writer.writeBytes(
	      12,
	      f
	    );
	  }
	  f = message.getBsig_asU8();
	  if (f.length > 0) {
	    writer.writeBytes(
	      13,
	      f
	    );
	  }
	  f = message.getEsig_asU8();
	  if (f.length > 0) {
	    writer.writeBytes(
	      14,
	      f
	    );
	  }
	};


	/**
	 * optional int64 ctime = 1;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getCtime = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 1, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Doc.prototype.setCtime = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 1, value);
	};


	/**
	 * optional int64 mtime = 2;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getMtime = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 2, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Doc.prototype.setMtime = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 2, value);
	};


	/**
	 * optional int64 atime = 3;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getAtime = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 3, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Doc.prototype.setAtime = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 3, value);
	};


	/**
	 * optional int32 atimes = 4;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getAtimes = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 4, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Doc.prototype.setAtimes = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 4, value);
	};


	/**
	 * optional int32 tage = 5;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getTage = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 5, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Doc.prototype.setTage = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 5, value);
	};


	/**
	 * optional bytes id = 6;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getId = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 6, ""));
	};


	/**
	 * optional bytes id = 6;
	 * This is a type-conversion wrapper around `getId()`
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getId_asB64 = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.bytesAsB64(
	      this.getId()));
	};


	/**
	 * optional bytes id = 6;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getId()`
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getId_asU8 = function() {
	  return /** @type {!Uint8Array} */ (googleProtobuf$1.Message.bytesAsU8(
	      this.getId()));
	};


	/** @param {!(string|Uint8Array)} value */
	proto.aitmed.ecos.v1beta1.Doc.prototype.setId = function(value) {
	  googleProtobuf$1.Message.setProto3BytesField(this, 6, value);
	};


	/**
	 * optional int32 type = 7;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getType = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 7, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Doc.prototype.setType = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 7, value);
	};


	/**
	 * optional string name = 8;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getName = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 8, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.Doc.prototype.setName = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 8, value);
	};


	/**
	 * optional string deat = 9;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getDeat = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 9, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.Doc.prototype.setDeat = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 9, value);
	};


	/**
	 * optional int32 size = 10;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getSize = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 10, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.Doc.prototype.setSize = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 10, value);
	};


	/**
	 * optional bytes fid = 11;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getFid = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 11, ""));
	};


	/**
	 * optional bytes fid = 11;
	 * This is a type-conversion wrapper around `getFid()`
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getFid_asB64 = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.bytesAsB64(
	      this.getFid()));
	};


	/**
	 * optional bytes fid = 11;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getFid()`
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getFid_asU8 = function() {
	  return /** @type {!Uint8Array} */ (googleProtobuf$1.Message.bytesAsU8(
	      this.getFid()));
	};


	/** @param {!(string|Uint8Array)} value */
	proto.aitmed.ecos.v1beta1.Doc.prototype.setFid = function(value) {
	  googleProtobuf$1.Message.setProto3BytesField(this, 11, value);
	};


	/**
	 * optional bytes eid = 12;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getEid = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 12, ""));
	};


	/**
	 * optional bytes eid = 12;
	 * This is a type-conversion wrapper around `getEid()`
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getEid_asB64 = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.bytesAsB64(
	      this.getEid()));
	};


	/**
	 * optional bytes eid = 12;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getEid()`
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getEid_asU8 = function() {
	  return /** @type {!Uint8Array} */ (googleProtobuf$1.Message.bytesAsU8(
	      this.getEid()));
	};


	/** @param {!(string|Uint8Array)} value */
	proto.aitmed.ecos.v1beta1.Doc.prototype.setEid = function(value) {
	  googleProtobuf$1.Message.setProto3BytesField(this, 12, value);
	};


	/**
	 * optional bytes bsig = 13;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getBsig = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 13, ""));
	};


	/**
	 * optional bytes bsig = 13;
	 * This is a type-conversion wrapper around `getBsig()`
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getBsig_asB64 = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.bytesAsB64(
	      this.getBsig()));
	};


	/**
	 * optional bytes bsig = 13;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getBsig()`
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getBsig_asU8 = function() {
	  return /** @type {!Uint8Array} */ (googleProtobuf$1.Message.bytesAsU8(
	      this.getBsig()));
	};


	/** @param {!(string|Uint8Array)} value */
	proto.aitmed.ecos.v1beta1.Doc.prototype.setBsig = function(value) {
	  googleProtobuf$1.Message.setProto3BytesField(this, 13, value);
	};


	/**
	 * optional bytes esig = 14;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getEsig = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 14, ""));
	};


	/**
	 * optional bytes esig = 14;
	 * This is a type-conversion wrapper around `getEsig()`
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getEsig_asB64 = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.bytesAsB64(
	      this.getEsig()));
	};


	/**
	 * optional bytes esig = 14;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getEsig()`
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.Doc.prototype.getEsig_asU8 = function() {
	  return /** @type {!Uint8Array} */ (googleProtobuf$1.Message.bytesAsU8(
	      this.getEsig()));
	};


	/** @param {!(string|Uint8Array)} value */
	proto.aitmed.ecos.v1beta1.Doc.prototype.setEsig = function(value) {
	  googleProtobuf$1.Message.setProto3BytesField(this, 14, value);
	};


	goog.object.extend(exports, proto.aitmed.ecos.v1beta1);
	});
	var types_pb_1$1 = types_pb$1.Edge;
	var types_pb_2$1 = types_pb$1.Vertex;
	var types_pb_3$1 = types_pb$1.Doc;

	var ecos_api_pb$1 = createCommonjsModule$1(function (module, exports) {
	/**
	 * @fileoverview
	 * @enhanceable
	 * @suppress {messageConventions} JS Compiler reports an error if a variable or
	 *     field starts with 'MSG_' and isn't a translatable message.
	 * @public
	 */
	// GENERATED CODE -- DO NOT EDIT!


	var goog = googleProtobuf$1;
	var global = Function('return this')();


	goog.object.extend(proto, field_mask_pb$1);

	goog.object.extend(proto, types_pb$1);
	goog.exportSymbol('proto.aitmed.ecos.v1beta1.cdReq', null, global);
	goog.exportSymbol('proto.aitmed.ecos.v1beta1.cdResp', null, global);
	goog.exportSymbol('proto.aitmed.ecos.v1beta1.ceReq', null, global);
	goog.exportSymbol('proto.aitmed.ecos.v1beta1.ceResp', null, global);
	goog.exportSymbol('proto.aitmed.ecos.v1beta1.cvReq', null, global);
	goog.exportSymbol('proto.aitmed.ecos.v1beta1.cvResp', null, global);
	goog.exportSymbol('proto.aitmed.ecos.v1beta1.dxReq', null, global);
	goog.exportSymbol('proto.aitmed.ecos.v1beta1.dxResp', null, global);
	goog.exportSymbol('proto.aitmed.ecos.v1beta1.rdResp', null, global);
	goog.exportSymbol('proto.aitmed.ecos.v1beta1.reResp', null, global);
	goog.exportSymbol('proto.aitmed.ecos.v1beta1.rvResp', null, global);
	goog.exportSymbol('proto.aitmed.ecos.v1beta1.rxReq', null, global);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.aitmed.ecos.v1beta1.ceReq = function(opt_data) {
	  googleProtobuf$1.Message.initialize(this, opt_data, 0, -1, null, null);
	};
	goog.inherits(proto.aitmed.ecos.v1beta1.ceReq, googleProtobuf$1.Message);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.aitmed.ecos.v1beta1.ceResp = function(opt_data) {
	  googleProtobuf$1.Message.initialize(this, opt_data, 0, -1, null, null);
	};
	goog.inherits(proto.aitmed.ecos.v1beta1.ceResp, googleProtobuf$1.Message);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.aitmed.ecos.v1beta1.rxReq = function(opt_data) {
	  googleProtobuf$1.Message.initialize(this, opt_data, 0, -1, proto.aitmed.ecos.v1beta1.rxReq.repeatedFields_, null);
	};
	goog.inherits(proto.aitmed.ecos.v1beta1.rxReq, googleProtobuf$1.Message);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.aitmed.ecos.v1beta1.reResp = function(opt_data) {
	  googleProtobuf$1.Message.initialize(this, opt_data, 0, -1, proto.aitmed.ecos.v1beta1.reResp.repeatedFields_, null);
	};
	goog.inherits(proto.aitmed.ecos.v1beta1.reResp, googleProtobuf$1.Message);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.aitmed.ecos.v1beta1.rvResp = function(opt_data) {
	  googleProtobuf$1.Message.initialize(this, opt_data, 0, -1, proto.aitmed.ecos.v1beta1.rvResp.repeatedFields_, null);
	};
	goog.inherits(proto.aitmed.ecos.v1beta1.rvResp, googleProtobuf$1.Message);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.aitmed.ecos.v1beta1.rdResp = function(opt_data) {
	  googleProtobuf$1.Message.initialize(this, opt_data, 0, -1, proto.aitmed.ecos.v1beta1.rdResp.repeatedFields_, null);
	};
	goog.inherits(proto.aitmed.ecos.v1beta1.rdResp, googleProtobuf$1.Message);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.aitmed.ecos.v1beta1.dxReq = function(opt_data) {
	  googleProtobuf$1.Message.initialize(this, opt_data, 0, -1, proto.aitmed.ecos.v1beta1.dxReq.repeatedFields_, null);
	};
	goog.inherits(proto.aitmed.ecos.v1beta1.dxReq, googleProtobuf$1.Message);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.aitmed.ecos.v1beta1.dxResp = function(opt_data) {
	  googleProtobuf$1.Message.initialize(this, opt_data, 0, -1, null, null);
	};
	goog.inherits(proto.aitmed.ecos.v1beta1.dxResp, googleProtobuf$1.Message);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.aitmed.ecos.v1beta1.cvReq = function(opt_data) {
	  googleProtobuf$1.Message.initialize(this, opt_data, 0, -1, null, null);
	};
	goog.inherits(proto.aitmed.ecos.v1beta1.cvReq, googleProtobuf$1.Message);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.aitmed.ecos.v1beta1.cvResp = function(opt_data) {
	  googleProtobuf$1.Message.initialize(this, opt_data, 0, -1, null, null);
	};
	goog.inherits(proto.aitmed.ecos.v1beta1.cvResp, googleProtobuf$1.Message);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.aitmed.ecos.v1beta1.cdReq = function(opt_data) {
	  googleProtobuf$1.Message.initialize(this, opt_data, 0, -1, null, null);
	};
	goog.inherits(proto.aitmed.ecos.v1beta1.cdReq, googleProtobuf$1.Message);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.aitmed.ecos.v1beta1.cdResp = function(opt_data) {
	  googleProtobuf$1.Message.initialize(this, opt_data, 0, -1, null, null);
	};
	goog.inherits(proto.aitmed.ecos.v1beta1.cdResp, googleProtobuf$1.Message);



	if (googleProtobuf$1.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto suitable for use in Soy templates.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	 *     for transitional soy proto support: http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.aitmed.ecos.v1beta1.ceReq.prototype.toObject = function(opt_includeInstance) {
	  return proto.aitmed.ecos.v1beta1.ceReq.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Whether to include the JSPB
	 *     instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.aitmed.ecos.v1beta1.ceReq} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.ceReq.toObject = function(includeInstance, msg) {
	  var f, obj = {
	    jwt: googleProtobuf$1.Message.getFieldWithDefault(msg, 1, ""),
	    pmask: (f = msg.getPmask()) && field_mask_pb$1.FieldMask.toObject(includeInstance, f),
	    rmask: (f = msg.getRmask()) && field_mask_pb$1.FieldMask.toObject(includeInstance, f),
	    edge: (f = msg.getEdge()) && types_pb$1.Edge.toObject(includeInstance, f)
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.aitmed.ecos.v1beta1.ceReq}
	 */
	proto.aitmed.ecos.v1beta1.ceReq.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf$1.BinaryReader(bytes);
	  var msg = new proto.aitmed.ecos.v1beta1.ceReq;
	  return proto.aitmed.ecos.v1beta1.ceReq.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.aitmed.ecos.v1beta1.ceReq} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.aitmed.ecos.v1beta1.ceReq}
	 */
	proto.aitmed.ecos.v1beta1.ceReq.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setJwt(value);
	      break;
	    case 2:
	      var value = new field_mask_pb$1.FieldMask;
	      reader.readMessage(value,field_mask_pb$1.FieldMask.deserializeBinaryFromReader);
	      msg.setPmask(value);
	      break;
	    case 3:
	      var value = new field_mask_pb$1.FieldMask;
	      reader.readMessage(value,field_mask_pb$1.FieldMask.deserializeBinaryFromReader);
	      msg.setRmask(value);
	      break;
	    case 4:
	      var value = new types_pb$1.Edge;
	      reader.readMessage(value,types_pb$1.Edge.deserializeBinaryFromReader);
	      msg.setEdge(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.ceReq.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf$1.BinaryWriter();
	  proto.aitmed.ecos.v1beta1.ceReq.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.aitmed.ecos.v1beta1.ceReq} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.ceReq.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getJwt();
	  if (f.length > 0) {
	    writer.writeString(
	      1,
	      f
	    );
	  }
	  f = message.getPmask();
	  if (f != null) {
	    writer.writeMessage(
	      2,
	      f,
	      field_mask_pb$1.FieldMask.serializeBinaryToWriter
	    );
	  }
	  f = message.getRmask();
	  if (f != null) {
	    writer.writeMessage(
	      3,
	      f,
	      field_mask_pb$1.FieldMask.serializeBinaryToWriter
	    );
	  }
	  f = message.getEdge();
	  if (f != null) {
	    writer.writeMessage(
	      4,
	      f,
	      types_pb$1.Edge.serializeBinaryToWriter
	    );
	  }
	};


	/**
	 * optional string jwt = 1;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.ceReq.prototype.getJwt = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 1, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.ceReq.prototype.setJwt = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 1, value);
	};


	/**
	 * optional google.protobuf.FieldMask pmask = 2;
	 * @return {?proto.google.protobuf.FieldMask}
	 */
	proto.aitmed.ecos.v1beta1.ceReq.prototype.getPmask = function() {
	  return /** @type{?proto.google.protobuf.FieldMask} */ (
	    googleProtobuf$1.Message.getWrapperField(this, field_mask_pb$1.FieldMask, 2));
	};


	/** @param {?proto.google.protobuf.FieldMask|undefined} value */
	proto.aitmed.ecos.v1beta1.ceReq.prototype.setPmask = function(value) {
	  googleProtobuf$1.Message.setWrapperField(this, 2, value);
	};


	/**
	 * Clears the message field making it undefined.
	 */
	proto.aitmed.ecos.v1beta1.ceReq.prototype.clearPmask = function() {
	  this.setPmask(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.aitmed.ecos.v1beta1.ceReq.prototype.hasPmask = function() {
	  return googleProtobuf$1.Message.getField(this, 2) != null;
	};


	/**
	 * optional google.protobuf.FieldMask rmask = 3;
	 * @return {?proto.google.protobuf.FieldMask}
	 */
	proto.aitmed.ecos.v1beta1.ceReq.prototype.getRmask = function() {
	  return /** @type{?proto.google.protobuf.FieldMask} */ (
	    googleProtobuf$1.Message.getWrapperField(this, field_mask_pb$1.FieldMask, 3));
	};


	/** @param {?proto.google.protobuf.FieldMask|undefined} value */
	proto.aitmed.ecos.v1beta1.ceReq.prototype.setRmask = function(value) {
	  googleProtobuf$1.Message.setWrapperField(this, 3, value);
	};


	/**
	 * Clears the message field making it undefined.
	 */
	proto.aitmed.ecos.v1beta1.ceReq.prototype.clearRmask = function() {
	  this.setRmask(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.aitmed.ecos.v1beta1.ceReq.prototype.hasRmask = function() {
	  return googleProtobuf$1.Message.getField(this, 3) != null;
	};


	/**
	 * optional Edge edge = 4;
	 * @return {?proto.aitmed.ecos.v1beta1.Edge}
	 */
	proto.aitmed.ecos.v1beta1.ceReq.prototype.getEdge = function() {
	  return /** @type{?proto.aitmed.ecos.v1beta1.Edge} */ (
	    googleProtobuf$1.Message.getWrapperField(this, types_pb$1.Edge, 4));
	};


	/** @param {?proto.aitmed.ecos.v1beta1.Edge|undefined} value */
	proto.aitmed.ecos.v1beta1.ceReq.prototype.setEdge = function(value) {
	  googleProtobuf$1.Message.setWrapperField(this, 4, value);
	};


	/**
	 * Clears the message field making it undefined.
	 */
	proto.aitmed.ecos.v1beta1.ceReq.prototype.clearEdge = function() {
	  this.setEdge(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.aitmed.ecos.v1beta1.ceReq.prototype.hasEdge = function() {
	  return googleProtobuf$1.Message.getField(this, 4) != null;
	};





	if (googleProtobuf$1.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto suitable for use in Soy templates.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	 *     for transitional soy proto support: http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.aitmed.ecos.v1beta1.ceResp.prototype.toObject = function(opt_includeInstance) {
	  return proto.aitmed.ecos.v1beta1.ceResp.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Whether to include the JSPB
	 *     instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.aitmed.ecos.v1beta1.ceResp} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.ceResp.toObject = function(includeInstance, msg) {
	  var f, obj = {
	    jwt: googleProtobuf$1.Message.getFieldWithDefault(msg, 1, ""),
	    code: googleProtobuf$1.Message.getFieldWithDefault(msg, 2, 0),
	    error: googleProtobuf$1.Message.getFieldWithDefault(msg, 3, ""),
	    edge: (f = msg.getEdge()) && types_pb$1.Edge.toObject(includeInstance, f)
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.aitmed.ecos.v1beta1.ceResp}
	 */
	proto.aitmed.ecos.v1beta1.ceResp.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf$1.BinaryReader(bytes);
	  var msg = new proto.aitmed.ecos.v1beta1.ceResp;
	  return proto.aitmed.ecos.v1beta1.ceResp.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.aitmed.ecos.v1beta1.ceResp} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.aitmed.ecos.v1beta1.ceResp}
	 */
	proto.aitmed.ecos.v1beta1.ceResp.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setJwt(value);
	      break;
	    case 2:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setCode(value);
	      break;
	    case 3:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setError(value);
	      break;
	    case 4:
	      var value = new types_pb$1.Edge;
	      reader.readMessage(value,types_pb$1.Edge.deserializeBinaryFromReader);
	      msg.setEdge(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.ceResp.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf$1.BinaryWriter();
	  proto.aitmed.ecos.v1beta1.ceResp.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.aitmed.ecos.v1beta1.ceResp} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.ceResp.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getJwt();
	  if (f.length > 0) {
	    writer.writeString(
	      1,
	      f
	    );
	  }
	  f = message.getCode();
	  if (f !== 0) {
	    writer.writeInt32(
	      2,
	      f
	    );
	  }
	  f = message.getError();
	  if (f.length > 0) {
	    writer.writeString(
	      3,
	      f
	    );
	  }
	  f = message.getEdge();
	  if (f != null) {
	    writer.writeMessage(
	      4,
	      f,
	      types_pb$1.Edge.serializeBinaryToWriter
	    );
	  }
	};


	/**
	 * optional string jwt = 1;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.ceResp.prototype.getJwt = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 1, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.ceResp.prototype.setJwt = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 1, value);
	};


	/**
	 * optional int32 code = 2;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.ceResp.prototype.getCode = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 2, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.ceResp.prototype.setCode = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 2, value);
	};


	/**
	 * optional string error = 3;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.ceResp.prototype.getError = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 3, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.ceResp.prototype.setError = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 3, value);
	};


	/**
	 * optional Edge edge = 4;
	 * @return {?proto.aitmed.ecos.v1beta1.Edge}
	 */
	proto.aitmed.ecos.v1beta1.ceResp.prototype.getEdge = function() {
	  return /** @type{?proto.aitmed.ecos.v1beta1.Edge} */ (
	    googleProtobuf$1.Message.getWrapperField(this, types_pb$1.Edge, 4));
	};


	/** @param {?proto.aitmed.ecos.v1beta1.Edge|undefined} value */
	proto.aitmed.ecos.v1beta1.ceResp.prototype.setEdge = function(value) {
	  googleProtobuf$1.Message.setWrapperField(this, 4, value);
	};


	/**
	 * Clears the message field making it undefined.
	 */
	proto.aitmed.ecos.v1beta1.ceResp.prototype.clearEdge = function() {
	  this.setEdge(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.aitmed.ecos.v1beta1.ceResp.prototype.hasEdge = function() {
	  return googleProtobuf$1.Message.getField(this, 4) != null;
	};



	/**
	 * List of repeated fields within this message type.
	 * @private {!Array<number>}
	 * @const
	 */
	proto.aitmed.ecos.v1beta1.rxReq.repeatedFields_ = [5];



	if (googleProtobuf$1.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto suitable for use in Soy templates.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	 *     for transitional soy proto support: http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.toObject = function(opt_includeInstance) {
	  return proto.aitmed.ecos.v1beta1.rxReq.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Whether to include the JSPB
	 *     instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.aitmed.ecos.v1beta1.rxReq} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.rxReq.toObject = function(includeInstance, msg) {
	  var f, obj = {
	    jwt: googleProtobuf$1.Message.getFieldWithDefault(msg, 1, ""),
	    pmask: (f = msg.getPmask()) && field_mask_pb$1.FieldMask.toObject(includeInstance, f),
	    rmask: (f = msg.getRmask()) && field_mask_pb$1.FieldMask.toObject(includeInstance, f),
	    objtype: googleProtobuf$1.Message.getFieldWithDefault(msg, 4, 0),
	    idList: msg.getIdList_asB64(),
	    xfname: googleProtobuf$1.Message.getFieldWithDefault(msg, 6, ""),
	    type: googleProtobuf$1.Message.getFieldWithDefault(msg, 7, 0),
	    key: googleProtobuf$1.Message.getFieldWithDefault(msg, 8, ""),
	    sfname: googleProtobuf$1.Message.getFieldWithDefault(msg, 9, ""),
	    loid: msg.getLoid_asB64(),
	    maxcount: googleProtobuf$1.Message.getFieldWithDefault(msg, 11, 0),
	    obfname: googleProtobuf$1.Message.getFieldWithDefault(msg, 12, ""),
	    scondition: googleProtobuf$1.Message.getFieldWithDefault(msg, 13, ""),
	    asc: googleProtobuf$1.Message.getFieldWithDefault(msg, 14, false)
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.aitmed.ecos.v1beta1.rxReq}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf$1.BinaryReader(bytes);
	  var msg = new proto.aitmed.ecos.v1beta1.rxReq;
	  return proto.aitmed.ecos.v1beta1.rxReq.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.aitmed.ecos.v1beta1.rxReq} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.aitmed.ecos.v1beta1.rxReq}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setJwt(value);
	      break;
	    case 2:
	      var value = new field_mask_pb$1.FieldMask;
	      reader.readMessage(value,field_mask_pb$1.FieldMask.deserializeBinaryFromReader);
	      msg.setPmask(value);
	      break;
	    case 3:
	      var value = new field_mask_pb$1.FieldMask;
	      reader.readMessage(value,field_mask_pb$1.FieldMask.deserializeBinaryFromReader);
	      msg.setRmask(value);
	      break;
	    case 4:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setObjtype(value);
	      break;
	    case 5:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.addId(value);
	      break;
	    case 6:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setXfname(value);
	      break;
	    case 7:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setType(value);
	      break;
	    case 8:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setKey(value);
	      break;
	    case 9:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setSfname(value);
	      break;
	    case 10:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.setLoid(value);
	      break;
	    case 11:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setMaxcount(value);
	      break;
	    case 12:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setObfname(value);
	      break;
	    case 13:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setScondition(value);
	      break;
	    case 14:
	      var value = /** @type {boolean} */ (reader.readBool());
	      msg.setAsc(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf$1.BinaryWriter();
	  proto.aitmed.ecos.v1beta1.rxReq.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.aitmed.ecos.v1beta1.rxReq} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.rxReq.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getJwt();
	  if (f.length > 0) {
	    writer.writeString(
	      1,
	      f
	    );
	  }
	  f = message.getPmask();
	  if (f != null) {
	    writer.writeMessage(
	      2,
	      f,
	      field_mask_pb$1.FieldMask.serializeBinaryToWriter
	    );
	  }
	  f = message.getRmask();
	  if (f != null) {
	    writer.writeMessage(
	      3,
	      f,
	      field_mask_pb$1.FieldMask.serializeBinaryToWriter
	    );
	  }
	  f = message.getObjtype();
	  if (f !== 0) {
	    writer.writeInt32(
	      4,
	      f
	    );
	  }
	  f = message.getIdList_asU8();
	  if (f.length > 0) {
	    writer.writeRepeatedBytes(
	      5,
	      f
	    );
	  }
	  f = message.getXfname();
	  if (f.length > 0) {
	    writer.writeString(
	      6,
	      f
	    );
	  }
	  f = message.getType();
	  if (f !== 0) {
	    writer.writeInt32(
	      7,
	      f
	    );
	  }
	  f = message.getKey();
	  if (f.length > 0) {
	    writer.writeString(
	      8,
	      f
	    );
	  }
	  f = message.getSfname();
	  if (f.length > 0) {
	    writer.writeString(
	      9,
	      f
	    );
	  }
	  f = message.getLoid_asU8();
	  if (f.length > 0) {
	    writer.writeBytes(
	      10,
	      f
	    );
	  }
	  f = message.getMaxcount();
	  if (f !== 0) {
	    writer.writeInt32(
	      11,
	      f
	    );
	  }
	  f = message.getObfname();
	  if (f.length > 0) {
	    writer.writeString(
	      12,
	      f
	    );
	  }
	  f = message.getScondition();
	  if (f.length > 0) {
	    writer.writeString(
	      13,
	      f
	    );
	  }
	  f = message.getAsc();
	  if (f) {
	    writer.writeBool(
	      14,
	      f
	    );
	  }
	};


	/**
	 * optional string jwt = 1;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getJwt = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 1, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.setJwt = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 1, value);
	};


	/**
	 * optional google.protobuf.FieldMask pmask = 2;
	 * @return {?proto.google.protobuf.FieldMask}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getPmask = function() {
	  return /** @type{?proto.google.protobuf.FieldMask} */ (
	    googleProtobuf$1.Message.getWrapperField(this, field_mask_pb$1.FieldMask, 2));
	};


	/** @param {?proto.google.protobuf.FieldMask|undefined} value */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.setPmask = function(value) {
	  googleProtobuf$1.Message.setWrapperField(this, 2, value);
	};


	/**
	 * Clears the message field making it undefined.
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.clearPmask = function() {
	  this.setPmask(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.hasPmask = function() {
	  return googleProtobuf$1.Message.getField(this, 2) != null;
	};


	/**
	 * optional google.protobuf.FieldMask rmask = 3;
	 * @return {?proto.google.protobuf.FieldMask}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getRmask = function() {
	  return /** @type{?proto.google.protobuf.FieldMask} */ (
	    googleProtobuf$1.Message.getWrapperField(this, field_mask_pb$1.FieldMask, 3));
	};


	/** @param {?proto.google.protobuf.FieldMask|undefined} value */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.setRmask = function(value) {
	  googleProtobuf$1.Message.setWrapperField(this, 3, value);
	};


	/**
	 * Clears the message field making it undefined.
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.clearRmask = function() {
	  this.setRmask(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.hasRmask = function() {
	  return googleProtobuf$1.Message.getField(this, 3) != null;
	};


	/**
	 * optional int32 ObjType = 4;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getObjtype = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 4, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.setObjtype = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 4, value);
	};


	/**
	 * repeated bytes id = 5;
	 * @return {!Array<string>}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getIdList = function() {
	  return /** @type {!Array<string>} */ (googleProtobuf$1.Message.getRepeatedField(this, 5));
	};


	/**
	 * repeated bytes id = 5;
	 * This is a type-conversion wrapper around `getIdList()`
	 * @return {!Array<string>}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getIdList_asB64 = function() {
	  return /** @type {!Array<string>} */ (googleProtobuf$1.Message.bytesListAsB64(
	      this.getIdList()));
	};


	/**
	 * repeated bytes id = 5;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getIdList()`
	 * @return {!Array<!Uint8Array>}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getIdList_asU8 = function() {
	  return /** @type {!Array<!Uint8Array>} */ (googleProtobuf$1.Message.bytesListAsU8(
	      this.getIdList()));
	};


	/** @param {!(Array<!Uint8Array>|Array<string>)} value */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.setIdList = function(value) {
	  googleProtobuf$1.Message.setField(this, 5, value || []);
	};


	/**
	 * @param {!(string|Uint8Array)} value
	 * @param {number=} opt_index
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.addId = function(value, opt_index) {
	  googleProtobuf$1.Message.addToRepeatedField(this, 5, value, opt_index);
	};


	/**
	 * Clears the list making it empty but non-null.
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.clearIdList = function() {
	  this.setIdList([]);
	};


	/**
	 * optional string xfname = 6;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getXfname = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 6, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.setXfname = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 6, value);
	};


	/**
	 * optional int32 type = 7;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getType = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 7, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.setType = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 7, value);
	};


	/**
	 * optional string key = 8;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getKey = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 8, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.setKey = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 8, value);
	};


	/**
	 * optional string sfname = 9;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getSfname = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 9, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.setSfname = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 9, value);
	};


	/**
	 * optional bytes loid = 10;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getLoid = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 10, ""));
	};


	/**
	 * optional bytes loid = 10;
	 * This is a type-conversion wrapper around `getLoid()`
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getLoid_asB64 = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.bytesAsB64(
	      this.getLoid()));
	};


	/**
	 * optional bytes loid = 10;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getLoid()`
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getLoid_asU8 = function() {
	  return /** @type {!Uint8Array} */ (googleProtobuf$1.Message.bytesAsU8(
	      this.getLoid()));
	};


	/** @param {!(string|Uint8Array)} value */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.setLoid = function(value) {
	  googleProtobuf$1.Message.setProto3BytesField(this, 10, value);
	};


	/**
	 * optional int32 maxcount = 11;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getMaxcount = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 11, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.setMaxcount = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 11, value);
	};


	/**
	 * optional string obfname = 12;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getObfname = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 12, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.setObfname = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 12, value);
	};


	/**
	 * optional string sCondition = 13;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getScondition = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 13, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.setScondition = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 13, value);
	};


	/**
	 * optional bool asc = 14;
	 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
	 * You should avoid comparisons like {@code val === true/false} in those cases.
	 * @return {boolean}
	 */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.getAsc = function() {
	  return /** @type {boolean} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 14, false));
	};


	/** @param {boolean} value */
	proto.aitmed.ecos.v1beta1.rxReq.prototype.setAsc = function(value) {
	  googleProtobuf$1.Message.setProto3BooleanField(this, 14, value);
	};



	/**
	 * List of repeated fields within this message type.
	 * @private {!Array<number>}
	 * @const
	 */
	proto.aitmed.ecos.v1beta1.reResp.repeatedFields_ = [4];



	if (googleProtobuf$1.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto suitable for use in Soy templates.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	 *     for transitional soy proto support: http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.aitmed.ecos.v1beta1.reResp.prototype.toObject = function(opt_includeInstance) {
	  return proto.aitmed.ecos.v1beta1.reResp.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Whether to include the JSPB
	 *     instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.aitmed.ecos.v1beta1.reResp} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.reResp.toObject = function(includeInstance, msg) {
	  var obj = {
	    jwt: googleProtobuf$1.Message.getFieldWithDefault(msg, 1, ""),
	    code: googleProtobuf$1.Message.getFieldWithDefault(msg, 2, 0),
	    error: googleProtobuf$1.Message.getFieldWithDefault(msg, 3, ""),
	    edgeList: googleProtobuf$1.Message.toObjectList(msg.getEdgeList(),
	    types_pb$1.Edge.toObject, includeInstance)
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.aitmed.ecos.v1beta1.reResp}
	 */
	proto.aitmed.ecos.v1beta1.reResp.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf$1.BinaryReader(bytes);
	  var msg = new proto.aitmed.ecos.v1beta1.reResp;
	  return proto.aitmed.ecos.v1beta1.reResp.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.aitmed.ecos.v1beta1.reResp} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.aitmed.ecos.v1beta1.reResp}
	 */
	proto.aitmed.ecos.v1beta1.reResp.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setJwt(value);
	      break;
	    case 2:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setCode(value);
	      break;
	    case 3:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setError(value);
	      break;
	    case 4:
	      var value = new types_pb$1.Edge;
	      reader.readMessage(value,types_pb$1.Edge.deserializeBinaryFromReader);
	      msg.addEdge(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.reResp.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf$1.BinaryWriter();
	  proto.aitmed.ecos.v1beta1.reResp.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.aitmed.ecos.v1beta1.reResp} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.reResp.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getJwt();
	  if (f.length > 0) {
	    writer.writeString(
	      1,
	      f
	    );
	  }
	  f = message.getCode();
	  if (f !== 0) {
	    writer.writeInt32(
	      2,
	      f
	    );
	  }
	  f = message.getError();
	  if (f.length > 0) {
	    writer.writeString(
	      3,
	      f
	    );
	  }
	  f = message.getEdgeList();
	  if (f.length > 0) {
	    writer.writeRepeatedMessage(
	      4,
	      f,
	      types_pb$1.Edge.serializeBinaryToWriter
	    );
	  }
	};


	/**
	 * optional string jwt = 1;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.reResp.prototype.getJwt = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 1, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.reResp.prototype.setJwt = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 1, value);
	};


	/**
	 * optional int32 code = 2;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.reResp.prototype.getCode = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 2, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.reResp.prototype.setCode = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 2, value);
	};


	/**
	 * optional string error = 3;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.reResp.prototype.getError = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 3, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.reResp.prototype.setError = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 3, value);
	};


	/**
	 * repeated Edge edge = 4;
	 * @return {!Array<!proto.aitmed.ecos.v1beta1.Edge>}
	 */
	proto.aitmed.ecos.v1beta1.reResp.prototype.getEdgeList = function() {
	  return /** @type{!Array<!proto.aitmed.ecos.v1beta1.Edge>} */ (
	    googleProtobuf$1.Message.getRepeatedWrapperField(this, types_pb$1.Edge, 4));
	};


	/** @param {!Array<!proto.aitmed.ecos.v1beta1.Edge>} value */
	proto.aitmed.ecos.v1beta1.reResp.prototype.setEdgeList = function(value) {
	  googleProtobuf$1.Message.setRepeatedWrapperField(this, 4, value);
	};


	/**
	 * @param {!proto.aitmed.ecos.v1beta1.Edge=} opt_value
	 * @param {number=} opt_index
	 * @return {!proto.aitmed.ecos.v1beta1.Edge}
	 */
	proto.aitmed.ecos.v1beta1.reResp.prototype.addEdge = function(opt_value, opt_index) {
	  return googleProtobuf$1.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.aitmed.ecos.v1beta1.Edge, opt_index);
	};


	/**
	 * Clears the list making it empty but non-null.
	 */
	proto.aitmed.ecos.v1beta1.reResp.prototype.clearEdgeList = function() {
	  this.setEdgeList([]);
	};



	/**
	 * List of repeated fields within this message type.
	 * @private {!Array<number>}
	 * @const
	 */
	proto.aitmed.ecos.v1beta1.rvResp.repeatedFields_ = [4];



	if (googleProtobuf$1.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto suitable for use in Soy templates.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	 *     for transitional soy proto support: http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.aitmed.ecos.v1beta1.rvResp.prototype.toObject = function(opt_includeInstance) {
	  return proto.aitmed.ecos.v1beta1.rvResp.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Whether to include the JSPB
	 *     instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.aitmed.ecos.v1beta1.rvResp} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.rvResp.toObject = function(includeInstance, msg) {
	  var obj = {
	    jwt: googleProtobuf$1.Message.getFieldWithDefault(msg, 1, ""),
	    code: googleProtobuf$1.Message.getFieldWithDefault(msg, 2, 0),
	    error: googleProtobuf$1.Message.getFieldWithDefault(msg, 3, ""),
	    vertexList: googleProtobuf$1.Message.toObjectList(msg.getVertexList(),
	    types_pb$1.Vertex.toObject, includeInstance)
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.aitmed.ecos.v1beta1.rvResp}
	 */
	proto.aitmed.ecos.v1beta1.rvResp.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf$1.BinaryReader(bytes);
	  var msg = new proto.aitmed.ecos.v1beta1.rvResp;
	  return proto.aitmed.ecos.v1beta1.rvResp.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.aitmed.ecos.v1beta1.rvResp} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.aitmed.ecos.v1beta1.rvResp}
	 */
	proto.aitmed.ecos.v1beta1.rvResp.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setJwt(value);
	      break;
	    case 2:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setCode(value);
	      break;
	    case 3:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setError(value);
	      break;
	    case 4:
	      var value = new types_pb$1.Vertex;
	      reader.readMessage(value,types_pb$1.Vertex.deserializeBinaryFromReader);
	      msg.addVertex(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.rvResp.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf$1.BinaryWriter();
	  proto.aitmed.ecos.v1beta1.rvResp.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.aitmed.ecos.v1beta1.rvResp} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.rvResp.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getJwt();
	  if (f.length > 0) {
	    writer.writeString(
	      1,
	      f
	    );
	  }
	  f = message.getCode();
	  if (f !== 0) {
	    writer.writeInt32(
	      2,
	      f
	    );
	  }
	  f = message.getError();
	  if (f.length > 0) {
	    writer.writeString(
	      3,
	      f
	    );
	  }
	  f = message.getVertexList();
	  if (f.length > 0) {
	    writer.writeRepeatedMessage(
	      4,
	      f,
	      types_pb$1.Vertex.serializeBinaryToWriter
	    );
	  }
	};


	/**
	 * optional string jwt = 1;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.rvResp.prototype.getJwt = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 1, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.rvResp.prototype.setJwt = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 1, value);
	};


	/**
	 * optional int32 code = 2;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.rvResp.prototype.getCode = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 2, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.rvResp.prototype.setCode = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 2, value);
	};


	/**
	 * optional string error = 3;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.rvResp.prototype.getError = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 3, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.rvResp.prototype.setError = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 3, value);
	};


	/**
	 * repeated Vertex vertex = 4;
	 * @return {!Array<!proto.aitmed.ecos.v1beta1.Vertex>}
	 */
	proto.aitmed.ecos.v1beta1.rvResp.prototype.getVertexList = function() {
	  return /** @type{!Array<!proto.aitmed.ecos.v1beta1.Vertex>} */ (
	    googleProtobuf$1.Message.getRepeatedWrapperField(this, types_pb$1.Vertex, 4));
	};


	/** @param {!Array<!proto.aitmed.ecos.v1beta1.Vertex>} value */
	proto.aitmed.ecos.v1beta1.rvResp.prototype.setVertexList = function(value) {
	  googleProtobuf$1.Message.setRepeatedWrapperField(this, 4, value);
	};


	/**
	 * @param {!proto.aitmed.ecos.v1beta1.Vertex=} opt_value
	 * @param {number=} opt_index
	 * @return {!proto.aitmed.ecos.v1beta1.Vertex}
	 */
	proto.aitmed.ecos.v1beta1.rvResp.prototype.addVertex = function(opt_value, opt_index) {
	  return googleProtobuf$1.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.aitmed.ecos.v1beta1.Vertex, opt_index);
	};


	/**
	 * Clears the list making it empty but non-null.
	 */
	proto.aitmed.ecos.v1beta1.rvResp.prototype.clearVertexList = function() {
	  this.setVertexList([]);
	};



	/**
	 * List of repeated fields within this message type.
	 * @private {!Array<number>}
	 * @const
	 */
	proto.aitmed.ecos.v1beta1.rdResp.repeatedFields_ = [4];



	if (googleProtobuf$1.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto suitable for use in Soy templates.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	 *     for transitional soy proto support: http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.aitmed.ecos.v1beta1.rdResp.prototype.toObject = function(opt_includeInstance) {
	  return proto.aitmed.ecos.v1beta1.rdResp.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Whether to include the JSPB
	 *     instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.aitmed.ecos.v1beta1.rdResp} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.rdResp.toObject = function(includeInstance, msg) {
	  var obj = {
	    jwt: googleProtobuf$1.Message.getFieldWithDefault(msg, 1, ""),
	    code: googleProtobuf$1.Message.getFieldWithDefault(msg, 2, 0),
	    error: googleProtobuf$1.Message.getFieldWithDefault(msg, 3, ""),
	    docList: googleProtobuf$1.Message.toObjectList(msg.getDocList(),
	    types_pb$1.Doc.toObject, includeInstance)
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.aitmed.ecos.v1beta1.rdResp}
	 */
	proto.aitmed.ecos.v1beta1.rdResp.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf$1.BinaryReader(bytes);
	  var msg = new proto.aitmed.ecos.v1beta1.rdResp;
	  return proto.aitmed.ecos.v1beta1.rdResp.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.aitmed.ecos.v1beta1.rdResp} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.aitmed.ecos.v1beta1.rdResp}
	 */
	proto.aitmed.ecos.v1beta1.rdResp.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setJwt(value);
	      break;
	    case 2:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setCode(value);
	      break;
	    case 3:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setError(value);
	      break;
	    case 4:
	      var value = new types_pb$1.Doc;
	      reader.readMessage(value,types_pb$1.Doc.deserializeBinaryFromReader);
	      msg.addDoc(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.rdResp.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf$1.BinaryWriter();
	  proto.aitmed.ecos.v1beta1.rdResp.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.aitmed.ecos.v1beta1.rdResp} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.rdResp.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getJwt();
	  if (f.length > 0) {
	    writer.writeString(
	      1,
	      f
	    );
	  }
	  f = message.getCode();
	  if (f !== 0) {
	    writer.writeInt32(
	      2,
	      f
	    );
	  }
	  f = message.getError();
	  if (f.length > 0) {
	    writer.writeString(
	      3,
	      f
	    );
	  }
	  f = message.getDocList();
	  if (f.length > 0) {
	    writer.writeRepeatedMessage(
	      4,
	      f,
	      types_pb$1.Doc.serializeBinaryToWriter
	    );
	  }
	};


	/**
	 * optional string jwt = 1;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.rdResp.prototype.getJwt = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 1, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.rdResp.prototype.setJwt = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 1, value);
	};


	/**
	 * optional int32 code = 2;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.rdResp.prototype.getCode = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 2, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.rdResp.prototype.setCode = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 2, value);
	};


	/**
	 * optional string error = 3;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.rdResp.prototype.getError = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 3, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.rdResp.prototype.setError = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 3, value);
	};


	/**
	 * repeated Doc doc = 4;
	 * @return {!Array<!proto.aitmed.ecos.v1beta1.Doc>}
	 */
	proto.aitmed.ecos.v1beta1.rdResp.prototype.getDocList = function() {
	  return /** @type{!Array<!proto.aitmed.ecos.v1beta1.Doc>} */ (
	    googleProtobuf$1.Message.getRepeatedWrapperField(this, types_pb$1.Doc, 4));
	};


	/** @param {!Array<!proto.aitmed.ecos.v1beta1.Doc>} value */
	proto.aitmed.ecos.v1beta1.rdResp.prototype.setDocList = function(value) {
	  googleProtobuf$1.Message.setRepeatedWrapperField(this, 4, value);
	};


	/**
	 * @param {!proto.aitmed.ecos.v1beta1.Doc=} opt_value
	 * @param {number=} opt_index
	 * @return {!proto.aitmed.ecos.v1beta1.Doc}
	 */
	proto.aitmed.ecos.v1beta1.rdResp.prototype.addDoc = function(opt_value, opt_index) {
	  return googleProtobuf$1.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.aitmed.ecos.v1beta1.Doc, opt_index);
	};


	/**
	 * Clears the list making it empty but non-null.
	 */
	proto.aitmed.ecos.v1beta1.rdResp.prototype.clearDocList = function() {
	  this.setDocList([]);
	};



	/**
	 * List of repeated fields within this message type.
	 * @private {!Array<number>}
	 * @const
	 */
	proto.aitmed.ecos.v1beta1.dxReq.repeatedFields_ = [2];



	if (googleProtobuf$1.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto suitable for use in Soy templates.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	 *     for transitional soy proto support: http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.aitmed.ecos.v1beta1.dxReq.prototype.toObject = function(opt_includeInstance) {
	  return proto.aitmed.ecos.v1beta1.dxReq.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Whether to include the JSPB
	 *     instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.aitmed.ecos.v1beta1.dxReq} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.dxReq.toObject = function(includeInstance, msg) {
	  var obj = {
	    jwt: googleProtobuf$1.Message.getFieldWithDefault(msg, 1, ""),
	    idList: msg.getIdList_asB64()
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.aitmed.ecos.v1beta1.dxReq}
	 */
	proto.aitmed.ecos.v1beta1.dxReq.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf$1.BinaryReader(bytes);
	  var msg = new proto.aitmed.ecos.v1beta1.dxReq;
	  return proto.aitmed.ecos.v1beta1.dxReq.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.aitmed.ecos.v1beta1.dxReq} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.aitmed.ecos.v1beta1.dxReq}
	 */
	proto.aitmed.ecos.v1beta1.dxReq.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setJwt(value);
	      break;
	    case 2:
	      var value = /** @type {!Uint8Array} */ (reader.readBytes());
	      msg.addId(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.dxReq.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf$1.BinaryWriter();
	  proto.aitmed.ecos.v1beta1.dxReq.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.aitmed.ecos.v1beta1.dxReq} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.dxReq.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getJwt();
	  if (f.length > 0) {
	    writer.writeString(
	      1,
	      f
	    );
	  }
	  f = message.getIdList_asU8();
	  if (f.length > 0) {
	    writer.writeRepeatedBytes(
	      2,
	      f
	    );
	  }
	};


	/**
	 * optional string jwt = 1;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.dxReq.prototype.getJwt = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 1, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.dxReq.prototype.setJwt = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 1, value);
	};


	/**
	 * repeated bytes id = 2;
	 * @return {!Array<string>}
	 */
	proto.aitmed.ecos.v1beta1.dxReq.prototype.getIdList = function() {
	  return /** @type {!Array<string>} */ (googleProtobuf$1.Message.getRepeatedField(this, 2));
	};


	/**
	 * repeated bytes id = 2;
	 * This is a type-conversion wrapper around `getIdList()`
	 * @return {!Array<string>}
	 */
	proto.aitmed.ecos.v1beta1.dxReq.prototype.getIdList_asB64 = function() {
	  return /** @type {!Array<string>} */ (googleProtobuf$1.Message.bytesListAsB64(
	      this.getIdList()));
	};


	/**
	 * repeated bytes id = 2;
	 * Note that Uint8Array is not supported on all browsers.
	 * @see http://caniuse.com/Uint8Array
	 * This is a type-conversion wrapper around `getIdList()`
	 * @return {!Array<!Uint8Array>}
	 */
	proto.aitmed.ecos.v1beta1.dxReq.prototype.getIdList_asU8 = function() {
	  return /** @type {!Array<!Uint8Array>} */ (googleProtobuf$1.Message.bytesListAsU8(
	      this.getIdList()));
	};


	/** @param {!(Array<!Uint8Array>|Array<string>)} value */
	proto.aitmed.ecos.v1beta1.dxReq.prototype.setIdList = function(value) {
	  googleProtobuf$1.Message.setField(this, 2, value || []);
	};


	/**
	 * @param {!(string|Uint8Array)} value
	 * @param {number=} opt_index
	 */
	proto.aitmed.ecos.v1beta1.dxReq.prototype.addId = function(value, opt_index) {
	  googleProtobuf$1.Message.addToRepeatedField(this, 2, value, opt_index);
	};


	/**
	 * Clears the list making it empty but non-null.
	 */
	proto.aitmed.ecos.v1beta1.dxReq.prototype.clearIdList = function() {
	  this.setIdList([]);
	};





	if (googleProtobuf$1.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto suitable for use in Soy templates.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	 *     for transitional soy proto support: http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.aitmed.ecos.v1beta1.dxResp.prototype.toObject = function(opt_includeInstance) {
	  return proto.aitmed.ecos.v1beta1.dxResp.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Whether to include the JSPB
	 *     instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.aitmed.ecos.v1beta1.dxResp} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.dxResp.toObject = function(includeInstance, msg) {
	  var obj = {
	    jwt: googleProtobuf$1.Message.getFieldWithDefault(msg, 1, ""),
	    code: googleProtobuf$1.Message.getFieldWithDefault(msg, 2, 0),
	    error: googleProtobuf$1.Message.getFieldWithDefault(msg, 3, "")
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.aitmed.ecos.v1beta1.dxResp}
	 */
	proto.aitmed.ecos.v1beta1.dxResp.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf$1.BinaryReader(bytes);
	  var msg = new proto.aitmed.ecos.v1beta1.dxResp;
	  return proto.aitmed.ecos.v1beta1.dxResp.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.aitmed.ecos.v1beta1.dxResp} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.aitmed.ecos.v1beta1.dxResp}
	 */
	proto.aitmed.ecos.v1beta1.dxResp.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setJwt(value);
	      break;
	    case 2:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setCode(value);
	      break;
	    case 3:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setError(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.dxResp.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf$1.BinaryWriter();
	  proto.aitmed.ecos.v1beta1.dxResp.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.aitmed.ecos.v1beta1.dxResp} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.dxResp.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getJwt();
	  if (f.length > 0) {
	    writer.writeString(
	      1,
	      f
	    );
	  }
	  f = message.getCode();
	  if (f !== 0) {
	    writer.writeInt32(
	      2,
	      f
	    );
	  }
	  f = message.getError();
	  if (f.length > 0) {
	    writer.writeString(
	      3,
	      f
	    );
	  }
	};


	/**
	 * optional string jwt = 1;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.dxResp.prototype.getJwt = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 1, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.dxResp.prototype.setJwt = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 1, value);
	};


	/**
	 * optional int32 code = 2;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.dxResp.prototype.getCode = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 2, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.dxResp.prototype.setCode = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 2, value);
	};


	/**
	 * optional string error = 3;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.dxResp.prototype.getError = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 3, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.dxResp.prototype.setError = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 3, value);
	};





	if (googleProtobuf$1.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto suitable for use in Soy templates.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	 *     for transitional soy proto support: http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.aitmed.ecos.v1beta1.cvReq.prototype.toObject = function(opt_includeInstance) {
	  return proto.aitmed.ecos.v1beta1.cvReq.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Whether to include the JSPB
	 *     instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.aitmed.ecos.v1beta1.cvReq} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.cvReq.toObject = function(includeInstance, msg) {
	  var f, obj = {
	    jwt: googleProtobuf$1.Message.getFieldWithDefault(msg, 1, ""),
	    pmask: (f = msg.getPmask()) && field_mask_pb$1.FieldMask.toObject(includeInstance, f),
	    rmask: (f = msg.getRmask()) && field_mask_pb$1.FieldMask.toObject(includeInstance, f),
	    vertex: (f = msg.getVertex()) && types_pb$1.Vertex.toObject(includeInstance, f)
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.aitmed.ecos.v1beta1.cvReq}
	 */
	proto.aitmed.ecos.v1beta1.cvReq.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf$1.BinaryReader(bytes);
	  var msg = new proto.aitmed.ecos.v1beta1.cvReq;
	  return proto.aitmed.ecos.v1beta1.cvReq.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.aitmed.ecos.v1beta1.cvReq} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.aitmed.ecos.v1beta1.cvReq}
	 */
	proto.aitmed.ecos.v1beta1.cvReq.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setJwt(value);
	      break;
	    case 2:
	      var value = new field_mask_pb$1.FieldMask;
	      reader.readMessage(value,field_mask_pb$1.FieldMask.deserializeBinaryFromReader);
	      msg.setPmask(value);
	      break;
	    case 3:
	      var value = new field_mask_pb$1.FieldMask;
	      reader.readMessage(value,field_mask_pb$1.FieldMask.deserializeBinaryFromReader);
	      msg.setRmask(value);
	      break;
	    case 4:
	      var value = new types_pb$1.Vertex;
	      reader.readMessage(value,types_pb$1.Vertex.deserializeBinaryFromReader);
	      msg.setVertex(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.cvReq.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf$1.BinaryWriter();
	  proto.aitmed.ecos.v1beta1.cvReq.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.aitmed.ecos.v1beta1.cvReq} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.cvReq.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getJwt();
	  if (f.length > 0) {
	    writer.writeString(
	      1,
	      f
	    );
	  }
	  f = message.getPmask();
	  if (f != null) {
	    writer.writeMessage(
	      2,
	      f,
	      field_mask_pb$1.FieldMask.serializeBinaryToWriter
	    );
	  }
	  f = message.getRmask();
	  if (f != null) {
	    writer.writeMessage(
	      3,
	      f,
	      field_mask_pb$1.FieldMask.serializeBinaryToWriter
	    );
	  }
	  f = message.getVertex();
	  if (f != null) {
	    writer.writeMessage(
	      4,
	      f,
	      types_pb$1.Vertex.serializeBinaryToWriter
	    );
	  }
	};


	/**
	 * optional string jwt = 1;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.cvReq.prototype.getJwt = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 1, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.cvReq.prototype.setJwt = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 1, value);
	};


	/**
	 * optional google.protobuf.FieldMask pmask = 2;
	 * @return {?proto.google.protobuf.FieldMask}
	 */
	proto.aitmed.ecos.v1beta1.cvReq.prototype.getPmask = function() {
	  return /** @type{?proto.google.protobuf.FieldMask} */ (
	    googleProtobuf$1.Message.getWrapperField(this, field_mask_pb$1.FieldMask, 2));
	};


	/** @param {?proto.google.protobuf.FieldMask|undefined} value */
	proto.aitmed.ecos.v1beta1.cvReq.prototype.setPmask = function(value) {
	  googleProtobuf$1.Message.setWrapperField(this, 2, value);
	};


	/**
	 * Clears the message field making it undefined.
	 */
	proto.aitmed.ecos.v1beta1.cvReq.prototype.clearPmask = function() {
	  this.setPmask(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.aitmed.ecos.v1beta1.cvReq.prototype.hasPmask = function() {
	  return googleProtobuf$1.Message.getField(this, 2) != null;
	};


	/**
	 * optional google.protobuf.FieldMask rmask = 3;
	 * @return {?proto.google.protobuf.FieldMask}
	 */
	proto.aitmed.ecos.v1beta1.cvReq.prototype.getRmask = function() {
	  return /** @type{?proto.google.protobuf.FieldMask} */ (
	    googleProtobuf$1.Message.getWrapperField(this, field_mask_pb$1.FieldMask, 3));
	};


	/** @param {?proto.google.protobuf.FieldMask|undefined} value */
	proto.aitmed.ecos.v1beta1.cvReq.prototype.setRmask = function(value) {
	  googleProtobuf$1.Message.setWrapperField(this, 3, value);
	};


	/**
	 * Clears the message field making it undefined.
	 */
	proto.aitmed.ecos.v1beta1.cvReq.prototype.clearRmask = function() {
	  this.setRmask(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.aitmed.ecos.v1beta1.cvReq.prototype.hasRmask = function() {
	  return googleProtobuf$1.Message.getField(this, 3) != null;
	};


	/**
	 * optional Vertex vertex = 4;
	 * @return {?proto.aitmed.ecos.v1beta1.Vertex}
	 */
	proto.aitmed.ecos.v1beta1.cvReq.prototype.getVertex = function() {
	  return /** @type{?proto.aitmed.ecos.v1beta1.Vertex} */ (
	    googleProtobuf$1.Message.getWrapperField(this, types_pb$1.Vertex, 4));
	};


	/** @param {?proto.aitmed.ecos.v1beta1.Vertex|undefined} value */
	proto.aitmed.ecos.v1beta1.cvReq.prototype.setVertex = function(value) {
	  googleProtobuf$1.Message.setWrapperField(this, 4, value);
	};


	/**
	 * Clears the message field making it undefined.
	 */
	proto.aitmed.ecos.v1beta1.cvReq.prototype.clearVertex = function() {
	  this.setVertex(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.aitmed.ecos.v1beta1.cvReq.prototype.hasVertex = function() {
	  return googleProtobuf$1.Message.getField(this, 4) != null;
	};





	if (googleProtobuf$1.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto suitable for use in Soy templates.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	 *     for transitional soy proto support: http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.aitmed.ecos.v1beta1.cvResp.prototype.toObject = function(opt_includeInstance) {
	  return proto.aitmed.ecos.v1beta1.cvResp.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Whether to include the JSPB
	 *     instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.aitmed.ecos.v1beta1.cvResp} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.cvResp.toObject = function(includeInstance, msg) {
	  var f, obj = {
	    jwt: googleProtobuf$1.Message.getFieldWithDefault(msg, 1, ""),
	    code: googleProtobuf$1.Message.getFieldWithDefault(msg, 2, 0),
	    error: googleProtobuf$1.Message.getFieldWithDefault(msg, 3, ""),
	    vertex: (f = msg.getVertex()) && types_pb$1.Vertex.toObject(includeInstance, f)
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.aitmed.ecos.v1beta1.cvResp}
	 */
	proto.aitmed.ecos.v1beta1.cvResp.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf$1.BinaryReader(bytes);
	  var msg = new proto.aitmed.ecos.v1beta1.cvResp;
	  return proto.aitmed.ecos.v1beta1.cvResp.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.aitmed.ecos.v1beta1.cvResp} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.aitmed.ecos.v1beta1.cvResp}
	 */
	proto.aitmed.ecos.v1beta1.cvResp.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setJwt(value);
	      break;
	    case 2:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setCode(value);
	      break;
	    case 3:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setError(value);
	      break;
	    case 4:
	      var value = new types_pb$1.Vertex;
	      reader.readMessage(value,types_pb$1.Vertex.deserializeBinaryFromReader);
	      msg.setVertex(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.cvResp.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf$1.BinaryWriter();
	  proto.aitmed.ecos.v1beta1.cvResp.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.aitmed.ecos.v1beta1.cvResp} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.cvResp.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getJwt();
	  if (f.length > 0) {
	    writer.writeString(
	      1,
	      f
	    );
	  }
	  f = message.getCode();
	  if (f !== 0) {
	    writer.writeInt32(
	      2,
	      f
	    );
	  }
	  f = message.getError();
	  if (f.length > 0) {
	    writer.writeString(
	      3,
	      f
	    );
	  }
	  f = message.getVertex();
	  if (f != null) {
	    writer.writeMessage(
	      4,
	      f,
	      types_pb$1.Vertex.serializeBinaryToWriter
	    );
	  }
	};


	/**
	 * optional string jwt = 1;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.cvResp.prototype.getJwt = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 1, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.cvResp.prototype.setJwt = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 1, value);
	};


	/**
	 * optional int32 code = 2;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.cvResp.prototype.getCode = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 2, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.cvResp.prototype.setCode = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 2, value);
	};


	/**
	 * optional string error = 3;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.cvResp.prototype.getError = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 3, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.cvResp.prototype.setError = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 3, value);
	};


	/**
	 * optional Vertex vertex = 4;
	 * @return {?proto.aitmed.ecos.v1beta1.Vertex}
	 */
	proto.aitmed.ecos.v1beta1.cvResp.prototype.getVertex = function() {
	  return /** @type{?proto.aitmed.ecos.v1beta1.Vertex} */ (
	    googleProtobuf$1.Message.getWrapperField(this, types_pb$1.Vertex, 4));
	};


	/** @param {?proto.aitmed.ecos.v1beta1.Vertex|undefined} value */
	proto.aitmed.ecos.v1beta1.cvResp.prototype.setVertex = function(value) {
	  googleProtobuf$1.Message.setWrapperField(this, 4, value);
	};


	/**
	 * Clears the message field making it undefined.
	 */
	proto.aitmed.ecos.v1beta1.cvResp.prototype.clearVertex = function() {
	  this.setVertex(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.aitmed.ecos.v1beta1.cvResp.prototype.hasVertex = function() {
	  return googleProtobuf$1.Message.getField(this, 4) != null;
	};





	if (googleProtobuf$1.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto suitable for use in Soy templates.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	 *     for transitional soy proto support: http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.aitmed.ecos.v1beta1.cdReq.prototype.toObject = function(opt_includeInstance) {
	  return proto.aitmed.ecos.v1beta1.cdReq.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Whether to include the JSPB
	 *     instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.aitmed.ecos.v1beta1.cdReq} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.cdReq.toObject = function(includeInstance, msg) {
	  var f, obj = {
	    jwt: googleProtobuf$1.Message.getFieldWithDefault(msg, 1, ""),
	    pmask: (f = msg.getPmask()) && field_mask_pb$1.FieldMask.toObject(includeInstance, f),
	    rmask: (f = msg.getRmask()) && field_mask_pb$1.FieldMask.toObject(includeInstance, f),
	    doc: (f = msg.getDoc()) && types_pb$1.Doc.toObject(includeInstance, f)
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.aitmed.ecos.v1beta1.cdReq}
	 */
	proto.aitmed.ecos.v1beta1.cdReq.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf$1.BinaryReader(bytes);
	  var msg = new proto.aitmed.ecos.v1beta1.cdReq;
	  return proto.aitmed.ecos.v1beta1.cdReq.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.aitmed.ecos.v1beta1.cdReq} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.aitmed.ecos.v1beta1.cdReq}
	 */
	proto.aitmed.ecos.v1beta1.cdReq.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setJwt(value);
	      break;
	    case 2:
	      var value = new field_mask_pb$1.FieldMask;
	      reader.readMessage(value,field_mask_pb$1.FieldMask.deserializeBinaryFromReader);
	      msg.setPmask(value);
	      break;
	    case 3:
	      var value = new field_mask_pb$1.FieldMask;
	      reader.readMessage(value,field_mask_pb$1.FieldMask.deserializeBinaryFromReader);
	      msg.setRmask(value);
	      break;
	    case 4:
	      var value = new types_pb$1.Doc;
	      reader.readMessage(value,types_pb$1.Doc.deserializeBinaryFromReader);
	      msg.setDoc(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.cdReq.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf$1.BinaryWriter();
	  proto.aitmed.ecos.v1beta1.cdReq.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.aitmed.ecos.v1beta1.cdReq} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.cdReq.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getJwt();
	  if (f.length > 0) {
	    writer.writeString(
	      1,
	      f
	    );
	  }
	  f = message.getPmask();
	  if (f != null) {
	    writer.writeMessage(
	      2,
	      f,
	      field_mask_pb$1.FieldMask.serializeBinaryToWriter
	    );
	  }
	  f = message.getRmask();
	  if (f != null) {
	    writer.writeMessage(
	      3,
	      f,
	      field_mask_pb$1.FieldMask.serializeBinaryToWriter
	    );
	  }
	  f = message.getDoc();
	  if (f != null) {
	    writer.writeMessage(
	      4,
	      f,
	      types_pb$1.Doc.serializeBinaryToWriter
	    );
	  }
	};


	/**
	 * optional string jwt = 1;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.cdReq.prototype.getJwt = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 1, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.cdReq.prototype.setJwt = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 1, value);
	};


	/**
	 * optional google.protobuf.FieldMask pmask = 2;
	 * @return {?proto.google.protobuf.FieldMask}
	 */
	proto.aitmed.ecos.v1beta1.cdReq.prototype.getPmask = function() {
	  return /** @type{?proto.google.protobuf.FieldMask} */ (
	    googleProtobuf$1.Message.getWrapperField(this, field_mask_pb$1.FieldMask, 2));
	};


	/** @param {?proto.google.protobuf.FieldMask|undefined} value */
	proto.aitmed.ecos.v1beta1.cdReq.prototype.setPmask = function(value) {
	  googleProtobuf$1.Message.setWrapperField(this, 2, value);
	};


	/**
	 * Clears the message field making it undefined.
	 */
	proto.aitmed.ecos.v1beta1.cdReq.prototype.clearPmask = function() {
	  this.setPmask(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.aitmed.ecos.v1beta1.cdReq.prototype.hasPmask = function() {
	  return googleProtobuf$1.Message.getField(this, 2) != null;
	};


	/**
	 * optional google.protobuf.FieldMask rmask = 3;
	 * @return {?proto.google.protobuf.FieldMask}
	 */
	proto.aitmed.ecos.v1beta1.cdReq.prototype.getRmask = function() {
	  return /** @type{?proto.google.protobuf.FieldMask} */ (
	    googleProtobuf$1.Message.getWrapperField(this, field_mask_pb$1.FieldMask, 3));
	};


	/** @param {?proto.google.protobuf.FieldMask|undefined} value */
	proto.aitmed.ecos.v1beta1.cdReq.prototype.setRmask = function(value) {
	  googleProtobuf$1.Message.setWrapperField(this, 3, value);
	};


	/**
	 * Clears the message field making it undefined.
	 */
	proto.aitmed.ecos.v1beta1.cdReq.prototype.clearRmask = function() {
	  this.setRmask(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.aitmed.ecos.v1beta1.cdReq.prototype.hasRmask = function() {
	  return googleProtobuf$1.Message.getField(this, 3) != null;
	};


	/**
	 * optional Doc doc = 4;
	 * @return {?proto.aitmed.ecos.v1beta1.Doc}
	 */
	proto.aitmed.ecos.v1beta1.cdReq.prototype.getDoc = function() {
	  return /** @type{?proto.aitmed.ecos.v1beta1.Doc} */ (
	    googleProtobuf$1.Message.getWrapperField(this, types_pb$1.Doc, 4));
	};


	/** @param {?proto.aitmed.ecos.v1beta1.Doc|undefined} value */
	proto.aitmed.ecos.v1beta1.cdReq.prototype.setDoc = function(value) {
	  googleProtobuf$1.Message.setWrapperField(this, 4, value);
	};


	/**
	 * Clears the message field making it undefined.
	 */
	proto.aitmed.ecos.v1beta1.cdReq.prototype.clearDoc = function() {
	  this.setDoc(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.aitmed.ecos.v1beta1.cdReq.prototype.hasDoc = function() {
	  return googleProtobuf$1.Message.getField(this, 4) != null;
	};





	if (googleProtobuf$1.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto suitable for use in Soy templates.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
	 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
	 *     for transitional soy proto support: http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.aitmed.ecos.v1beta1.cdResp.prototype.toObject = function(opt_includeInstance) {
	  return proto.aitmed.ecos.v1beta1.cdResp.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Whether to include the JSPB
	 *     instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.aitmed.ecos.v1beta1.cdResp} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.cdResp.toObject = function(includeInstance, msg) {
	  var f, obj = {
	    jwt: googleProtobuf$1.Message.getFieldWithDefault(msg, 1, ""),
	    code: googleProtobuf$1.Message.getFieldWithDefault(msg, 2, 0),
	    error: googleProtobuf$1.Message.getFieldWithDefault(msg, 3, ""),
	    doc: (f = msg.getDoc()) && types_pb$1.Doc.toObject(includeInstance, f)
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.aitmed.ecos.v1beta1.cdResp}
	 */
	proto.aitmed.ecos.v1beta1.cdResp.deserializeBinary = function(bytes) {
	  var reader = new googleProtobuf$1.BinaryReader(bytes);
	  var msg = new proto.aitmed.ecos.v1beta1.cdResp;
	  return proto.aitmed.ecos.v1beta1.cdResp.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.aitmed.ecos.v1beta1.cdResp} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.aitmed.ecos.v1beta1.cdResp}
	 */
	proto.aitmed.ecos.v1beta1.cdResp.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setJwt(value);
	      break;
	    case 2:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setCode(value);
	      break;
	    case 3:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setError(value);
	      break;
	    case 4:
	      var value = new types_pb$1.Doc;
	      reader.readMessage(value,types_pb$1.Doc.deserializeBinaryFromReader);
	      msg.setDoc(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.aitmed.ecos.v1beta1.cdResp.prototype.serializeBinary = function() {
	  var writer = new googleProtobuf$1.BinaryWriter();
	  proto.aitmed.ecos.v1beta1.cdResp.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.aitmed.ecos.v1beta1.cdResp} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.aitmed.ecos.v1beta1.cdResp.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getJwt();
	  if (f.length > 0) {
	    writer.writeString(
	      1,
	      f
	    );
	  }
	  f = message.getCode();
	  if (f !== 0) {
	    writer.writeInt32(
	      2,
	      f
	    );
	  }
	  f = message.getError();
	  if (f.length > 0) {
	    writer.writeString(
	      3,
	      f
	    );
	  }
	  f = message.getDoc();
	  if (f != null) {
	    writer.writeMessage(
	      4,
	      f,
	      types_pb$1.Doc.serializeBinaryToWriter
	    );
	  }
	};


	/**
	 * optional string jwt = 1;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.cdResp.prototype.getJwt = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 1, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.cdResp.prototype.setJwt = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 1, value);
	};


	/**
	 * optional int32 code = 2;
	 * @return {number}
	 */
	proto.aitmed.ecos.v1beta1.cdResp.prototype.getCode = function() {
	  return /** @type {number} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 2, 0));
	};


	/** @param {number} value */
	proto.aitmed.ecos.v1beta1.cdResp.prototype.setCode = function(value) {
	  googleProtobuf$1.Message.setProto3IntField(this, 2, value);
	};


	/**
	 * optional string error = 3;
	 * @return {string}
	 */
	proto.aitmed.ecos.v1beta1.cdResp.prototype.getError = function() {
	  return /** @type {string} */ (googleProtobuf$1.Message.getFieldWithDefault(this, 3, ""));
	};


	/** @param {string} value */
	proto.aitmed.ecos.v1beta1.cdResp.prototype.setError = function(value) {
	  googleProtobuf$1.Message.setProto3StringField(this, 3, value);
	};


	/**
	 * optional Doc doc = 4;
	 * @return {?proto.aitmed.ecos.v1beta1.Doc}
	 */
	proto.aitmed.ecos.v1beta1.cdResp.prototype.getDoc = function() {
	  return /** @type{?proto.aitmed.ecos.v1beta1.Doc} */ (
	    googleProtobuf$1.Message.getWrapperField(this, types_pb$1.Doc, 4));
	};


	/** @param {?proto.aitmed.ecos.v1beta1.Doc|undefined} value */
	proto.aitmed.ecos.v1beta1.cdResp.prototype.setDoc = function(value) {
	  googleProtobuf$1.Message.setWrapperField(this, 4, value);
	};


	/**
	 * Clears the message field making it undefined.
	 */
	proto.aitmed.ecos.v1beta1.cdResp.prototype.clearDoc = function() {
	  this.setDoc(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.aitmed.ecos.v1beta1.cdResp.prototype.hasDoc = function() {
	  return googleProtobuf$1.Message.getField(this, 4) != null;
	};


	goog.object.extend(exports, proto.aitmed.ecos.v1beta1);
	});
	var ecos_api_pb_1$1 = ecos_api_pb$1.cdReq;
	var ecos_api_pb_2$1 = ecos_api_pb$1.cdResp;
	var ecos_api_pb_3$1 = ecos_api_pb$1.ceReq;
	var ecos_api_pb_4$1 = ecos_api_pb$1.ceResp;
	var ecos_api_pb_5$1 = ecos_api_pb$1.cvReq;
	var ecos_api_pb_6$1 = ecos_api_pb$1.cvResp;
	var ecos_api_pb_7$1 = ecos_api_pb$1.dxReq;
	var ecos_api_pb_8$1 = ecos_api_pb$1.dxResp;
	var ecos_api_pb_9$1 = ecos_api_pb$1.rdResp;
	var ecos_api_pb_10$1 = ecos_api_pb$1.reResp;
	var ecos_api_pb_11$1 = ecos_api_pb$1.rvResp;
	var ecos_api_pb_12$1 = ecos_api_pb$1.rxReq;

	var minimalisticAssert = assert;

	function assert(val, msg) {
	  if (!val)
	    throw new Error(msg || 'Assertion failed');
	}

	assert.equal = function assertEqual(l, r, msg) {
	  if (l != r)
	    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
	};

	var inherits_browser = createCommonjsModule$1(function (module) {
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}
	});

	var inherits_1 = inherits_browser;

	function isSurrogatePair(msg, i) {
	  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
	    return false;
	  }
	  if (i < 0 || i + 1 >= msg.length) {
	    return false;
	  }
	  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
	}

	function toArray$1$1(msg, enc) {
	  if (Array.isArray(msg))
	    return msg.slice();
	  if (!msg)
	    return [];
	  var res = [];
	  if (typeof msg === 'string') {
	    if (!enc) {
	      // Inspired by stringToUtf8ByteArray() in closure-library by Google
	      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
	      // Apache License 2.0
	      // https://github.com/google/closure-library/blob/master/LICENSE
	      var p = 0;
	      for (var i = 0; i < msg.length; i++) {
	        var c = msg.charCodeAt(i);
	        if (c < 128) {
	          res[p++] = c;
	        } else if (c < 2048) {
	          res[p++] = (c >> 6) | 192;
	          res[p++] = (c & 63) | 128;
	        } else if (isSurrogatePair(msg, i)) {
	          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
	          res[p++] = (c >> 18) | 240;
	          res[p++] = ((c >> 12) & 63) | 128;
	          res[p++] = ((c >> 6) & 63) | 128;
	          res[p++] = (c & 63) | 128;
	        } else {
	          res[p++] = (c >> 12) | 224;
	          res[p++] = ((c >> 6) & 63) | 128;
	          res[p++] = (c & 63) | 128;
	        }
	      }
	    } else if (enc === 'hex') {
	      msg = msg.replace(/[^a-z0-9]+/ig, '');
	      if (msg.length % 2 !== 0)
	        msg = '0' + msg;
	      for (i = 0; i < msg.length; i += 2)
	        res.push(parseInt(msg[i] + msg[i + 1], 16));
	    }
	  } else {
	    for (i = 0; i < msg.length; i++)
	      res[i] = msg[i] | 0;
	  }
	  return res;
	}
	var toArray_1 = toArray$1$1;

	function toHex$1$1(msg) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++)
	    res += zero2(msg[i].toString(16));
	  return res;
	}
	var toHex_1 = toHex$1$1;

	function htonl(w) {
	  var res = (w >>> 24) |
	            ((w >>> 8) & 0xff00) |
	            ((w << 8) & 0xff0000) |
	            ((w & 0xff) << 24);
	  return res >>> 0;
	}
	var htonl_1 = htonl;

	function toHex32(msg, endian) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++) {
	    var w = msg[i];
	    if (endian === 'little')
	      w = htonl(w);
	    res += zero8(w.toString(16));
	  }
	  return res;
	}
	var toHex32_1 = toHex32;

	function zero2(word) {
	  if (word.length === 1)
	    return '0' + word;
	  else
	    return word;
	}
	var zero2_1 = zero2;

	function zero8(word) {
	  if (word.length === 7)
	    return '0' + word;
	  else if (word.length === 6)
	    return '00' + word;
	  else if (word.length === 5)
	    return '000' + word;
	  else if (word.length === 4)
	    return '0000' + word;
	  else if (word.length === 3)
	    return '00000' + word;
	  else if (word.length === 2)
	    return '000000' + word;
	  else if (word.length === 1)
	    return '0000000' + word;
	  else
	    return word;
	}
	var zero8_1 = zero8;

	function join32(msg, start, end, endian) {
	  var len = end - start;
	  minimalisticAssert(len % 4 === 0);
	  var res = new Array(len / 4);
	  for (var i = 0, k = start; i < res.length; i++, k += 4) {
	    var w;
	    if (endian === 'big')
	      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
	    else
	      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
	    res[i] = w >>> 0;
	  }
	  return res;
	}
	var join32_1 = join32;

	function split32(msg, endian) {
	  var res = new Array(msg.length * 4);
	  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
	    var m = msg[i];
	    if (endian === 'big') {
	      res[k] = m >>> 24;
	      res[k + 1] = (m >>> 16) & 0xff;
	      res[k + 2] = (m >>> 8) & 0xff;
	      res[k + 3] = m & 0xff;
	    } else {
	      res[k + 3] = m >>> 24;
	      res[k + 2] = (m >>> 16) & 0xff;
	      res[k + 1] = (m >>> 8) & 0xff;
	      res[k] = m & 0xff;
	    }
	  }
	  return res;
	}
	var split32_1 = split32;

	function rotr32(w, b) {
	  return (w >>> b) | (w << (32 - b));
	}
	var rotr32_1 = rotr32;

	function rotl32(w, b) {
	  return (w << b) | (w >>> (32 - b));
	}
	var rotl32_1 = rotl32;

	function sum32(a, b) {
	  return (a + b) >>> 0;
	}
	var sum32_1 = sum32;

	function sum32_3(a, b, c) {
	  return (a + b + c) >>> 0;
	}
	var sum32_3_1 = sum32_3;

	function sum32_4(a, b, c, d) {
	  return (a + b + c + d) >>> 0;
	}
	var sum32_4_1 = sum32_4;

	function sum32_5(a, b, c, d, e) {
	  return (a + b + c + d + e) >>> 0;
	}
	var sum32_5_1 = sum32_5;

	function sum64(buf, pos, ah, al) {
	  var bh = buf[pos];
	  var bl = buf[pos + 1];

	  var lo = (al + bl) >>> 0;
	  var hi = (lo < al ? 1 : 0) + ah + bh;
	  buf[pos] = hi >>> 0;
	  buf[pos + 1] = lo;
	}
	var sum64_1 = sum64;

	function sum64_hi(ah, al, bh, bl) {
	  var lo = (al + bl) >>> 0;
	  var hi = (lo < al ? 1 : 0) + ah + bh;
	  return hi >>> 0;
	}
	var sum64_hi_1 = sum64_hi;

	function sum64_lo(ah, al, bh, bl) {
	  var lo = al + bl;
	  return lo >>> 0;
	}
	var sum64_lo_1 = sum64_lo;

	function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
	  var carry = 0;
	  var lo = al;
	  lo = (lo + bl) >>> 0;
	  carry += lo < al ? 1 : 0;
	  lo = (lo + cl) >>> 0;
	  carry += lo < cl ? 1 : 0;
	  lo = (lo + dl) >>> 0;
	  carry += lo < dl ? 1 : 0;

	  var hi = ah + bh + ch + dh + carry;
	  return hi >>> 0;
	}
	var sum64_4_hi_1 = sum64_4_hi;

	function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
	  var lo = al + bl + cl + dl;
	  return lo >>> 0;
	}
	var sum64_4_lo_1 = sum64_4_lo;

	function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  var carry = 0;
	  var lo = al;
	  lo = (lo + bl) >>> 0;
	  carry += lo < al ? 1 : 0;
	  lo = (lo + cl) >>> 0;
	  carry += lo < cl ? 1 : 0;
	  lo = (lo + dl) >>> 0;
	  carry += lo < dl ? 1 : 0;
	  lo = (lo + el) >>> 0;
	  carry += lo < el ? 1 : 0;

	  var hi = ah + bh + ch + dh + eh + carry;
	  return hi >>> 0;
	}
	var sum64_5_hi_1 = sum64_5_hi;

	function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  var lo = al + bl + cl + dl + el;

	  return lo >>> 0;
	}
	var sum64_5_lo_1 = sum64_5_lo;

	function rotr64_hi(ah, al, num) {
	  var r = (al << (32 - num)) | (ah >>> num);
	  return r >>> 0;
	}
	var rotr64_hi_1 = rotr64_hi;

	function rotr64_lo(ah, al, num) {
	  var r = (ah << (32 - num)) | (al >>> num);
	  return r >>> 0;
	}
	var rotr64_lo_1 = rotr64_lo;

	function shr64_hi(ah, al, num) {
	  return ah >>> num;
	}
	var shr64_hi_1 = shr64_hi;

	function shr64_lo(ah, al, num) {
	  var r = (ah << (32 - num)) | (al >>> num);
	  return r >>> 0;
	}
	var shr64_lo_1 = shr64_lo;

	var utils$1$1 = {
		inherits: inherits_1,
		toArray: toArray_1,
		toHex: toHex_1,
		htonl: htonl_1,
		toHex32: toHex32_1,
		zero2: zero2_1,
		zero8: zero8_1,
		join32: join32_1,
		split32: split32_1,
		rotr32: rotr32_1,
		rotl32: rotl32_1,
		sum32: sum32_1,
		sum32_3: sum32_3_1,
		sum32_4: sum32_4_1,
		sum32_5: sum32_5_1,
		sum64: sum64_1,
		sum64_hi: sum64_hi_1,
		sum64_lo: sum64_lo_1,
		sum64_4_hi: sum64_4_hi_1,
		sum64_4_lo: sum64_4_lo_1,
		sum64_5_hi: sum64_5_hi_1,
		sum64_5_lo: sum64_5_lo_1,
		rotr64_hi: rotr64_hi_1,
		rotr64_lo: rotr64_lo_1,
		shr64_hi: shr64_hi_1,
		shr64_lo: shr64_lo_1
	};

	function BlockHash() {
	  this.pending = null;
	  this.pendingTotal = 0;
	  this.blockSize = this.constructor.blockSize;
	  this.outSize = this.constructor.outSize;
	  this.hmacStrength = this.constructor.hmacStrength;
	  this.padLength = this.constructor.padLength / 8;
	  this.endian = 'big';

	  this._delta8 = this.blockSize / 8;
	  this._delta32 = this.blockSize / 32;
	}
	var BlockHash_1 = BlockHash;

	BlockHash.prototype.update = function update(msg, enc) {
	  // Convert message to array, pad it, and join into 32bit blocks
	  msg = utils$1$1.toArray(msg, enc);
	  if (!this.pending)
	    this.pending = msg;
	  else
	    this.pending = this.pending.concat(msg);
	  this.pendingTotal += msg.length;

	  // Enough data, try updating
	  if (this.pending.length >= this._delta8) {
	    msg = this.pending;

	    // Process pending data in blocks
	    var r = msg.length % this._delta8;
	    this.pending = msg.slice(msg.length - r, msg.length);
	    if (this.pending.length === 0)
	      this.pending = null;

	    msg = utils$1$1.join32(msg, 0, msg.length - r, this.endian);
	    for (var i = 0; i < msg.length; i += this._delta32)
	      this._update(msg, i, i + this._delta32);
	  }

	  return this;
	};

	BlockHash.prototype.digest = function digest(enc) {
	  this.update(this._pad());
	  minimalisticAssert(this.pending === null);

	  return this._digest(enc);
	};

	BlockHash.prototype._pad = function pad() {
	  var len = this.pendingTotal;
	  var bytes = this._delta8;
	  var k = bytes - ((len + this.padLength) % bytes);
	  var res = new Array(k + this.padLength);
	  res[0] = 0x80;
	  for (var i = 1; i < k; i++)
	    res[i] = 0;

	  // Append length
	  len <<= 3;
	  if (this.endian === 'big') {
	    for (var t = 8; t < this.padLength; t++)
	      res[i++] = 0;

	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = (len >>> 24) & 0xff;
	    res[i++] = (len >>> 16) & 0xff;
	    res[i++] = (len >>> 8) & 0xff;
	    res[i++] = len & 0xff;
	  } else {
	    res[i++] = len & 0xff;
	    res[i++] = (len >>> 8) & 0xff;
	    res[i++] = (len >>> 16) & 0xff;
	    res[i++] = (len >>> 24) & 0xff;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;

	    for (t = 8; t < this.padLength; t++)
	      res[i++] = 0;
	  }

	  return res;
	};

	var common = {
		BlockHash: BlockHash_1
	};

	var rotr32$1 = utils$1$1.rotr32;

	function ft_1(s, x, y, z) {
	  if (s === 0)
	    return ch32(x, y, z);
	  if (s === 1 || s === 3)
	    return p32(x, y, z);
	  if (s === 2)
	    return maj32(x, y, z);
	}
	var ft_1_1 = ft_1;

	function ch32(x, y, z) {
	  return (x & y) ^ ((~x) & z);
	}
	var ch32_1 = ch32;

	function maj32(x, y, z) {
	  return (x & y) ^ (x & z) ^ (y & z);
	}
	var maj32_1 = maj32;

	function p32(x, y, z) {
	  return x ^ y ^ z;
	}
	var p32_1 = p32;

	function s0_256(x) {
	  return rotr32$1(x, 2) ^ rotr32$1(x, 13) ^ rotr32$1(x, 22);
	}
	var s0_256_1 = s0_256;

	function s1_256(x) {
	  return rotr32$1(x, 6) ^ rotr32$1(x, 11) ^ rotr32$1(x, 25);
	}
	var s1_256_1 = s1_256;

	function g0_256(x) {
	  return rotr32$1(x, 7) ^ rotr32$1(x, 18) ^ (x >>> 3);
	}
	var g0_256_1 = g0_256;

	function g1_256(x) {
	  return rotr32$1(x, 17) ^ rotr32$1(x, 19) ^ (x >>> 10);
	}
	var g1_256_1 = g1_256;

	var common$1 = {
		ft_1: ft_1_1,
		ch32: ch32_1,
		maj32: maj32_1,
		p32: p32_1,
		s0_256: s0_256_1,
		s1_256: s1_256_1,
		g0_256: g0_256_1,
		g1_256: g1_256_1
	};

	var rotl32$1 = utils$1$1.rotl32;
	var sum32$1 = utils$1$1.sum32;
	var sum32_5$1 = utils$1$1.sum32_5;
	var ft_1$1 = common$1.ft_1;
	var BlockHash$1 = common.BlockHash;

	var sha1_K = [
	  0x5A827999, 0x6ED9EBA1,
	  0x8F1BBCDC, 0xCA62C1D6
	];

	function SHA1() {
	  if (!(this instanceof SHA1))
	    return new SHA1();

	  BlockHash$1.call(this);
	  this.h = [
	    0x67452301, 0xefcdab89, 0x98badcfe,
	    0x10325476, 0xc3d2e1f0 ];
	  this.W = new Array(80);
	}

	utils$1$1.inherits(SHA1, BlockHash$1);
	var _1 = SHA1;

	SHA1.blockSize = 512;
	SHA1.outSize = 160;
	SHA1.hmacStrength = 80;
	SHA1.padLength = 64;

	SHA1.prototype._update = function _update(msg, start) {
	  var W = this.W;

	  for (var i = 0; i < 16; i++)
	    W[i] = msg[start + i];

	  for(; i < W.length; i++)
	    W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

	  var a = this.h[0];
	  var b = this.h[1];
	  var c = this.h[2];
	  var d = this.h[3];
	  var e = this.h[4];

	  for (i = 0; i < W.length; i++) {
	    var s = ~~(i / 20);
	    var t = sum32_5$1(rotl32$1(a, 5), ft_1$1(s, b, c, d), e, W[i], sha1_K[s]);
	    e = d;
	    d = c;
	    c = rotl32$1(b, 30);
	    b = a;
	    a = t;
	  }

	  this.h[0] = sum32$1(this.h[0], a);
	  this.h[1] = sum32$1(this.h[1], b);
	  this.h[2] = sum32$1(this.h[2], c);
	  this.h[3] = sum32$1(this.h[3], d);
	  this.h[4] = sum32$1(this.h[4], e);
	};

	SHA1.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils$1$1.toHex32(this.h, 'big');
	  else
	    return utils$1$1.split32(this.h, 'big');
	};

	var sum32$2 = utils$1$1.sum32;
	var sum32_4$1 = utils$1$1.sum32_4;
	var sum32_5$2 = utils$1$1.sum32_5;
	var ch32$1 = common$1.ch32;
	var maj32$1 = common$1.maj32;
	var s0_256$1 = common$1.s0_256;
	var s1_256$1 = common$1.s1_256;
	var g0_256$1 = common$1.g0_256;
	var g1_256$1 = common$1.g1_256;

	var BlockHash$2 = common.BlockHash;

	var sha256_K = [
	  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
	  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
	  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
	  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
	  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
	  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
	  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
	  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
	  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
	];

	function SHA256() {
	  if (!(this instanceof SHA256))
	    return new SHA256();

	  BlockHash$2.call(this);
	  this.h = [
	    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
	    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
	  ];
	  this.k = sha256_K;
	  this.W = new Array(64);
	}
	utils$1$1.inherits(SHA256, BlockHash$2);
	var _256 = SHA256;

	SHA256.blockSize = 512;
	SHA256.outSize = 256;
	SHA256.hmacStrength = 192;
	SHA256.padLength = 64;

	SHA256.prototype._update = function _update(msg, start) {
	  var W = this.W;

	  for (var i = 0; i < 16; i++)
	    W[i] = msg[start + i];
	  for (; i < W.length; i++)
	    W[i] = sum32_4$1(g1_256$1(W[i - 2]), W[i - 7], g0_256$1(W[i - 15]), W[i - 16]);

	  var a = this.h[0];
	  var b = this.h[1];
	  var c = this.h[2];
	  var d = this.h[3];
	  var e = this.h[4];
	  var f = this.h[5];
	  var g = this.h[6];
	  var h = this.h[7];

	  minimalisticAssert(this.k.length === W.length);
	  for (i = 0; i < W.length; i++) {
	    var T1 = sum32_5$2(h, s1_256$1(e), ch32$1(e, f, g), this.k[i], W[i]);
	    var T2 = sum32$2(s0_256$1(a), maj32$1(a, b, c));
	    h = g;
	    g = f;
	    f = e;
	    e = sum32$2(d, T1);
	    d = c;
	    c = b;
	    b = a;
	    a = sum32$2(T1, T2);
	  }

	  this.h[0] = sum32$2(this.h[0], a);
	  this.h[1] = sum32$2(this.h[1], b);
	  this.h[2] = sum32$2(this.h[2], c);
	  this.h[3] = sum32$2(this.h[3], d);
	  this.h[4] = sum32$2(this.h[4], e);
	  this.h[5] = sum32$2(this.h[5], f);
	  this.h[6] = sum32$2(this.h[6], g);
	  this.h[7] = sum32$2(this.h[7], h);
	};

	SHA256.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils$1$1.toHex32(this.h, 'big');
	  else
	    return utils$1$1.split32(this.h, 'big');
	};

	function SHA224() {
	  if (!(this instanceof SHA224))
	    return new SHA224();

	  _256.call(this);
	  this.h = [
	    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
	}
	utils$1$1.inherits(SHA224, _256);
	var _224 = SHA224;

	SHA224.blockSize = 512;
	SHA224.outSize = 224;
	SHA224.hmacStrength = 192;
	SHA224.padLength = 64;

	SHA224.prototype._digest = function digest(enc) {
	  // Just truncate output
	  if (enc === 'hex')
	    return utils$1$1.toHex32(this.h.slice(0, 7), 'big');
	  else
	    return utils$1$1.split32(this.h.slice(0, 7), 'big');
	};

	var rotr64_hi$1 = utils$1$1.rotr64_hi;
	var rotr64_lo$1 = utils$1$1.rotr64_lo;
	var shr64_hi$1 = utils$1$1.shr64_hi;
	var shr64_lo$1 = utils$1$1.shr64_lo;
	var sum64$1 = utils$1$1.sum64;
	var sum64_hi$1 = utils$1$1.sum64_hi;
	var sum64_lo$1 = utils$1$1.sum64_lo;
	var sum64_4_hi$1 = utils$1$1.sum64_4_hi;
	var sum64_4_lo$1 = utils$1$1.sum64_4_lo;
	var sum64_5_hi$1 = utils$1$1.sum64_5_hi;
	var sum64_5_lo$1 = utils$1$1.sum64_5_lo;

	var BlockHash$3 = common.BlockHash;

	var sha512_K = [
	  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	];

	function SHA512() {
	  if (!(this instanceof SHA512))
	    return new SHA512();

	  BlockHash$3.call(this);
	  this.h = [
	    0x6a09e667, 0xf3bcc908,
	    0xbb67ae85, 0x84caa73b,
	    0x3c6ef372, 0xfe94f82b,
	    0xa54ff53a, 0x5f1d36f1,
	    0x510e527f, 0xade682d1,
	    0x9b05688c, 0x2b3e6c1f,
	    0x1f83d9ab, 0xfb41bd6b,
	    0x5be0cd19, 0x137e2179 ];
	  this.k = sha512_K;
	  this.W = new Array(160);
	}
	utils$1$1.inherits(SHA512, BlockHash$3);
	var _512 = SHA512;

	SHA512.blockSize = 1024;
	SHA512.outSize = 512;
	SHA512.hmacStrength = 192;
	SHA512.padLength = 128;

	SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
	  var W = this.W;

	  // 32 x 32bit words
	  for (var i = 0; i < 32; i++)
	    W[i] = msg[start + i];
	  for (; i < W.length; i += 2) {
	    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
	    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
	    var c1_hi = W[i - 14];  // i - 7
	    var c1_lo = W[i - 13];
	    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
	    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
	    var c3_hi = W[i - 32];  // i - 16
	    var c3_lo = W[i - 31];

	    W[i] = sum64_4_hi$1(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo);
	    W[i + 1] = sum64_4_lo$1(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo);
	  }
	};

	SHA512.prototype._update = function _update(msg, start) {
	  this._prepareBlock(msg, start);

	  var W = this.W;

	  var ah = this.h[0];
	  var al = this.h[1];
	  var bh = this.h[2];
	  var bl = this.h[3];
	  var ch = this.h[4];
	  var cl = this.h[5];
	  var dh = this.h[6];
	  var dl = this.h[7];
	  var eh = this.h[8];
	  var el = this.h[9];
	  var fh = this.h[10];
	  var fl = this.h[11];
	  var gh = this.h[12];
	  var gl = this.h[13];
	  var hh = this.h[14];
	  var hl = this.h[15];

	  minimalisticAssert(this.k.length === W.length);
	  for (var i = 0; i < W.length; i += 2) {
	    var c0_hi = hh;
	    var c0_lo = hl;
	    var c1_hi = s1_512_hi(eh, el);
	    var c1_lo = s1_512_lo(eh, el);
	    var c2_hi = ch64_hi(eh, el, fh, fl, gh);
	    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
	    var c3_hi = this.k[i];
	    var c3_lo = this.k[i + 1];
	    var c4_hi = W[i];
	    var c4_lo = W[i + 1];

	    var T1_hi = sum64_5_hi$1(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo,
	      c4_hi, c4_lo);
	    var T1_lo = sum64_5_lo$1(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo,
	      c4_hi, c4_lo);

	    c0_hi = s0_512_hi(ah, al);
	    c0_lo = s0_512_lo(ah, al);
	    c1_hi = maj64_hi(ah, al, bh, bl, ch);
	    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

	    var T2_hi = sum64_hi$1(c0_hi, c0_lo, c1_hi, c1_lo);
	    var T2_lo = sum64_lo$1(c0_hi, c0_lo, c1_hi, c1_lo);

	    hh = gh;
	    hl = gl;

	    gh = fh;
	    gl = fl;

	    fh = eh;
	    fl = el;

	    eh = sum64_hi$1(dh, dl, T1_hi, T1_lo);
	    el = sum64_lo$1(dl, dl, T1_hi, T1_lo);

	    dh = ch;
	    dl = cl;

	    ch = bh;
	    cl = bl;

	    bh = ah;
	    bl = al;

	    ah = sum64_hi$1(T1_hi, T1_lo, T2_hi, T2_lo);
	    al = sum64_lo$1(T1_hi, T1_lo, T2_hi, T2_lo);
	  }

	  sum64$1(this.h, 0, ah, al);
	  sum64$1(this.h, 2, bh, bl);
	  sum64$1(this.h, 4, ch, cl);
	  sum64$1(this.h, 6, dh, dl);
	  sum64$1(this.h, 8, eh, el);
	  sum64$1(this.h, 10, fh, fl);
	  sum64$1(this.h, 12, gh, gl);
	  sum64$1(this.h, 14, hh, hl);
	};

	SHA512.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils$1$1.toHex32(this.h, 'big');
	  else
	    return utils$1$1.split32(this.h, 'big');
	};

	function ch64_hi(xh, xl, yh, yl, zh) {
	  var r = (xh & yh) ^ ((~xh) & zh);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function ch64_lo(xh, xl, yh, yl, zh, zl) {
	  var r = (xl & yl) ^ ((~xl) & zl);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function maj64_hi(xh, xl, yh, yl, zh) {
	  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function maj64_lo(xh, xl, yh, yl, zh, zl) {
	  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s0_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi$1(xh, xl, 28);
	  var c1_hi = rotr64_hi$1(xl, xh, 2);  // 34
	  var c2_hi = rotr64_hi$1(xl, xh, 7);  // 39

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s0_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo$1(xh, xl, 28);
	  var c1_lo = rotr64_lo$1(xl, xh, 2);  // 34
	  var c2_lo = rotr64_lo$1(xl, xh, 7);  // 39

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s1_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi$1(xh, xl, 14);
	  var c1_hi = rotr64_hi$1(xh, xl, 18);
	  var c2_hi = rotr64_hi$1(xl, xh, 9);  // 41

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s1_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo$1(xh, xl, 14);
	  var c1_lo = rotr64_lo$1(xh, xl, 18);
	  var c2_lo = rotr64_lo$1(xl, xh, 9);  // 41

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g0_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi$1(xh, xl, 1);
	  var c1_hi = rotr64_hi$1(xh, xl, 8);
	  var c2_hi = shr64_hi$1(xh, xl, 7);

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g0_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo$1(xh, xl, 1);
	  var c1_lo = rotr64_lo$1(xh, xl, 8);
	  var c2_lo = shr64_lo$1(xh, xl, 7);

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g1_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi$1(xh, xl, 19);
	  var c1_hi = rotr64_hi$1(xl, xh, 29);  // 61
	  var c2_hi = shr64_hi$1(xh, xl, 6);

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g1_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo$1(xh, xl, 19);
	  var c1_lo = rotr64_lo$1(xl, xh, 29);  // 61
	  var c2_lo = shr64_lo$1(xh, xl, 6);

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function SHA384() {
	  if (!(this instanceof SHA384))
	    return new SHA384();

	  _512.call(this);
	  this.h = [
	    0xcbbb9d5d, 0xc1059ed8,
	    0x629a292a, 0x367cd507,
	    0x9159015a, 0x3070dd17,
	    0x152fecd8, 0xf70e5939,
	    0x67332667, 0xffc00b31,
	    0x8eb44a87, 0x68581511,
	    0xdb0c2e0d, 0x64f98fa7,
	    0x47b5481d, 0xbefa4fa4 ];
	}
	utils$1$1.inherits(SHA384, _512);
	var _384 = SHA384;

	SHA384.blockSize = 1024;
	SHA384.outSize = 384;
	SHA384.hmacStrength = 192;
	SHA384.padLength = 128;

	SHA384.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils$1$1.toHex32(this.h.slice(0, 12), 'big');
	  else
	    return utils$1$1.split32(this.h.slice(0, 12), 'big');
	};

	var sha1 = _1;
	var sha224 = _224;
	var sha256 = _256;
	var sha384 = _384;
	var sha512 = _512;

	var sha = {
		sha1: sha1,
		sha224: sha224,
		sha256: sha256,
		sha384: sha384,
		sha512: sha512
	};

	var rotl32$2 = utils$1$1.rotl32;
	var sum32$3 = utils$1$1.sum32;
	var sum32_3$1 = utils$1$1.sum32_3;
	var sum32_4$2 = utils$1$1.sum32_4;
	var BlockHash$4 = common.BlockHash;

	function RIPEMD160() {
	  if (!(this instanceof RIPEMD160))
	    return new RIPEMD160();

	  BlockHash$4.call(this);

	  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
	  this.endian = 'little';
	}
	utils$1$1.inherits(RIPEMD160, BlockHash$4);
	var ripemd160 = RIPEMD160;

	RIPEMD160.blockSize = 512;
	RIPEMD160.outSize = 160;
	RIPEMD160.hmacStrength = 192;
	RIPEMD160.padLength = 64;

	RIPEMD160.prototype._update = function update(msg, start) {
	  var A = this.h[0];
	  var B = this.h[1];
	  var C = this.h[2];
	  var D = this.h[3];
	  var E = this.h[4];
	  var Ah = A;
	  var Bh = B;
	  var Ch = C;
	  var Dh = D;
	  var Eh = E;
	  for (var j = 0; j < 80; j++) {
	    var T = sum32$3(
	      rotl32$2(
	        sum32_4$2(A, f$8(j, B, C, D), msg[r[j] + start], K(j)),
	        s[j]),
	      E);
	    A = E;
	    E = D;
	    D = rotl32$2(C, 10);
	    C = B;
	    B = T;
	    T = sum32$3(
	      rotl32$2(
	        sum32_4$2(Ah, f$8(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
	        sh[j]),
	      Eh);
	    Ah = Eh;
	    Eh = Dh;
	    Dh = rotl32$2(Ch, 10);
	    Ch = Bh;
	    Bh = T;
	  }
	  T = sum32_3$1(this.h[1], C, Dh);
	  this.h[1] = sum32_3$1(this.h[2], D, Eh);
	  this.h[2] = sum32_3$1(this.h[3], E, Ah);
	  this.h[3] = sum32_3$1(this.h[4], A, Bh);
	  this.h[4] = sum32_3$1(this.h[0], B, Ch);
	  this.h[0] = T;
	};

	RIPEMD160.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils$1$1.toHex32(this.h, 'little');
	  else
	    return utils$1$1.split32(this.h, 'little');
	};

	function f$8(j, x, y, z) {
	  if (j <= 15)
	    return x ^ y ^ z;
	  else if (j <= 31)
	    return (x & y) | ((~x) & z);
	  else if (j <= 47)
	    return (x | (~y)) ^ z;
	  else if (j <= 63)
	    return (x & z) | (y & (~z));
	  else
	    return x ^ (y | (~z));
	}

	function K(j) {
	  if (j <= 15)
	    return 0x00000000;
	  else if (j <= 31)
	    return 0x5a827999;
	  else if (j <= 47)
	    return 0x6ed9eba1;
	  else if (j <= 63)
	    return 0x8f1bbcdc;
	  else
	    return 0xa953fd4e;
	}

	function Kh(j) {
	  if (j <= 15)
	    return 0x50a28be6;
	  else if (j <= 31)
	    return 0x5c4dd124;
	  else if (j <= 47)
	    return 0x6d703ef3;
	  else if (j <= 63)
	    return 0x7a6d76e9;
	  else
	    return 0x00000000;
	}

	var r = [
	  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
	  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
	  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
	  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
	];

	var rh = [
	  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
	  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
	  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
	  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
	  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
	];

	var s = [
	  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
	  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
	  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
	  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
	  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
	];

	var sh = [
	  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
	  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
	  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
	  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
	  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
	];

	var ripemd = {
		ripemd160: ripemd160
	};

	function Hmac(hash, key, enc) {
	  if (!(this instanceof Hmac))
	    return new Hmac(hash, key, enc);
	  this.Hash = hash;
	  this.blockSize = hash.blockSize / 8;
	  this.outSize = hash.outSize / 8;
	  this.inner = null;
	  this.outer = null;

	  this._init(utils$1$1.toArray(key, enc));
	}
	var hmac = Hmac;

	Hmac.prototype._init = function init(key) {
	  // Shorten key, if needed
	  if (key.length > this.blockSize)
	    key = new this.Hash().update(key).digest();
	  minimalisticAssert(key.length <= this.blockSize);

	  // Add padding to key
	  for (var i = key.length; i < this.blockSize; i++)
	    key.push(0);

	  for (i = 0; i < key.length; i++)
	    key[i] ^= 0x36;
	  this.inner = new this.Hash().update(key);

	  // 0x36 ^ 0x5c = 0x6a
	  for (i = 0; i < key.length; i++)
	    key[i] ^= 0x6a;
	  this.outer = new this.Hash().update(key);
	};

	Hmac.prototype.update = function update(msg, enc) {
	  this.inner.update(msg, enc);
	  return this;
	};

	Hmac.prototype.digest = function digest(enc) {
	  this.outer.update(this.inner.digest());
	  return this.outer.digest(enc);
	};

	var hash_1 = createCommonjsModule$1(function (module, exports) {
	var hash = exports;

	hash.utils = utils$1$1;
	hash.common = common;
	hash.sha = sha;
	hash.ripemd = ripemd;
	hash.hmac = hmac;

	// Proxy hash functions to the main object
	hash.sha1 = hash.sha.sha1;
	hash.sha256 = hash.sha.sha256;
	hash.sha224 = hash.sha.sha224;
	hash.sha384 = hash.sha.sha384;
	hash.sha512 = hash.sha.sha512;
	hash.ripemd160 = hash.ripemd.ripemd160;
	});
	var hash_2 = hash_1.sha256;

	var _nodeResolve_empty = {};

	var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': _nodeResolve_empty
	});

	var require$$0 = getCjsExportFromNamespace(_nodeResolve_empty$1);

	var naclFast = createCommonjsModule$1(function (module) {
	(function(nacl) {

	// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
	// Public domain.
	//
	// Implementation derived from TweetNaCl version 20140427.
	// See for details: http://tweetnacl.cr.yp.to/

	var gf = function(init) {
	  var i, r = new Float64Array(16);
	  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
	  return r;
	};

	//  Pluggable, initialized in high-level API below.
	var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

	var _0 = new Uint8Array(16);
	var _9 = new Uint8Array(32); _9[0] = 9;

	var gf0 = gf(),
	    gf1 = gf([1]),
	    _121665 = gf([0xdb41, 1]),
	    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
	    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
	    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
	    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
	    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

	function ts64(x, i, h, l) {
	  x[i]   = (h >> 24) & 0xff;
	  x[i+1] = (h >> 16) & 0xff;
	  x[i+2] = (h >>  8) & 0xff;
	  x[i+3] = h & 0xff;
	  x[i+4] = (l >> 24)  & 0xff;
	  x[i+5] = (l >> 16)  & 0xff;
	  x[i+6] = (l >>  8)  & 0xff;
	  x[i+7] = l & 0xff;
	}

	function vn(x, xi, y, yi, n) {
	  var i,d = 0;
	  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
	  return (1 & ((d - 1) >>> 8)) - 1;
	}

	function crypto_verify_16(x, xi, y, yi) {
	  return vn(x,xi,y,yi,16);
	}

	function crypto_verify_32(x, xi, y, yi) {
	  return vn(x,xi,y,yi,32);
	}

	function core_salsa20(o, p, k, c) {
	  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
	      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
	      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
	      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
	      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
	      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
	      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
	      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
	      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
	      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
	      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
	      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
	      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
	      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
	      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
	      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

	  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
	      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
	      x15 = j15, u;

	  for (var i = 0; i < 20; i += 2) {
	    u = x0 + x12 | 0;
	    x4 ^= u<<7 | u>>>(32-7);
	    u = x4 + x0 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x4 | 0;
	    x12 ^= u<<13 | u>>>(32-13);
	    u = x12 + x8 | 0;
	    x0 ^= u<<18 | u>>>(32-18);

	    u = x5 + x1 | 0;
	    x9 ^= u<<7 | u>>>(32-7);
	    u = x9 + x5 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x9 | 0;
	    x1 ^= u<<13 | u>>>(32-13);
	    u = x1 + x13 | 0;
	    x5 ^= u<<18 | u>>>(32-18);

	    u = x10 + x6 | 0;
	    x14 ^= u<<7 | u>>>(32-7);
	    u = x14 + x10 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x14 | 0;
	    x6 ^= u<<13 | u>>>(32-13);
	    u = x6 + x2 | 0;
	    x10 ^= u<<18 | u>>>(32-18);

	    u = x15 + x11 | 0;
	    x3 ^= u<<7 | u>>>(32-7);
	    u = x3 + x15 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x3 | 0;
	    x11 ^= u<<13 | u>>>(32-13);
	    u = x11 + x7 | 0;
	    x15 ^= u<<18 | u>>>(32-18);

	    u = x0 + x3 | 0;
	    x1 ^= u<<7 | u>>>(32-7);
	    u = x1 + x0 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x1 | 0;
	    x3 ^= u<<13 | u>>>(32-13);
	    u = x3 + x2 | 0;
	    x0 ^= u<<18 | u>>>(32-18);

	    u = x5 + x4 | 0;
	    x6 ^= u<<7 | u>>>(32-7);
	    u = x6 + x5 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x6 | 0;
	    x4 ^= u<<13 | u>>>(32-13);
	    u = x4 + x7 | 0;
	    x5 ^= u<<18 | u>>>(32-18);

	    u = x10 + x9 | 0;
	    x11 ^= u<<7 | u>>>(32-7);
	    u = x11 + x10 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x11 | 0;
	    x9 ^= u<<13 | u>>>(32-13);
	    u = x9 + x8 | 0;
	    x10 ^= u<<18 | u>>>(32-18);

	    u = x15 + x14 | 0;
	    x12 ^= u<<7 | u>>>(32-7);
	    u = x12 + x15 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x12 | 0;
	    x14 ^= u<<13 | u>>>(32-13);
	    u = x14 + x13 | 0;
	    x15 ^= u<<18 | u>>>(32-18);
	  }
	   x0 =  x0 +  j0 | 0;
	   x1 =  x1 +  j1 | 0;
	   x2 =  x2 +  j2 | 0;
	   x3 =  x3 +  j3 | 0;
	   x4 =  x4 +  j4 | 0;
	   x5 =  x5 +  j5 | 0;
	   x6 =  x6 +  j6 | 0;
	   x7 =  x7 +  j7 | 0;
	   x8 =  x8 +  j8 | 0;
	   x9 =  x9 +  j9 | 0;
	  x10 = x10 + j10 | 0;
	  x11 = x11 + j11 | 0;
	  x12 = x12 + j12 | 0;
	  x13 = x13 + j13 | 0;
	  x14 = x14 + j14 | 0;
	  x15 = x15 + j15 | 0;

	  o[ 0] = x0 >>>  0 & 0xff;
	  o[ 1] = x0 >>>  8 & 0xff;
	  o[ 2] = x0 >>> 16 & 0xff;
	  o[ 3] = x0 >>> 24 & 0xff;

	  o[ 4] = x1 >>>  0 & 0xff;
	  o[ 5] = x1 >>>  8 & 0xff;
	  o[ 6] = x1 >>> 16 & 0xff;
	  o[ 7] = x1 >>> 24 & 0xff;

	  o[ 8] = x2 >>>  0 & 0xff;
	  o[ 9] = x2 >>>  8 & 0xff;
	  o[10] = x2 >>> 16 & 0xff;
	  o[11] = x2 >>> 24 & 0xff;

	  o[12] = x3 >>>  0 & 0xff;
	  o[13] = x3 >>>  8 & 0xff;
	  o[14] = x3 >>> 16 & 0xff;
	  o[15] = x3 >>> 24 & 0xff;

	  o[16] = x4 >>>  0 & 0xff;
	  o[17] = x4 >>>  8 & 0xff;
	  o[18] = x4 >>> 16 & 0xff;
	  o[19] = x4 >>> 24 & 0xff;

	  o[20] = x5 >>>  0 & 0xff;
	  o[21] = x5 >>>  8 & 0xff;
	  o[22] = x5 >>> 16 & 0xff;
	  o[23] = x5 >>> 24 & 0xff;

	  o[24] = x6 >>>  0 & 0xff;
	  o[25] = x6 >>>  8 & 0xff;
	  o[26] = x6 >>> 16 & 0xff;
	  o[27] = x6 >>> 24 & 0xff;

	  o[28] = x7 >>>  0 & 0xff;
	  o[29] = x7 >>>  8 & 0xff;
	  o[30] = x7 >>> 16 & 0xff;
	  o[31] = x7 >>> 24 & 0xff;

	  o[32] = x8 >>>  0 & 0xff;
	  o[33] = x8 >>>  8 & 0xff;
	  o[34] = x8 >>> 16 & 0xff;
	  o[35] = x8 >>> 24 & 0xff;

	  o[36] = x9 >>>  0 & 0xff;
	  o[37] = x9 >>>  8 & 0xff;
	  o[38] = x9 >>> 16 & 0xff;
	  o[39] = x9 >>> 24 & 0xff;

	  o[40] = x10 >>>  0 & 0xff;
	  o[41] = x10 >>>  8 & 0xff;
	  o[42] = x10 >>> 16 & 0xff;
	  o[43] = x10 >>> 24 & 0xff;

	  o[44] = x11 >>>  0 & 0xff;
	  o[45] = x11 >>>  8 & 0xff;
	  o[46] = x11 >>> 16 & 0xff;
	  o[47] = x11 >>> 24 & 0xff;

	  o[48] = x12 >>>  0 & 0xff;
	  o[49] = x12 >>>  8 & 0xff;
	  o[50] = x12 >>> 16 & 0xff;
	  o[51] = x12 >>> 24 & 0xff;

	  o[52] = x13 >>>  0 & 0xff;
	  o[53] = x13 >>>  8 & 0xff;
	  o[54] = x13 >>> 16 & 0xff;
	  o[55] = x13 >>> 24 & 0xff;

	  o[56] = x14 >>>  0 & 0xff;
	  o[57] = x14 >>>  8 & 0xff;
	  o[58] = x14 >>> 16 & 0xff;
	  o[59] = x14 >>> 24 & 0xff;

	  o[60] = x15 >>>  0 & 0xff;
	  o[61] = x15 >>>  8 & 0xff;
	  o[62] = x15 >>> 16 & 0xff;
	  o[63] = x15 >>> 24 & 0xff;
	}

	function core_hsalsa20(o,p,k,c) {
	  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
	      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
	      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
	      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
	      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
	      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
	      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
	      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
	      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
	      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
	      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
	      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
	      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
	      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
	      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
	      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

	  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
	      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
	      x15 = j15, u;

	  for (var i = 0; i < 20; i += 2) {
	    u = x0 + x12 | 0;
	    x4 ^= u<<7 | u>>>(32-7);
	    u = x4 + x0 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x4 | 0;
	    x12 ^= u<<13 | u>>>(32-13);
	    u = x12 + x8 | 0;
	    x0 ^= u<<18 | u>>>(32-18);

	    u = x5 + x1 | 0;
	    x9 ^= u<<7 | u>>>(32-7);
	    u = x9 + x5 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x9 | 0;
	    x1 ^= u<<13 | u>>>(32-13);
	    u = x1 + x13 | 0;
	    x5 ^= u<<18 | u>>>(32-18);

	    u = x10 + x6 | 0;
	    x14 ^= u<<7 | u>>>(32-7);
	    u = x14 + x10 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x14 | 0;
	    x6 ^= u<<13 | u>>>(32-13);
	    u = x6 + x2 | 0;
	    x10 ^= u<<18 | u>>>(32-18);

	    u = x15 + x11 | 0;
	    x3 ^= u<<7 | u>>>(32-7);
	    u = x3 + x15 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x3 | 0;
	    x11 ^= u<<13 | u>>>(32-13);
	    u = x11 + x7 | 0;
	    x15 ^= u<<18 | u>>>(32-18);

	    u = x0 + x3 | 0;
	    x1 ^= u<<7 | u>>>(32-7);
	    u = x1 + x0 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x1 | 0;
	    x3 ^= u<<13 | u>>>(32-13);
	    u = x3 + x2 | 0;
	    x0 ^= u<<18 | u>>>(32-18);

	    u = x5 + x4 | 0;
	    x6 ^= u<<7 | u>>>(32-7);
	    u = x6 + x5 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x6 | 0;
	    x4 ^= u<<13 | u>>>(32-13);
	    u = x4 + x7 | 0;
	    x5 ^= u<<18 | u>>>(32-18);

	    u = x10 + x9 | 0;
	    x11 ^= u<<7 | u>>>(32-7);
	    u = x11 + x10 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x11 | 0;
	    x9 ^= u<<13 | u>>>(32-13);
	    u = x9 + x8 | 0;
	    x10 ^= u<<18 | u>>>(32-18);

	    u = x15 + x14 | 0;
	    x12 ^= u<<7 | u>>>(32-7);
	    u = x12 + x15 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x12 | 0;
	    x14 ^= u<<13 | u>>>(32-13);
	    u = x14 + x13 | 0;
	    x15 ^= u<<18 | u>>>(32-18);
	  }

	  o[ 0] = x0 >>>  0 & 0xff;
	  o[ 1] = x0 >>>  8 & 0xff;
	  o[ 2] = x0 >>> 16 & 0xff;
	  o[ 3] = x0 >>> 24 & 0xff;

	  o[ 4] = x5 >>>  0 & 0xff;
	  o[ 5] = x5 >>>  8 & 0xff;
	  o[ 6] = x5 >>> 16 & 0xff;
	  o[ 7] = x5 >>> 24 & 0xff;

	  o[ 8] = x10 >>>  0 & 0xff;
	  o[ 9] = x10 >>>  8 & 0xff;
	  o[10] = x10 >>> 16 & 0xff;
	  o[11] = x10 >>> 24 & 0xff;

	  o[12] = x15 >>>  0 & 0xff;
	  o[13] = x15 >>>  8 & 0xff;
	  o[14] = x15 >>> 16 & 0xff;
	  o[15] = x15 >>> 24 & 0xff;

	  o[16] = x6 >>>  0 & 0xff;
	  o[17] = x6 >>>  8 & 0xff;
	  o[18] = x6 >>> 16 & 0xff;
	  o[19] = x6 >>> 24 & 0xff;

	  o[20] = x7 >>>  0 & 0xff;
	  o[21] = x7 >>>  8 & 0xff;
	  o[22] = x7 >>> 16 & 0xff;
	  o[23] = x7 >>> 24 & 0xff;

	  o[24] = x8 >>>  0 & 0xff;
	  o[25] = x8 >>>  8 & 0xff;
	  o[26] = x8 >>> 16 & 0xff;
	  o[27] = x8 >>> 24 & 0xff;

	  o[28] = x9 >>>  0 & 0xff;
	  o[29] = x9 >>>  8 & 0xff;
	  o[30] = x9 >>> 16 & 0xff;
	  o[31] = x9 >>> 24 & 0xff;
	}

	function crypto_core_salsa20(out,inp,k,c) {
	  core_salsa20(out,inp,k,c);
	}

	function crypto_core_hsalsa20(out,inp,k,c) {
	  core_hsalsa20(out,inp,k,c);
	}

	var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
	            // "expand 32-byte k"

	function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
	  var z = new Uint8Array(16), x = new Uint8Array(64);
	  var u, i;
	  for (i = 0; i < 16; i++) z[i] = 0;
	  for (i = 0; i < 8; i++) z[i] = n[i];
	  while (b >= 64) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
	    u = 1;
	    for (i = 8; i < 16; i++) {
	      u = u + (z[i] & 0xff) | 0;
	      z[i] = u & 0xff;
	      u >>>= 8;
	    }
	    b -= 64;
	    cpos += 64;
	    mpos += 64;
	  }
	  if (b > 0) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
	  }
	  return 0;
	}

	function crypto_stream_salsa20(c,cpos,b,n,k) {
	  var z = new Uint8Array(16), x = new Uint8Array(64);
	  var u, i;
	  for (i = 0; i < 16; i++) z[i] = 0;
	  for (i = 0; i < 8; i++) z[i] = n[i];
	  while (b >= 64) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
	    u = 1;
	    for (i = 8; i < 16; i++) {
	      u = u + (z[i] & 0xff) | 0;
	      z[i] = u & 0xff;
	      u >>>= 8;
	    }
	    b -= 64;
	    cpos += 64;
	  }
	  if (b > 0) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < b; i++) c[cpos+i] = x[i];
	  }
	  return 0;
	}

	function crypto_stream(c,cpos,d,n,k) {
	  var s = new Uint8Array(32);
	  crypto_core_hsalsa20(s,n,k,sigma);
	  var sn = new Uint8Array(8);
	  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
	  return crypto_stream_salsa20(c,cpos,d,sn,s);
	}

	function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
	  var s = new Uint8Array(32);
	  crypto_core_hsalsa20(s,n,k,sigma);
	  var sn = new Uint8Array(8);
	  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
	  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
	}

	/*
	* Port of Andrew Moon's Poly1305-donna-16. Public domain.
	* https://github.com/floodyberry/poly1305-donna
	*/

	var poly1305 = function(key) {
	  this.buffer = new Uint8Array(16);
	  this.r = new Uint16Array(10);
	  this.h = new Uint16Array(10);
	  this.pad = new Uint16Array(8);
	  this.leftover = 0;
	  this.fin = 0;

	  var t0, t1, t2, t3, t4, t5, t6, t7;

	  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
	  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
	  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
	  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
	  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
	  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
	  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
	  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
	  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
	  this.r[9] = ((t7 >>>  5)) & 0x007f;

	  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
	  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
	  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
	  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
	  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
	  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
	  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
	  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
	};

	poly1305.prototype.blocks = function(m, mpos, bytes) {
	  var hibit = this.fin ? 0 : (1 << 11);
	  var t0, t1, t2, t3, t4, t5, t6, t7, c;
	  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

	  var h0 = this.h[0],
	      h1 = this.h[1],
	      h2 = this.h[2],
	      h3 = this.h[3],
	      h4 = this.h[4],
	      h5 = this.h[5],
	      h6 = this.h[6],
	      h7 = this.h[7],
	      h8 = this.h[8],
	      h9 = this.h[9];

	  var r0 = this.r[0],
	      r1 = this.r[1],
	      r2 = this.r[2],
	      r3 = this.r[3],
	      r4 = this.r[4],
	      r5 = this.r[5],
	      r6 = this.r[6],
	      r7 = this.r[7],
	      r8 = this.r[8],
	      r9 = this.r[9];

	  while (bytes >= 16) {
	    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
	    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
	    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
	    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
	    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
	    h5 += ((t4 >>>  1)) & 0x1fff;
	    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
	    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
	    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
	    h9 += ((t7 >>> 5)) | hibit;

	    c = 0;

	    d0 = c;
	    d0 += h0 * r0;
	    d0 += h1 * (5 * r9);
	    d0 += h2 * (5 * r8);
	    d0 += h3 * (5 * r7);
	    d0 += h4 * (5 * r6);
	    c = (d0 >>> 13); d0 &= 0x1fff;
	    d0 += h5 * (5 * r5);
	    d0 += h6 * (5 * r4);
	    d0 += h7 * (5 * r3);
	    d0 += h8 * (5 * r2);
	    d0 += h9 * (5 * r1);
	    c += (d0 >>> 13); d0 &= 0x1fff;

	    d1 = c;
	    d1 += h0 * r1;
	    d1 += h1 * r0;
	    d1 += h2 * (5 * r9);
	    d1 += h3 * (5 * r8);
	    d1 += h4 * (5 * r7);
	    c = (d1 >>> 13); d1 &= 0x1fff;
	    d1 += h5 * (5 * r6);
	    d1 += h6 * (5 * r5);
	    d1 += h7 * (5 * r4);
	    d1 += h8 * (5 * r3);
	    d1 += h9 * (5 * r2);
	    c += (d1 >>> 13); d1 &= 0x1fff;

	    d2 = c;
	    d2 += h0 * r2;
	    d2 += h1 * r1;
	    d2 += h2 * r0;
	    d2 += h3 * (5 * r9);
	    d2 += h4 * (5 * r8);
	    c = (d2 >>> 13); d2 &= 0x1fff;
	    d2 += h5 * (5 * r7);
	    d2 += h6 * (5 * r6);
	    d2 += h7 * (5 * r5);
	    d2 += h8 * (5 * r4);
	    d2 += h9 * (5 * r3);
	    c += (d2 >>> 13); d2 &= 0x1fff;

	    d3 = c;
	    d3 += h0 * r3;
	    d3 += h1 * r2;
	    d3 += h2 * r1;
	    d3 += h3 * r0;
	    d3 += h4 * (5 * r9);
	    c = (d3 >>> 13); d3 &= 0x1fff;
	    d3 += h5 * (5 * r8);
	    d3 += h6 * (5 * r7);
	    d3 += h7 * (5 * r6);
	    d3 += h8 * (5 * r5);
	    d3 += h9 * (5 * r4);
	    c += (d3 >>> 13); d3 &= 0x1fff;

	    d4 = c;
	    d4 += h0 * r4;
	    d4 += h1 * r3;
	    d4 += h2 * r2;
	    d4 += h3 * r1;
	    d4 += h4 * r0;
	    c = (d4 >>> 13); d4 &= 0x1fff;
	    d4 += h5 * (5 * r9);
	    d4 += h6 * (5 * r8);
	    d4 += h7 * (5 * r7);
	    d4 += h8 * (5 * r6);
	    d4 += h9 * (5 * r5);
	    c += (d4 >>> 13); d4 &= 0x1fff;

	    d5 = c;
	    d5 += h0 * r5;
	    d5 += h1 * r4;
	    d5 += h2 * r3;
	    d5 += h3 * r2;
	    d5 += h4 * r1;
	    c = (d5 >>> 13); d5 &= 0x1fff;
	    d5 += h5 * r0;
	    d5 += h6 * (5 * r9);
	    d5 += h7 * (5 * r8);
	    d5 += h8 * (5 * r7);
	    d5 += h9 * (5 * r6);
	    c += (d5 >>> 13); d5 &= 0x1fff;

	    d6 = c;
	    d6 += h0 * r6;
	    d6 += h1 * r5;
	    d6 += h2 * r4;
	    d6 += h3 * r3;
	    d6 += h4 * r2;
	    c = (d6 >>> 13); d6 &= 0x1fff;
	    d6 += h5 * r1;
	    d6 += h6 * r0;
	    d6 += h7 * (5 * r9);
	    d6 += h8 * (5 * r8);
	    d6 += h9 * (5 * r7);
	    c += (d6 >>> 13); d6 &= 0x1fff;

	    d7 = c;
	    d7 += h0 * r7;
	    d7 += h1 * r6;
	    d7 += h2 * r5;
	    d7 += h3 * r4;
	    d7 += h4 * r3;
	    c = (d7 >>> 13); d7 &= 0x1fff;
	    d7 += h5 * r2;
	    d7 += h6 * r1;
	    d7 += h7 * r0;
	    d7 += h8 * (5 * r9);
	    d7 += h9 * (5 * r8);
	    c += (d7 >>> 13); d7 &= 0x1fff;

	    d8 = c;
	    d8 += h0 * r8;
	    d8 += h1 * r7;
	    d8 += h2 * r6;
	    d8 += h3 * r5;
	    d8 += h4 * r4;
	    c = (d8 >>> 13); d8 &= 0x1fff;
	    d8 += h5 * r3;
	    d8 += h6 * r2;
	    d8 += h7 * r1;
	    d8 += h8 * r0;
	    d8 += h9 * (5 * r9);
	    c += (d8 >>> 13); d8 &= 0x1fff;

	    d9 = c;
	    d9 += h0 * r9;
	    d9 += h1 * r8;
	    d9 += h2 * r7;
	    d9 += h3 * r6;
	    d9 += h4 * r5;
	    c = (d9 >>> 13); d9 &= 0x1fff;
	    d9 += h5 * r4;
	    d9 += h6 * r3;
	    d9 += h7 * r2;
	    d9 += h8 * r1;
	    d9 += h9 * r0;
	    c += (d9 >>> 13); d9 &= 0x1fff;

	    c = (((c << 2) + c)) | 0;
	    c = (c + d0) | 0;
	    d0 = c & 0x1fff;
	    c = (c >>> 13);
	    d1 += c;

	    h0 = d0;
	    h1 = d1;
	    h2 = d2;
	    h3 = d3;
	    h4 = d4;
	    h5 = d5;
	    h6 = d6;
	    h7 = d7;
	    h8 = d8;
	    h9 = d9;

	    mpos += 16;
	    bytes -= 16;
	  }
	  this.h[0] = h0;
	  this.h[1] = h1;
	  this.h[2] = h2;
	  this.h[3] = h3;
	  this.h[4] = h4;
	  this.h[5] = h5;
	  this.h[6] = h6;
	  this.h[7] = h7;
	  this.h[8] = h8;
	  this.h[9] = h9;
	};

	poly1305.prototype.finish = function(mac, macpos) {
	  var g = new Uint16Array(10);
	  var c, mask, f, i;

	  if (this.leftover) {
	    i = this.leftover;
	    this.buffer[i++] = 1;
	    for (; i < 16; i++) this.buffer[i] = 0;
	    this.fin = 1;
	    this.blocks(this.buffer, 0, 16);
	  }

	  c = this.h[1] >>> 13;
	  this.h[1] &= 0x1fff;
	  for (i = 2; i < 10; i++) {
	    this.h[i] += c;
	    c = this.h[i] >>> 13;
	    this.h[i] &= 0x1fff;
	  }
	  this.h[0] += (c * 5);
	  c = this.h[0] >>> 13;
	  this.h[0] &= 0x1fff;
	  this.h[1] += c;
	  c = this.h[1] >>> 13;
	  this.h[1] &= 0x1fff;
	  this.h[2] += c;

	  g[0] = this.h[0] + 5;
	  c = g[0] >>> 13;
	  g[0] &= 0x1fff;
	  for (i = 1; i < 10; i++) {
	    g[i] = this.h[i] + c;
	    c = g[i] >>> 13;
	    g[i] &= 0x1fff;
	  }
	  g[9] -= (1 << 13);

	  mask = (c ^ 1) - 1;
	  for (i = 0; i < 10; i++) g[i] &= mask;
	  mask = ~mask;
	  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

	  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
	  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
	  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
	  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
	  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
	  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
	  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
	  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

	  f = this.h[0] + this.pad[0];
	  this.h[0] = f & 0xffff;
	  for (i = 1; i < 8; i++) {
	    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
	    this.h[i] = f & 0xffff;
	  }

	  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
	  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
	  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
	  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
	  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
	  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
	  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
	  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
	  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
	  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
	  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
	  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
	  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
	  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
	  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
	  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
	};

	poly1305.prototype.update = function(m, mpos, bytes) {
	  var i, want;

	  if (this.leftover) {
	    want = (16 - this.leftover);
	    if (want > bytes)
	      want = bytes;
	    for (i = 0; i < want; i++)
	      this.buffer[this.leftover + i] = m[mpos+i];
	    bytes -= want;
	    mpos += want;
	    this.leftover += want;
	    if (this.leftover < 16)
	      return;
	    this.blocks(this.buffer, 0, 16);
	    this.leftover = 0;
	  }

	  if (bytes >= 16) {
	    want = bytes - (bytes % 16);
	    this.blocks(m, mpos, want);
	    mpos += want;
	    bytes -= want;
	  }

	  if (bytes) {
	    for (i = 0; i < bytes; i++)
	      this.buffer[this.leftover + i] = m[mpos+i];
	    this.leftover += bytes;
	  }
	};

	function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
	  var s = new poly1305(k);
	  s.update(m, mpos, n);
	  s.finish(out, outpos);
	  return 0;
	}

	function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
	  var x = new Uint8Array(16);
	  crypto_onetimeauth(x,0,m,mpos,n,k);
	  return crypto_verify_16(h,hpos,x,0);
	}

	function crypto_secretbox(c,m,d,n,k) {
	  var i;
	  if (d < 32) return -1;
	  crypto_stream_xor(c,0,m,0,d,n,k);
	  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
	  for (i = 0; i < 16; i++) c[i] = 0;
	  return 0;
	}

	function crypto_secretbox_open(m,c,d,n,k) {
	  var i;
	  var x = new Uint8Array(32);
	  if (d < 32) return -1;
	  crypto_stream(x,0,32,n,k);
	  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
	  crypto_stream_xor(m,0,c,0,d,n,k);
	  for (i = 0; i < 32; i++) m[i] = 0;
	  return 0;
	}

	function set25519(r, a) {
	  var i;
	  for (i = 0; i < 16; i++) r[i] = a[i]|0;
	}

	function car25519(o) {
	  var i, v, c = 1;
	  for (i = 0; i < 16; i++) {
	    v = o[i] + c + 65535;
	    c = Math.floor(v / 65536);
	    o[i] = v - c * 65536;
	  }
	  o[0] += c-1 + 37 * (c-1);
	}

	function sel25519(p, q, b) {
	  var t, c = ~(b-1);
	  for (var i = 0; i < 16; i++) {
	    t = c & (p[i] ^ q[i]);
	    p[i] ^= t;
	    q[i] ^= t;
	  }
	}

	function pack25519(o, n) {
	  var i, j, b;
	  var m = gf(), t = gf();
	  for (i = 0; i < 16; i++) t[i] = n[i];
	  car25519(t);
	  car25519(t);
	  car25519(t);
	  for (j = 0; j < 2; j++) {
	    m[0] = t[0] - 0xffed;
	    for (i = 1; i < 15; i++) {
	      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
	      m[i-1] &= 0xffff;
	    }
	    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
	    b = (m[15]>>16) & 1;
	    m[14] &= 0xffff;
	    sel25519(t, m, 1-b);
	  }
	  for (i = 0; i < 16; i++) {
	    o[2*i] = t[i] & 0xff;
	    o[2*i+1] = t[i]>>8;
	  }
	}

	function neq25519(a, b) {
	  var c = new Uint8Array(32), d = new Uint8Array(32);
	  pack25519(c, a);
	  pack25519(d, b);
	  return crypto_verify_32(c, 0, d, 0);
	}

	function par25519(a) {
	  var d = new Uint8Array(32);
	  pack25519(d, a);
	  return d[0] & 1;
	}

	function unpack25519(o, n) {
	  var i;
	  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
	  o[15] &= 0x7fff;
	}

	function A(o, a, b) {
	  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
	}

	function Z(o, a, b) {
	  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
	}

	function M(o, a, b) {
	  var v, c,
	     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
	     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
	    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
	    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
	    b0 = b[0],
	    b1 = b[1],
	    b2 = b[2],
	    b3 = b[3],
	    b4 = b[4],
	    b5 = b[5],
	    b6 = b[6],
	    b7 = b[7],
	    b8 = b[8],
	    b9 = b[9],
	    b10 = b[10],
	    b11 = b[11],
	    b12 = b[12],
	    b13 = b[13],
	    b14 = b[14],
	    b15 = b[15];

	  v = a[0];
	  t0 += v * b0;
	  t1 += v * b1;
	  t2 += v * b2;
	  t3 += v * b3;
	  t4 += v * b4;
	  t5 += v * b5;
	  t6 += v * b6;
	  t7 += v * b7;
	  t8 += v * b8;
	  t9 += v * b9;
	  t10 += v * b10;
	  t11 += v * b11;
	  t12 += v * b12;
	  t13 += v * b13;
	  t14 += v * b14;
	  t15 += v * b15;
	  v = a[1];
	  t1 += v * b0;
	  t2 += v * b1;
	  t3 += v * b2;
	  t4 += v * b3;
	  t5 += v * b4;
	  t6 += v * b5;
	  t7 += v * b6;
	  t8 += v * b7;
	  t9 += v * b8;
	  t10 += v * b9;
	  t11 += v * b10;
	  t12 += v * b11;
	  t13 += v * b12;
	  t14 += v * b13;
	  t15 += v * b14;
	  t16 += v * b15;
	  v = a[2];
	  t2 += v * b0;
	  t3 += v * b1;
	  t4 += v * b2;
	  t5 += v * b3;
	  t6 += v * b4;
	  t7 += v * b5;
	  t8 += v * b6;
	  t9 += v * b7;
	  t10 += v * b8;
	  t11 += v * b9;
	  t12 += v * b10;
	  t13 += v * b11;
	  t14 += v * b12;
	  t15 += v * b13;
	  t16 += v * b14;
	  t17 += v * b15;
	  v = a[3];
	  t3 += v * b0;
	  t4 += v * b1;
	  t5 += v * b2;
	  t6 += v * b3;
	  t7 += v * b4;
	  t8 += v * b5;
	  t9 += v * b6;
	  t10 += v * b7;
	  t11 += v * b8;
	  t12 += v * b9;
	  t13 += v * b10;
	  t14 += v * b11;
	  t15 += v * b12;
	  t16 += v * b13;
	  t17 += v * b14;
	  t18 += v * b15;
	  v = a[4];
	  t4 += v * b0;
	  t5 += v * b1;
	  t6 += v * b2;
	  t7 += v * b3;
	  t8 += v * b4;
	  t9 += v * b5;
	  t10 += v * b6;
	  t11 += v * b7;
	  t12 += v * b8;
	  t13 += v * b9;
	  t14 += v * b10;
	  t15 += v * b11;
	  t16 += v * b12;
	  t17 += v * b13;
	  t18 += v * b14;
	  t19 += v * b15;
	  v = a[5];
	  t5 += v * b0;
	  t6 += v * b1;
	  t7 += v * b2;
	  t8 += v * b3;
	  t9 += v * b4;
	  t10 += v * b5;
	  t11 += v * b6;
	  t12 += v * b7;
	  t13 += v * b8;
	  t14 += v * b9;
	  t15 += v * b10;
	  t16 += v * b11;
	  t17 += v * b12;
	  t18 += v * b13;
	  t19 += v * b14;
	  t20 += v * b15;
	  v = a[6];
	  t6 += v * b0;
	  t7 += v * b1;
	  t8 += v * b2;
	  t9 += v * b3;
	  t10 += v * b4;
	  t11 += v * b5;
	  t12 += v * b6;
	  t13 += v * b7;
	  t14 += v * b8;
	  t15 += v * b9;
	  t16 += v * b10;
	  t17 += v * b11;
	  t18 += v * b12;
	  t19 += v * b13;
	  t20 += v * b14;
	  t21 += v * b15;
	  v = a[7];
	  t7 += v * b0;
	  t8 += v * b1;
	  t9 += v * b2;
	  t10 += v * b3;
	  t11 += v * b4;
	  t12 += v * b5;
	  t13 += v * b6;
	  t14 += v * b7;
	  t15 += v * b8;
	  t16 += v * b9;
	  t17 += v * b10;
	  t18 += v * b11;
	  t19 += v * b12;
	  t20 += v * b13;
	  t21 += v * b14;
	  t22 += v * b15;
	  v = a[8];
	  t8 += v * b0;
	  t9 += v * b1;
	  t10 += v * b2;
	  t11 += v * b3;
	  t12 += v * b4;
	  t13 += v * b5;
	  t14 += v * b6;
	  t15 += v * b7;
	  t16 += v * b8;
	  t17 += v * b9;
	  t18 += v * b10;
	  t19 += v * b11;
	  t20 += v * b12;
	  t21 += v * b13;
	  t22 += v * b14;
	  t23 += v * b15;
	  v = a[9];
	  t9 += v * b0;
	  t10 += v * b1;
	  t11 += v * b2;
	  t12 += v * b3;
	  t13 += v * b4;
	  t14 += v * b5;
	  t15 += v * b6;
	  t16 += v * b7;
	  t17 += v * b8;
	  t18 += v * b9;
	  t19 += v * b10;
	  t20 += v * b11;
	  t21 += v * b12;
	  t22 += v * b13;
	  t23 += v * b14;
	  t24 += v * b15;
	  v = a[10];
	  t10 += v * b0;
	  t11 += v * b1;
	  t12 += v * b2;
	  t13 += v * b3;
	  t14 += v * b4;
	  t15 += v * b5;
	  t16 += v * b6;
	  t17 += v * b7;
	  t18 += v * b8;
	  t19 += v * b9;
	  t20 += v * b10;
	  t21 += v * b11;
	  t22 += v * b12;
	  t23 += v * b13;
	  t24 += v * b14;
	  t25 += v * b15;
	  v = a[11];
	  t11 += v * b0;
	  t12 += v * b1;
	  t13 += v * b2;
	  t14 += v * b3;
	  t15 += v * b4;
	  t16 += v * b5;
	  t17 += v * b6;
	  t18 += v * b7;
	  t19 += v * b8;
	  t20 += v * b9;
	  t21 += v * b10;
	  t22 += v * b11;
	  t23 += v * b12;
	  t24 += v * b13;
	  t25 += v * b14;
	  t26 += v * b15;
	  v = a[12];
	  t12 += v * b0;
	  t13 += v * b1;
	  t14 += v * b2;
	  t15 += v * b3;
	  t16 += v * b4;
	  t17 += v * b5;
	  t18 += v * b6;
	  t19 += v * b7;
	  t20 += v * b8;
	  t21 += v * b9;
	  t22 += v * b10;
	  t23 += v * b11;
	  t24 += v * b12;
	  t25 += v * b13;
	  t26 += v * b14;
	  t27 += v * b15;
	  v = a[13];
	  t13 += v * b0;
	  t14 += v * b1;
	  t15 += v * b2;
	  t16 += v * b3;
	  t17 += v * b4;
	  t18 += v * b5;
	  t19 += v * b6;
	  t20 += v * b7;
	  t21 += v * b8;
	  t22 += v * b9;
	  t23 += v * b10;
	  t24 += v * b11;
	  t25 += v * b12;
	  t26 += v * b13;
	  t27 += v * b14;
	  t28 += v * b15;
	  v = a[14];
	  t14 += v * b0;
	  t15 += v * b1;
	  t16 += v * b2;
	  t17 += v * b3;
	  t18 += v * b4;
	  t19 += v * b5;
	  t20 += v * b6;
	  t21 += v * b7;
	  t22 += v * b8;
	  t23 += v * b9;
	  t24 += v * b10;
	  t25 += v * b11;
	  t26 += v * b12;
	  t27 += v * b13;
	  t28 += v * b14;
	  t29 += v * b15;
	  v = a[15];
	  t15 += v * b0;
	  t16 += v * b1;
	  t17 += v * b2;
	  t18 += v * b3;
	  t19 += v * b4;
	  t20 += v * b5;
	  t21 += v * b6;
	  t22 += v * b7;
	  t23 += v * b8;
	  t24 += v * b9;
	  t25 += v * b10;
	  t26 += v * b11;
	  t27 += v * b12;
	  t28 += v * b13;
	  t29 += v * b14;
	  t30 += v * b15;

	  t0  += 38 * t16;
	  t1  += 38 * t17;
	  t2  += 38 * t18;
	  t3  += 38 * t19;
	  t4  += 38 * t20;
	  t5  += 38 * t21;
	  t6  += 38 * t22;
	  t7  += 38 * t23;
	  t8  += 38 * t24;
	  t9  += 38 * t25;
	  t10 += 38 * t26;
	  t11 += 38 * t27;
	  t12 += 38 * t28;
	  t13 += 38 * t29;
	  t14 += 38 * t30;
	  // t15 left as is

	  // first car
	  c = 1;
	  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
	  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
	  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
	  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
	  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
	  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
	  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
	  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
	  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
	  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
	  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
	  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
	  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
	  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
	  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
	  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
	  t0 += c-1 + 37 * (c-1);

	  // second car
	  c = 1;
	  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
	  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
	  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
	  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
	  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
	  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
	  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
	  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
	  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
	  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
	  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
	  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
	  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
	  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
	  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
	  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
	  t0 += c-1 + 37 * (c-1);

	  o[ 0] = t0;
	  o[ 1] = t1;
	  o[ 2] = t2;
	  o[ 3] = t3;
	  o[ 4] = t4;
	  o[ 5] = t5;
	  o[ 6] = t6;
	  o[ 7] = t7;
	  o[ 8] = t8;
	  o[ 9] = t9;
	  o[10] = t10;
	  o[11] = t11;
	  o[12] = t12;
	  o[13] = t13;
	  o[14] = t14;
	  o[15] = t15;
	}

	function S(o, a) {
	  M(o, a, a);
	}

	function inv25519(o, i) {
	  var c = gf();
	  var a;
	  for (a = 0; a < 16; a++) c[a] = i[a];
	  for (a = 253; a >= 0; a--) {
	    S(c, c);
	    if(a !== 2 && a !== 4) M(c, c, i);
	  }
	  for (a = 0; a < 16; a++) o[a] = c[a];
	}

	function pow2523(o, i) {
	  var c = gf();
	  var a;
	  for (a = 0; a < 16; a++) c[a] = i[a];
	  for (a = 250; a >= 0; a--) {
	      S(c, c);
	      if(a !== 1) M(c, c, i);
	  }
	  for (a = 0; a < 16; a++) o[a] = c[a];
	}

	function crypto_scalarmult(q, n, p) {
	  var z = new Uint8Array(32);
	  var x = new Float64Array(80), r, i;
	  var a = gf(), b = gf(), c = gf(),
	      d = gf(), e = gf(), f = gf();
	  for (i = 0; i < 31; i++) z[i] = n[i];
	  z[31]=(n[31]&127)|64;
	  z[0]&=248;
	  unpack25519(x,p);
	  for (i = 0; i < 16; i++) {
	    b[i]=x[i];
	    d[i]=a[i]=c[i]=0;
	  }
	  a[0]=d[0]=1;
	  for (i=254; i>=0; --i) {
	    r=(z[i>>>3]>>>(i&7))&1;
	    sel25519(a,b,r);
	    sel25519(c,d,r);
	    A(e,a,c);
	    Z(a,a,c);
	    A(c,b,d);
	    Z(b,b,d);
	    S(d,e);
	    S(f,a);
	    M(a,c,a);
	    M(c,b,e);
	    A(e,a,c);
	    Z(a,a,c);
	    S(b,a);
	    Z(c,d,f);
	    M(a,c,_121665);
	    A(a,a,d);
	    M(c,c,a);
	    M(a,d,f);
	    M(d,b,x);
	    S(b,e);
	    sel25519(a,b,r);
	    sel25519(c,d,r);
	  }
	  for (i = 0; i < 16; i++) {
	    x[i+16]=a[i];
	    x[i+32]=c[i];
	    x[i+48]=b[i];
	    x[i+64]=d[i];
	  }
	  var x32 = x.subarray(32);
	  var x16 = x.subarray(16);
	  inv25519(x32,x32);
	  M(x16,x16,x32);
	  pack25519(q,x16);
	  return 0;
	}

	function crypto_scalarmult_base(q, n) {
	  return crypto_scalarmult(q, n, _9);
	}

	function crypto_box_keypair(y, x) {
	  randombytes(x, 32);
	  return crypto_scalarmult_base(y, x);
	}

	function crypto_box_beforenm(k, y, x) {
	  var s = new Uint8Array(32);
	  crypto_scalarmult(s, x, y);
	  return crypto_core_hsalsa20(k, _0, s, sigma);
	}

	var crypto_box_afternm = crypto_secretbox;
	var crypto_box_open_afternm = crypto_secretbox_open;

	function crypto_box(c, m, d, n, y, x) {
	  var k = new Uint8Array(32);
	  crypto_box_beforenm(k, y, x);
	  return crypto_box_afternm(c, m, d, n, k);
	}

	function crypto_box_open(m, c, d, n, y, x) {
	  var k = new Uint8Array(32);
	  crypto_box_beforenm(k, y, x);
	  return crypto_box_open_afternm(m, c, d, n, k);
	}

	var K = [
	  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	];

	function crypto_hashblocks_hl(hh, hl, m, n) {
	  var wh = new Int32Array(16), wl = new Int32Array(16),
	      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
	      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
	      th, tl, i, j, h, l, a, b, c, d;

	  var ah0 = hh[0],
	      ah1 = hh[1],
	      ah2 = hh[2],
	      ah3 = hh[3],
	      ah4 = hh[4],
	      ah5 = hh[5],
	      ah6 = hh[6],
	      ah7 = hh[7],

	      al0 = hl[0],
	      al1 = hl[1],
	      al2 = hl[2],
	      al3 = hl[3],
	      al4 = hl[4],
	      al5 = hl[5],
	      al6 = hl[6],
	      al7 = hl[7];

	  var pos = 0;
	  while (n >= 128) {
	    for (i = 0; i < 16; i++) {
	      j = 8 * i + pos;
	      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
	      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
	    }
	    for (i = 0; i < 80; i++) {
	      bh0 = ah0;
	      bh1 = ah1;
	      bh2 = ah2;
	      bh3 = ah3;
	      bh4 = ah4;
	      bh5 = ah5;
	      bh6 = ah6;
	      bh7 = ah7;

	      bl0 = al0;
	      bl1 = al1;
	      bl2 = al2;
	      bl3 = al3;
	      bl4 = al4;
	      bl5 = al5;
	      bl6 = al6;
	      bl7 = al7;

	      // add
	      h = ah7;
	      l = al7;

	      a = l & 0xffff; b = l >>> 16;
	      c = h & 0xffff; d = h >>> 16;

	      // Sigma1
	      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
	      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      // Ch
	      h = (ah4 & ah5) ^ (~ah4 & ah6);
	      l = (al4 & al5) ^ (~al4 & al6);

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      // K
	      h = K[i*2];
	      l = K[i*2+1];

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      // w
	      h = wh[i%16];
	      l = wl[i%16];

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      b += a >>> 16;
	      c += b >>> 16;
	      d += c >>> 16;

	      th = c & 0xffff | d << 16;
	      tl = a & 0xffff | b << 16;

	      // add
	      h = th;
	      l = tl;

	      a = l & 0xffff; b = l >>> 16;
	      c = h & 0xffff; d = h >>> 16;

	      // Sigma0
	      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
	      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      // Maj
	      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
	      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      b += a >>> 16;
	      c += b >>> 16;
	      d += c >>> 16;

	      bh7 = (c & 0xffff) | (d << 16);
	      bl7 = (a & 0xffff) | (b << 16);

	      // add
	      h = bh3;
	      l = bl3;

	      a = l & 0xffff; b = l >>> 16;
	      c = h & 0xffff; d = h >>> 16;

	      h = th;
	      l = tl;

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      b += a >>> 16;
	      c += b >>> 16;
	      d += c >>> 16;

	      bh3 = (c & 0xffff) | (d << 16);
	      bl3 = (a & 0xffff) | (b << 16);

	      ah1 = bh0;
	      ah2 = bh1;
	      ah3 = bh2;
	      ah4 = bh3;
	      ah5 = bh4;
	      ah6 = bh5;
	      ah7 = bh6;
	      ah0 = bh7;

	      al1 = bl0;
	      al2 = bl1;
	      al3 = bl2;
	      al4 = bl3;
	      al5 = bl4;
	      al6 = bl5;
	      al7 = bl6;
	      al0 = bl7;

	      if (i%16 === 15) {
	        for (j = 0; j < 16; j++) {
	          // add
	          h = wh[j];
	          l = wl[j];

	          a = l & 0xffff; b = l >>> 16;
	          c = h & 0xffff; d = h >>> 16;

	          h = wh[(j+9)%16];
	          l = wl[(j+9)%16];

	          a += l & 0xffff; b += l >>> 16;
	          c += h & 0xffff; d += h >>> 16;

	          // sigma0
	          th = wh[(j+1)%16];
	          tl = wl[(j+1)%16];
	          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
	          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

	          a += l & 0xffff; b += l >>> 16;
	          c += h & 0xffff; d += h >>> 16;

	          // sigma1
	          th = wh[(j+14)%16];
	          tl = wl[(j+14)%16];
	          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
	          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

	          a += l & 0xffff; b += l >>> 16;
	          c += h & 0xffff; d += h >>> 16;

	          b += a >>> 16;
	          c += b >>> 16;
	          d += c >>> 16;

	          wh[j] = (c & 0xffff) | (d << 16);
	          wl[j] = (a & 0xffff) | (b << 16);
	        }
	      }
	    }

	    // add
	    h = ah0;
	    l = al0;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[0];
	    l = hl[0];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[0] = ah0 = (c & 0xffff) | (d << 16);
	    hl[0] = al0 = (a & 0xffff) | (b << 16);

	    h = ah1;
	    l = al1;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[1];
	    l = hl[1];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[1] = ah1 = (c & 0xffff) | (d << 16);
	    hl[1] = al1 = (a & 0xffff) | (b << 16);

	    h = ah2;
	    l = al2;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[2];
	    l = hl[2];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[2] = ah2 = (c & 0xffff) | (d << 16);
	    hl[2] = al2 = (a & 0xffff) | (b << 16);

	    h = ah3;
	    l = al3;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[3];
	    l = hl[3];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[3] = ah3 = (c & 0xffff) | (d << 16);
	    hl[3] = al3 = (a & 0xffff) | (b << 16);

	    h = ah4;
	    l = al4;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[4];
	    l = hl[4];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[4] = ah4 = (c & 0xffff) | (d << 16);
	    hl[4] = al4 = (a & 0xffff) | (b << 16);

	    h = ah5;
	    l = al5;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[5];
	    l = hl[5];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[5] = ah5 = (c & 0xffff) | (d << 16);
	    hl[5] = al5 = (a & 0xffff) | (b << 16);

	    h = ah6;
	    l = al6;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[6];
	    l = hl[6];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[6] = ah6 = (c & 0xffff) | (d << 16);
	    hl[6] = al6 = (a & 0xffff) | (b << 16);

	    h = ah7;
	    l = al7;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[7];
	    l = hl[7];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[7] = ah7 = (c & 0xffff) | (d << 16);
	    hl[7] = al7 = (a & 0xffff) | (b << 16);

	    pos += 128;
	    n -= 128;
	  }

	  return n;
	}

	function crypto_hash(out, m, n) {
	  var hh = new Int32Array(8),
	      hl = new Int32Array(8),
	      x = new Uint8Array(256),
	      i, b = n;

	  hh[0] = 0x6a09e667;
	  hh[1] = 0xbb67ae85;
	  hh[2] = 0x3c6ef372;
	  hh[3] = 0xa54ff53a;
	  hh[4] = 0x510e527f;
	  hh[5] = 0x9b05688c;
	  hh[6] = 0x1f83d9ab;
	  hh[7] = 0x5be0cd19;

	  hl[0] = 0xf3bcc908;
	  hl[1] = 0x84caa73b;
	  hl[2] = 0xfe94f82b;
	  hl[3] = 0x5f1d36f1;
	  hl[4] = 0xade682d1;
	  hl[5] = 0x2b3e6c1f;
	  hl[6] = 0xfb41bd6b;
	  hl[7] = 0x137e2179;

	  crypto_hashblocks_hl(hh, hl, m, n);
	  n %= 128;

	  for (i = 0; i < n; i++) x[i] = m[b-n+i];
	  x[n] = 128;

	  n = 256-128*(n<112?1:0);
	  x[n-9] = 0;
	  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
	  crypto_hashblocks_hl(hh, hl, x, n);

	  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

	  return 0;
	}

	function add(p, q) {
	  var a = gf(), b = gf(), c = gf(),
	      d = gf(), e = gf(), f = gf(),
	      g = gf(), h = gf(), t = gf();

	  Z(a, p[1], p[0]);
	  Z(t, q[1], q[0]);
	  M(a, a, t);
	  A(b, p[0], p[1]);
	  A(t, q[0], q[1]);
	  M(b, b, t);
	  M(c, p[3], q[3]);
	  M(c, c, D2);
	  M(d, p[2], q[2]);
	  A(d, d, d);
	  Z(e, b, a);
	  Z(f, d, c);
	  A(g, d, c);
	  A(h, b, a);

	  M(p[0], e, f);
	  M(p[1], h, g);
	  M(p[2], g, f);
	  M(p[3], e, h);
	}

	function cswap(p, q, b) {
	  var i;
	  for (i = 0; i < 4; i++) {
	    sel25519(p[i], q[i], b);
	  }
	}

	function pack(r, p) {
	  var tx = gf(), ty = gf(), zi = gf();
	  inv25519(zi, p[2]);
	  M(tx, p[0], zi);
	  M(ty, p[1], zi);
	  pack25519(r, ty);
	  r[31] ^= par25519(tx) << 7;
	}

	function scalarmult(p, q, s) {
	  var b, i;
	  set25519(p[0], gf0);
	  set25519(p[1], gf1);
	  set25519(p[2], gf1);
	  set25519(p[3], gf0);
	  for (i = 255; i >= 0; --i) {
	    b = (s[(i/8)|0] >> (i&7)) & 1;
	    cswap(p, q, b);
	    add(q, p);
	    add(p, p);
	    cswap(p, q, b);
	  }
	}

	function scalarbase(p, s) {
	  var q = [gf(), gf(), gf(), gf()];
	  set25519(q[0], X);
	  set25519(q[1], Y);
	  set25519(q[2], gf1);
	  M(q[3], X, Y);
	  scalarmult(p, q, s);
	}

	function crypto_sign_keypair(pk, sk, seeded) {
	  var d = new Uint8Array(64);
	  var p = [gf(), gf(), gf(), gf()];
	  var i;

	  if (!seeded) randombytes(sk, 32);
	  crypto_hash(d, sk, 32);
	  d[0] &= 248;
	  d[31] &= 127;
	  d[31] |= 64;

	  scalarbase(p, d);
	  pack(pk, p);

	  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
	  return 0;
	}

	var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

	function modL(r, x) {
	  var carry, i, j, k;
	  for (i = 63; i >= 32; --i) {
	    carry = 0;
	    for (j = i - 32, k = i - 12; j < k; ++j) {
	      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
	      carry = (x[j] + 128) >> 8;
	      x[j] -= carry * 256;
	    }
	    x[j] += carry;
	    x[i] = 0;
	  }
	  carry = 0;
	  for (j = 0; j < 32; j++) {
	    x[j] += carry - (x[31] >> 4) * L[j];
	    carry = x[j] >> 8;
	    x[j] &= 255;
	  }
	  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
	  for (i = 0; i < 32; i++) {
	    x[i+1] += x[i] >> 8;
	    r[i] = x[i] & 255;
	  }
	}

	function reduce(r) {
	  var x = new Float64Array(64), i;
	  for (i = 0; i < 64; i++) x[i] = r[i];
	  for (i = 0; i < 64; i++) r[i] = 0;
	  modL(r, x);
	}

	// Note: difference from C - smlen returned, not passed as argument.
	function crypto_sign(sm, m, n, sk) {
	  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
	  var i, j, x = new Float64Array(64);
	  var p = [gf(), gf(), gf(), gf()];

	  crypto_hash(d, sk, 32);
	  d[0] &= 248;
	  d[31] &= 127;
	  d[31] |= 64;

	  var smlen = n + 64;
	  for (i = 0; i < n; i++) sm[64 + i] = m[i];
	  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

	  crypto_hash(r, sm.subarray(32), n+32);
	  reduce(r);
	  scalarbase(p, r);
	  pack(sm, p);

	  for (i = 32; i < 64; i++) sm[i] = sk[i];
	  crypto_hash(h, sm, n + 64);
	  reduce(h);

	  for (i = 0; i < 64; i++) x[i] = 0;
	  for (i = 0; i < 32; i++) x[i] = r[i];
	  for (i = 0; i < 32; i++) {
	    for (j = 0; j < 32; j++) {
	      x[i+j] += h[i] * d[j];
	    }
	  }

	  modL(sm.subarray(32), x);
	  return smlen;
	}

	function unpackneg(r, p) {
	  var t = gf(), chk = gf(), num = gf(),
	      den = gf(), den2 = gf(), den4 = gf(),
	      den6 = gf();

	  set25519(r[2], gf1);
	  unpack25519(r[1], p);
	  S(num, r[1]);
	  M(den, num, D);
	  Z(num, num, r[2]);
	  A(den, r[2], den);

	  S(den2, den);
	  S(den4, den2);
	  M(den6, den4, den2);
	  M(t, den6, num);
	  M(t, t, den);

	  pow2523(t, t);
	  M(t, t, num);
	  M(t, t, den);
	  M(t, t, den);
	  M(r[0], t, den);

	  S(chk, r[0]);
	  M(chk, chk, den);
	  if (neq25519(chk, num)) M(r[0], r[0], I);

	  S(chk, r[0]);
	  M(chk, chk, den);
	  if (neq25519(chk, num)) return -1;

	  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

	  M(r[3], r[0], r[1]);
	  return 0;
	}

	function crypto_sign_open(m, sm, n, pk) {
	  var i, mlen;
	  var t = new Uint8Array(32), h = new Uint8Array(64);
	  var p = [gf(), gf(), gf(), gf()],
	      q = [gf(), gf(), gf(), gf()];

	  mlen = -1;
	  if (n < 64) return -1;

	  if (unpackneg(q, pk)) return -1;

	  for (i = 0; i < n; i++) m[i] = sm[i];
	  for (i = 0; i < 32; i++) m[i+32] = pk[i];
	  crypto_hash(h, m, n);
	  reduce(h);
	  scalarmult(p, q, h);

	  scalarbase(q, sm.subarray(32));
	  add(p, q);
	  pack(t, p);

	  n -= 64;
	  if (crypto_verify_32(sm, 0, t, 0)) {
	    for (i = 0; i < n; i++) m[i] = 0;
	    return -1;
	  }

	  for (i = 0; i < n; i++) m[i] = sm[i + 64];
	  mlen = n;
	  return mlen;
	}

	var crypto_secretbox_KEYBYTES = 32,
	    crypto_secretbox_NONCEBYTES = 24,
	    crypto_secretbox_ZEROBYTES = 32,
	    crypto_secretbox_BOXZEROBYTES = 16,
	    crypto_scalarmult_BYTES = 32,
	    crypto_scalarmult_SCALARBYTES = 32,
	    crypto_box_PUBLICKEYBYTES = 32,
	    crypto_box_SECRETKEYBYTES = 32,
	    crypto_box_BEFORENMBYTES = 32,
	    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
	    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
	    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
	    crypto_sign_BYTES = 64,
	    crypto_sign_PUBLICKEYBYTES = 32,
	    crypto_sign_SECRETKEYBYTES = 64,
	    crypto_sign_SEEDBYTES = 32,
	    crypto_hash_BYTES = 64;

	nacl.lowlevel = {
	  crypto_core_hsalsa20: crypto_core_hsalsa20,
	  crypto_stream_xor: crypto_stream_xor,
	  crypto_stream: crypto_stream,
	  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
	  crypto_stream_salsa20: crypto_stream_salsa20,
	  crypto_onetimeauth: crypto_onetimeauth,
	  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
	  crypto_verify_16: crypto_verify_16,
	  crypto_verify_32: crypto_verify_32,
	  crypto_secretbox: crypto_secretbox,
	  crypto_secretbox_open: crypto_secretbox_open,
	  crypto_scalarmult: crypto_scalarmult,
	  crypto_scalarmult_base: crypto_scalarmult_base,
	  crypto_box_beforenm: crypto_box_beforenm,
	  crypto_box_afternm: crypto_box_afternm,
	  crypto_box: crypto_box,
	  crypto_box_open: crypto_box_open,
	  crypto_box_keypair: crypto_box_keypair,
	  crypto_hash: crypto_hash,
	  crypto_sign: crypto_sign,
	  crypto_sign_keypair: crypto_sign_keypair,
	  crypto_sign_open: crypto_sign_open,

	  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
	  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
	  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
	  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
	  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
	  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
	  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
	  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
	  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
	  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
	  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
	  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
	  crypto_sign_BYTES: crypto_sign_BYTES,
	  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
	  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
	  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
	  crypto_hash_BYTES: crypto_hash_BYTES
	};

	/* High-level API */

	function checkLengths(k, n) {
	  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
	  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
	}

	function checkBoxLengths(pk, sk) {
	  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
	  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
	}

	function checkArrayTypes() {
	  for (var i = 0; i < arguments.length; i++) {
	    if (!(arguments[i] instanceof Uint8Array))
	      throw new TypeError('unexpected type, use Uint8Array');
	  }
	}

	function cleanup(arr) {
	  for (var i = 0; i < arr.length; i++) arr[i] = 0;
	}

	nacl.randomBytes = function(n) {
	  var b = new Uint8Array(n);
	  randombytes(b, n);
	  return b;
	};

	nacl.secretbox = function(msg, nonce, key) {
	  checkArrayTypes(msg, nonce, key);
	  checkLengths(key, nonce);
	  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
	  var c = new Uint8Array(m.length);
	  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
	  crypto_secretbox(c, m, m.length, nonce, key);
	  return c.subarray(crypto_secretbox_BOXZEROBYTES);
	};

	nacl.secretbox.open = function(box, nonce, key) {
	  checkArrayTypes(box, nonce, key);
	  checkLengths(key, nonce);
	  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
	  var m = new Uint8Array(c.length);
	  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
	  if (c.length < 32) return null;
	  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
	  return m.subarray(crypto_secretbox_ZEROBYTES);
	};

	nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
	nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
	nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

	nacl.scalarMult = function(n, p) {
	  checkArrayTypes(n, p);
	  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
	  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
	  var q = new Uint8Array(crypto_scalarmult_BYTES);
	  crypto_scalarmult(q, n, p);
	  return q;
	};

	nacl.scalarMult.base = function(n) {
	  checkArrayTypes(n);
	  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
	  var q = new Uint8Array(crypto_scalarmult_BYTES);
	  crypto_scalarmult_base(q, n);
	  return q;
	};

	nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
	nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

	nacl.box = function(msg, nonce, publicKey, secretKey) {
	  var k = nacl.box.before(publicKey, secretKey);
	  return nacl.secretbox(msg, nonce, k);
	};

	nacl.box.before = function(publicKey, secretKey) {
	  checkArrayTypes(publicKey, secretKey);
	  checkBoxLengths(publicKey, secretKey);
	  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
	  crypto_box_beforenm(k, publicKey, secretKey);
	  return k;
	};

	nacl.box.after = nacl.secretbox;

	nacl.box.open = function(msg, nonce, publicKey, secretKey) {
	  var k = nacl.box.before(publicKey, secretKey);
	  return nacl.secretbox.open(msg, nonce, k);
	};

	nacl.box.open.after = nacl.secretbox.open;

	nacl.box.keyPair = function() {
	  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
	  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
	  crypto_box_keypair(pk, sk);
	  return {publicKey: pk, secretKey: sk};
	};

	nacl.box.keyPair.fromSecretKey = function(secretKey) {
	  checkArrayTypes(secretKey);
	  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
	    throw new Error('bad secret key size');
	  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
	  crypto_scalarmult_base(pk, secretKey);
	  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
	};

	nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
	nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
	nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
	nacl.box.nonceLength = crypto_box_NONCEBYTES;
	nacl.box.overheadLength = nacl.secretbox.overheadLength;

	nacl.sign = function(msg, secretKey) {
	  checkArrayTypes(msg, secretKey);
	  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
	    throw new Error('bad secret key size');
	  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
	  crypto_sign(signedMsg, msg, msg.length, secretKey);
	  return signedMsg;
	};

	nacl.sign.open = function(signedMsg, publicKey) {
	  checkArrayTypes(signedMsg, publicKey);
	  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
	    throw new Error('bad public key size');
	  var tmp = new Uint8Array(signedMsg.length);
	  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
	  if (mlen < 0) return null;
	  var m = new Uint8Array(mlen);
	  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
	  return m;
	};

	nacl.sign.detached = function(msg, secretKey) {
	  var signedMsg = nacl.sign(msg, secretKey);
	  var sig = new Uint8Array(crypto_sign_BYTES);
	  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
	  return sig;
	};

	nacl.sign.detached.verify = function(msg, sig, publicKey) {
	  checkArrayTypes(msg, sig, publicKey);
	  if (sig.length !== crypto_sign_BYTES)
	    throw new Error('bad signature size');
	  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
	    throw new Error('bad public key size');
	  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
	  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
	  var i;
	  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
	  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
	  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
	};

	nacl.sign.keyPair = function() {
	  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
	  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
	  crypto_sign_keypair(pk, sk);
	  return {publicKey: pk, secretKey: sk};
	};

	nacl.sign.keyPair.fromSecretKey = function(secretKey) {
	  checkArrayTypes(secretKey);
	  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
	    throw new Error('bad secret key size');
	  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
	  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
	  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
	};

	nacl.sign.keyPair.fromSeed = function(seed) {
	  checkArrayTypes(seed);
	  if (seed.length !== crypto_sign_SEEDBYTES)
	    throw new Error('bad seed size');
	  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
	  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
	  for (var i = 0; i < 32; i++) sk[i] = seed[i];
	  crypto_sign_keypair(pk, sk, true);
	  return {publicKey: pk, secretKey: sk};
	};

	nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
	nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
	nacl.sign.seedLength = crypto_sign_SEEDBYTES;
	nacl.sign.signatureLength = crypto_sign_BYTES;

	nacl.hash = function(msg) {
	  checkArrayTypes(msg);
	  var h = new Uint8Array(crypto_hash_BYTES);
	  crypto_hash(h, msg, msg.length);
	  return h;
	};

	nacl.hash.hashLength = crypto_hash_BYTES;

	nacl.verify = function(x, y) {
	  checkArrayTypes(x, y);
	  // Zero length arguments are considered not equal.
	  if (x.length === 0 || y.length === 0) return false;
	  if (x.length !== y.length) return false;
	  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
	};

	nacl.setPRNG = function(fn) {
	  randombytes = fn;
	};

	(function() {
	  // Initialize PRNG if environment provides CSPRNG.
	  // If not, methods calling randombytes will throw.
	  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
	  if (crypto && crypto.getRandomValues) {
	    // Browsers.
	    var QUOTA = 65536;
	    nacl.setPRNG(function(x, n) {
	      var i, v = new Uint8Array(n);
	      for (i = 0; i < n; i += QUOTA) {
	        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
	      }
	      for (i = 0; i < n; i++) x[i] = v[i];
	      cleanup(v);
	    });
	  } else if (typeof commonjsRequire$1 !== 'undefined') {
	    // Node.js.
	    crypto = require$$0;
	    if (crypto && crypto.randomBytes) {
	      nacl.setPRNG(function(x, n) {
	        var i, v = crypto.randomBytes(n);
	        for (i = 0; i < n; i++) x[i] = v[i];
	        cleanup(v);
	      });
	    }
	  }
	})();

	})( module.exports ? module.exports : (self.nacl = self.nacl || {}));
	});
	var naclFast_1 = naclFast.secretbox;
	var naclFast_2 = naclFast.randomBytes;
	var naclFast_3 = naclFast.box;
	var naclFast_4 = naclFast.scalarMult;
	var naclFast_5 = naclFast.sign;
	var naclFast_6 = naclFast.verify;

	var naclUtil = createCommonjsModule$1(function (module) {
	// Written in 2014-2016 by Dmitry Chestnykh and Devi Mandiri.
	// Public domain.
	(function(root, f) {
	  if ( module.exports) module.exports = f();
	  else if (root.nacl) root.nacl.util = f();
	  else {
	    root.nacl = {};
	    root.nacl.util = f();
	  }
	}(commonjsGlobal$1, function() {

	  var util = {};

	  function validateBase64(s) {
	    if (!(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(s))) {
	      throw new TypeError('invalid encoding');
	    }
	  }

	  util.decodeUTF8 = function(s) {
	    if (typeof s !== 'string') throw new TypeError('expected string');
	    var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);
	    for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
	    return b;
	  };

	  util.encodeUTF8 = function(arr) {
	    var i, s = [];
	    for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));
	    return decodeURIComponent(escape(s.join('')));
	  };

	  if (typeof atob === 'undefined') {
	    // Node.js

	    if (typeof Buffer$1.from !== 'undefined') {
	       // Node v6 and later
	      util.encodeBase64 = function (arr) { // v6 and later
	          return Buffer$1.from(arr).toString('base64');
	      };

	      util.decodeBase64 = function (s) {
	        validateBase64(s);
	        return new Uint8Array(Array.prototype.slice.call(Buffer$1.from(s, 'base64'), 0));
	      };

	    } else {
	      // Node earlier than v6
	      util.encodeBase64 = function (arr) { // v6 and later
	        return (new Buffer$1(arr)).toString('base64');
	      };

	      util.decodeBase64 = function(s) {
	        validateBase64(s);
	        return new Uint8Array(Array.prototype.slice.call(new Buffer$1(s, 'base64'), 0));
	      };
	    }

	  } else {
	    // Browsers

	    util.encodeBase64 = function(arr) {
	      var i, s = [], len = arr.length;
	      for (i = 0; i < len; i++) s.push(String.fromCharCode(arr[i]));
	      return btoa(s.join(''));
	    };

	    util.decodeBase64 = function(s) {
	      validateBase64(s);
	      var i, d = atob(s), b = new Uint8Array(d.length);
	      for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
	      return b;
	    };

	  }

	  return util;

	}));
	});
	var naclUtil_1 = naclUtil.decodeUTF8;
	var naclUtil_2 = naclUtil.encodeUTF8;
	var naclUtil_3 = naclUtil.encodeBase64;
	var naclUtil_4 = naclUtil.decodeBase64;

	var utils$2 = function () {
	  return {
	    generalCallback: generalCallback,
	    encryptSecretKeyWithPassword: encryptSecretKeyWithPassword,
	    normalizeStringTo32BitArray: normalizeStringTo32BitArray,
	    objectToBase64: objectToBase64,
	    storeCredentialsInLocalStorage: storeCredentialsInLocalStorage,
	    removeCredentialsFromLocalStorage: removeCredentialsFromLocalStorage,
	    generateAKey: generateAKey,
	    aKeyCheck: aKeyCheck,
	    aKeyEncrypt: aKeyEncrypt,
	    aKeyEncrypt_str: aKeyEncrypt_str,
	    aKeyDecrypt: aKeyDecrypt,
	    aKeyDecrypt_str: aKeyDecrypt_str,
	    generateSKey: generateSKey,
	    sKeyEncrypt: sKeyEncrypt,
	    sKeyDecrypt: sKeyDecrypt,
	    uint8ArrayToBase64: uint8ArrayToBase64,
	    base64ToUint8Array: base64ToUint8Array,
	    uTF8ToUint8Array: uTF8ToUint8Array,
	    uint8ArrayToUTF8: uint8ArrayToUTF8,
	    base64ToBlob: base64ToBlob,
	    blobToBase64: blobToBase64,
	    uTF8ToBase64: uTF8ToBase64,
	    base64ToUTF8: base64ToUTF8,
	    blobToUint8Array: blobToUint8Array,
	    uint8ArrayToBlob: uint8ArrayToBlob
	  };
	  /**
	   *
	   * @param _response the response
	   * @param _error an error response
	   *
	   * used as a general callback to pass to methods
	   */

	  function generalCallback(_response, _error) {
	    if (_error !== null) {
	      throw new AitmedError({
	        code: _error.code,
	        message: _error.message
	      });
	    }

	    return new Response$1({
	      code: _response.code
	    });
	  }
	  /**
	   *
	   * @param param0
	   *
	   * helper method to encrypt the secretKey with the user's password
	   */


	  function encryptSecretKeyWithPassword(_ref) {
	    var secretKey = _ref.secretKey,
	        password = _ref.password;
	    var passwordSha256 = hash_2().update(password).digest();
	    var passwordUintArray = new Uint8Array(passwordSha256);
	    var encryptedSecretKey = sKeyEncrypt(passwordUintArray, secretKey);
	    return encryptedSecretKey;
	  }
	  /**
	   *
	   * @param string
	   *
	   * helper method used to normalize any size string to a 32bit array
	   * used to pass in data to encrypt since encrypt/decrypt methods
	   * only handle 32bit array data
	   */


	  function normalizeStringTo32BitArray(string) {
	    var stringSha256 = hash_2().update(string).digest();
	    var stringUintArray = new Uint8Array(stringSha256);
	    return stringUintArray;
	  }
	  /**
	   *
	   * @param obj
	   *
	   * converts object to base64 to be able to decrease the data size of the JSONObject
	   */


	  function objectToBase64(obj) {
	    var objJsonString = '';

	    try {
	      objJsonString = JSON.stringify(obj);
	    } catch (error) {
	      new AitmedError({
	        name: 'JSON_STRINGIFY_FAILED'
	      });
	    }

	    if (objJsonString) {
	      var objJsonB64 = Buffer.from(objJsonString).toString('base64');
	      return objJsonB64;
	    } else {
	      return null;
	    }
	  }
	  /**
	   *
	   * @param string
	   *
	   * converts utf8 string to base64 
	   */


	  function uTF8ToBase64(string) {
	    var stringB64 = Buffer.from(string).toString('base64');
	    return stringB64;
	  }
	  /**
	   *
	   * @param string
	   *
	   * converts base64 string to utf8 
	   */


	  function base64ToUTF8(string) {
	    var stringUTF8 = Buffer.from(string, "base64").toString('utf8');
	    return stringUTF8;
	  }
	  /**
	   *
	   * @param param0
	   *
	   * helper function to store user credentials in localstorage
	   */


	  function storeCredentialsInLocalStorage(_ref2) {
	    var secretKey = _ref2.secretKey,
	        publicKey = _ref2.publicKey,
	        encryptedSecretKey = _ref2.encryptedSecretKey,
	        vcjwt = _ref2.vcjwt,
	        jwt = _ref2.jwt,
	        user_vid = _ref2.user_vid,
	        uid = _ref2.uid;

	    if (publicKey) {
	      var pk;

	      if (typeof publicKey !== 'string') {
	        pk = uint8ArrayToBase64(publicKey);
	      } else {
	        pk = publicKey;
	      }

	      localStorage.setItem('pk', pk);
	    }

	    if (secretKey) {
	      var sk;

	      if (typeof secretKey !== 'string') {
	        sk = uint8ArrayToBase64(secretKey);
	      } else {
	        sk = secretKey;
	      }

	      localStorage.setItem('sk', sk);
	    }

	    if (encryptedSecretKey) {
	      var esk;

	      if (typeof encryptedSecretKey !== 'string') {
	        esk = uint8ArrayToBase64(encryptedSecretKey);
	      } else {
	        esk = encryptedSecretKey;
	      }

	      localStorage.setItem('esk', esk);
	    }

	    if (user_vid) {
	      var userVidB64;

	      if (typeof user_vid !== 'string') {
	        userVidB64 = uint8ArrayToBase64(user_vid);
	      } else {
	        userVidB64 = user_vid;
	      }

	      localStorage.setItem('user_vid', userVidB64);
	    }

	    if (jwt) {
	      localStorage.setItem('jwt', jwt);
	    }

	    if (vcjwt) {
	      localStorage.setItem('vcjwt', vcjwt);
	    }

	    if (uid) {
	      var uidToBase64 = uTF8ToBase64(uid);
	      localStorage.setItem('uid', uidToBase64);
	    }
	  }
	  /**
	   * returns a public, and secret key pair for asymmetric encrypting
	   */


	  function generateAKey() {
	    return naclFast_3.keyPair();
	  }
	  /**
	   *
	   * @param publicKey
	   * @param secretKey
	   *
	   * checks if the inputs are a valid KeyPair
	   */


	  function isUint8ArrayEqual(aa, bb) {
	    if (aa.length != bb.length) {
	      return false;
	    }

	    for (var ii = 0; ii < aa.length; ii++) {
	      if (aa[ii] != bb[ii]) return false;
	    }

	    return true;
	  }

	  function aKeyCheck(publicKey, secretKey) {
	    return isUint8ArrayEqual(publicKey, naclFast_4.base(secretKey));
	  }
	  /**
	   *
	   * @param secretKey
	   * @param data
	   *
	   * assymetrically encrypts data using the sender's secretKey
	   * and receiver's publicKey
	   * extraKey provide extra protection which needs to be exchanged separatedly
	   */


	  function aKeyEncrypt(recvPublicKey, sendSecretKey, data, extraKey) {
	    var nonce = newNonce();
	    var sharedKey = naclFast_3.before(recvPublicKey, sendSecretKey);
	    var encrypted = extraKey ? naclFast_3(data, nonce, extraKey, sharedKey) : naclFast_3.after(data, nonce, sharedKey);
	    var fullMessage = new Uint8Array(nonce.length + encrypted.length);
	    fullMessage.set(nonce);
	    fullMessage.set(encrypted, nonce.length);
	    return fullMessage;
	  }

	  function aKeyEncrypt_str(recvPublicKey, sendSecretKey, data, extraKey) {
	    var fullMessage = extraKey ? aKeyEncrypt(recvPublicKey, sendSecretKey, naclUtil_1(data), new Uint8Array(hash_1.sha256().update(extraKey).digest())) : aKeyEncrypt(recvPublicKey, sendSecretKey, naclUtil_1(data));
	    return naclUtil_3(fullMessage);
	  }
	  /**
	   *
	   * @param publicKey
	   * @param eData
	   *
	   * decrypts assymetrically encrypted data using the sender's publicKey
	   * and receiver's secretKey
	   * extraKey:may needed
	   */


	  function aKeyDecrypt(sendPublicKey, recvSecretKey, eData, extraKey) {
	    var sharedKey = naclFast_3.before(sendPublicKey, recvSecretKey);
	    var nonce = eData.slice(0, naclFast_3.nonceLength);
	    var message = eData.slice(naclFast_3.nonceLength, eData.length);
	    var decrypted = extraKey ? naclFast_3.open(message, nonce, extraKey, sharedKey) : naclFast_3.open.after(message, nonce, sharedKey);
	    /*
	            if (!decrypted) {
	            throw new Error('Could not decrypt message');
	        }
	        */

	    return decrypted;
	  }

	  function aKeyDecrypt_str(sendPublicKey, recvSecretKey, eData, // any string
	  extraKey) {
	    var eDataArr = naclUtil_4(eData);
	    console.log(eDataArr.length);
	    var decrypted = extraKey ? aKeyDecrypt(sendPublicKey, recvSecretKey, eDataArr, new Uint8Array(hash_1.sha256().update(extraKey).digest())) : aKeyDecrypt(sendPublicKey, recvSecretKey, eDataArr);

	    if (!decrypted) {
	      console.log('fail to decrypt!');
	      return '';
	    }

	    return naclUtil_2(decrypted);
	  }
	  /**
	   * returns a secretKey for symmetric encrypting
	   */


	  function generateSKey() {
	    var secretKey = naclFast_2(naclFast_1.keyLength);
	    return secretKey;
	  }
	  /**
	   *
	   * @param secretKey
	   * @param data
	   *
	   * encrypts data symmetrically using teh provided secretKey
	   */


	  function sKeyEncrypt(secretKey, data) {
	    var nonce = naclFast_2(naclFast_1.nonceLength);
	    var box = naclFast_1(data, nonce, secretKey);
	    var encryptedData = new Uint8Array(nonce.length + box.length);
	    encryptedData.set(nonce);
	    encryptedData.set(box, nonce.length);
	    return encryptedData;
	  }
	  /**
	   *
	   * @param secretKey
	   * @param eData
	   *
	   * decrypt data symmetrically using the secretKey provided
	   */


	  function sKeyDecrypt(secretKey, eData) {
	    var nonce = eData.slice(0, naclFast_1.nonceLength);
	    var data = eData.slice(naclFast_1.nonceLength, eData.length);
	    var decryptedData;

	    try {
	      decryptedData = naclFast_1.open(data, nonce, secretKey);
	    } catch (error) {
	      throw new Error('Could not decrypt data');
	    }

	    return decryptedData;
	  }
	  /**
	   *
	   * @param data
	   *
	   * encodes Uint8Array data to base64 string
	   */


	  function uint8ArrayToBase64(data) {
	    return naclUtil_3(data);
	  }
	  /**
	   *
	   * @param data
	   *
	   * decodes string data to Uint8Array
	   */


	  function base64ToUint8Array(data) {
	    return naclUtil_4(data);
	  }
	  /**
	   *
	   * @param data
	   *
	   * converts Blob to base64
	   */


	  function blobToBase64(_x) {
	    return _blobToBase.apply(this, arguments);
	  }
	  /**
	   *
	   * @param data
	   * @param type optional
	   *
	   * converts string data to Blob
	   */


	  function _blobToBase() {
	    _blobToBase = asyncToGenerator$1(
	    /*#__PURE__*/
	    regenerator$1.mark(function _callee(data) {
	      var dataToBuffer, dataBufferToUint8Array, dataUint8ArrayToBase64;
	      return regenerator$1.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return new Response(data).arrayBuffer();

	            case 2:
	              dataToBuffer = _context.sent;
	              dataBufferToUint8Array = new Uint8Array(dataToBuffer);
	              dataUint8ArrayToBase64 = uint8ArrayToBase64(dataBufferToUint8Array);
	              return _context.abrupt("return", dataUint8ArrayToBase64);

	            case 6:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, _callee);
	    }));
	    return _blobToBase.apply(this, arguments);
	  }

	  function base64ToBlob(data, type) {
	    var dataToUint8Array = naclUtil_4(data);
	    var dataUint8ArrayToBuffer = new Buffer(dataToUint8Array);
	    var dataBufferToBlob = new Blob([dataUint8ArrayToBuffer.buffer], {
	      type: type
	    });
	    return dataBufferToBlob;
	  }
	  /**
	   *
	   * @param data
	   *
	   * decodes string and returns Uint8Array
	   */


	  function uTF8ToUint8Array(data) {
	    return naclUtil_1(data);
	  }
	  /**
	   *
	   * @param data
	   *
	   * encodes Uint8Array or Array of bytes into string
	   */


	  function uint8ArrayToUTF8(data) {
	    return naclUtil_2(data);
	  }
	  /**
	   * 
	   * @param data 
	   * 
	   * converts data from Blob to Uint8Array
	   */


	  function blobToUint8Array(_x2) {
	    return _blobToUint8Array.apply(this, arguments);
	  }
	  /**
	   * 
	   * @param data 
	   * @param type 
	   * 
	   * converts data from Uint8Array to Blob
	   */


	  function _blobToUint8Array() {
	    _blobToUint8Array = asyncToGenerator$1(
	    /*#__PURE__*/
	    regenerator$1.mark(function _callee2(data) {
	      var dataToBuffer, dataBufferToUint8Array;
	      return regenerator$1.wrap(function _callee2$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              _context2.next = 2;
	              return new Response(data).arrayBuffer();

	            case 2:
	              dataToBuffer = _context2.sent;
	              dataBufferToUint8Array = new Uint8Array(dataToBuffer);
	              return _context2.abrupt("return", dataBufferToUint8Array);

	            case 5:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      }, _callee2);
	    }));
	    return _blobToUint8Array.apply(this, arguments);
	  }

	  function uint8ArrayToBlob(data, type) {
	    var dataUint8ArrayToBuffer = new Buffer(data);
	    var dataBufferToBlob = new Blob([dataUint8ArrayToBuffer.buffer], {
	      type: type
	    });
	    return dataBufferToBlob;
	  }
	  /**
	   * creates random nonce
	   */


	  function newNonce() {
	    return naclFast_2(naclFast_3.nonceLength);
	  }

	  function removeCredentialsFromLocalStorage() {
	    localStorage.removeItem('sk');
	    localStorage.removeItem('pk');
	    localStorage.removeItem('esk');
	    localStorage.removeItem('user_vid');
	    localStorage.removeItem('jwt');
	    localStorage.removeItem('vcjwt');
	    localStorage.removeItem('uid');
	  }
	}();

	var jsonEscape = function jsonEscape(str) {
	  return str.replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t');
	};

	var jwtNotFound =
	/*#__PURE__*/
	function () {
	  var _ref2 = asyncToGenerator$1(
	  /*#__PURE__*/
	  regenerator$1.mark(function _callee(_ref) {
	    var fn, args, account;
	    return regenerator$1.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            fn = _ref.fn, args = _ref.args;
	            _context.prev = 1;
	            account = new Account();
	            _context.next = 5;
	            return account.login();

	          case 5:
	            return _context.abrupt("return", fn(args));

	          case 8:
	            _context.prev = 8;
	            _context.t0 = _context["catch"](1);
	            throw new AitmedError({
	              code: _context.t0.code,
	              message: _context.t0.message || "There was an error retrieving a new JWT"
	            });

	          case 11:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee, null, [[1, 8]]);
	  }));

	  return function jwtNotFound(_x) {
	    return _ref2.apply(this, arguments);
	  };
	}();

	var jwtExpired =
	/*#__PURE__*/
	function () {
	  var _ref2 = asyncToGenerator$1(
	  /*#__PURE__*/
	  regenerator$1.mark(function _callee(_ref) {
	    var fn, args, account;
	    return regenerator$1.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            fn = _ref.fn, args = _ref.args;
	            _context.prev = 1;
	            account = new Account();
	            _context.next = 5;
	            return account.login();

	          case 5:
	            return _context.abrupt("return", fn(args));

	          case 8:
	            _context.prev = 8;
	            _context.t0 = _context["catch"](1);
	            throw new AitmedError({
	              code: _context.t0.code,
	              message: _context.t0.message || "There was an error retrieving a new JWT"
	            });

	          case 11:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee, null, [[1, 8]]);
	  }));

	  return function jwtExpired(_x) {
	    return _ref2.apply(this, arguments);
	  };
	}();

	var errorSwitch =
	/*#__PURE__*/
	function () {
	  var _ref2 = asyncToGenerator$1(
	  /*#__PURE__*/
	  regenerator$1.mark(function _callee(_ref) {
	    var name, code, message, fn, args, errorName, response;
	    return regenerator$1.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            name = _ref.name, code = _ref.code, message = _ref.message, fn = _ref.fn, args = _ref.args;

	            if (name === undefined && code !== undefined) {
	              errorName = Codes[code];
	            } else {
	              errorName = name;
	            }

	            _context.t0 = errorName;
	            _context.next = _context.t0 === 'JWT_NOT_FOUND' ? 5 : _context.t0 === 'JWT_EXPIRED' ? 9 : 13;
	            break;

	          case 5:
	            _context.next = 7;
	            return jwtNotFound({
	              fn: fn,
	              args: args
	            });

	          case 7:
	            response = _context.sent;
	            return _context.abrupt("return", response);

	          case 9:
	            _context.next = 11;
	            return jwtExpired({
	              fn: fn,
	              args: args
	            });

	          case 11:
	            response = _context.sent;
	            return _context.abrupt("return", response);

	          case 13:
	            throw new AitmedError({
	              name: errorName,
	              message: message
	            });

	          case 14:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee);
	  }));

	  return function errorSwitch(_x) {
	    return _ref2.apply(this, arguments);
	  };
	}();

	var Edge = function Edge() {
	  classCallCheck$1(this, Edge);

	  defineProperty$e(this, "eid", void 0);

	  defineProperty$e(this, "ctime", void 0);

	  defineProperty$e(this, "mtime", void 0);

	  defineProperty$e(this, "atime", void 0);

	  defineProperty$e(this, "atimes", void 0);

	  defineProperty$e(this, "bvid", void 0);

	  defineProperty$e(this, "type", void 0);

	  defineProperty$e(this, "name", void 0);

	  defineProperty$e(this, "evid", void 0);

	  defineProperty$e(this, "subtype", void 0);

	  defineProperty$e(this, "stime", void 0);

	  defineProperty$e(this, "etime", void 0);

	  defineProperty$e(this, "refid", void 0);

	  defineProperty$e(this, "besak", void 0);

	  defineProperty$e(this, "eesak", void 0);

	  defineProperty$e(this, "sig", void 0);

	  defineProperty$e(this, "tage", void 0);

	  defineProperty$e(this, "deat", void 0);
	};
	var Vertex = function Vertex() {
	  classCallCheck$1(this, Vertex);

	  defineProperty$e(this, "id", void 0);

	  defineProperty$e(this, "ctime", void 0);

	  defineProperty$e(this, "mtime", void 0);

	  defineProperty$e(this, "atime", void 0);

	  defineProperty$e(this, "atimes", void 0);

	  defineProperty$e(this, "type", void 0);

	  defineProperty$e(this, "name", void 0);

	  defineProperty$e(this, "esk", void 0);

	  defineProperty$e(this, "pk", void 0);

	  defineProperty$e(this, "uid", void 0);

	  defineProperty$e(this, "deat", void 0);

	  defineProperty$e(this, "tage", void 0);
	} // target age
	;
	var Doc = function Doc() {
	  classCallCheck$1(this, Doc);

	  defineProperty$e(this, "id", void 0);

	  defineProperty$e(this, "ctime", void 0);

	  defineProperty$e(this, "mtime", void 0);

	  defineProperty$e(this, "atime", void 0);

	  defineProperty$e(this, "atimes", void 0);

	  defineProperty$e(this, "tage", void 0);

	  defineProperty$e(this, "type", void 0);

	  defineProperty$e(this, "name", void 0);

	  defineProperty$e(this, "deat", void 0);

	  defineProperty$e(this, "size", void 0);

	  defineProperty$e(this, "fid", void 0);

	  defineProperty$e(this, "eid", void 0);

	  defineProperty$e(this, "bsig", void 0);

	  defineProperty$e(this, "esig", void 0);
	};

	function toSDKVertex(vertex) {
	  var res = new Vertex();
	  res.id = vertex.getId();
	  res.mtime = vertex.getMtime();
	  res.ctime = vertex.getCtime();
	  res.atime = vertex.getAtime();
	  res.atimes = vertex.getAtimes();
	  res.type = vertex.getType();
	  var name = vertex.getName();

	  if (name === '') {
	    res.name = null;
	  } else {
	    try {
	      res.name = JSON.parse(jsonEscape(name));
	    } catch (error) {
	      new AitmedError({
	        name: 'JSON_PARSE_FAILED',
	        message: name
	      });
	    }
	  }

	  res.esk = vertex.getEsk();
	  res.pk = vertex.getPk();
	  res.uid = vertex.getUid();
	  var deat = vertex.getDeat();

	  if (deat === '') {
	    res.deat = null;
	  } else {
	    try {
	      res.deat = JSON.parse(deat);
	    } catch (error) {
	      new AitmedError({
	        name: 'JSON_PARSE_FAILED',
	        message: deat
	      });
	    }
	  }

	  res.tage = vertex.getTage();
	  return res;
	}

	function toSDKEdge(edge) {
	  var res = new Edge();
	  res.eid = edge.getId();
	  res.bvid = edge.getBvid();
	  res.type = edge.getType();
	  res.tage = edge.getTage();
	  var name = edge.getName();

	  if (name === '') {
	    res.name = '';
	  } else {
	    try {
	      res.name = JSON.parse(jsonEscape(name));
	    } catch (error) {
	      throw new AitmedError({
	        name: 'JSON_PARSE_FAILED',
	        message: name
	      });
	    }
	  }

	  res.evid = edge.getEvid();
	  res.subtype = edge.getSubtype();
	  res.etime = edge.getEtime();
	  res.mtime = edge.getMtime();
	  res.atime = edge.getAtime();
	  res.atimes = edge.getAtimes();
	  res.refid = edge.getRefid();
	  res.besak = edge.getBesak();
	  res.eesak = edge.getEesak();
	  res.ctime = edge.getCtime();
	  res.sig = edge.getSig();
	  var deat = edge.getDeat();

	  if (deat === '') {
	    res.deat = null;
	  } else {
	    try {
	      res.deat = JSON.parse(deat);
	    } catch (error) {
	      throw new AitmedError({
	        name: 'JSON_PARSE_FAILED',
	        message: deat
	      });
	    }
	  }

	  return res;
	}

	function toSDKDoc(doc) {
	  var res = new Doc();
	  res.id = doc.getId();
	  res.ctime = doc.getCtime();
	  res.mtime = doc.getMtime();
	  res.atime = doc.getAtime();
	  res.atimes = doc.getAtimes();
	  res.tage = doc.getTage();
	  res.type = doc.getType();
	  var name = doc.getName();

	  if (name === '') {
	    res.name = null;
	  } else {
	    try {
	      res.name = JSON.parse(jsonEscape(name));
	    } catch (error) {
	      throw new AitmedError({
	        name: 'JSON_PARSE_FAILED',
	        message: name
	      });
	    }
	  }

	  var deat = doc.getDeat();

	  if (deat === '') {
	    res.deat = null;
	  } else {
	    try {
	      res.deat = JSON.parse(deat);
	    } catch (error) {
	      throw new AitmedError({
	        name: 'JSON_PARSE_FAILED',
	        message: deat
	      });
	    }
	  }

	  res.size = doc.getSize();
	  res.fid = doc.getFid();
	  res.eid = doc.getEid();
	  res.bsig = doc.getBsig();
	  res.esig = doc.getEsig();
	  return res;
	}
	/**
	 * creates esak for an edge(either besak || eesak)
	 */


	function generateEsak(publicKey) {
	  var secretKey = localStorage.getItem('sk');

	  if (publicKey === null) {
	    throw new AitmedError({
	      name: 'ERROR_CREATING_ESAK'
	    });
	  }

	  if (secretKey === null) {
	    throw new AitmedError({
	      name: 'LOGIN_REQUIRED',
	      message: 'There is no secretKey present in localStorage. Please log In.'
	    });
	  }

	  var pkToUint8Array;

	  if (typeof publicKey === 'string') {
	    pkToUint8Array = utils$2.base64ToUint8Array(publicKey);
	  } else {
	    pkToUint8Array = publicKey;
	  }

	  var skToUint8Array = utils$2.base64ToUint8Array(secretKey);
	  var symmetricKey = utils$2.generateSKey();
	  var partialKey = symmetricKey.slice(0, 16);
	  var esak = utils$2.aKeyEncrypt(pkToUint8Array, skToUint8Array, partialKey);
	  return esak;
	} //TODO change when a receiver is added
	//currently both sk and pk belong to the current logged in user


	function encryptData(_x, _x2, _x3) {
	  return _encryptData.apply(this, arguments);
	} //TODO change when a receiver is added
	//currently both sk and pk belong to the current logged in user


	function _encryptData() {
	  _encryptData = asyncToGenerator$1(
	  /*#__PURE__*/
	  regenerator$1.mark(function _callee(esak, publicKey, data) {
	    var secretKey, esakUint8Array, pkToUint8Array, skToUint8Array, partialKey, sak, sakUint8Array, encryptedData;
	    return regenerator$1.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            secretKey = localStorage.getItem('sk');

	            if (!(publicKey === null)) {
	              _context.next = 3;
	              break;
	            }

	            throw new AitmedError({
	              name: 'REQUIRED_PHONE_NUMBER_AND_VERIFICATION_CODE',
	              message: 'There is no publicKey present in localStorage. Please log In.'
	            });

	          case 3:
	            if (!(secretKey === null)) {
	              _context.next = 5;
	              break;
	            }

	            throw new AitmedError({
	              name: 'LOGIN_REQUIRED',
	              message: 'There is no secretKey present in localStorage. Please log In.'
	            });

	          case 5:
	            if (typeof esak === 'string') {
	              esakUint8Array = utils$2.base64ToUint8Array(esak);
	            } else {
	              esakUint8Array = esak;
	            }

	            pkToUint8Array = utils$2.base64ToUint8Array(publicKey);
	            skToUint8Array = utils$2.base64ToUint8Array(secretKey);
	            partialKey = utils$2.aKeyDecrypt(pkToUint8Array, skToUint8Array, esakUint8Array);
	            sak = hash_2().update(partialKey).digest();
	            sakUint8Array = new Uint8Array(sak);
	            encryptedData = utils$2.sKeyEncrypt(sakUint8Array, data);
	            return _context.abrupt("return", encryptedData);

	          case 13:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee);
	  }));
	  return _encryptData.apply(this, arguments);
	}

	function decryptData(esak, publicKey, data) {
	  var secretKey = localStorage.getItem('sk');

	  if (publicKey === null) {
	    throw new AitmedError({
	      name: 'REQUIRED_PHONE_NUMBER_AND_VERIFICATION_CODE',
	      message: 'There is no publicKey present in localStorage. Please log In.'
	    });
	  }

	  if (secretKey === null) {
	    throw new AitmedError({
	      name: 'LOGIN_REQUIRED',
	      message: 'There is no secretKey present in localStorage. Please log In.'
	    });
	  }

	  var esakUint8Array;

	  if (typeof esak === 'string') {
	    esakUint8Array = utils$2.base64ToUint8Array(esak);
	  } else {
	    esakUint8Array = esak;
	  }

	  var pkToUint8Array = utils$2.base64ToUint8Array(publicKey);
	  var skToUint8Array = utils$2.base64ToUint8Array(secretKey);
	  var partialKey = utils$2.aKeyDecrypt(pkToUint8Array, skToUint8Array, esakUint8Array);
	  var sak = hash_2().update(partialKey).digest();
	  var sakUint8Array = new Uint8Array(sak);
	  var decryptedDataUint8Array = utils$2.sKeyDecrypt(sakUint8Array, data);

	  if (decryptedDataUint8Array !== null) {
	    return decryptedDataUint8Array;
	  } else {
	    throw new AitmedError({
	      name: 'ERROR_DECRYPTING_DATA'
	    });
	  }
	}

	var commonServices = /*#__PURE__*/Object.freeze({
		__proto__: null,
		toSDKVertex: toSDKVertex,
		toSDKEdge: toSDKEdge,
		toSDKDoc: toSDKDoc,
		generateEsak: generateEsak,
		encryptData: encryptData,
		decryptData: decryptData
	});

	function retrieveVertexService(_request) {
	  return new Promise(function (resolve, reject) {
	    store$2.grpcClient.rv(_request, null, callback);

	    function callback(_error, _response) {
	      return retrieveVertexCallBack(_error, _response, resolve, reject);
	    }
	  });
	}

	function retrieveDocumentService(_request) {
	  return new Promise(function (resolve, reject) {
	    store$2.grpcClient.rd(_request, null, callback);

	    function callback(_error, _response) {
	      return retrieveDocumentCallBack(_error, _response, resolve, reject);
	    }
	  });
	}

	function retrieveEdgeService(_request) {
	  return new Promise(function (resolve, reject) {
	    store$2.grpcClient.re(_request, null, callback);

	    function callback(_error, _response) {
	      return retrieveEdgeCallBack(_error, _response, resolve, reject);
	    }
	  });
	}

	function handleServerError(_x) {
	  return _handleServerError.apply(this, arguments);
	}

	function _handleServerError() {
	  _handleServerError = asyncToGenerator$1(
	  /*#__PURE__*/
	  regenerator$1.mark(function _callee(_ref) {
	    var response, fn, args, reject, resolve, serverResponseCode, serverError, translatedCode, errorIsUnknown, errorName, switchResponse;
	    return regenerator$1.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            response = _ref.response, fn = _ref.fn, args = _ref.args, reject = _ref.reject, resolve = _ref.resolve;
	            serverResponseCode = response.getCode();
	            serverError = response.getError();
	            translatedCode = translateErrorCode(serverResponseCode);
	            errorIsUnknown = translatedCode === -1;

	            if (!errorIsUnknown) {
	              _context.next = 9;
	              break;
	            }

	            reject(new AitmedError({
	              code: serverResponseCode,
	              source: 'lvl-1',
	              message: serverError
	            }));
	            _context.next = 20;
	            break;

	          case 9:
	            _context.prev = 9;
	            errorName = Codes[translatedCode];
	            _context.next = 13;
	            return errorSwitch({
	              name: errorName,
	              fn: fn,
	              args: args
	            });

	          case 13:
	            switchResponse = _context.sent;
	            resolve(switchResponse);
	            _context.next = 20;
	            break;

	          case 17:
	            _context.prev = 17;
	            _context.t0 = _context["catch"](9);
	            reject(_context.t0);

	          case 20:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee, null, [[9, 17]]);
	  }));
	  return _handleServerError.apply(this, arguments);
	}

	function retrieveVertexCallBack(_x2, _x3, _x4, _x5) {
	  return _retrieveVertexCallBack.apply(this, arguments);
	}

	function _retrieveVertexCallBack() {
	  _retrieveVertexCallBack = asyncToGenerator$1(
	  /*#__PURE__*/
	  regenerator$1.mark(function _callee2(_error, _response, resolve, reject) {
	    var gRPCErrorExists, serverResponseCode, serverErrorExists, list, listIsUndefined, sdkList, newJWT, response;
	    return regenerator$1.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            gRPCErrorExists = _error !== null;

	            if (gRPCErrorExists) {
	              reject(new AitmedError({
	                code: _error.code,
	                message: _error.message
	              }));
	            }

	            serverResponseCode = _response.getCode();
	            serverErrorExists = serverResponseCode !== 0;

	            if (serverErrorExists) {
	              resolve([serverErrorExists, _response]);
	            }

	            list = _response.getVertexList();
	            listIsUndefined = list === undefined;

	            if (listIsUndefined) {
	              reject(new AitmedError({
	                name: 'VERTEX_IS_UNDEFINED'
	              }));
	            }

	            sdkList = list.map(function (data) {
	              return toSDKVertex(data);
	            });
	            newJWT = _response.getJwt();
	            utils$2.storeCredentialsInLocalStorage({
	              jwt: newJWT
	            });
	            response = new Response$1({
	              code: 0,
	              data: sdkList
	            });
	            resolve([false, response]);

	          case 13:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, _callee2);
	  }));
	  return _retrieveVertexCallBack.apply(this, arguments);
	}

	function retrieveDocumentCallBack(_x6, _x7, _x8, _x9) {
	  return _retrieveDocumentCallBack.apply(this, arguments);
	}

	function _retrieveDocumentCallBack() {
	  _retrieveDocumentCallBack = asyncToGenerator$1(
	  /*#__PURE__*/
	  regenerator$1.mark(function _callee3(_error, _response, resolve, reject) {
	    var gRPCErrorExists, serverResponseCode, serverErrorExists, list, listIsUndefined, sdkList, newJWT, response;
	    return regenerator$1.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            gRPCErrorExists = _error !== null;

	            if (gRPCErrorExists) {
	              reject(new AitmedError({
	                code: _error.code,
	                message: _error.message
	              }));
	            }

	            serverResponseCode = _response.getCode();
	            serverErrorExists = serverResponseCode !== 0;

	            if (serverErrorExists) {
	              resolve([serverErrorExists, _response]);
	            }

	            list = _response.getDocList();
	            listIsUndefined = list === undefined;

	            if (listIsUndefined) {
	              reject(new AitmedError({
	                name: 'DOCUMENT_IS_UNDEFINED'
	              }));
	            }

	            sdkList = list.map(function (data) {
	              return toSDKDoc(data);
	            });
	            newJWT = _response.getJwt();
	            utils$2.storeCredentialsInLocalStorage({
	              jwt: newJWT
	            });
	            response = new Response$1({
	              code: 0,
	              data: sdkList
	            });
	            resolve([false, response]);

	          case 13:
	          case "end":
	            return _context3.stop();
	        }
	      }
	    }, _callee3);
	  }));
	  return _retrieveDocumentCallBack.apply(this, arguments);
	}

	function retrieveEdgeCallBack(_x10, _x11, _x12, _x13) {
	  return _retrieveEdgeCallBack.apply(this, arguments);
	}

	function _retrieveEdgeCallBack() {
	  _retrieveEdgeCallBack = asyncToGenerator$1(
	  /*#__PURE__*/
	  regenerator$1.mark(function _callee4(_error, _response, resolve, reject) {
	    var gRPCErrorExists, serverResponseCode, serverErrorExists, list, listIsUndefined, sdkList, newJWT, response;
	    return regenerator$1.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            gRPCErrorExists = _error !== null;

	            if (gRPCErrorExists) {
	              reject(new AitmedError({
	                code: _error.code,
	                message: _error.message
	              }));
	            }

	            serverResponseCode = _response.getCode();
	            serverErrorExists = serverResponseCode !== 0;

	            if (serverErrorExists) {
	              resolve([serverErrorExists, _response]);
	            }

	            list = _response.getEdgeList();
	            listIsUndefined = list === undefined;

	            if (listIsUndefined) {
	              reject(new AitmedError({
	                name: 'EDGE_IS_UNDEFINED'
	              }));
	            }

	            sdkList = list.map(function (data) {
	              return toSDKEdge(data);
	            });
	            newJWT = _response.getJwt();
	            utils$2.storeCredentialsInLocalStorage({
	              jwt: newJWT
	            });
	            response = new Response$1({
	              code: 0,
	              data: sdkList
	            });
	            resolve([false, response]);

	          case 13:
	          case "end":
	            return _context4.stop();
	        }
	      }
	    }, _callee4);
	  }));
	  return _retrieveEdgeCallBack.apply(this, arguments);
	}

	/**
	 *
	 * @param objType     0 - Vertex, 1 = Doc, 2 = Edge
	 * @param idList
	 */

	function retrieveRequest(objType) {
	  return function innerRetrieveFunc(_ref) {
	    var _ref$idList = _ref.idList,
	        idList = _ref$idList === void 0 ? [] : _ref$idList,
	        _ref$options = _ref.options,
	        options = _ref$options === void 0 ? {
	      xfname: 'id'
	    } : _ref$options;
	    return new Promise(
	    /*#__PURE__*/
	    function () {
	      var _ref2 = asyncToGenerator$1(
	      /*#__PURE__*/
	      regenerator$1.mark(function _callee(resolve, reject) {
	        var request, jwt, xfname, type, key, sfname, loid, maxcount, obfname, scondition, asc, result, _result, _result2, _error, _response;

	        return regenerator$1.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (!store$2.grpcClient) {
	                  reject(new AitmedError({
	                    name: 'INVALID_API_VERSION'
	                  }));
	                }

	                request = new ecos_api_pb_12$1();
	                jwt = localStorage.getItem('jwt');
	                request.setJwt(jwt ? jwt : '');
	                request.setIdList(idList);
	                xfname = options.xfname, type = options.type, key = options.key, sfname = options.sfname, loid = options.loid, maxcount = options.maxcount, obfname = options.obfname, scondition = options.scondition, asc = options.asc;
	                request.setXfname(xfname === undefined ? 'id' : xfname);
	                if (type !== undefined) request.setType(type);
	                if (key !== undefined) request.setKey(key);
	                if (sfname !== undefined) request.setSfname(sfname);
	                if (loid !== undefined) request.setLoid(loid);
	                if (maxcount !== undefined) request.setMaxcount(maxcount);
	                if (obfname !== undefined) request.setObfname(obfname);
	                if (scondition !== undefined) request.setScondition(scondition);
	                if (asc !== undefined) request.setAsc(asc);
	                _context.t0 = objType;
	                _context.next = _context.t0 === 0 ? 18 : _context.t0 === 1 ? 22 : _context.t0 === 2 ? 26 : 30;
	                break;

	              case 18:
	                _context.next = 20;
	                return retrieveVertexService(request);

	              case 20:
	                result = _context.sent;
	                return _context.abrupt("break", 31);

	              case 22:
	                _context.next = 24;
	                return retrieveDocumentService(request);

	              case 24:
	                result = _context.sent;
	                return _context.abrupt("break", 31);

	              case 26:
	                _context.next = 28;
	                return retrieveEdgeService(request);

	              case 28:
	                result = _context.sent;
	                return _context.abrupt("break", 31);

	              case 30:
	                throw new AitmedError({
	                  name: 'OBJECT_TYPE_INVALID'
	                });

	              case 31:
	                _result = result, _result2 = slicedToArray$1(_result, 2), _error = _result2[0], _response = _result2[1];

	                if (!_error) {
	                  _context.next = 37;
	                  break;
	                }

	                _context.next = 35;
	                return handleServerError({
	                  response: _response,
	                  fn: innerRetrieveFunc,
	                  args: options,
	                  reject: reject,
	                  resolve: resolve
	                });

	              case 35:
	                _context.next = 38;
	                break;

	              case 37:
	                if (!_error && _response instanceof Response$1) {
	                  resolve(_response);
	                }

	              case 38:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee);
	      }));

	      return function (_x, _x2) {
	        return _ref2.apply(this, arguments);
	      };
	    }());
	  };
	}

	function deleteRequest(idList) {
	  return new Promise(function (resolve, reject) {
	    if (!store$2.grpcClient) {
	      reject(new AitmedError({
	        name: 'INVALID_API_VERSION'
	      }));
	      return;
	    }

	    var request = new ecos_api_pb_7$1();
	    var jwt = localStorage.getItem('jwt');
	    request.setJwt(jwt ? jwt : '');
	    request.setIdList(idList);
	    store$2.grpcClient.dx(request, null,
	    /*#__PURE__*/
	    function () {
	      var _ref = asyncToGenerator$1(
	      /*#__PURE__*/
	      regenerator$1.mark(function _callee(_error, _response) {
	        var error, responseCode, translatedCode, switchResponse, newJWT, response;
	        return regenerator$1.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (!_error) {
	                  _context.next = 4;
	                  break;
	                }

	                error = new AitmedError({
	                  code: _error.code,
	                  message: _error.message
	                });
	                reject(error);
	                return _context.abrupt("return");

	              case 4:
	                responseCode = _response.getCode();

	                if (!(responseCode !== 0)) {
	                  _context.next = 22;
	                  break;
	                }

	                translatedCode = translateErrorCode(responseCode);

	                if (!(translatedCode === -1)) {
	                  _context.next = 10;
	                  break;
	                }

	                reject(new AitmedError({
	                  code: responseCode,
	                  source: 'lvl-1',
	                  message: _response.getError()
	                }));
	                return _context.abrupt("return");

	              case 10:
	                _context.prev = 10;
	                _context.next = 13;
	                return errorSwitch({
	                  code: translatedCode,
	                  fn: deleteRequest,
	                  args: idList
	                });

	              case 13:
	                switchResponse = _context.sent;
	                resolve(switchResponse);
	                return _context.abrupt("return");

	              case 18:
	                _context.prev = 18;
	                _context.t0 = _context["catch"](10);
	                reject(_context.t0);
	                return _context.abrupt("return");

	              case 22:
	                newJWT = _response.getJwt();
	                utils$2.storeCredentialsInLocalStorage({
	                  jwt: newJWT
	                });
	                response = new Response$1({
	                  code: responseCode
	                });
	                resolve(response);
	                return _context.abrupt("return");

	              case 27:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, null, [[10, 18]]);
	      }));

	      return function (_x, _x2) {
	        return _ref.apply(this, arguments);
	      };
	    }());
	  });
	}

	function ownKeys$1$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1$1(source, true).forEach(function (key) { defineProperty$e(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1$1(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	var documentServices = function () {
	  var services = {
	    createDocument: function createDocument(args) {
	      return documentRequest(_objectSpread$1({}, args));
	    },
	    updateDocument: function updateDocument(args) {
	      return documentRequest(_objectSpread$1({}, args));
	    },
	    retrieveDocument: retrieveRequest(1),
	    deleteDocument: deleteRequest,
	    attachDocument: attachDocument,
	    uploadDocumentToS3: uploadDocumentToS3,
	    downloadDocumentFromS3: downloadDocumentFromS3
	  };
	  /**
	     *
	     * @param {DocumentRequestArgs} args
	     * @param {string | Uint8Array} args.id if id is undefined, create document, otherwise, update document.
	     */

	  function documentRequest(_ref) {
	    var documentOptions = _extends_1({}, _ref);

	    return new Promise(function (resolve, reject) {
	      if (!store$2.grpcClient) {
	        reject(new AitmedError({
	          name: 'INVALID_API_VERSION'
	        }));
	        return;
	      }

	      var apiDocument = generateGRPCDocument(documentOptions);
	      var jwt = localStorage.getItem('jwt');
	      var request = new ecos_api_pb_1$1();
	      request.setJwt(jwt === null ? '' : jwt);
	      request.setDoc(apiDocument);
	      store$2.grpcClient.cd(request, null,
	      /*#__PURE__*/
	      function () {
	        var _ref2 = asyncToGenerator$1(
	        /*#__PURE__*/
	        regenerator$1.mark(function _callee(_error, _response) {
	          var error, document, _error2, responseCode, translatedCode, switchResponse, newJWT, sdkDocument, response;

	          return regenerator$1.wrap(function _callee$(_context) {
	            while (1) {
	              switch (_context.prev = _context.next) {
	                case 0:
	                  if (!_error) {
	                    _context.next = 4;
	                    break;
	                  }

	                  error = new AitmedError({
	                    code: _error.code,
	                    message: _error.message
	                  });
	                  reject(error);
	                  return _context.abrupt("return");

	                case 4:
	                  document = _response.getDoc();

	                  if (!(document === undefined)) {
	                    _context.next = 9;
	                    break;
	                  }

	                  _error2 = new AitmedError({
	                    name: 'DOCUMENT_IS_UNDEFINED'
	                  });
	                  reject(_error2);
	                  return _context.abrupt("return");

	                case 9:
	                  responseCode = _response.getCode();

	                  if (!(responseCode !== 0)) {
	                    _context.next = 27;
	                    break;
	                  }

	                  translatedCode = translateErrorCode(responseCode);

	                  if (!(translatedCode === -1)) {
	                    _context.next = 15;
	                    break;
	                  }

	                  reject(new AitmedError({
	                    code: responseCode,
	                    source: 'lvl-1',
	                    message: _response.getError()
	                  }));
	                  return _context.abrupt("return");

	                case 15:
	                  _context.prev = 15;
	                  _context.next = 18;
	                  return errorSwitch({
	                    code: translatedCode,
	                    fn: documentRequest,
	                    args: documentOptions
	                  });

	                case 18:
	                  switchResponse = _context.sent;
	                  resolve(switchResponse);
	                  return _context.abrupt("return");

	                case 23:
	                  _context.prev = 23;
	                  _context.t0 = _context["catch"](15);
	                  reject(_context.t0);
	                  return _context.abrupt("return");

	                case 27:
	                  newJWT = _response.getJwt();
	                  utils$2.storeCredentialsInLocalStorage({
	                    jwt: newJWT
	                  });
	                  sdkDocument = toSDKDoc(document);
	                  response = new Response$1({
	                    code: responseCode,
	                    data: sdkDocument
	                  });
	                  resolve(response);
	                  return _context.abrupt("return");

	                case 33:
	                case "end":
	                  return _context.stop();
	              }
	            }
	          }, _callee, null, [[15, 23]]);
	        }));

	        return function (_x, _x2) {
	          return _ref2.apply(this, arguments);
	        };
	      }());
	    });
	  }

	  function generateGRPCDocument(_ref3) {
	    var id = _ref3.id,
	        type = _ref3.type,
	        name = _ref3.name,
	        deat = _ref3.deat,
	        size = _ref3.size,
	        fid = _ref3.fid,
	        eid = _ref3.eid,
	        bSig = _ref3.bSig,
	        eSig = _ref3.eSig,
	        ctime = _ref3.ctime,
	        mtime = _ref3.mtime,
	        atime = _ref3.atime,
	        atimes = _ref3.atimes,
	        tage = _ref3.tage;
	    var document = new types_pb_3$1();
	    if (id !== undefined) document.setId(id);
	    if (type !== undefined) document.setType(type);

	    if (name) {
	      try {
	        var nameJSONString = JSON.stringify(name);
	        document.setName(nameJSONString);
	      } catch (error) {
	        throw new AitmedError({
	          name: 'JSON_STRINGIFY_FAILED'
	        });
	      }
	    }

	    if (deat) {
	      try {
	        var deatJSONString = JSON.stringify(deat);
	        document.setDeat(deatJSONString);
	      } catch (error) {
	        throw new AitmedError({
	          name: 'JSON_STRINGIFY_FAILED'
	        });
	      }
	    }

	    if (size !== undefined) document.setSize(size);
	    if (fid !== undefined) document.setFid(fid);
	    if (eid !== undefined) document.setEid(eid);
	    if (bSig !== undefined) document.setBsig(bSig);
	    if (eSig !== undefined) document.setEsig(eSig);
	    if (ctime !== undefined) document.setCtime(ctime);
	    if (mtime !== undefined) document.setMtime(mtime);
	    if (atime !== undefined) document.setAtime(atime);
	    if (atimes !== undefined) document.setAtimes(atimes);
	    if (tage !== undefined) document.setTage(tage);
	    return document;
	  }

	  function attachDocument(_x3) {
	    return _attachDocument.apply(this, arguments);
	  }

	  function _attachDocument() {
	    _attachDocument = asyncToGenerator$1(
	    /*#__PURE__*/
	    regenerator$1.mark(function _callee2(_ref4) {
	      var eid, name, data, size, _ref7, deat, url, sig;

	      return regenerator$1.wrap(function _callee2$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              eid = _ref4.eid, name = _ref4.documentInfo, data = _ref4.data, size = _ref4.size;
	              _context2.prev = 1;
	              _context2.next = 4;
	              return services.createDocument({
	                eid: eid,
	                name: name,
	                size: size
	              });

	            case 4:
	              _ref7 = _context2.sent;
	              deat = _ref7.data.deat;
	              _context2.next = 11;
	              break;

	            case 8:
	              _context2.prev = 8;
	              _context2.t0 = _context2["catch"](1);
	              throw _context2.t0;

	            case 11:
	              _context2.prev = 11;
	              url = deat.url, sig = deat.sig;
	              _context2.next = 15;
	              return uploadDocumentToS3({
	                url: url,
	                sig: sig,
	                data: data
	              });

	            case 15:
	              return _context2.abrupt("return", new Response$1({
	                code: 0
	              }));

	            case 18:
	              _context2.prev = 18;
	              _context2.t1 = _context2["catch"](11);
	              throw new AitmedError({
	                name: 'ERROR_UPLOADING_TO_AWS_S3'
	              });

	            case 21:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      }, _callee2, null, [[1, 8], [11, 18]]);
	    }));
	    return _attachDocument.apply(this, arguments);
	  }

	  function uploadDocumentToS3(_x4) {
	    return _uploadDocumentToS.apply(this, arguments);
	  }

	  function _uploadDocumentToS() {
	    _uploadDocumentToS = asyncToGenerator$1(
	    /*#__PURE__*/
	    regenerator$1.mark(function _callee3(_ref5) {
	      var url, sig, data;
	      return regenerator$1.wrap(function _callee3$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              url = _ref5.url, sig = _ref5.sig, data = _ref5.data;
	              _context3.prev = 1;
	              _context3.next = 4;
	              return axios$1$1({
	                method: 'put',
	                url: "".concat(url, "?").concat(sig),
	                data: data
	              });

	            case 4:
	              return _context3.abrupt("return", new Response$1({
	                code: 0
	              }));

	            case 7:
	              _context3.prev = 7;
	              _context3.t0 = _context3["catch"](1);
	              throw new AitmedError({
	                name: 'ERROR_UPLOADING_TO_AWS_S3'
	              });

	            case 10:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, _callee3, null, [[1, 7]]);
	    }));
	    return _uploadDocumentToS.apply(this, arguments);
	  }

	  function downloadDocumentFromS3(_x5) {
	    return _downloadDocumentFromS.apply(this, arguments);
	  }

	  function _downloadDocumentFromS() {
	    _downloadDocumentFromS = asyncToGenerator$1(
	    /*#__PURE__*/
	    regenerator$1.mark(function _callee4(_ref6) {
	      var url, _ref8, data;

	      return regenerator$1.wrap(function _callee4$(_context4) {
	        while (1) {
	          switch (_context4.prev = _context4.next) {
	            case 0:
	              url = _ref6.url;
	              _context4.prev = 1;
	              _context4.next = 4;
	              return axios$1$1.get(url);

	            case 4:
	              _ref8 = _context4.sent;
	              data = _ref8.data;
	              return _context4.abrupt("return", new Response$1({
	                code: 0,
	                data: data
	              }));

	            case 9:
	              _context4.prev = 9;
	              _context4.t0 = _context4["catch"](1);
	              throw new AitmedError({
	                name: 'ERROR_DOWNLOADING_FROM_AWS_S3'
	              });

	            case 12:
	            case "end":
	              return _context4.stop();
	          }
	        }
	      }, _callee4, null, [[1, 9]]);
	    }));
	    return _downloadDocumentFromS.apply(this, arguments);
	  }

	  return services;
	}();

	function getJWT(type) {
	  switch (type) {
	    case 1040:
	      {
	        var vcjwt = localStorage.getItem('vcjwt');
	        return vcjwt;
	      }

	    default:
	      var jwt = localStorage.getItem('jwt');
	      return jwt;
	  }
	}

	function setJWT(type, jwt) {
	  if ([1010, 1011].includes(type)) {
	    utils$2.storeCredentialsInLocalStorage({
	      vcjwt: jwt
	    });
	  } else {
	    utils$2.storeCredentialsInLocalStorage({
	      jwt: jwt
	    });
	  }
	}

	function findRoot(_x) {
	  return _findRoot.apply(this, arguments);
	}

	function _findRoot() {
	  _findRoot = asyncToGenerator$1(
	  /*#__PURE__*/
	  regenerator$1.mark(function _callee(id) {
	    var _ref2, edge, refid;

	    return regenerator$1.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            _context.next = 2;
	            return edgesServices.retrieveEdge({
	              idList: [id]
	            });

	          case 2:
	            _ref2 = _context.sent;
	            edge = _ref2.data;
	            refid = edge[0].refid;

	            if (!refid) {
	              _context.next = 7;
	              break;
	            }

	            return _context.abrupt("return", findRoot(refid));

	          case 7:
	            return _context.abrupt("return", edge[0]);

	          case 8:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee);
	  }));
	  return _findRoot.apply(this, arguments);
	}

	function findEdgeWithEsak(_x2) {
	  return _findEdgeWithEsak.apply(this, arguments);
	}

	function _findEdgeWithEsak() {
	  _findEdgeWithEsak = asyncToGenerator$1(
	  /*#__PURE__*/
	  regenerator$1.mark(function _callee2(id) {
	    var _ref3, edge, _edge$, eesak, besak, refid;

	    return regenerator$1.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            _context2.next = 2;
	            return edgesServices.retrieveEdge({
	              idList: [id]
	            });

	          case 2:
	            _ref3 = _context2.sent;
	            edge = _ref3.data;
	            _edge$ = edge[0], eesak = _edge$.eesak, besak = _edge$.besak, refid = _edge$.refid;

	            if (!(eesak || besak)) {
	              _context2.next = 9;
	              break;
	            }

	            return _context2.abrupt("return", edge[0]);

	          case 9:
	            return _context2.abrupt("return", findEdgeWithEsak(refid));

	          case 10:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, _callee2);
	  }));
	  return _findEdgeWithEsak.apply(this, arguments);
	}

	function handleServerError$1(_x3) {
	  return _handleServerError$1.apply(this, arguments);
	}

	function _handleServerError$1() {
	  _handleServerError$1 = asyncToGenerator$1(
	  /*#__PURE__*/
	  regenerator$1.mark(function _callee3(_ref) {
	    var response, fn, args, reject, resolve, serverResponseCode, serverError, translatedCode, errorIsUnknown, errorName, switchResponse;
	    return regenerator$1.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            response = _ref.response, fn = _ref.fn, args = _ref.args, reject = _ref.reject, resolve = _ref.resolve;
	            serverResponseCode = response.getCode();
	            serverError = response.getError();
	            translatedCode = translateErrorCode(serverResponseCode);
	            errorIsUnknown = translatedCode === -1;

	            if (!errorIsUnknown) {
	              _context3.next = 10;
	              break;
	            }

	            reject(new AitmedError({
	              code: serverResponseCode,
	              source: 'lvl-1',
	              message: serverError
	            }));
	            return _context3.abrupt("return");

	          case 10:
	            _context3.prev = 10;
	            errorName = Codes[translatedCode];
	            _context3.next = 14;
	            return errorSwitch({
	              name: errorName,
	              fn: fn,
	              args: args
	            });

	          case 14:
	            switchResponse = _context3.sent;
	            resolve(switchResponse);
	            return _context3.abrupt("return");

	          case 19:
	            _context3.prev = 19;
	            _context3.t0 = _context3["catch"](10);
	            reject(_context3.t0);
	            return _context3.abrupt("return");

	          case 23:
	          case "end":
	            return _context3.stop();
	        }
	      }
	    }, _callee3, null, [[10, 19]]);
	  }));
	  return _handleServerError$1.apply(this, arguments);
	}

	function createEdgeService(_request) {
	  return new Promise(function (resolve, reject) {
	    store$2.grpcClient.ce(_request, null, callback);

	    function callback(_error, _response) {
	      return createEdgeServiceCallBack(_error, _response, resolve, reject);
	    }
	  });
	}

	function createEdgeServiceCallBack(_error, _response, resolve, reject) {
	  var gRPCErrorExists = _error !== null;

	  if (gRPCErrorExists) {
	    reject(new AitmedError({
	      code: _error.code,
	      message: _error.message
	    }));
	  }

	  var serverResponseCode = _response.getCode();

	  var serverErrorExists = serverResponseCode !== 0;

	  if (serverErrorExists) {
	    resolve([serverErrorExists, _response]);
	  }

	  var edge = _response.getEdge();

	  var edgeIsUndefined = edge === undefined;

	  if (edgeIsUndefined) {
	    reject(new AitmedError({
	      name: "EDGE_IS_UNDEFINED"
	    }));
	  }

	  var sdkEdge = toSDKEdge(edge);

	  var newJWT = _response.getJwt();

	  setJWT(sdkEdge.type, newJWT);
	  var response = new Response$1({
	    code: 0,
	    data: sdkEdge
	  });
	  resolve([false, response]);
	}

	function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(source, true).forEach(function (key) { defineProperty$e(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
	/**
	 * 
	 * @param edgeOptions
	 * 
	 * @param edgeOptions.tage  number
	 * @param edgeOptions.id  Uint8Array | string
	 * @param edgeOptions.type  number
	 * @param edgeOptions.name  Record<string, any>
	 * @param edgeOptions.deat  Record<string, any>
	 * @param edgeOptions.subtype  number
	 * @param edgeOptions.bvid  Uint8Array | string
	 * @param edgeOptions.evid  Uint8Array | string
	 * @param edgeOptions.stime  number
	 * @param edgeOptions.etime  number
	 * @param edgeOptions.refid  Uint8Array | string
	 * @param edgeOptions.besak  Uint8Array | string
	 * @param edgeOptions.eesak  Uint8Array | string
	 * @param edgeOptions.sig  Uint8Array | string
	 * @param edgeOptions.isEncrypt  boolean
	 *  
	 */

	function defaultPath(_ref) {
	  var tage = _ref.tage,
	      id = _ref.id,
	      type = _ref.type,
	      name = _ref.name,
	      deat = _ref.deat,
	      subtype = _ref.subtype,
	      bvid = _ref.bvid,
	      evid = _ref.evid,
	      stime = _ref.stime,
	      etime = _ref.etime,
	      refid = _ref.refid,
	      eesak = _ref.eesak,
	      sig = _ref.sig,
	      isEncrypt = _ref.isEncrypt;
	  var apiEdge = new types_pb_1$1();
	  var besak;

	  if (isEncrypt === true) {
	    //event is encrypted
	    try {
	      //TODO refactor uneeded conversion to Uint8Array
	      var pk = localStorage.getItem('pk');
	      var pkToUint8Array;

	      if (pk) {
	        pkToUint8Array = utils$2.base64ToUint8Array(pk);
	      }

	      besak = generateEsak(pk);
	      apiEdge.setSig(pk ? pkToUint8Array : '');
	    } catch (error) {
	      throw new AitmedError({
	        name: "ERROR_CREATING_BESAK"
	      });
	    }
	  } else {
	    if (sig !== undefined) apiEdge.setSig(sig);
	  }

	  if (name) {
	    try {
	      var nameJSONString = JSON.stringify(name);
	      apiEdge.setName(nameJSONString);
	    } catch (error) {
	      throw new AitmedError({
	        name: 'JSON_STRINGIFY_FAILED'
	      });
	    }
	  }

	  if (deat) {
	    try {
	      var deatJSONString = JSON.stringify(deat);
	      apiEdge.setDeat(deatJSONString);
	    } catch (error) {
	      throw new AitmedError({
	        name: 'JSON_STRINGIFY_FAILED'
	      });
	    }
	  }

	  if (bvid !== undefined) apiEdge.setBvid(bvid);
	  if (stime !== undefined) apiEdge.setStime(stime);
	  if (type !== undefined) apiEdge.setType(type);
	  if (tage !== undefined) apiEdge.setTage(tage);
	  if (id !== undefined) apiEdge.setId(id);
	  if (subtype !== undefined) apiEdge.setSubtype(subtype);
	  if (evid !== undefined) apiEdge.setEvid(evid);
	  if (etime !== undefined) apiEdge.setEtime(etime);
	  if (refid !== undefined) apiEdge.setRefid(refid);
	  if (besak !== undefined) apiEdge.setBesak(besak);
	  if (eesak !== undefined) apiEdge.setEesak(eesak);
	  return apiEdge;
	}
	/**
	   * 
	   * @param edgeOptions
	   * @param edgeOptions.name Record<string, any>
	   * @param edgeOptions.type number
	   * @param edgeOptions.refid string //eventId 
	   * @param edgeOptions.evid string //the receiver of this particular edge
	   */


	function createInvite(_x) {
	  return _createInvite.apply(this, arguments);
	}
	/**
	   * 
	   * @param params
	   * @param params.name Record<string, any> 
	   * @param params.type number 
	   * @param params.refid string //inviteId
	   * @param params.evid string //the receiver of this particular edge(i.e. who this acceptance is directed to)
	   */


	function _createInvite() {
	  _createInvite = asyncToGenerator$1(
	  /*#__PURE__*/
	  regenerator$1.mark(function _callee(_ref2) {
	    var name, type, refid, bvid, evid, apiEdge, nameJSONString;
	    return regenerator$1.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            name = _ref2.name, type = _ref2.type, refid = _ref2.refid, bvid = _ref2.bvid, evid = _ref2.evid;
	            apiEdge = new types_pb_1$1();
	            _context.prev = 2;
	            nameJSONString = JSON.stringify(name);
	            apiEdge.setName(nameJSONString);
	            _context.next = 10;
	            break;

	          case 7:
	            _context.prev = 7;
	            _context.t0 = _context["catch"](2);
	            throw new AitmedError({
	              name: 'JSON_STRINGIFY_FAILED'
	            });

	          case 10:
	            apiEdge.setType(type);
	            apiEdge.setBvid(bvid);
	            apiEdge.setRefid(refid);
	            if (typeof evid !== 'undefined') apiEdge.setEvid(evid); // if (stime !== undefined) apiEdge.setStime(stime)
	            // if (etime !== undefined) apiEdge.setEtime(etime)

	            return _context.abrupt("return", apiEdge);

	          case 15:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee, null, [[2, 7]]);
	  }));
	  return _createInvite.apply(this, arguments);
	}

	function acceptInvite(_x2) {
	  return _acceptInvite.apply(this, arguments);
	} // used for one to many communications 
	// ex shared notebooks
	// where multiple users are able to access the same edge


	function _acceptInvite() {
	  _acceptInvite = asyncToGenerator$1(
	  /*#__PURE__*/
	  regenerator$1.mark(function _callee2(_ref3) {
	    var name, type, refid, evid, bvid, apiEdge, nameJSONString, evidPk;
	    return regenerator$1.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            name = _ref3.name, type = _ref3.type, refid = _ref3.refid, evid = _ref3.evid, bvid = _ref3.bvid;
	            apiEdge = new types_pb_1$1();
	            _context2.prev = 2;
	            nameJSONString = JSON.stringify(name);
	            apiEdge.setName(nameJSONString);
	            _context2.next = 10;
	            break;

	          case 7:
	            _context2.prev = 7;
	            _context2.t0 = _context2["catch"](2);
	            throw new AitmedError({
	              name: 'JSON_STRINGIFY_FAILED'
	            });

	          case 10:
	            evidPk = localStorage.getItem('pk');
	            apiEdge.setSig(evidPk === null ? '' : evidPk);
	            apiEdge.setType(type);
	            apiEdge.setRefid(refid);
	            apiEdge.setEvid(evid);
	            apiEdge.setBvid(bvid);
	            return _context2.abrupt("return", apiEdge);

	          case 17:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, _callee2, null, [[2, 7]]);
	  }));
	  return _acceptInvite.apply(this, arguments);
	}

	function authorizeEvent_Dependent(_x3) {
	  return _authorizeEvent_Dependent.apply(this, arguments);
	} //ex. authorize inbox
	// used for one to one communication
	// only one bvid and evid are able to modify and access the docs on edge


	function _authorizeEvent_Dependent() {
	  _authorizeEvent_Dependent = asyncToGenerator$1(
	  /*#__PURE__*/
	  regenerator$1.mark(function _callee3(_ref4) {
	    var bvid, evid, refid, name, sharedEvent, _ref6, besak, rootName, type, eid, apiEdge, eesak, esak, edgeWithEsak, _ref7, acceptEdge, evidPk, evidPkUint8Array, publicKey, secretKey, partialKey, pkToUint8Array, skToUint8Array, mergedName, nameJSONString;

	    return regenerator$1.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            bvid = _ref4.bvid, evid = _ref4.evid, refid = _ref4.refid, name = _ref4.name;
	            _context3.prev = 1;
	            _context3.next = 4;
	            return findRoot(refid);

	          case 4:
	            _ref6 = _context3.sent;
	            besak = _ref6.besak;
	            rootName = _ref6.rootName;
	            type = _ref6.type;
	            eid = _ref6.eid;
	            sharedEvent = {
	              besak: besak,
	              rootName: rootName,
	              type: type,
	              eid: eid
	            };
	            _context3.next = 15;
	            break;

	          case 12:
	            _context3.prev = 12;
	            _context3.t0 = _context3["catch"](1);
	            throw _context3.t0;

	          case 15:
	            apiEdge = new types_pb_1$1(); //check if event is encrypted 
	            //if so attach a eesak to this edge

	            if (!sharedEvent.besak) {
	              _context3.next = 31;
	              break;
	            }

	            _context3.next = 19;
	            return findEdgeWithEsak(refid);

	          case 19:
	            edgeWithEsak = _context3.sent;
	            _context3.next = 22;
	            return edgesServices.retrieveEdge({
	              idList: [refid]
	            });

	          case 22:
	            _ref7 = _context3.sent;
	            acceptEdge = _ref7.data;
	            evidPk = acceptEdge[0].sig;
	            evidPkUint8Array = evidPk;

	            if (typeof evidPk === 'string') {
	              evidPkUint8Array = utils$2.base64ToUint8Array(evidPk);
	            }

	            if (edgeWithEsak.besak) {
	              esak = edgeWithEsak.besak; //user authorizing shared edge is user who created the orignal notebook

	              publicKey = localStorage.getItem('pk');
	              secretKey = localStorage.getItem('sk');
	            } else {
	              esak = edgeWithEsak.eesak; //user authorizing shared edge is not the user who created the original notebook

	              publicKey = utils$2.uint8ArrayToBase64(edgeWithEsak.sig);
	              secretKey = localStorage.getItem('sk');
	            } //get the sak


	            if (publicKey && secretKey) {
	              pkToUint8Array = utils$2.base64ToUint8Array(publicKey);
	              skToUint8Array = utils$2.base64ToUint8Array(secretKey);
	              partialKey = utils$2.aKeyDecrypt(pkToUint8Array, skToUint8Array, esak);
	            } //encrypt sak with receiverPk and senderSk


	            if (partialKey) {
	              eesak = utils$2.aKeyEncrypt(evidPkUint8Array, skToUint8Array, partialKey);
	            } //attach sender public key so receiver can decrypt eesak


	            apiEdge.setSig(publicKey === null ? '' : publicKey);

	          case 31:
	            _context3.prev = 31;
	            mergedName = _objectSpread$2({}, sharedEvent.rootName, {}, name);
	            nameJSONString = JSON.stringify(mergedName);
	            apiEdge.setName(nameJSONString);
	            _context3.next = 40;
	            break;

	          case 37:
	            _context3.prev = 37;
	            _context3.t1 = _context3["catch"](31);
	            throw new AitmedError({
	              name: 'JSON_STRINGIFY_FAILED'
	            });

	          case 40:
	            if (eesak !== undefined) apiEdge.setEesak(eesak);
	            apiEdge.setType(sharedEvent.type);
	            apiEdge.setRefid(sharedEvent.eid);
	            apiEdge.setEvid(evid);
	            apiEdge.setBvid(bvid);
	            return _context3.abrupt("return", apiEdge);

	          case 46:
	          case "end":
	            return _context3.stop();
	        }
	      }
	    }, _callee3, null, [[1, 12], [31, 37]]);
	  }));
	  return _authorizeEvent_Dependent.apply(this, arguments);
	}

	function authorizeEvent_Independent(_x4) {
	  return _authorizeEvent_Independent.apply(this, arguments);
	}

	function _authorizeEvent_Independent() {
	  _authorizeEvent_Independent = asyncToGenerator$1(
	  /*#__PURE__*/
	  regenerator$1.mark(function _callee4(_ref5) {
	    var evid, bvid, refid, name, _ref5$isEncrypt, isEncrypt, sharedEvent, _ref8, _besak, rootName, type, eid, apiEdge, eesak, besak, _ref9, acceptEdge, evidPk, evidPkUint8Array, bvidPk, bvidSK, partialKey, pkToUint8Array, skToUint8Array, mergedName, nameJSONString;

	    return regenerator$1.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            evid = _ref5.evid, bvid = _ref5.bvid, refid = _ref5.refid, name = _ref5.name, _ref5$isEncrypt = _ref5.isEncrypt, isEncrypt = _ref5$isEncrypt === void 0 ? false : _ref5$isEncrypt;
	            _context4.prev = 1;
	            _context4.next = 4;
	            return findRoot(refid);

	          case 4:
	            _ref8 = _context4.sent;
	            _besak = _ref8.besak;
	            rootName = _ref8.name;
	            type = _ref8.type;
	            eid = _ref8.eid;
	            sharedEvent = {
	              besak: _besak,
	              rootName: rootName,
	              type: type,
	              eid: eid
	            };
	            _context4.next = 15;
	            break;

	          case 12:
	            _context4.prev = 12;
	            _context4.t0 = _context4["catch"](1);
	            throw _context4.t0;

	          case 15:
	            apiEdge = new types_pb_1$1(); //check if event is encrypted 
	            //if so attach a eesak to this edge

	            if (!isEncrypt) {
	              _context4.next = 36;
	              break;
	            }

	            _context4.next = 19;
	            return edgesServices.retrieveEdge({
	              idList: [refid]
	            });

	          case 19:
	            _ref9 = _context4.sent;
	            acceptEdge = _ref9.data;
	            evidPk = acceptEdge[0].sig;
	            evidPkUint8Array = evidPk;

	            if (typeof evidPk === 'string') {
	              evidPkUint8Array = utils$2.base64ToUint8Array(evidPk);
	            } //get the pk and sk of bvid


	            bvidPk = localStorage.getItem('pk');
	            bvidSK = localStorage.getItem('sk');
	            _context4.prev = 26;
	            besak = generateEsak(bvidPk);
	            _context4.next = 33;
	            break;

	          case 30:
	            _context4.prev = 30;
	            _context4.t1 = _context4["catch"](26);
	            throw new AitmedError({
	              name: "ERROR_CREATING_BESAK"
	            });

	          case 33:
	            if (bvidPk && bvidSK) {
	              pkToUint8Array = utils$2.base64ToUint8Array(bvidPk);
	              skToUint8Array = utils$2.base64ToUint8Array(bvidSK);
	              partialKey = utils$2.aKeyDecrypt(pkToUint8Array, skToUint8Array, besak);
	            } //encrypt sak with receiverPk and senderSk


	            if (partialKey) {
	              eesak = utils$2.aKeyEncrypt(evidPkUint8Array, skToUint8Array, partialKey);
	            } //attach sender public key so receiver can decrypt eesak


	            apiEdge.setSig(bvidPk === null ? '' : bvidPk);

	          case 36:
	            _context4.prev = 36;
	            mergedName = _objectSpread$2({}, sharedEvent.rootName, {}, name);
	            nameJSONString = JSON.stringify(mergedName);
	            apiEdge.setName(nameJSONString);
	            _context4.next = 45;
	            break;

	          case 42:
	            _context4.prev = 42;
	            _context4.t2 = _context4["catch"](36);
	            throw new AitmedError({
	              name: 'JSON_STRINGIFY_FAILED'
	            });

	          case 45:
	            if (besak !== undefined) apiEdge.setBesak(besak);
	            if (eesak !== undefined) apiEdge.setEesak(eesak);
	            apiEdge.setType(sharedEvent.type);
	            apiEdge.setRefid(sharedEvent.eid);
	            apiEdge.setEvid(evid);
	            apiEdge.setBvid(bvid);
	            return _context4.abrupt("return", apiEdge);

	          case 52:
	          case "end":
	            return _context4.stop();
	        }
	      }
	    }, _callee4, null, [[1, 12], [26, 30], [36, 42]]);
	  }));
	  return _authorizeEvent_Independent.apply(this, arguments);
	}

	var buildRequest = function buildRequest(edgeOptions) {
	  switch (edgeOptions.type) {
	    case 1050:
	      return createInvite(edgeOptions);

	    case 1060:
	      return acceptInvite(edgeOptions);

	    case 1070:
	      //this type(1070) serves as a placeholder
	      //and will be replaced by the type of the original event
	      return authorizeEvent_Dependent(edgeOptions);

	    case 1071:
	      //this type(1071) serves as a placeholder
	      //and will be replaced by the type of the original event
	      return authorizeEvent_Independent(edgeOptions);

	    default:
	      return defaultPath(edgeOptions);
	  }
	};

	function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(source, true).forEach(function (key) { defineProperty$e(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	var edgesServices = function () {
	  var services = {
	    createEdge: function createEdge(args) {
	      return edgeRequest(_objectSpread$3({}, args));
	    },
	    updateEdge: function updateEdge(args) {
	      return edgeRequest(_objectSpread$3({}, args));
	    },
	    retrieveEdge: retrieveRequest(2),
	    deleteEdge: deleteRequest
	  };
	  /**
	    *
	    * @param {EdgeRequestArgs} args
	    * @param {string | Uint8Array} args.id if id is undefined, create edge, otherwise, update edge.
	    * 
	    */

	  function edgeRequest(_ref) {
	    var edgeOptions = _extends_1({}, _ref);

	    return new Promise(
	    /*#__PURE__*/
	    function () {
	      var _ref2 = asyncToGenerator$1(
	      /*#__PURE__*/
	      regenerator$1.mark(function _callee(resolve, reject) {
	        var noGRPCClientIsDetected, _request, requestEdge, jwt, _ref3, _ref4, _error, _response;

	        return regenerator$1.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                noGRPCClientIsDetected = !store$2.grpcClient;

	                if (!noGRPCClientIsDetected) {
	                  _context.next = 4;
	                  break;
	                }

	                reject(new AitmedError({
	                  name: 'INVALID_API_VERSION'
	                }));
	                return _context.abrupt("return");

	              case 4:
	                _request = new ecos_api_pb_3$1();
	                _context.next = 7;
	                return buildRequest(_objectSpread$3({}, edgeOptions));

	              case 7:
	                requestEdge = _context.sent;

	                _request.setEdge(requestEdge);

	                jwt = getJWT(edgeOptions.type);

	                _request.setJwt(jwt === null ? '' : jwt);

	                _context.next = 13;
	                return createEdgeService(_request);

	              case 13:
	                _ref3 = _context.sent;
	                _ref4 = slicedToArray$1(_ref3, 2);
	                _error = _ref4[0];
	                _response = _ref4[1];

	                if (!_error) {
	                  _context.next = 22;
	                  break;
	                }

	                _context.next = 20;
	                return handleServerError$1({
	                  response: _response,
	                  fn: edgeRequest,
	                  args: edgeOptions,
	                  reject: reject,
	                  resolve: resolve
	                });

	              case 20:
	                _context.next = 23;
	                break;

	              case 22:
	                if (!_error && _response instanceof Response$1) {
	                  resolve(_response);
	                }

	              case 23:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee);
	      }));

	      return function (_x, _x2) {
	        return _ref2.apply(this, arguments);
	      };
	    }());
	  }

	  return services;
	}();

	function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(source, true).forEach(function (key) { defineProperty$e(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	var vertexServices = function () {
	  var services = {
	    createVertex: function createVertex(args) {
	      return vertexRequest(_objectSpread$4({}, args));
	    },
	    updateVertex: function updateVertex(args) {
	      return vertexRequest(_objectSpread$4({}, args));
	    },
	    retrieveVertex: retrieveRequest(0),
	    deleteVertex: deleteRequest
	  };
	  /**
	   *
	   * @param {VertexRequestArgs} args
	   * @param {string | Uint8Array} args.id if id is undefined, create vector, otherwise, update vector.
	   */

	  function vertexRequest(_ref) {
	    var vertexOptions = _extends_1({}, _ref);

	    return new Promise(function (resolve, reject) {
	      if (!store$2.grpcClient) {
	        reject(new AitmedError({
	          name: 'INVALID_API_VERSION'
	        }));
	        return;
	      }

	      var apiVertex = generateGRPCVertex(_objectSpread$4({}, vertexOptions));
	      var request = new ecos_api_pb_5$1();

	      if (vertexOptions.type && [1, -1].includes(vertexOptions.type)) {
	        var vcjwt = localStorage.getItem('vcjwt');
	        request.setJwt(vcjwt === null ? '' : vcjwt);
	      } else {
	        var jwt = localStorage.getItem('jwt');
	        request.setJwt(jwt === null ? '' : jwt);
	      }

	      request.setVertex(apiVertex);
	      store$2.grpcClient.cv(request, null,
	      /*#__PURE__*/
	      function () {
	        var _ref2 = asyncToGenerator$1(
	        /*#__PURE__*/
	        regenerator$1.mark(function _callee(_error, _response) {
	          var error, vertex, _error2, responseCode, translatedCode, switchResponse, newJWT, sdkVertex, response;

	          return regenerator$1.wrap(function _callee$(_context) {
	            while (1) {
	              switch (_context.prev = _context.next) {
	                case 0:
	                  if (!_error) {
	                    _context.next = 4;
	                    break;
	                  }

	                  error = new AitmedError({
	                    code: _error.code,
	                    message: _error.message
	                  });
	                  reject(error);
	                  return _context.abrupt("return");

	                case 4:
	                  vertex = _response.getVertex();

	                  if (!(vertex === undefined)) {
	                    _context.next = 9;
	                    break;
	                  }

	                  _error2 = new AitmedError({
	                    name: 'VERTEX_IS_UNDEFINED'
	                  });
	                  reject(_error2);
	                  return _context.abrupt("return");

	                case 9:
	                  responseCode = _response.getCode();

	                  if (!(responseCode !== 0)) {
	                    _context.next = 27;
	                    break;
	                  }

	                  translatedCode = translateErrorCode(responseCode);

	                  if (!(translatedCode === -1)) {
	                    _context.next = 15;
	                    break;
	                  }

	                  reject(new AitmedError({
	                    code: responseCode,
	                    source: 'lvl-1',
	                    message: _response.getError()
	                  }));
	                  return _context.abrupt("return");

	                case 15:
	                  _context.prev = 15;
	                  _context.next = 18;
	                  return errorSwitch({
	                    code: translatedCode,
	                    fn: vertexRequest,
	                    args: vertexOptions
	                  });

	                case 18:
	                  switchResponse = _context.sent;
	                  resolve(switchResponse);
	                  return _context.abrupt("return");

	                case 23:
	                  _context.prev = 23;
	                  _context.t0 = _context["catch"](15);
	                  reject(_context.t0);
	                  return _context.abrupt("return");

	                case 27:
	                  newJWT = _response.getJwt();
	                  utils$2.storeCredentialsInLocalStorage({
	                    jwt: newJWT
	                  });
	                  sdkVertex = toSDKVertex(vertex);
	                  response = new Response$1({
	                    code: responseCode,
	                    data: sdkVertex
	                  });
	                  resolve(response);
	                  return _context.abrupt("return");

	                case 33:
	                case "end":
	                  return _context.stop();
	              }
	            }
	          }, _callee, null, [[15, 23]]);
	        }));

	        return function (_x, _x2) {
	          return _ref2.apply(this, arguments);
	        };
	      }());
	    });
	  }

	  function generateGRPCVertex(_ref3) {
	    var tage = _ref3.tage,
	        id = _ref3.id,
	        type = _ref3.type,
	        name = _ref3.name,
	        deat = _ref3.deat,
	        pk = _ref3.pk,
	        esk = _ref3.esk,
	        uid = _ref3.uid;
	    var apiVertex = new types_pb_2$1();

	    if (name) {
	      try {
	        var nameJSONString = JSON.stringify(name);
	        apiVertex.setName(nameJSONString);
	      } catch (error) {
	        throw new AitmedError({
	          name: 'JSON_STRINGIFY_FAILED'
	        });
	      }
	    }

	    if (deat) {
	      try {
	        var deatJSONString = JSON.stringify(deat);
	        apiVertex.setDeat(deatJSONString);
	      } catch (error) {
	        throw new AitmedError({
	          name: 'JSON_STRINGIFY_FAILED'
	        });
	      }
	    }

	    if (tage !== undefined) apiVertex.setTage(tage);
	    if (id !== undefined) apiVertex.setId(id);
	    if (type !== undefined) apiVertex.setType(type);
	    if (pk !== undefined) apiVertex.setPk(pk);
	    if (esk !== undefined) apiVertex.setEsk(esk);
	    if (uid !== undefined) apiVertex.setUid(uid);
	    return apiVertex;
	  }

	  return services;
	}();

	var StatusCodes;

	(function (StatusCodes) {
	  StatusCodes[StatusCodes["LOGGED_IN"] = 0] = "LOGGED_IN";
	  StatusCodes[StatusCodes["LOGGED_OUT"] = 1] = "LOGGED_OUT";
	  StatusCodes[StatusCodes["NEW_DEVICE"] = 2] = "NEW_DEVICE";
	})(StatusCodes || (StatusCodes = {}));

	var defaultMessages$1 = {
	  LOGGED_IN: 'User is already in a logged in state.',
	  LOGGED_OUT: "User needs to verify their password to be logged in.",
	  NEW_DEVICE: "There are no user credentials stored. User must be authenticated."
	};

	var Status = function Status(_ref) {
	  var code = _ref.code,
	      message = _ref.message;

	  classCallCheck$1(this, Status);

	  defineProperty$e(this, "code", void 0);

	  defineProperty$e(this, "name", void 0);

	  defineProperty$e(this, "message", void 0);

	  defineProperty$e(this, "config", void 0);

	  var name = StatusCodes[code];

	  if (name === undefined) {
	    this.code = -1;
	    this.name = 'UNKNOWN_STATUS';
	  } else {
	    this.code = code;
	    this.name = name;
	  }

	  this.message = message === undefined ? defaultMessages$1[name] : message;
	  this.config = store$2.getConfig();
	};

	var EtypeCode;

	(function (EtypeCode) {
	  EtypeCode[EtypeCode["generalEvent"] = 1000] = "generalEvent";
	  EtypeCode[EtypeCode["sendVerificationCode"] = 1010] = "sendVerificationCode";
	  EtypeCode[EtypeCode["createUser"] = 1020] = "createUser";
	  EtypeCode[EtypeCode["loginUser"] = 1030] = "loginUser";
	  EtypeCode[EtypeCode["loginNewDevice"] = 1040] = "loginNewDevice";
	  EtypeCode[EtypeCode["resetUserPassword"] = 1050] = "resetUserPassword";
	  EtypeCode[EtypeCode["retrieveUser"] = 1060] = "retrieveUser";
	  EtypeCode[EtypeCode["updateUser"] = 1070] = "updateUser";
	  EtypeCode[EtypeCode["deactivateUser"] = 1080] = "deactivateUser";
	})(EtypeCode || (EtypeCode = {}));

	var etypes = EtypeCode;

	var updatePassword =
	/*#__PURE__*/
	function () {
	  var _ref2 = asyncToGenerator$1(
	  /*#__PURE__*/
	  regenerator$1.mark(function _callee(_ref) {
	    var password, userId, pk, sk, vidUint8Array, pkUint8Array, skUint8Array, newESK;
	    return regenerator$1.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            password = _ref.password, userId = _ref.userId, pk = _ref.pk, sk = _ref.sk;
	            _context.prev = 1;
	            vidUint8Array = typeof userId === 'string' ? utils$2.base64ToUint8Array(userId) : userId;
	            pkUint8Array = typeof pk === 'string' ? utils$2.base64ToUint8Array(pk) : pk;
	            skUint8Array = typeof sk === 'string' ? utils$2.base64ToUint8Array(sk) : sk;
	            newESK = utils$2.encryptSecretKeyWithPassword({
	              secretKey: skUint8Array,
	              password: password
	            });
	            _context.next = 8;
	            return vertexServices.updateVertex({
	              id: vidUint8Array,
	              esk: newESK,
	              pk: pkUint8Array
	            });

	          case 8:
	            utils$2.storeCredentialsInLocalStorage({
	              encryptedSecretKey: newESK
	            });
	            return _context.abrupt("return", new Response$1({
	              code: 0
	            }));

	          case 12:
	            _context.prev = 12;
	            _context.t0 = _context["catch"](1);
	            throw _context.t0;

	          case 15:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee, null, [[1, 12]]);
	  }));

	  return function updatePassword(_x) {
	    return _ref2.apply(this, arguments);
	  };
	}();

	var Account =
	/*#__PURE__*/
	function () {
	  function Account() {
	    classCallCheck$1(this, Account);
	  }

	  createClass$1(Account, [{
	    key: "requestVerificationCode",

	    /**
	     *
	     * @param {RequestVerificationCodeArgs} args
	     *
	     * requests a verification code needed for the user to
	     * complete loging in from new device or registering for the first time
	     */
	    value: function () {
	      var _requestVerificationCode = asyncToGenerator$1(
	      /*#__PURE__*/
	      regenerator$1.mark(function _callee(_ref) {
	        var phone_number, name, _ref2, deat;

	        return regenerator$1.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                phone_number = _ref.phone_number;

	                if (!(store$2.getConfig() === null)) {
	                  _context.next = 4;
	                  break;
	                }

	                _context.next = 4;
	                return store$2.loadConfig();

	              case 4:
	                name = {
	                  phone_number: phone_number
	                };
	                _context.prev = 5;
	                _context.next = 8;
	                return edgesServices.createEdge({
	                  type: etypes.sendVerificationCode,
	                  name: name
	                });

	              case 8:
	                _ref2 = _context.sent;
	                deat = _ref2.data.deat;
	                return _context.abrupt("return", new Response$1({
	                  code: 0,
	                  data: {
	                    verification_code: deat.verification_code
	                  }
	                }));

	              case 13:
	                _context.prev = 13;
	                _context.t0 = _context["catch"](5);
	                throw _context.t0;

	              case 16:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, null, [[5, 13]]);
	      }));

	      function requestVerificationCode(_x) {
	        return _requestVerificationCode.apply(this, arguments);
	      }

	      return requestVerificationCode;
	    }()
	    /**
	     *
	     * @param {CreateUserArgs} args
	     *
	     * used to register user and store the user credentials such jwt, publicKey, secretKey in
	     * localStorage
	     */

	  }, {
	    key: "createUser",
	    value: function () {
	      var _createUser = asyncToGenerator$1(
	      /*#__PURE__*/
	      regenerator$1.mark(function _callee2(_ref3) {
	        var password, phone_number, verification_code, name, _ref3$type, type, _utils$generateAKey, publicKey, secretKey, encryptedSecretKey, _ref4, code, deat;

	        return regenerator$1.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                password = _ref3.password, phone_number = _ref3.phone_number, verification_code = _ref3.verification_code, name = _ref3.userInfo, _ref3$type = _ref3.type, type = _ref3$type === void 0 ? 1 : _ref3$type;

	                if (!(store$2.getConfig() === null)) {
	                  _context2.next = 4;
	                  break;
	                }

	                _context2.next = 4;
	                return store$2.loadConfig();

	              case 4:
	                //generate assymetric keyPair
	                _utils$generateAKey = utils$2.generateAKey(), publicKey = _utils$generateAKey.publicKey, secretKey = _utils$generateAKey.secretKey; //symmetrically encrypt secretKey with password

	                encryptedSecretKey = utils$2.encryptSecretKeyWithPassword({
	                  password: password,
	                  secretKey: secretKey
	                });
	                _context2.prev = 6;
	                _context2.next = 9;
	                return vertexServices.createVertex({
	                  uid: phone_number,
	                  name: name,
	                  pk: publicKey,
	                  type: type,
	                  tage: verification_code,
	                  esk: encryptedSecretKey
	                });

	              case 9:
	                _ref4 = _context2.sent;
	                code = _ref4.code;
	                deat = _ref4.data;
	                //store credentials in local storage
	                utils$2.storeCredentialsInLocalStorage({
	                  publicKey: publicKey,
	                  secretKey: secretKey,
	                  encryptedSecretKey: encryptedSecretKey,
	                  user_vid: deat.id,
	                  uid: phone_number
	                });
	                return _context2.abrupt("return", new Response$1({
	                  code: code,
	                  data: deat
	                }));

	              case 16:
	                _context2.prev = 16;
	                _context2.t0 = _context2["catch"](6);
	                throw _context2.t0;

	              case 19:
	              case "end":
	                return _context2.stop();
	            }
	          }
	        }, _callee2, null, [[6, 16]]);
	      }));

	      function createUser(_x2) {
	        return _createUser.apply(this, arguments);
	      }

	      return createUser;
	    }()
	    /**
	     *
	     * @param {LoginArgs} args
	     *
	     * the user's credentials found in the locaStorage are used to authenticate the user
	     * this sends back a JWT token
	     *
	     */

	  }, {
	    key: "login",
	    value: function () {
	      var _login = asyncToGenerator$1(
	      /*#__PURE__*/
	      regenerator$1.mark(function _callee3() {
	        var _ref5,
	            password,
	            user_id,
	            userIdToUint8Array,
	            sk,
	            _this$verifyUserPassw,
	            _this$verifyUserPassw2,
	            isPasswordValid,
	            secretKey,
	            _ref6,
	            code,
	            _args3 = arguments;

	        return regenerator$1.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                _ref5 = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {}, password = _ref5.password;

	                if (!(store$2.getConfig() === null)) {
	                  _context3.next = 4;
	                  break;
	                }

	                _context3.next = 4;
	                return store$2.loadConfig();

	              case 4:
	                user_id = localStorage.getItem('user_vid');

	                if (!(user_id === null)) {
	                  _context3.next = 7;
	                  break;
	                }

	                throw new AitmedError({
	                  name: 'REQUIRED_PHONE_NUMBER_AND_VERIFICATION_CODE'
	                });

	              case 7:
	                userIdToUint8Array = utils$2.base64ToUint8Array(user_id); //TODO eventually a signature parameter will be sent along
	                //with the loginUser createEdge request to verify that the sk is valid
	                //Check for invalid password or user is not registered

	                sk = localStorage.getItem('sk');

	                if (!(password !== undefined && sk === null)) {
	                  _context3.next = 22;
	                  break;
	                }

	                _context3.prev = 10;
	                _this$verifyUserPassw = this.verifyUserPassword({
	                  password: password
	                }), _this$verifyUserPassw2 = slicedToArray$1(_this$verifyUserPassw, 2), isPasswordValid = _this$verifyUserPassw2[0], secretKey = _this$verifyUserPassw2[1];

	                if (!(isPasswordValid === false)) {
	                  _context3.next = 16;
	                  break;
	                }

	                throw new AitmedError({
	                  name: 'PASSWORD_INVALID'
	                });

	              case 16:
	                if (isPasswordValid && secretKey !== null) {
	                  utils$2.storeCredentialsInLocalStorage({
	                    secretKey: secretKey
	                  });
	                }

	              case 17:
	                _context3.next = 22;
	                break;

	              case 19:
	                _context3.prev = 19;
	                _context3.t0 = _context3["catch"](10);
	                throw _context3.t0;

	              case 22:
	                _context3.prev = 22;
	                _context3.next = 25;
	                return edgesServices.createEdge({
	                  type: etypes.loginUser,
	                  bvid: userIdToUint8Array,
	                  stime: Date.now()
	                });

	              case 25:
	                _ref6 = _context3.sent;
	                code = _ref6.code;
	                return _context3.abrupt("return", new Response$1({
	                  code: code
	                }));

	              case 30:
	                _context3.prev = 30;
	                _context3.t1 = _context3["catch"](22);
	                throw _context3.t1;

	              case 33:
	              case "end":
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this, [[10, 19], [22, 30]]);
	      }));

	      function login() {
	        return _login.apply(this, arguments);
	      }

	      return login;
	    }()
	    /**
	     *
	     * @param {LoginNewDeviceArgs} args
	     *
	     * the user's credentials were not found in localStorage so a phone_number and verification_code are required
	     */

	  }, {
	    key: "loginNewDevice",
	    value: function () {
	      var _loginNewDevice = asyncToGenerator$1(
	      /*#__PURE__*/
	      regenerator$1.mark(function _callee4(_ref7) {
	        var phone_number, verification_code, name, _response, _response2, data, deat;

	        return regenerator$1.wrap(function _callee4$(_context4) {
	          while (1) {
	            switch (_context4.prev = _context4.next) {
	              case 0:
	                phone_number = _ref7.phone_number, verification_code = _ref7.verification_code;

	                if (!(store$2.getConfig() === null)) {
	                  _context4.next = 4;
	                  break;
	                }

	                _context4.next = 4;
	                return store$2.loadConfig();

	              case 4:
	                name = {
	                  phone_number: phone_number,
	                  verification_code: verification_code
	                };
	                _context4.prev = 5;
	                _context4.next = 8;
	                return edgesServices.createEdge({
	                  type: etypes.loginNewDevice,
	                  name: name
	                });

	              case 8:
	                _response = _context4.sent;
	                _context4.next = 14;
	                break;

	              case 11:
	                _context4.prev = 11;
	                _context4.t0 = _context4["catch"](5);
	                throw _context4.t0;

	              case 14:
	                _response2 = _response, data = _response2.data;
	                deat = data.deat;

	                if (!(deat.pk && deat.esk)) {
	                  _context4.next = 21;
	                  break;
	                }

	                //we know the user is registered since they have a publicKey and secretKey pair
	                utils$2.storeCredentialsInLocalStorage({
	                  encryptedSecretKey: deat.esk,
	                  publicKey: deat.pk,
	                  user_vid: deat.user_id,
	                  uid: phone_number
	                });
	                return _context4.abrupt("return", new Response$1({
	                  code: 0,
	                  data: data
	                }));

	              case 21:
	                throw new AitmedError({
	                  name: 'UNREGISTERED'
	                });

	              case 22:
	              case "end":
	                return _context4.stop();
	            }
	          }
	        }, _callee4, null, [[5, 11]]);
	      }));

	      function loginNewDevice(_x3) {
	        return _loginNewDevice.apply(this, arguments);
	      }

	      return loginNewDevice;
	    }()
	    /**
	     * logs user out by removing the sk from localStorage and leaving the esk
	     */

	  }, {
	    key: "logout",
	    value: function logout() {
	      var sk = localStorage.getItem('sk');

	      if (sk !== null) {
	        localStorage.removeItem('sk');
	        return new Response$1({
	          code: 0,
	          message: 'Successfully logged out'
	        });
	      }

	      return new Response$1({
	        code: 0,
	        message: 'Already logged out.'
	      });
	    }
	    /**
	     * clears the user's credentials from local storage. User must sign in
	     * using the loginNewDevice method
	     */

	  }, {
	    key: "logoutClean",
	    value: function logoutClean() {
	      try {
	        utils$2.removeCredentialsFromLocalStorage();
	        store$2.cleanConfig();
	      } catch (error) {
	        throw new AitmedError({
	          name: 'ERROR_CLEARING_CREDENTIALS'
	        });
	      }

	      return new Response$1({
	        code: 0,
	        message: 'Local credentials were cleared. User logged out.'
	      });
	    }
	    /**
	     * retrieves the users login status
	     */

	  }, {
	    key: "getStatus",
	    value: function () {
	      var _getStatus = asyncToGenerator$1(
	      /*#__PURE__*/
	      regenerator$1.mark(function _callee5() {
	        var sk, esk, code;
	        return regenerator$1.wrap(function _callee5$(_context5) {
	          while (1) {
	            switch (_context5.prev = _context5.next) {
	              case 0:
	                if (!(store$2.getConfig() === null)) {
	                  _context5.next = 3;
	                  break;
	                }

	                _context5.next = 3;
	                return store$2.loadConfig();

	              case 3:
	                sk = localStorage.getItem('sk');
	                esk = localStorage.getItem('esk');
	                code = sk !== null ? 0 : esk !== null ? 1 : 2;
	                return _context5.abrupt("return", new Status({
	                  code: code
	                }));

	              case 7:
	              case "end":
	                return _context5.stop();
	            }
	          }
	        }, _callee5);
	      }));

	      function getStatus() {
	        return _getStatus.apply(this, arguments);
	      }

	      return getStatus;
	    }()
	    /**
	     *
	     * @param {ChangePasswordWithOldPasswordArgs} args
	     *
	     * change the users password by providing the old and new password.
	     * User must be in loggedIn(status 0) or loggedOut(status 1) to be able to
	     * use this method.
	     */

	  }, {
	    key: "changePasswordWithOldPassword",
	    value: function () {
	      var _changePasswordWithOldPassword = asyncToGenerator$1(
	      /*#__PURE__*/
	      regenerator$1.mark(function _callee6(_ref8) {
	        var oldPassword, newPassword, _ref9, statusCode, pk, userIdBase64, isOldPasswordValid, sk, _this$verifyUserPassw3, _this$verifyUserPassw4, response;

	        return regenerator$1.wrap(function _callee6$(_context6) {
	          while (1) {
	            switch (_context6.prev = _context6.next) {
	              case 0:
	                oldPassword = _ref8.oldPassword, newPassword = _ref8.newPassword;
	                _context6.next = 3;
	                return this.getStatus();

	              case 3:
	                _ref9 = _context6.sent;
	                statusCode = _ref9.code;

	                if (!(statusCode === 2)) {
	                  _context6.next = 7;
	                  break;
	                }

	                throw new AitmedError({
	                  name: 'REQUIRED_PHONE_NUMBER_AND_VERIFICATION_CODE',
	                  message: 'Local credentials were not found. Please login.'
	                });

	              case 7:
	                pk = localStorage.getItem('pk');
	                userIdBase64 = localStorage.getItem('user_vid');

	                if (!(userIdBase64 === null || pk === null)) {
	                  _context6.next = 11;
	                  break;
	                }

	                throw new AitmedError({
	                  name: 'REQUIRED_PHONE_NUMBER_AND_VERIFICATION_CODE',
	                  message: 'User id or pk were not found in localStorage. Login as new device is required.'
	                });

	              case 11:
	                _context6.prev = 11;
	                _this$verifyUserPassw3 = this.verifyUserPassword({
	                  password: oldPassword
	                });
	                _this$verifyUserPassw4 = slicedToArray$1(_this$verifyUserPassw3, 2);
	                isOldPasswordValid = _this$verifyUserPassw4[0];
	                sk = _this$verifyUserPassw4[1];

	                if (isOldPasswordValid) {
	                  _context6.next = 19;
	                  break;
	                }

	                throw new AitmedError({
	                  name: 'PASSWORD_INVALID'
	                });

	              case 19:
	                _context6.next = 24;
	                break;

	              case 21:
	                _context6.prev = 21;
	                _context6.t0 = _context6["catch"](11);
	                throw _context6.t0;

	              case 24:
	                _context6.next = 26;
	                return updatePassword({
	                  password: newPassword,
	                  userId: userIdBase64,
	                  pk: pk,
	                  sk: sk
	                });

	              case 26:
	                response = _context6.sent;
	                return _context6.abrupt("return", response);

	              case 28:
	              case "end":
	                return _context6.stop();
	            }
	          }
	        }, _callee6, this, [[11, 21]]);
	      }));

	      function changePasswordWithOldPassword(_x4) {
	        return _changePasswordWithOldPassword.apply(this, arguments);
	      }

	      return changePasswordWithOldPassword;
	    }()
	    /**
	     *
	     * @param {ChangePasswordWithVerificationCode} args
	     *
	     * change the users password by providing the old and new password.
	     * User must be in loggedIn(status 0) or loggedOut(status 1) to be able to
	     * use this method.
	     */

	  }, {
	    key: "changePasswordWithVerificationCode",
	    value: function () {
	      var _changePasswordWithVerificationCode = asyncToGenerator$1(
	      /*#__PURE__*/
	      regenerator$1.mark(function _callee7(_ref10) {
	        var password, _ref11, statusCode, pk, userIdBase64, sk, response;

	        return regenerator$1.wrap(function _callee7$(_context7) {
	          while (1) {
	            switch (_context7.prev = _context7.next) {
	              case 0:
	                password = _ref10.password;
	                _context7.next = 3;
	                return this.getStatus();

	              case 3:
	                _ref11 = _context7.sent;
	                statusCode = _ref11.code;

	                if (!(statusCode === 2)) {
	                  _context7.next = 7;
	                  break;
	                }

	                throw new AitmedError({
	                  name: 'REQUIRED_PHONE_NUMBER_AND_VERIFICATION_CODE',
	                  message: 'Local credentials were not found. Please login.'
	                });

	              case 7:
	                pk = localStorage.getItem('pk');
	                userIdBase64 = localStorage.getItem('user_vid');
	                sk = localStorage.getItem('sk');

	                if (!(userIdBase64 === null || pk === null || sk === null)) {
	                  _context7.next = 12;
	                  break;
	                }

	                throw new AitmedError({
	                  name: 'REQUIRED_PHONE_NUMBER_AND_VERIFICATION_CODE',
	                  message: 'User id or pk or sk were not found in localStorage. Login as new device is required.'
	                });

	              case 12:
	                _context7.next = 14;
	                return updatePassword({
	                  password: password,
	                  userId: userIdBase64,
	                  pk: pk,
	                  sk: sk
	                });

	              case 14:
	                response = _context7.sent;
	                return _context7.abrupt("return", response);

	              case 16:
	              case "end":
	                return _context7.stop();
	            }
	          }
	        }, _callee7, this);
	      }));

	      function changePasswordWithVerificationCode(_x5) {
	        return _changePasswordWithVerificationCode.apply(this, arguments);
	      }

	      return changePasswordWithVerificationCode;
	    }()
	    /**
	     *
	     * @param {VerifyUserPasswordArgs} args.password 
	     * @returns Array<[boolean, null | Uint8Array]> 
	     * 
	     * used to verify the user's password
	     * 
	     * returns [true, sk:Uint8Array] if password is valid
	     * 
	     */

	  }, {
	    key: "verifyUserPassword",
	    value: function verifyUserPassword(_ref12) {
	      var password = _ref12.password;
	      var passwordTo32BitArray = utils$2.normalizeStringTo32BitArray(password);
	      var eskBase64 = localStorage.getItem('esk');
	      var pkBase64 = localStorage.getItem('pk');
	      var sk;
	      var isSkValid;

	      if (eskBase64 && pkBase64) {
	        var pkUint8Array = utils$2.base64ToUint8Array(pkBase64);
	        var eskUint8Array = utils$2.base64ToUint8Array(eskBase64);
	        sk = utils$2.sKeyDecrypt(passwordTo32BitArray, eskUint8Array);

	        if (sk === null) {
	          return [false, null];
	        }

	        isSkValid = utils$2.aKeyCheck(pkUint8Array, sk);
	      } else {
	        throw new AitmedError({
	          name: 'REQUIRED_PHONE_NUMBER_AND_VERIFICATION_CODE'
	        });
	      }

	      if (isSkValid) {
	        return [true, sk];
	      }

	      return [false, null];
	    } // async changePasswordWithoutOldPassword({
	    //     password,
	    //     phone_number,
	    //     verification_code,
	    // }: ChangePasswordWithoutOldPasswordArgs): Promise<Response> {
	    //     const vidBase64 = localStorage.getItem('user')
	    //     if (vidBase64 === null) {
	    //         throw new AitmedError({ code: 1005, message: "User id was not found. Please login as new device." })
	    //     }
	    //     // const vidUint8Array = utils.base64ToUint8Array(vidBase64)
	    //     //generate assymetric keyPair
	    //     const { publicKey, secretKey } = utils.generateAKey()
	    //     //symmetrically encrypt secretKey with password
	    //     const encryptedSecretKey = utils.encryptSecretKeyWithPassword({
	    //         password,
	    //         secretKey,
	    //     })
	    //     try {
	    //         const { data: deat } = await vertexServices.updateVertex({
	    //             id: vidBase64,
	    //             tage: verification_code,
	    //             pk: publicKey,
	    //             esk: encryptedSecretKey,
	    //         })
	    //         utils.storeCredentialsInLocalStorage({
	    //             publicKey,
	    //             secretKey,
	    //             encryptedSecretKey,
	    //             user: deat.user_id,
	    //             uid: phone_number
	    //         })
	    //         return new Response({ code: 0 })
	    //     } catch (error) {
	    //         throw error
	    //     }
	    // }

	  }]);

	  return Account;
	}();

	var SDK =
	/*#__PURE__*/
	function () {
	  function SDK(_ref) {
	    var apiVersion = _ref.apiVersion,
	        apiHost = _ref.apiHost,
	        env = _ref.env,
	        configUrl = _ref.configUrl;

	    classCallCheck$1(this, SDK);

	    defineProperty$e(this, "Account", void 0);

	    defineProperty$e(this, "edgeServices", void 0);

	    defineProperty$e(this, "documentServices", void 0);

	    defineProperty$e(this, "vertexServices", void 0);

	    defineProperty$e(this, "commonServices", void 0);

	    defineProperty$e(this, "utilServices", void 0);

	    store$2.env = env;
	    store$2.configUrl = configUrl;
	    if (apiVersion) store$2.apiVersion = apiVersion;
	    if (apiHost) store$2.apiHost = apiHost;
	    this.Account = new Account();
	    this.edgeServices = edgesServices;
	    this.documentServices = documentServices;
	    this.vertexServices = vertexServices;
	    this.commonServices = commonServices;
	    this.utilServices = utils$2;
	  }

	  createClass$1(SDK, [{
	    key: "getConfigData",
	    value: function getConfigData() {
	      return store$2.getConfig();
	    }
	  }, {
	    key: "loadConfigData",
	    value: function () {
	      var _loadConfigData = asyncToGenerator$1(
	      /*#__PURE__*/
	      regenerator$1.mark(function _callee(appName) {
	        return regenerator$1.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return store$2.loadConfig(appName);

	              case 2:
	                return _context.abrupt("return", _context.sent);

	              case 3:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee);
	      }));

	      function loadConfigData(_x) {
	        return _loadConfigData.apply(this, arguments);
	      }

	      return loadConfigData;
	    }()
	  }, {
	    key: "apiVersion",
	    set: function set(apiVersion) {
	      store$2.apiVersion = apiVersion;
	    },
	    get: function get() {
	      return store$2.apiVersion;
	    }
	  }, {
	    key: "env",
	    set: function set(value) {
	      store$2.env = value;
	    },
	    get: function get() {
	      return store$2.env;
	    }
	  }, {
	    key: "apiHost",
	    get: function get() {
	      return store$2.apiHost;
	    },
	    set: function set(value) {
	      store$2.apiHost = value;
	    }
	  }, {
	    key: "configUrl",
	    get: function get() {
	      return store$2.configUrl;
	    },
	    set: function set(value) {
	      store$2.configUrl = value;
	    }
	  }]);

	  return SDK;
	}();

	var ErrorCodes;

	(function (ErrorCodes) {
	  ErrorCodes[ErrorCodes["UNKNOW_ERROR"] = -1] = "UNKNOW_ERROR";
	  ErrorCodes[ErrorCodes["PERMISSION_DENIED"] = 1] = "PERMISSION_DENIED";
	  ErrorCodes[ErrorCodes["UNREGISTERED"] = 2] = "UNREGISTERED";
	  ErrorCodes[ErrorCodes["REGISTERED"] = 3] = "REGISTERED";
	  ErrorCodes[ErrorCodes["PHONE_NUMBER_INVALID"] = 1000] = "PHONE_NUMBER_INVALID";
	  ErrorCodes[ErrorCodes["PASSWORD_INVALID"] = 1001] = "PASSWORD_INVALID";
	  ErrorCodes[ErrorCodes["VERIFICATION_CODE_INVALID"] = 1002] = "VERIFICATION_CODE_INVALID";
	  ErrorCodes[ErrorCodes["REQUIRED_VERIFICATION_CODE"] = 1003] = "REQUIRED_VERIFICATION_CODE";
	  ErrorCodes[ErrorCodes["REQUIRED_PASSWORD"] = 1004] = "REQUIRED_PASSWORD";
	  ErrorCodes[ErrorCodes["USER_NOT_FOUND"] = 1005] = "USER_NOT_FOUND";
	  ErrorCodes[ErrorCodes["PROFILE_NOT_FOUND"] = 1006] = "PROFILE_NOT_FOUND";
	  ErrorCodes[ErrorCodes["UID_INVALID"] = 1007] = "UID_INVALID";
	  ErrorCodes[ErrorCodes["PROFILE_PHOTO_INVALID"] = 1008] = "PROFILE_PHOTO_INVALID";
	  ErrorCodes[ErrorCodes["NOTEBOOK_NOT_EXIST"] = 2000] = "NOTEBOOK_NOT_EXIST";
	  ErrorCodes[ErrorCodes["NOTEBOOK_PERMISSION_DENIED"] = 2001] = "NOTEBOOK_PERMISSION_DENIED";
	  ErrorCodes[ErrorCodes["NOT_A_NOTEBOOk"] = 2002] = "NOT_A_NOTEBOOk";
	  ErrorCodes[ErrorCodes["ROOT_NOTEBOOK_EXIST"] = 2003] = "ROOT_NOTEBOOK_EXIST";
	  ErrorCodes[ErrorCodes["ROOT_NOTEBOOK_NOT_EXIST"] = 2004] = "ROOT_NOTEBOOK_NOT_EXIST";
	  ErrorCodes[ErrorCodes["ROOT_NOTEBOOK_CANNOT_BE_REMOVED"] = 2005] = "ROOT_NOTEBOOK_CANNOT_BE_REMOVED";
	  ErrorCodes[ErrorCodes["NOTEBOOK_TYPE_INVALID"] = 2006] = "NOTEBOOK_TYPE_INVALID";
	  ErrorCodes[ErrorCodes["NOT_AN_INVITE"] = 2007] = "NOT_AN_INVITE";
	  ErrorCodes[ErrorCodes["NOT_AN_ACCEPTED_INVITE"] = 2008] = "NOT_AN_ACCEPTED_INVITE";
	  ErrorCodes[ErrorCodes["NOTE_NOT_EXIST"] = 3000] = "NOTE_NOT_EXIST";
	  ErrorCodes[ErrorCodes["NOTE_PERMISSION_DENIED"] = 3001] = "NOTE_PERMISSION_DENIED";
	  ErrorCodes[ErrorCodes["NOTE_CONTENT_INVALID"] = 3002] = "NOTE_CONTENT_INVALID";
	  ErrorCodes[ErrorCodes["NOT_A_NOTE"] = 3003] = "NOT_A_NOTE";
	  ErrorCodes[ErrorCodes["NOTEBOOK_ID_NOT_MATCH"] = 3004] = "NOTEBOOK_ID_NOT_MATCH";
	  ErrorCodes[ErrorCodes["CONTENT_TOO_LARGE"] = 3005] = "CONTENT_TOO_LARGE";
	  ErrorCodes[ErrorCodes["DOWNLOAD_FROM_S3_FAIL"] = 3006] = "DOWNLOAD_FROM_S3_FAIL";
	  ErrorCodes[ErrorCodes["DECRYPTING_NOTES_FAIL"] = 3007] = "DECRYPTING_NOTES_FAIL";
	  ErrorCodes[ErrorCodes["YAML_PARSE_FAILED"] = 4000] = "YAML_PARSE_FAILED";
	  ErrorCodes[ErrorCodes["NO_DATA_MODELS_AVAILABLE"] = 4001] = "NO_DATA_MODELS_AVAILABLE";
	  ErrorCodes[ErrorCodes["INVALID_DATAMODEL_KEY"] = 4002] = "INVALID_DATAMODEL_KEY";
	  ErrorCodes[ErrorCodes["ERROR_RETRIEVING_UIDL_DATA"] = 4003] = "ERROR_RETRIEVING_UIDL_DATA";
	  ErrorCodes[ErrorCodes["INVALID_ROOT_TYPE"] = 4004] = "INVALID_ROOT_TYPE";
	  ErrorCodes[ErrorCodes["INVALID_LINK"] = 5000] = "INVALID_LINK";
	  ErrorCodes[ErrorCodes["LINK_DOES_NOT_EXIST"] = 5001] = "LINK_DOES_NOT_EXIST";
	  ErrorCodes[ErrorCodes["NOT_AN_INBOX"] = 6000] = "NOT_AN_INBOX";
	  ErrorCodes[ErrorCodes["ROOT_INBOX_EXISTS"] = 6001] = "ROOT_INBOX_EXISTS";
	  ErrorCodes[ErrorCodes["ROOT_INBOX_DOES_NOT_EXIST"] = 6002] = "ROOT_INBOX_DOES_NOT_EXIST";
	})(ErrorCodes || (ErrorCodes = {}));

	var defaultErrorMessages = {
	  UNKNOW_ERROR: 'error occurred',
	  PERMISSION_DENIED: 'permission denied',
	  UNREGISTERED: 'account is not registered',
	  REGISTERED: 'account is already registered',

	  /* Account */
	  PHONE_NUMBER_INVALID: 'phone number is invalid',
	  PASSWORD_INVALID: 'password is invalid',
	  VERIFICATION_CODE_INVALID: 'verification code is invalid',
	  REQUIRED_VERIFICATION_CODE: 'verification code is required',
	  REQUIRED_PASSWORD: 'password is required',
	  USER_NOT_FOUND: 'user is not found',
	  PROFILE_NOT_FOUND: 'profile note found',
	  UID_INVALID: 'uid is invalid',
	  PROFILE_PHOTO_INVALID: 'profile photo is invalid',

	  /* Notebook */
	  NOTEBOOK_NOT_EXIST: 'notebook is not exist',
	  NOTEBOOK_PERMISSION_DENIED: 'notebook permission denied',
	  NOT_A_NOTEBOOk: 'not a notebook',
	  ROOT_NOTEBOOK_EXIST: 'the root notebook is already exist',
	  ROOT_NOTEBOOK_NOT_EXIST: 'the root notebook is not exist',
	  ROOT_NOTEBOOK_CANNOT_BE_REMOVED: 'the root notebook cannot be removed',
	  NOTEBOOK_TYPE_INVALID: 'notebook type is invalid',
	  NOT_AN_INVITE: 'this is not an invite',
	  NOT_AN_ACCEPTED_INVITE: ' this is not an accepted invite',

	  /* Note */
	  NOTE_NOT_EXIST: 'note is not exist',
	  NOTE_PERMISSION_DENIED: 'note permission denied',
	  NOTE_CONTENT_INVALID: 'note content is invalid',
	  NOT_A_NOTE: 'not a note',
	  NOTEBOOK_ID_NOT_MATCH: 'notebook id is not match',
	  CONTENT_TOO_LARGE: 'content is too large [maximum 32KB]',
	  DOWNLOAD_FROM_S3_FAIL: 'download document from s3 fail',
	  DECRYPTING_NOTES_FAIL: 'an error occurred while decrypting the shared notes',

	  /* Link */
	  INVALID_LINK: 'this is not a valid Link type',
	  LINK_DOES_NOT_EXIST: 'Link does not exist',

	  /* INBOX */
	  NOT_AN_INBOX: 'This is not a valid inbox/relation.',
	  ROOT_INBOX_EXISTS: 'Root inbox already exists.',
	  ROOT_INBOX_DOES_NOT_EXIST: 'There is no root inbox for the user.',

	  /* UIDL */
	  YAML_PARSE_FAILED: 'failed to parse yaml data',
	  NO_DATA_MODELS_AVAILABLE: 'There are no dataModels for this uidl',
	  INVALID_DATAMODEL_KEY: 'Please provide a valid dataModel key',
	  ERROR_RETRIEVING_UIDL_DATA: 'Could not retrieve data for UIDL dataModel.',
	  INVALID_ROOT_TYPE: 'The root type provided is invalid'
	};

	function _createSuper$n(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$o(); return function () { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$o() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
	var names = Object.keys(ErrorCodes).filter(function (name) {
	  return typeof ErrorCodes[name] === 'number';
	});
	var codes = names.map(function (name) {
	  return parseInt(ErrorCodes[name]);
	});

	var AiTmedError = /*#__PURE__*/function (_Error) {
	  inherits(AiTmedError, _Error);

	  var _super = _createSuper$n(AiTmedError);

	  function AiTmedError(_ref) {
	    var _this;

	    var code = _ref.code,
	        name = _ref.name,
	        message = _ref.message;

	    classCallCheck(this, AiTmedError);

	    _this = _super.call(this);

	    defineProperty(assertThisInitialized(_this), "code", void 0);

	    defineProperty(assertThisInitialized(_this), "name", void 0);

	    defineProperty(assertThisInitialized(_this), "message", void 0);

	    defineProperty(assertThisInitialized(_this), "source", void 0);

	    if (code === undefined && name !== undefined) {
	      _this.name = name;
	      _this.code = getErrorCode(name);
	    } else if (code !== undefined && name === undefined) {
	      _this.name = getErrorName(code);
	      _this.code = getErrorCode(_this.name);
	    } else {
	      _this.code = -1;
	      _this.name = ErrorCodes[_this.code];
	    }

	    _this.message = message === undefined ? defaultErrorMessages[_this.name] : message;
	    _this.source = 'lv-3';
	    return _this;
	  }

	  return AiTmedError;
	}( /*#__PURE__*/wrapNativeSuper(Error));

	function getErrorCode(name) {
	  if (names.includes(name)) {
	    return parseInt(ErrorCodes[name]);
	  } else {
	    return -1;
	  }
	}

	function getErrorName(code) {
	  if (codes.includes(code)) {
	    return ErrorCodes[code];
	  } else {
	    return ErrorCodes.UNKNOW_ERROR.toString();
	  }
	}

	var common$2 = createCommonjsModule(function (module, exports) {


	var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
	                (typeof Uint16Array !== 'undefined') &&
	                (typeof Int32Array !== 'undefined');

	function _has(obj, key) {
	  return Object.prototype.hasOwnProperty.call(obj, key);
	}

	exports.assign = function (obj /*from1, from2, from3, ...*/) {
	  var sources = Array.prototype.slice.call(arguments, 1);
	  while (sources.length) {
	    var source = sources.shift();
	    if (!source) { continue; }

	    if (typeof source !== 'object') {
	      throw new TypeError(source + 'must be non-object');
	    }

	    for (var p in source) {
	      if (_has(source, p)) {
	        obj[p] = source[p];
	      }
	    }
	  }

	  return obj;
	};


	// reduce buffer size, avoiding mem copy
	exports.shrinkBuf = function (buf, size) {
	  if (buf.length === size) { return buf; }
	  if (buf.subarray) { return buf.subarray(0, size); }
	  buf.length = size;
	  return buf;
	};


	var fnTyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    if (src.subarray && dest.subarray) {
	      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
	      return;
	    }
	    // Fallback to ordinary array
	    for (var i = 0; i < len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function (chunks) {
	    var i, l, len, pos, chunk, result;

	    // calculate data length
	    len = 0;
	    for (i = 0, l = chunks.length; i < l; i++) {
	      len += chunks[i].length;
	    }

	    // join chunks
	    result = new Uint8Array(len);
	    pos = 0;
	    for (i = 0, l = chunks.length; i < l; i++) {
	      chunk = chunks[i];
	      result.set(chunk, pos);
	      pos += chunk.length;
	    }

	    return result;
	  }
	};

	var fnUntyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    for (var i = 0; i < len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function (chunks) {
	    return [].concat.apply([], chunks);
	  }
	};


	// Enable/Disable typed arrays use, for testing
	//
	exports.setTyped = function (on) {
	  if (on) {
	    exports.Buf8  = Uint8Array;
	    exports.Buf16 = Uint16Array;
	    exports.Buf32 = Int32Array;
	    exports.assign(exports, fnTyped);
	  } else {
	    exports.Buf8  = Array;
	    exports.Buf16 = Array;
	    exports.Buf32 = Array;
	    exports.assign(exports, fnUntyped);
	  }
	};

	exports.setTyped(TYPED_OK);
	});
	var common_1 = common$2.assign;
	var common_2 = common$2.shrinkBuf;
	var common_3 = common$2.setTyped;
	var common_4 = common$2.Buf8;
	var common_5 = common$2.Buf16;
	var common_6 = common$2.Buf32;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	/* eslint-disable space-unary-ops */



	/* Public constants ==========================================================*/
	/* ===========================================================================*/


	//var Z_FILTERED          = 1;
	//var Z_HUFFMAN_ONLY      = 2;
	//var Z_RLE               = 3;
	var Z_FIXED               = 4;
	//var Z_DEFAULT_STRATEGY  = 0;

	/* Possible values of the data_type field (though see inflate()) */
	var Z_BINARY              = 0;
	var Z_TEXT                = 1;
	//var Z_ASCII             = 1; // = Z_TEXT
	var Z_UNKNOWN             = 2;

	/*============================================================================*/


	function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

	// From zutil.h

	var STORED_BLOCK = 0;
	var STATIC_TREES = 1;
	var DYN_TREES    = 2;
	/* The three kinds of block type */

	var MIN_MATCH    = 3;
	var MAX_MATCH    = 258;
	/* The minimum and maximum match lengths */

	// From deflate.h
	/* ===========================================================================
	 * Internal compression state.
	 */

	var LENGTH_CODES  = 29;
	/* number of length codes, not counting the special END_BLOCK code */

	var LITERALS      = 256;
	/* number of literal bytes 0..255 */

	var L_CODES       = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */

	var D_CODES       = 30;
	/* number of distance codes */

	var BL_CODES      = 19;
	/* number of codes used to transfer the bit lengths */

	var HEAP_SIZE     = 2 * L_CODES + 1;
	/* maximum heap size */

	var MAX_BITS      = 15;
	/* All codes must not exceed MAX_BITS bits */

	var Buf_size      = 16;
	/* size of bit buffer in bi_buf */


	/* ===========================================================================
	 * Constants
	 */

	var MAX_BL_BITS = 7;
	/* Bit length codes must not exceed MAX_BL_BITS bits */

	var END_BLOCK   = 256;
	/* end of block literal code */

	var REP_3_6     = 16;
	/* repeat previous bit length 3-6 times (2 bits of repeat count) */

	var REPZ_3_10   = 17;
	/* repeat a zero length 3-10 times  (3 bits of repeat count) */

	var REPZ_11_138 = 18;
	/* repeat a zero length 11-138 times  (7 bits of repeat count) */

	/* eslint-disable comma-spacing,array-bracket-spacing */
	var extra_lbits =   /* extra bits for each length code */
	  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

	var extra_dbits =   /* extra bits for each distance code */
	  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

	var extra_blbits =  /* extra bits for each bit length code */
	  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

	var bl_order =
	  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
	/* eslint-enable comma-spacing,array-bracket-spacing */

	/* The lengths of the bit length codes are sent in order of decreasing
	 * probability, to avoid transmitting the lengths for unused bit length codes.
	 */

	/* ===========================================================================
	 * Local data. These are initialized only once.
	 */

	// We pre-fill arrays with 0 to avoid uninitialized gaps

	var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

	// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
	var static_ltree  = new Array((L_CODES + 2) * 2);
	zero(static_ltree);
	/* The static literal tree. Since the bit lengths are imposed, there is no
	 * need for the L_CODES extra codes used during heap construction. However
	 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
	 * below).
	 */

	var static_dtree  = new Array(D_CODES * 2);
	zero(static_dtree);
	/* The static distance tree. (Actually a trivial tree since all codes use
	 * 5 bits.)
	 */

	var _dist_code    = new Array(DIST_CODE_LEN);
	zero(_dist_code);
	/* Distance codes. The first 256 values correspond to the distances
	 * 3 .. 258, the last 256 values correspond to the top 8 bits of
	 * the 15 bit distances.
	 */

	var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
	zero(_length_code);
	/* length code for each normalized match length (0 == MIN_MATCH) */

	var base_length   = new Array(LENGTH_CODES);
	zero(base_length);
	/* First normalized length for each code (0 = MIN_MATCH) */

	var base_dist     = new Array(D_CODES);
	zero(base_dist);
	/* First normalized distance for each code (0 = distance of 1) */


	function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

	  this.static_tree  = static_tree;  /* static tree or NULL */
	  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
	  this.extra_base   = extra_base;   /* base index for extra_bits */
	  this.elems        = elems;        /* max number of elements in the tree */
	  this.max_length   = max_length;   /* max bit length for the codes */

	  // show if `static_tree` has data or dummy - needed for monomorphic objects
	  this.has_stree    = static_tree && static_tree.length;
	}


	var static_l_desc;
	var static_d_desc;
	var static_bl_desc;


	function TreeDesc(dyn_tree, stat_desc) {
	  this.dyn_tree = dyn_tree;     /* the dynamic tree */
	  this.max_code = 0;            /* largest code with non zero frequency */
	  this.stat_desc = stat_desc;   /* the corresponding static tree */
	}



	function d_code(dist) {
	  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
	}


	/* ===========================================================================
	 * Output a short LSB first on the stream.
	 * IN assertion: there is enough room in pendingBuf.
	 */
	function put_short(s, w) {
	//    put_byte(s, (uch)((w) & 0xff));
	//    put_byte(s, (uch)((ush)(w) >> 8));
	  s.pending_buf[s.pending++] = (w) & 0xff;
	  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
	}


	/* ===========================================================================
	 * Send a value on a given number of bits.
	 * IN assertion: length <= 16 and value fits in length bits.
	 */
	function send_bits(s, value, length) {
	  if (s.bi_valid > (Buf_size - length)) {
	    s.bi_buf |= (value << s.bi_valid) & 0xffff;
	    put_short(s, s.bi_buf);
	    s.bi_buf = value >> (Buf_size - s.bi_valid);
	    s.bi_valid += length - Buf_size;
	  } else {
	    s.bi_buf |= (value << s.bi_valid) & 0xffff;
	    s.bi_valid += length;
	  }
	}


	function send_code(s, c, tree) {
	  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
	}


	/* ===========================================================================
	 * Reverse the first len bits of a code, using straightforward code (a faster
	 * method would use a table)
	 * IN assertion: 1 <= len <= 15
	 */
	function bi_reverse(code, len) {
	  var res = 0;
	  do {
	    res |= code & 1;
	    code >>>= 1;
	    res <<= 1;
	  } while (--len > 0);
	  return res >>> 1;
	}


	/* ===========================================================================
	 * Flush the bit buffer, keeping at most 7 bits in it.
	 */
	function bi_flush(s) {
	  if (s.bi_valid === 16) {
	    put_short(s, s.bi_buf);
	    s.bi_buf = 0;
	    s.bi_valid = 0;

	  } else if (s.bi_valid >= 8) {
	    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
	    s.bi_buf >>= 8;
	    s.bi_valid -= 8;
	  }
	}


	/* ===========================================================================
	 * Compute the optimal bit lengths for a tree and update the total bit length
	 * for the current block.
	 * IN assertion: the fields freq and dad are set, heap[heap_max] and
	 *    above are the tree nodes sorted by increasing frequency.
	 * OUT assertions: the field len is set to the optimal bit length, the
	 *     array bl_count contains the frequencies for each bit length.
	 *     The length opt_len is updated; static_len is also updated if stree is
	 *     not null.
	 */
	function gen_bitlen(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc;    /* the tree descriptor */
	{
	  var tree            = desc.dyn_tree;
	  var max_code        = desc.max_code;
	  var stree           = desc.stat_desc.static_tree;
	  var has_stree       = desc.stat_desc.has_stree;
	  var extra           = desc.stat_desc.extra_bits;
	  var base            = desc.stat_desc.extra_base;
	  var max_length      = desc.stat_desc.max_length;
	  var h;              /* heap index */
	  var n, m;           /* iterate over the tree elements */
	  var bits;           /* bit length */
	  var xbits;          /* extra bits */
	  var f;              /* frequency */
	  var overflow = 0;   /* number of elements with bit length too large */

	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    s.bl_count[bits] = 0;
	  }

	  /* In a first pass, compute the optimal bit lengths (which may
	   * overflow in the case of the bit length tree).
	   */
	  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

	  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
	    n = s.heap[h];
	    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
	    if (bits > max_length) {
	      bits = max_length;
	      overflow++;
	    }
	    tree[n * 2 + 1]/*.Len*/ = bits;
	    /* We overwrite tree[n].Dad which is no longer needed */

	    if (n > max_code) { continue; } /* not a leaf node */

	    s.bl_count[bits]++;
	    xbits = 0;
	    if (n >= base) {
	      xbits = extra[n - base];
	    }
	    f = tree[n * 2]/*.Freq*/;
	    s.opt_len += f * (bits + xbits);
	    if (has_stree) {
	      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
	    }
	  }
	  if (overflow === 0) { return; }

	  // Trace((stderr,"\nbit length overflow\n"));
	  /* This happens for example on obj2 and pic of the Calgary corpus */

	  /* Find the first bit length which could increase: */
	  do {
	    bits = max_length - 1;
	    while (s.bl_count[bits] === 0) { bits--; }
	    s.bl_count[bits]--;      /* move one leaf down the tree */
	    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
	    s.bl_count[max_length]--;
	    /* The brother of the overflow item also moves one step up,
	     * but this does not affect bl_count[max_length]
	     */
	    overflow -= 2;
	  } while (overflow > 0);

	  /* Now recompute all bit lengths, scanning in increasing frequency.
	   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
	   * lengths instead of fixing only the wrong ones. This idea is taken
	   * from 'ar' written by Haruhiko Okumura.)
	   */
	  for (bits = max_length; bits !== 0; bits--) {
	    n = s.bl_count[bits];
	    while (n !== 0) {
	      m = s.heap[--h];
	      if (m > max_code) { continue; }
	      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
	        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
	        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
	        tree[m * 2 + 1]/*.Len*/ = bits;
	      }
	      n--;
	    }
	  }
	}


	/* ===========================================================================
	 * Generate the codes for a given tree and bit counts (which need not be
	 * optimal).
	 * IN assertion: the array bl_count contains the bit length statistics for
	 * the given tree and the field len is set for all tree elements.
	 * OUT assertion: the field code is set for all tree elements of non
	 *     zero code length.
	 */
	function gen_codes(tree, max_code, bl_count)
	//    ct_data *tree;             /* the tree to decorate */
	//    int max_code;              /* largest code with non zero frequency */
	//    ushf *bl_count;            /* number of codes at each bit length */
	{
	  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
	  var code = 0;              /* running code value */
	  var bits;                  /* bit index */
	  var n;                     /* code index */

	  /* The distribution counts are first used to generate the code values
	   * without bit reversal.
	   */
	  for (bits = 1; bits <= MAX_BITS; bits++) {
	    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
	  }
	  /* Check that the bit counts in bl_count are consistent. The last code
	   * must be all ones.
	   */
	  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
	  //        "inconsistent bit counts");
	  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

	  for (n = 0;  n <= max_code; n++) {
	    var len = tree[n * 2 + 1]/*.Len*/;
	    if (len === 0) { continue; }
	    /* Now reverse the bits */
	    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

	    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
	    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
	  }
	}


	/* ===========================================================================
	 * Initialize the various 'constant' tables.
	 */
	function tr_static_init() {
	  var n;        /* iterates over tree elements */
	  var bits;     /* bit counter */
	  var length;   /* length value */
	  var code;     /* code value */
	  var dist;     /* distance index */
	  var bl_count = new Array(MAX_BITS + 1);
	  /* number of codes at each bit length for an optimal tree */

	  // do check in _tr_init()
	  //if (static_init_done) return;

	  /* For some embedded targets, global variables are not initialized: */
	/*#ifdef NO_INIT_GLOBAL_POINTERS
	  static_l_desc.static_tree = static_ltree;
	  static_l_desc.extra_bits = extra_lbits;
	  static_d_desc.static_tree = static_dtree;
	  static_d_desc.extra_bits = extra_dbits;
	  static_bl_desc.extra_bits = extra_blbits;
	#endif*/

	  /* Initialize the mapping length (0..255) -> length code (0..28) */
	  length = 0;
	  for (code = 0; code < LENGTH_CODES - 1; code++) {
	    base_length[code] = length;
	    for (n = 0; n < (1 << extra_lbits[code]); n++) {
	      _length_code[length++] = code;
	    }
	  }
	  //Assert (length == 256, "tr_static_init: length != 256");
	  /* Note that the length 255 (match length 258) can be represented
	   * in two different ways: code 284 + 5 bits or code 285, so we
	   * overwrite length_code[255] to use the best encoding:
	   */
	  _length_code[length - 1] = code;

	  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
	  dist = 0;
	  for (code = 0; code < 16; code++) {
	    base_dist[code] = dist;
	    for (n = 0; n < (1 << extra_dbits[code]); n++) {
	      _dist_code[dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: dist != 256");
	  dist >>= 7; /* from now on, all distances are divided by 128 */
	  for (; code < D_CODES; code++) {
	    base_dist[code] = dist << 7;
	    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
	      _dist_code[256 + dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

	  /* Construct the codes of the static literal tree */
	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    bl_count[bits] = 0;
	  }

	  n = 0;
	  while (n <= 143) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  while (n <= 255) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 9;
	    n++;
	    bl_count[9]++;
	  }
	  while (n <= 279) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 7;
	    n++;
	    bl_count[7]++;
	  }
	  while (n <= 287) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  /* Codes 286 and 287 do not exist, but we must include them in the
	   * tree construction to get a canonical Huffman tree (longest code
	   * all ones)
	   */
	  gen_codes(static_ltree, L_CODES + 1, bl_count);

	  /* The static distance tree is trivial: */
	  for (n = 0; n < D_CODES; n++) {
	    static_dtree[n * 2 + 1]/*.Len*/ = 5;
	    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
	  }

	  // Now data ready and we can init static trees
	  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
	  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
	  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

	  //static_init_done = true;
	}


	/* ===========================================================================
	 * Initialize a new block.
	 */
	function init_block(s) {
	  var n; /* iterates over tree elements */

	  /* Initialize the trees. */
	  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
	  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
	  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

	  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
	  s.opt_len = s.static_len = 0;
	  s.last_lit = s.matches = 0;
	}


	/* ===========================================================================
	 * Flush the bit buffer and align the output on a byte boundary
	 */
	function bi_windup(s)
	{
	  if (s.bi_valid > 8) {
	    put_short(s, s.bi_buf);
	  } else if (s.bi_valid > 0) {
	    //put_byte(s, (Byte)s->bi_buf);
	    s.pending_buf[s.pending++] = s.bi_buf;
	  }
	  s.bi_buf = 0;
	  s.bi_valid = 0;
	}

	/* ===========================================================================
	 * Copy a stored block, storing first the length and its
	 * one's complement if requested.
	 */
	function copy_block(s, buf, len, header)
	//DeflateState *s;
	//charf    *buf;    /* the input data */
	//unsigned len;     /* its length */
	//int      header;  /* true if block header must be written */
	{
	  bi_windup(s);        /* align on byte boundary */

	  if (header) {
	    put_short(s, len);
	    put_short(s, ~len);
	  }
	//  while (len--) {
	//    put_byte(s, *buf++);
	//  }
	  common$2.arraySet(s.pending_buf, s.window, buf, len, s.pending);
	  s.pending += len;
	}

	/* ===========================================================================
	 * Compares to subtrees, using the tree depth as tie breaker when
	 * the subtrees have equal frequency. This minimizes the worst case length.
	 */
	function smaller(tree, n, m, depth) {
	  var _n2 = n * 2;
	  var _m2 = m * 2;
	  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
	         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
	}

	/* ===========================================================================
	 * Restore the heap property by moving down the tree starting at node k,
	 * exchanging a node with the smallest of its two sons if necessary, stopping
	 * when the heap property is re-established (each father smaller than its
	 * two sons).
	 */
	function pqdownheap(s, tree, k)
	//    deflate_state *s;
	//    ct_data *tree;  /* the tree to restore */
	//    int k;               /* node to move down */
	{
	  var v = s.heap[k];
	  var j = k << 1;  /* left son of k */
	  while (j <= s.heap_len) {
	    /* Set j to the smallest of the two sons: */
	    if (j < s.heap_len &&
	      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
	      j++;
	    }
	    /* Exit if v is smaller than both sons */
	    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

	    /* Exchange v with the smallest son */
	    s.heap[k] = s.heap[j];
	    k = j;

	    /* And continue down the tree, setting j to the left son of k */
	    j <<= 1;
	  }
	  s.heap[k] = v;
	}


	// inlined manually
	// var SMALLEST = 1;

	/* ===========================================================================
	 * Send the block data compressed using the given Huffman trees
	 */
	function compress_block(s, ltree, dtree)
	//    deflate_state *s;
	//    const ct_data *ltree; /* literal tree */
	//    const ct_data *dtree; /* distance tree */
	{
	  var dist;           /* distance of matched string */
	  var lc;             /* match length or unmatched char (if dist == 0) */
	  var lx = 0;         /* running index in l_buf */
	  var code;           /* the code to send */
	  var extra;          /* number of extra bits to send */

	  if (s.last_lit !== 0) {
	    do {
	      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
	      lc = s.pending_buf[s.l_buf + lx];
	      lx++;

	      if (dist === 0) {
	        send_code(s, lc, ltree); /* send a literal byte */
	        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
	      } else {
	        /* Here, lc is the match length - MIN_MATCH */
	        code = _length_code[lc];
	        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
	        extra = extra_lbits[code];
	        if (extra !== 0) {
	          lc -= base_length[code];
	          send_bits(s, lc, extra);       /* send the extra length bits */
	        }
	        dist--; /* dist is now the match distance - 1 */
	        code = d_code(dist);
	        //Assert (code < D_CODES, "bad d_code");

	        send_code(s, code, dtree);       /* send the distance code */
	        extra = extra_dbits[code];
	        if (extra !== 0) {
	          dist -= base_dist[code];
	          send_bits(s, dist, extra);   /* send the extra distance bits */
	        }
	      } /* literal or match pair ? */

	      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
	      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
	      //       "pendingBuf overflow");

	    } while (lx < s.last_lit);
	  }

	  send_code(s, END_BLOCK, ltree);
	}


	/* ===========================================================================
	 * Construct one Huffman tree and assigns the code bit strings and lengths.
	 * Update the total bit length for the current block.
	 * IN assertion: the field freq is set for all tree elements.
	 * OUT assertions: the fields len and code are set to the optimal bit length
	 *     and corresponding code. The length opt_len is updated; static_len is
	 *     also updated if stree is not null. The field max_code is set.
	 */
	function build_tree(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc; /* the tree descriptor */
	{
	  var tree     = desc.dyn_tree;
	  var stree    = desc.stat_desc.static_tree;
	  var has_stree = desc.stat_desc.has_stree;
	  var elems    = desc.stat_desc.elems;
	  var n, m;          /* iterate over heap elements */
	  var max_code = -1; /* largest code with non zero frequency */
	  var node;          /* new node being created */

	  /* Construct the initial heap, with least frequent element in
	   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
	   * heap[0] is not used.
	   */
	  s.heap_len = 0;
	  s.heap_max = HEAP_SIZE;

	  for (n = 0; n < elems; n++) {
	    if (tree[n * 2]/*.Freq*/ !== 0) {
	      s.heap[++s.heap_len] = max_code = n;
	      s.depth[n] = 0;

	    } else {
	      tree[n * 2 + 1]/*.Len*/ = 0;
	    }
	  }

	  /* The pkzip format requires that at least one distance code exists,
	   * and that at least one bit should be sent even if there is only one
	   * possible code. So to avoid special checks later on we force at least
	   * two codes of non zero frequency.
	   */
	  while (s.heap_len < 2) {
	    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
	    tree[node * 2]/*.Freq*/ = 1;
	    s.depth[node] = 0;
	    s.opt_len--;

	    if (has_stree) {
	      s.static_len -= stree[node * 2 + 1]/*.Len*/;
	    }
	    /* node is 0 or 1 so it does not have extra bits */
	  }
	  desc.max_code = max_code;

	  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
	   * establish sub-heaps of increasing lengths:
	   */
	  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

	  /* Construct the Huffman tree by repeatedly combining the least two
	   * frequent nodes.
	   */
	  node = elems;              /* next internal node of the tree */
	  do {
	    //pqremove(s, tree, n);  /* n = node of least frequency */
	    /*** pqremove ***/
	    n = s.heap[1/*SMALLEST*/];
	    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
	    pqdownheap(s, tree, 1/*SMALLEST*/);
	    /***/

	    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

	    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
	    s.heap[--s.heap_max] = m;

	    /* Create a new node father of n and m */
	    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
	    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
	    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

	    /* and insert the new node in the heap */
	    s.heap[1/*SMALLEST*/] = node++;
	    pqdownheap(s, tree, 1/*SMALLEST*/);

	  } while (s.heap_len >= 2);

	  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

	  /* At this point, the fields freq and dad are set. We can now
	   * generate the bit lengths.
	   */
	  gen_bitlen(s, desc);

	  /* The field len is now set, we can generate the bit codes */
	  gen_codes(tree, max_code, s.bl_count);
	}


	/* ===========================================================================
	 * Scan a literal or distance tree to determine the frequencies of the codes
	 * in the bit length tree.
	 */
	function scan_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree;   /* the tree to be scanned */
	//    int max_code;    /* and its largest code of non zero frequency */
	{
	  var n;                     /* iterates over all tree elements */
	  var prevlen = -1;          /* last emitted length */
	  var curlen;                /* length of current code */

	  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

	  var count = 0;             /* repeat count of the current code */
	  var max_count = 7;         /* max repeat count */
	  var min_count = 4;         /* min repeat count */

	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }
	  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

	    if (++count < max_count && curlen === nextlen) {
	      continue;

	    } else if (count < min_count) {
	      s.bl_tree[curlen * 2]/*.Freq*/ += count;

	    } else if (curlen !== 0) {

	      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
	      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

	    } else if (count <= 10) {
	      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

	    } else {
	      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
	    }

	    count = 0;
	    prevlen = curlen;

	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;

	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;

	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}


	/* ===========================================================================
	 * Send a literal or distance tree in compressed form, using the codes in
	 * bl_tree.
	 */
	function send_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree; /* the tree to be scanned */
	//    int max_code;       /* and its largest code of non zero frequency */
	{
	  var n;                     /* iterates over all tree elements */
	  var prevlen = -1;          /* last emitted length */
	  var curlen;                /* length of current code */

	  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

	  var count = 0;             /* repeat count of the current code */
	  var max_count = 7;         /* max repeat count */
	  var min_count = 4;         /* min repeat count */

	  /* tree[max_code+1].Len = -1; */  /* guard already set */
	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }

	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

	    if (++count < max_count && curlen === nextlen) {
	      continue;

	    } else if (count < min_count) {
	      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

	    } else if (curlen !== 0) {
	      if (curlen !== prevlen) {
	        send_code(s, curlen, s.bl_tree);
	        count--;
	      }
	      //Assert(count >= 3 && count <= 6, " 3_6?");
	      send_code(s, REP_3_6, s.bl_tree);
	      send_bits(s, count - 3, 2);

	    } else if (count <= 10) {
	      send_code(s, REPZ_3_10, s.bl_tree);
	      send_bits(s, count - 3, 3);

	    } else {
	      send_code(s, REPZ_11_138, s.bl_tree);
	      send_bits(s, count - 11, 7);
	    }

	    count = 0;
	    prevlen = curlen;
	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;

	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;

	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}


	/* ===========================================================================
	 * Construct the Huffman tree for the bit lengths and return the index in
	 * bl_order of the last bit length code to send.
	 */
	function build_bl_tree(s) {
	  var max_blindex;  /* index of last bit length code of non zero freq */

	  /* Determine the bit length frequencies for literal and distance trees */
	  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
	  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

	  /* Build the bit length tree: */
	  build_tree(s, s.bl_desc);
	  /* opt_len now includes the length of the tree representations, except
	   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
	   */

	  /* Determine the number of bit length codes to send. The pkzip format
	   * requires that at least 4 bit length codes be sent. (appnote.txt says
	   * 3 but the actual value used is 4.)
	   */
	  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
	    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
	      break;
	    }
	  }
	  /* Update opt_len to include the bit length tree and counts */
	  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
	  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
	  //        s->opt_len, s->static_len));

	  return max_blindex;
	}


	/* ===========================================================================
	 * Send the header for a block using dynamic Huffman trees: the counts, the
	 * lengths of the bit length codes, the literal tree and the distance tree.
	 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
	 */
	function send_all_trees(s, lcodes, dcodes, blcodes)
	//    deflate_state *s;
	//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
	{
	  var rank;                    /* index in bl_order */

	  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
	  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
	  //        "too many codes");
	  //Tracev((stderr, "\nbl counts: "));
	  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
	  send_bits(s, dcodes - 1,   5);
	  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
	  for (rank = 0; rank < blcodes; rank++) {
	    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
	    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
	  }
	  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

	  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
	  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

	  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
	  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
	}


	/* ===========================================================================
	 * Check if the data type is TEXT or BINARY, using the following algorithm:
	 * - TEXT if the two conditions below are satisfied:
	 *    a) There are no non-portable control characters belonging to the
	 *       "black list" (0..6, 14..25, 28..31).
	 *    b) There is at least one printable character belonging to the
	 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
	 * - BINARY otherwise.
	 * - The following partially-portable control characters form a
	 *   "gray list" that is ignored in this detection algorithm:
	 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
	 * IN assertion: the fields Freq of dyn_ltree are set.
	 */
	function detect_data_type(s) {
	  /* black_mask is the bit mask of black-listed bytes
	   * set bits 0..6, 14..25, and 28..31
	   * 0xf3ffc07f = binary 11110011111111111100000001111111
	   */
	  var black_mask = 0xf3ffc07f;
	  var n;

	  /* Check for non-textual ("black-listed") bytes. */
	  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
	    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
	      return Z_BINARY;
	    }
	  }

	  /* Check for textual ("white-listed") bytes. */
	  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
	      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
	    return Z_TEXT;
	  }
	  for (n = 32; n < LITERALS; n++) {
	    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
	      return Z_TEXT;
	    }
	  }

	  /* There are no "black-listed" or "white-listed" bytes:
	   * this stream either is empty or has tolerated ("gray-listed") bytes only.
	   */
	  return Z_BINARY;
	}


	var static_init_done = false;

	/* ===========================================================================
	 * Initialize the tree data structures for a new zlib stream.
	 */
	function _tr_init(s)
	{

	  if (!static_init_done) {
	    tr_static_init();
	    static_init_done = true;
	  }

	  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
	  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
	  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

	  s.bi_buf = 0;
	  s.bi_valid = 0;

	  /* Initialize the first block of the first file: */
	  init_block(s);
	}


	/* ===========================================================================
	 * Send a stored block
	 */
	function _tr_stored_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
	  copy_block(s, buf, stored_len, true); /* with header */
	}


	/* ===========================================================================
	 * Send one empty static block to give enough lookahead for inflate.
	 * This takes 10 bits, of which 7 may remain in the bit buffer.
	 */
	function _tr_align(s) {
	  send_bits(s, STATIC_TREES << 1, 3);
	  send_code(s, END_BLOCK, static_ltree);
	  bi_flush(s);
	}


	/* ===========================================================================
	 * Determine the best encoding for the current block: dynamic trees, static
	 * trees or store, and output the encoded block to the zip file.
	 */
	function _tr_flush_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block, or NULL if too old */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
	  var max_blindex = 0;        /* index of last bit length code of non zero freq */

	  /* Build the Huffman trees unless a stored block is forced */
	  if (s.level > 0) {

	    /* Check if the file is binary or text */
	    if (s.strm.data_type === Z_UNKNOWN) {
	      s.strm.data_type = detect_data_type(s);
	    }

	    /* Construct the literal and distance trees */
	    build_tree(s, s.l_desc);
	    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));

	    build_tree(s, s.d_desc);
	    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));
	    /* At this point, opt_len and static_len are the total bit lengths of
	     * the compressed block data, excluding the tree representations.
	     */

	    /* Build the bit length tree for the above two trees, and get the index
	     * in bl_order of the last bit length code to send.
	     */
	    max_blindex = build_bl_tree(s);

	    /* Determine the best encoding. Compute the block lengths in bytes. */
	    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
	    static_lenb = (s.static_len + 3 + 7) >>> 3;

	    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
	    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
	    //        s->last_lit));

	    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

	  } else {
	    // Assert(buf != (char*)0, "lost buf");
	    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
	  }

	  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
	    /* 4: two words for the lengths */

	    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
	     * Otherwise we can't have processed more than WSIZE input bytes since
	     * the last block flush, because compression would have been
	     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
	     * transform a block into a stored block.
	     */
	    _tr_stored_block(s, buf, stored_len, last);

	  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

	    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
	    compress_block(s, static_ltree, static_dtree);

	  } else {
	    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
	    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
	    compress_block(s, s.dyn_ltree, s.dyn_dtree);
	  }
	  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
	  /* The above check is made mod 2^32, for files larger than 512 MB
	   * and uLong implemented on 32 bits.
	   */
	  init_block(s);

	  if (last) {
	    bi_windup(s);
	  }
	  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
	  //       s->compressed_len-7*last));
	}

	/* ===========================================================================
	 * Save the match info and tally the frequency counts. Return true if
	 * the current block must be flushed.
	 */
	function _tr_tally(s, dist, lc)
	//    deflate_state *s;
	//    unsigned dist;  /* distance of matched string */
	//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
	{
	  //var out_length, in_length, dcode;

	  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
	  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

	  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
	  s.last_lit++;

	  if (dist === 0) {
	    /* lc is the unmatched char */
	    s.dyn_ltree[lc * 2]/*.Freq*/++;
	  } else {
	    s.matches++;
	    /* Here, lc is the match length - MIN_MATCH */
	    dist--;             /* dist = match distance - 1 */
	    //Assert((ush)dist < (ush)MAX_DIST(s) &&
	    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
	    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

	    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
	    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
	  }

	// (!) This block is disabled in zlib defaults,
	// don't enable it for binary compatibility

	//#ifdef TRUNCATE_BLOCK
	//  /* Try to guess if it is profitable to stop the current block here */
	//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
	//    /* Compute an upper bound for the compressed length */
	//    out_length = s.last_lit*8;
	//    in_length = s.strstart - s.block_start;
	//
	//    for (dcode = 0; dcode < D_CODES; dcode++) {
	//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
	//    }
	//    out_length >>>= 3;
	//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
	//    //       s->last_lit, in_length, out_length,
	//    //       100L - out_length*100L/in_length));
	//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
	//      return true;
	//    }
	//  }
	//#endif

	  return (s.last_lit === s.lit_bufsize - 1);
	  /* We avoid equality with lit_bufsize because of wraparound at 64K
	   * on 16 bit machines and because stored blocks are restricted to
	   * 64K-1 bytes.
	   */
	}

	var _tr_init_1  = _tr_init;
	var _tr_stored_block_1 = _tr_stored_block;
	var _tr_flush_block_1  = _tr_flush_block;
	var _tr_tally_1 = _tr_tally;
	var _tr_align_1 = _tr_align;

	var trees = {
		_tr_init: _tr_init_1,
		_tr_stored_block: _tr_stored_block_1,
		_tr_flush_block: _tr_flush_block_1,
		_tr_tally: _tr_tally_1,
		_tr_align: _tr_align_1
	};

	// Note: adler32 takes 12% for level 0 and 2% for level 6.
	// It isn't worth it to make additional optimizations as in original.
	// Small size is preferable.

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	function adler32(adler, buf, len, pos) {
	  var s1 = (adler & 0xffff) |0,
	      s2 = ((adler >>> 16) & 0xffff) |0,
	      n = 0;

	  while (len !== 0) {
	    // Set limit ~ twice less than 5552, to keep
	    // s2 in 31-bits, because we force signed ints.
	    // in other case %= will fail.
	    n = len > 2000 ? 2000 : len;
	    len -= n;

	    do {
	      s1 = (s1 + buf[pos++]) |0;
	      s2 = (s2 + s1) |0;
	    } while (--n);

	    s1 %= 65521;
	    s2 %= 65521;
	  }

	  return (s1 | (s2 << 16)) |0;
	}


	var adler32_1 = adler32;

	// Note: we can't get significant speed boost here.
	// So write code to minimize size - no pregenerated tables
	// and array tools dependencies.

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	// Use ordinary array, since untyped makes no boost here
	function makeTable() {
	  var c, table = [];

	  for (var n = 0; n < 256; n++) {
	    c = n;
	    for (var k = 0; k < 8; k++) {
	      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
	    }
	    table[n] = c;
	  }

	  return table;
	}

	// Create table on load. Just 255 signed longs. Not a problem.
	var crcTable = makeTable();


	function crc32(crc, buf, len, pos) {
	  var t = crcTable,
	      end = pos + len;

	  crc ^= -1;

	  for (var i = pos; i < end; i++) {
	    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
	  }

	  return (crc ^ (-1)); // >>> 0;
	}


	var crc32_1 = crc32;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	var messages = {
	  2:      'need dictionary',     /* Z_NEED_DICT       2  */
	  1:      'stream end',          /* Z_STREAM_END      1  */
	  0:      '',                    /* Z_OK              0  */
	  '-1':   'file error',          /* Z_ERRNO         (-1) */
	  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
	  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
	  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
	  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
	  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
	};

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.







	/* Public constants ==========================================================*/
	/* ===========================================================================*/


	/* Allowed flush values; see deflate() and inflate() below for details */
	var Z_NO_FLUSH      = 0;
	var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	var Z_FULL_FLUSH    = 3;
	var Z_FINISH        = 4;
	var Z_BLOCK         = 5;
	//var Z_TREES         = 6;


	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	//var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR  = -2;
	var Z_DATA_ERROR    = -3;
	//var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR     = -5;
	//var Z_VERSION_ERROR = -6;


	/* compression levels */
	//var Z_NO_COMPRESSION      = 0;
	//var Z_BEST_SPEED          = 1;
	//var Z_BEST_COMPRESSION    = 9;
	var Z_DEFAULT_COMPRESSION = -1;


	var Z_FILTERED            = 1;
	var Z_HUFFMAN_ONLY        = 2;
	var Z_RLE                 = 3;
	var Z_FIXED$1               = 4;
	var Z_DEFAULT_STRATEGY    = 0;

	/* Possible values of the data_type field (though see inflate()) */
	//var Z_BINARY              = 0;
	//var Z_TEXT                = 1;
	//var Z_ASCII               = 1; // = Z_TEXT
	var Z_UNKNOWN$1             = 2;


	/* The deflate compression method */
	var Z_DEFLATED  = 8;

	/*============================================================================*/


	var MAX_MEM_LEVEL = 9;
	/* Maximum value for memLevel in deflateInit2 */
	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_MEM_LEVEL = 8;


	var LENGTH_CODES$1  = 29;
	/* number of length codes, not counting the special END_BLOCK code */
	var LITERALS$1      = 256;
	/* number of literal bytes 0..255 */
	var L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;
	/* number of Literal or Length codes, including the END_BLOCK code */
	var D_CODES$1       = 30;
	/* number of distance codes */
	var BL_CODES$1      = 19;
	/* number of codes used to transfer the bit lengths */
	var HEAP_SIZE$1     = 2 * L_CODES$1 + 1;
	/* maximum heap size */
	var MAX_BITS$1  = 15;
	/* All codes must not exceed MAX_BITS bits */

	var MIN_MATCH$1 = 3;
	var MAX_MATCH$1 = 258;
	var MIN_LOOKAHEAD = (MAX_MATCH$1 + MIN_MATCH$1 + 1);

	var PRESET_DICT = 0x20;

	var INIT_STATE = 42;
	var EXTRA_STATE = 69;
	var NAME_STATE = 73;
	var COMMENT_STATE = 91;
	var HCRC_STATE = 103;
	var BUSY_STATE = 113;
	var FINISH_STATE = 666;

	var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
	var BS_BLOCK_DONE     = 2; /* block flush performed */
	var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
	var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

	var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

	function err(strm, errorCode) {
	  strm.msg = messages[errorCode];
	  return errorCode;
	}

	function rank(f) {
	  return ((f) << 1) - ((f) > 4 ? 9 : 0);
	}

	function zero$1(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


	/* =========================================================================
	 * Flush as much pending output as possible. All deflate() output goes
	 * through this function so some applications may wish to modify it
	 * to avoid allocating a large strm->output buffer and copying into it.
	 * (See also read_buf()).
	 */
	function flush_pending(strm) {
	  var s = strm.state;

	  //_tr_flush_bits(s);
	  var len = s.pending;
	  if (len > strm.avail_out) {
	    len = strm.avail_out;
	  }
	  if (len === 0) { return; }

	  common$2.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
	  strm.next_out += len;
	  s.pending_out += len;
	  strm.total_out += len;
	  strm.avail_out -= len;
	  s.pending -= len;
	  if (s.pending === 0) {
	    s.pending_out = 0;
	  }
	}


	function flush_block_only(s, last) {
	  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
	  s.block_start = s.strstart;
	  flush_pending(s.strm);
	}


	function put_byte(s, b) {
	  s.pending_buf[s.pending++] = b;
	}


	/* =========================================================================
	 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
	 * IN assertion: the stream state is correct and there is enough room in
	 * pending_buf.
	 */
	function putShortMSB(s, b) {
	//  put_byte(s, (Byte)(b >> 8));
	//  put_byte(s, (Byte)(b & 0xff));
	  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
	  s.pending_buf[s.pending++] = b & 0xff;
	}


	/* ===========================================================================
	 * Read a new buffer from the current input stream, update the adler32
	 * and total number of bytes read.  All deflate() input goes through
	 * this function so some applications may wish to modify it to avoid
	 * allocating a large strm->input buffer and copying from it.
	 * (See also flush_pending()).
	 */
	function read_buf(strm, buf, start, size) {
	  var len = strm.avail_in;

	  if (len > size) { len = size; }
	  if (len === 0) { return 0; }

	  strm.avail_in -= len;

	  // zmemcpy(buf, strm->next_in, len);
	  common$2.arraySet(buf, strm.input, strm.next_in, len, start);
	  if (strm.state.wrap === 1) {
	    strm.adler = adler32_1(strm.adler, buf, len, start);
	  }

	  else if (strm.state.wrap === 2) {
	    strm.adler = crc32_1(strm.adler, buf, len, start);
	  }

	  strm.next_in += len;
	  strm.total_in += len;

	  return len;
	}


	/* ===========================================================================
	 * Set match_start to the longest match starting at the given string and
	 * return its length. Matches shorter or equal to prev_length are discarded,
	 * in which case the result is equal to prev_length and match_start is
	 * garbage.
	 * IN assertions: cur_match is the head of the hash chain for the current
	 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
	 * OUT assertion: the match length is not greater than s->lookahead.
	 */
	function longest_match(s, cur_match) {
	  var chain_length = s.max_chain_length;      /* max hash chain length */
	  var scan = s.strstart; /* current string */
	  var match;                       /* matched string */
	  var len;                           /* length of current match */
	  var best_len = s.prev_length;              /* best match length so far */
	  var nice_match = s.nice_match;             /* stop if match long enough */
	  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
	      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

	  var _win = s.window; // shortcut

	  var wmask = s.w_mask;
	  var prev  = s.prev;

	  /* Stop when cur_match becomes <= limit. To simplify the code,
	   * we prevent matches with the string of window index 0.
	   */

	  var strend = s.strstart + MAX_MATCH$1;
	  var scan_end1  = _win[scan + best_len - 1];
	  var scan_end   = _win[scan + best_len];

	  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
	   * It is easy to get rid of this optimization if necessary.
	   */
	  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

	  /* Do not waste too much time if we already have a good match: */
	  if (s.prev_length >= s.good_match) {
	    chain_length >>= 2;
	  }
	  /* Do not look for matches beyond the end of the input. This is necessary
	   * to make deflate deterministic.
	   */
	  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

	  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

	  do {
	    // Assert(cur_match < s->strstart, "no future");
	    match = cur_match;

	    /* Skip to next match if the match length cannot increase
	     * or if the match length is less than 2.  Note that the checks below
	     * for insufficient lookahead only occur occasionally for performance
	     * reasons.  Therefore uninitialized memory will be accessed, and
	     * conditional jumps will be made that depend on those values.
	     * However the length of the match is limited to the lookahead, so
	     * the output of deflate is not affected by the uninitialized values.
	     */

	    if (_win[match + best_len]     !== scan_end  ||
	        _win[match + best_len - 1] !== scan_end1 ||
	        _win[match]                !== _win[scan] ||
	        _win[++match]              !== _win[scan + 1]) {
	      continue;
	    }

	    /* The check at best_len-1 can be removed because it will be made
	     * again later. (This heuristic is not always a win.)
	     * It is not necessary to compare scan[2] and match[2] since they
	     * are always equal when the other bytes match, given that
	     * the hash keys are equal and that HASH_BITS >= 8.
	     */
	    scan += 2;
	    match++;
	    // Assert(*scan == *match, "match[2]?");

	    /* We check for insufficient lookahead only every 8th comparison;
	     * the 256th check will be made at strstart+258.
	     */
	    do {
	      /*jshint noempty:false*/
	    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             scan < strend);

	    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

	    len = MAX_MATCH$1 - (strend - scan);
	    scan = strend - MAX_MATCH$1;

	    if (len > best_len) {
	      s.match_start = cur_match;
	      best_len = len;
	      if (len >= nice_match) {
	        break;
	      }
	      scan_end1  = _win[scan + best_len - 1];
	      scan_end   = _win[scan + best_len];
	    }
	  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

	  if (best_len <= s.lookahead) {
	    return best_len;
	  }
	  return s.lookahead;
	}


	/* ===========================================================================
	 * Fill the window when the lookahead becomes insufficient.
	 * Updates strstart and lookahead.
	 *
	 * IN assertion: lookahead < MIN_LOOKAHEAD
	 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
	 *    At least one byte has been read, or avail_in == 0; reads are
	 *    performed for at least two bytes (required for the zip translate_eol
	 *    option -- not supported here).
	 */
	function fill_window(s) {
	  var _w_size = s.w_size;
	  var p, n, m, more, str;

	  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

	  do {
	    more = s.window_size - s.lookahead - s.strstart;

	    // JS ints have 32 bit, block below not needed
	    /* Deal with !@#$% 64K limit: */
	    //if (sizeof(int) <= 2) {
	    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
	    //        more = wsize;
	    //
	    //  } else if (more == (unsigned)(-1)) {
	    //        /* Very unlikely, but possible on 16 bit machine if
	    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
	    //         */
	    //        more--;
	    //    }
	    //}


	    /* If the window is almost full and there is insufficient lookahead,
	     * move the upper half to the lower one to make room in the upper half.
	     */
	    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

	      common$2.arraySet(s.window, s.window, _w_size, _w_size, 0);
	      s.match_start -= _w_size;
	      s.strstart -= _w_size;
	      /* we now have strstart >= MAX_DIST */
	      s.block_start -= _w_size;

	      /* Slide the hash table (could be avoided with 32 bit values
	       at the expense of memory usage). We slide even when level == 0
	       to keep the hash table consistent if we switch back to level > 0
	       later. (Using level 0 permanently is not an optimal usage of
	       zlib, so we don't care about this pathological case.)
	       */

	      n = s.hash_size;
	      p = n;
	      do {
	        m = s.head[--p];
	        s.head[p] = (m >= _w_size ? m - _w_size : 0);
	      } while (--n);

	      n = _w_size;
	      p = n;
	      do {
	        m = s.prev[--p];
	        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
	        /* If n is not on any hash chain, prev[n] is garbage but
	         * its value will never be used.
	         */
	      } while (--n);

	      more += _w_size;
	    }
	    if (s.strm.avail_in === 0) {
	      break;
	    }

	    /* If there was no sliding:
	     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
	     *    more == window_size - lookahead - strstart
	     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
	     * => more >= window_size - 2*WSIZE + 2
	     * In the BIG_MEM or MMAP case (not yet supported),
	     *   window_size == input_size + MIN_LOOKAHEAD  &&
	     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
	     * Otherwise, window_size == 2*WSIZE so more >= 2.
	     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
	     */
	    //Assert(more >= 2, "more < 2");
	    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
	    s.lookahead += n;

	    /* Initialize the hash value now that we have some input: */
	    if (s.lookahead + s.insert >= MIN_MATCH$1) {
	      str = s.strstart - s.insert;
	      s.ins_h = s.window[str];

	      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
	//#if MIN_MATCH != 3
	//        Call update_hash() MIN_MATCH-3 more times
	//#endif
	      while (s.insert) {
	        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
	        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH$1 - 1]) & s.hash_mask;

	        s.prev[str & s.w_mask] = s.head[s.ins_h];
	        s.head[s.ins_h] = str;
	        str++;
	        s.insert--;
	        if (s.lookahead + s.insert < MIN_MATCH$1) {
	          break;
	        }
	      }
	    }
	    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
	     * but this is not important since only literal bytes will be emitted.
	     */

	  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

	  /* If the WIN_INIT bytes after the end of the current data have never been
	   * written, then zero those bytes in order to avoid memory check reports of
	   * the use of uninitialized (or uninitialised as Julian writes) bytes by
	   * the longest match routines.  Update the high water mark for the next
	   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
	   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
	   */
	//  if (s.high_water < s.window_size) {
	//    var curr = s.strstart + s.lookahead;
	//    var init = 0;
	//
	//    if (s.high_water < curr) {
	//      /* Previous high water mark below current data -- zero WIN_INIT
	//       * bytes or up to end of window, whichever is less.
	//       */
	//      init = s.window_size - curr;
	//      if (init > WIN_INIT)
	//        init = WIN_INIT;
	//      zmemzero(s->window + curr, (unsigned)init);
	//      s->high_water = curr + init;
	//    }
	//    else if (s->high_water < (ulg)curr + WIN_INIT) {
	//      /* High water mark at or above current data, but below current data
	//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
	//       * to end of window, whichever is less.
	//       */
	//      init = (ulg)curr + WIN_INIT - s->high_water;
	//      if (init > s->window_size - s->high_water)
	//        init = s->window_size - s->high_water;
	//      zmemzero(s->window + s->high_water, (unsigned)init);
	//      s->high_water += init;
	//    }
	//  }
	//
	//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
	//    "not enough room for search");
	}

	/* ===========================================================================
	 * Copy without compression as much as possible from the input stream, return
	 * the current block state.
	 * This function does not insert new strings in the dictionary since
	 * uncompressible data is probably not useful. This function is used
	 * only for the level=0 compression option.
	 * NOTE: this function should be optimized to avoid extra copying from
	 * window to pending_buf.
	 */
	function deflate_stored(s, flush) {
	  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
	   * to pending_buf_size, and each stored block has a 5 byte header:
	   */
	  var max_block_size = 0xffff;

	  if (max_block_size > s.pending_buf_size - 5) {
	    max_block_size = s.pending_buf_size - 5;
	  }

	  /* Copy as much as possible from input to output: */
	  for (;;) {
	    /* Fill the window as much as possible: */
	    if (s.lookahead <= 1) {

	      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
	      //  s->block_start >= (long)s->w_size, "slide too late");
	//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
	//        s.block_start >= s.w_size)) {
	//        throw  new Error("slide too late");
	//      }

	      fill_window(s);
	      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }

	      if (s.lookahead === 0) {
	        break;
	      }
	      /* flush the current block */
	    }
	    //Assert(s->block_start >= 0L, "block gone");
	//    if (s.block_start < 0) throw new Error("block gone");

	    s.strstart += s.lookahead;
	    s.lookahead = 0;

	    /* Emit a stored block if pending_buf will be full: */
	    var max_start = s.block_start + max_block_size;

	    if (s.strstart === 0 || s.strstart >= max_start) {
	      /* strstart == 0 is possible when wraparound on 16-bit machine */
	      s.lookahead = s.strstart - max_start;
	      s.strstart = max_start;
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/


	    }
	    /* Flush if we may have to slide, otherwise block_start may become
	     * negative and the data will be gone:
	     */
	    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }

	  s.insert = 0;

	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }

	  if (s.strstart > s.block_start) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }

	  return BS_NEED_MORE;
	}

	/* ===========================================================================
	 * Compress as much as possible from the input stream, return the current
	 * block state.
	 * This function does not perform lazy evaluation of matches and inserts
	 * new strings in the dictionary only for unmatched strings or for short
	 * matches. It is used only for the fast compression options.
	 */
	function deflate_fast(s, flush) {
	  var hash_head;        /* head of the hash chain */
	  var bflush;           /* set if current block must be flushed */

	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) {
	        break; /* flush the current block */
	      }
	    }

	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0/*NIL*/;
	    if (s.lookahead >= MIN_MATCH$1) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }

	    /* Find the longest match, discarding those <= prev_length.
	     * At this point we have always match_length < MIN_MATCH
	     */
	    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */
	    }
	    if (s.match_length >= MIN_MATCH$1) {
	      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

	      /*** _tr_tally_dist(s, s.strstart - s.match_start,
	                     s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1);

	      s.lookahead -= s.match_length;

	      /* Insert new strings in the hash table only if the match length
	       * is not too large. This saves time but degrades compression.
	       */
	      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH$1) {
	        s.match_length--; /* string at strstart already in table */
	        do {
	          s.strstart++;
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
	           * always MIN_MATCH bytes ahead.
	           */
	        } while (--s.match_length !== 0);
	        s.strstart++;
	      } else
	      {
	        s.strstart += s.match_length;
	        s.match_length = 0;
	        s.ins_h = s.window[s.strstart];
	        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
	        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

	//#if MIN_MATCH != 3
	//                Call UPDATE_HASH() MIN_MATCH-3 more times
	//#endif
	        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
	         * matter since it will be recomputed at next deflate call.
	         */
	      }
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s.window[s.strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = ((s.strstart < (MIN_MATCH$1 - 1)) ? s.strstart : MIN_MATCH$1 - 1);
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* ===========================================================================
	 * Same as above, but achieves better compression. We use a lazy
	 * evaluation for matches: a match is finally adopted only if there is
	 * no better match at the next window position.
	 */
	function deflate_slow(s, flush) {
	  var hash_head;          /* head of hash chain */
	  var bflush;              /* set if current block must be flushed */

	  var max_insert;

	  /* Process the input block. */
	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) { break; } /* flush the current block */
	    }

	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0/*NIL*/;
	    if (s.lookahead >= MIN_MATCH$1) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }

	    /* Find the longest match, discarding those <= prev_length.
	     */
	    s.prev_length = s.match_length;
	    s.prev_match = s.match_start;
	    s.match_length = MIN_MATCH$1 - 1;

	    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
	        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */

	      if (s.match_length <= 5 &&
	         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

	        /* If prev_match is also MIN_MATCH, match_start is garbage
	         * but we will ignore the current match anyway.
	         */
	        s.match_length = MIN_MATCH$1 - 1;
	      }
	    }
	    /* If there was a match at the previous step and the current
	     * match is not better, output the previous match:
	     */
	    if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {
	      max_insert = s.strstart + s.lookahead - MIN_MATCH$1;
	      /* Do not insert strings in hash table beyond this. */

	      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

	      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
	                     s.prev_length - MIN_MATCH, bflush);***/
	      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1);
	      /* Insert in hash table all strings up to the end of the match.
	       * strstart-1 and strstart are already inserted. If there is not
	       * enough lookahead, the last two strings are not inserted in
	       * the hash table.
	       */
	      s.lookahead -= s.prev_length - 1;
	      s.prev_length -= 2;
	      do {
	        if (++s.strstart <= max_insert) {
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	        }
	      } while (--s.prev_length !== 0);
	      s.match_available = 0;
	      s.match_length = MIN_MATCH$1 - 1;
	      s.strstart++;

	      if (bflush) {
	        /*** FLUSH_BLOCK(s, 0); ***/
	        flush_block_only(s, false);
	        if (s.strm.avail_out === 0) {
	          return BS_NEED_MORE;
	        }
	        /***/
	      }

	    } else if (s.match_available) {
	      /* If there was no match at the previous position, output a
	       * single literal. If there was a match but the current match
	       * is longer, truncate the previous match to a single literal.
	       */
	      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

	      if (bflush) {
	        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
	        flush_block_only(s, false);
	        /***/
	      }
	      s.strstart++;
	      s.lookahead--;
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	    } else {
	      /* There is no previous match to compare with, wait for
	       * the next step to decide.
	       */
	      s.match_available = 1;
	      s.strstart++;
	      s.lookahead--;
	    }
	  }
	  //Assert (flush != Z_NO_FLUSH, "no flush?");
	  if (s.match_available) {
	    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

	    s.match_available = 0;
	  }
	  s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }

	  return BS_BLOCK_DONE;
	}


	/* ===========================================================================
	 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
	 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
	 * deflate switches away from Z_RLE.)
	 */
	function deflate_rle(s, flush) {
	  var bflush;            /* set if current block must be flushed */
	  var prev;              /* byte at distance one to match */
	  var scan, strend;      /* scan goes up to strend for length of run */

	  var _win = s.window;

	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the longest run, plus one for the unrolled loop.
	     */
	    if (s.lookahead <= MAX_MATCH$1) {
	      fill_window(s);
	      if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) { break; } /* flush the current block */
	    }

	    /* See how many times the previous byte repeats */
	    s.match_length = 0;
	    if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {
	      scan = s.strstart - 1;
	      prev = _win[scan];
	      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
	        strend = s.strstart + MAX_MATCH$1;
	        do {
	          /*jshint noempty:false*/
	        } while (prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 scan < strend);
	        s.match_length = MAX_MATCH$1 - (strend - scan);
	        if (s.match_length > s.lookahead) {
	          s.match_length = s.lookahead;
	        }
	      }
	      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
	    }

	    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
	    if (s.match_length >= MIN_MATCH$1) {
	      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

	      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH$1);

	      s.lookahead -= s.match_length;
	      s.strstart += s.match_length;
	      s.match_length = 0;
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s->window[s->strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* ===========================================================================
	 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
	 * (It will be regenerated if this run of deflate switches away from Huffman.)
	 */
	function deflate_huff(s, flush) {
	  var bflush;             /* set if current block must be flushed */

	  for (;;) {
	    /* Make sure that we have a literal to write. */
	    if (s.lookahead === 0) {
	      fill_window(s);
	      if (s.lookahead === 0) {
	        if (flush === Z_NO_FLUSH) {
	          return BS_NEED_MORE;
	        }
	        break;      /* flush the current block */
	      }
	    }

	    /* Output a literal byte */
	    s.match_length = 0;
	    //Tracevv((stderr,"%c", s->window[s->strstart]));
	    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	    s.lookahead--;
	    s.strstart++;
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* Values for max_lazy_match, good_match and max_chain_length, depending on
	 * the desired pack level (0..9). The values given below have been tuned to
	 * exclude worst case performance for pathological files. Better values may be
	 * found for specific files.
	 */
	function Config(good_length, max_lazy, nice_length, max_chain, func) {
	  this.good_length = good_length;
	  this.max_lazy = max_lazy;
	  this.nice_length = nice_length;
	  this.max_chain = max_chain;
	  this.func = func;
	}

	var configuration_table;

	configuration_table = [
	  /*      good lazy nice chain */
	  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
	  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
	  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
	  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

	  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
	  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
	  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
	  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
	  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
	  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
	];


	/* ===========================================================================
	 * Initialize the "longest match" routines for a new zlib stream
	 */
	function lm_init(s) {
	  s.window_size = 2 * s.w_size;

	  /*** CLEAR_HASH(s); ***/
	  zero$1(s.head); // Fill with NIL (= 0);

	  /* Set the default configuration parameters:
	   */
	  s.max_lazy_match = configuration_table[s.level].max_lazy;
	  s.good_match = configuration_table[s.level].good_length;
	  s.nice_match = configuration_table[s.level].nice_length;
	  s.max_chain_length = configuration_table[s.level].max_chain;

	  s.strstart = 0;
	  s.block_start = 0;
	  s.lookahead = 0;
	  s.insert = 0;
	  s.match_length = s.prev_length = MIN_MATCH$1 - 1;
	  s.match_available = 0;
	  s.ins_h = 0;
	}


	function DeflateState() {
	  this.strm = null;            /* pointer back to this zlib stream */
	  this.status = 0;            /* as the name implies */
	  this.pending_buf = null;      /* output still pending */
	  this.pending_buf_size = 0;  /* size of pending_buf */
	  this.pending_out = 0;       /* next pending byte to output to the stream */
	  this.pending = 0;           /* nb of bytes in the pending buffer */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.gzhead = null;         /* gzip header information to write */
	  this.gzindex = 0;           /* where in extra, name, or comment */
	  this.method = Z_DEFLATED; /* can only be DEFLATED */
	  this.last_flush = -1;   /* value of flush param for previous deflate call */

	  this.w_size = 0;  /* LZ77 window size (32K by default) */
	  this.w_bits = 0;  /* log2(w_size)  (8..16) */
	  this.w_mask = 0;  /* w_size - 1 */

	  this.window = null;
	  /* Sliding window. Input bytes are read into the second half of the window,
	   * and move to the first half later to keep a dictionary of at least wSize
	   * bytes. With this organization, matches are limited to a distance of
	   * wSize-MAX_MATCH bytes, but this ensures that IO is always
	   * performed with a length multiple of the block size.
	   */

	  this.window_size = 0;
	  /* Actual size of window: 2*wSize, except when the user input buffer
	   * is directly used as sliding window.
	   */

	  this.prev = null;
	  /* Link to older string with same hash index. To limit the size of this
	   * array to 64K, this link is maintained only for the last 32K strings.
	   * An index in this array is thus a window index modulo 32K.
	   */

	  this.head = null;   /* Heads of the hash chains or NIL. */

	  this.ins_h = 0;       /* hash index of string to be inserted */
	  this.hash_size = 0;   /* number of elements in hash table */
	  this.hash_bits = 0;   /* log2(hash_size) */
	  this.hash_mask = 0;   /* hash_size-1 */

	  this.hash_shift = 0;
	  /* Number of bits by which ins_h must be shifted at each input
	   * step. It must be such that after MIN_MATCH steps, the oldest
	   * byte no longer takes part in the hash key, that is:
	   *   hash_shift * MIN_MATCH >= hash_bits
	   */

	  this.block_start = 0;
	  /* Window position at the beginning of the current output block. Gets
	   * negative when the window is moved backwards.
	   */

	  this.match_length = 0;      /* length of best match */
	  this.prev_match = 0;        /* previous match */
	  this.match_available = 0;   /* set if previous match exists */
	  this.strstart = 0;          /* start of string to insert */
	  this.match_start = 0;       /* start of matching string */
	  this.lookahead = 0;         /* number of valid bytes ahead in window */

	  this.prev_length = 0;
	  /* Length of the best match at previous step. Matches not greater than this
	   * are discarded. This is used in the lazy match evaluation.
	   */

	  this.max_chain_length = 0;
	  /* To speed up deflation, hash chains are never searched beyond this
	   * length.  A higher limit improves compression ratio but degrades the
	   * speed.
	   */

	  this.max_lazy_match = 0;
	  /* Attempt to find a better match only when the current match is strictly
	   * smaller than this value. This mechanism is used only for compression
	   * levels >= 4.
	   */
	  // That's alias to max_lazy_match, don't use directly
	  //this.max_insert_length = 0;
	  /* Insert new strings in the hash table only if the match length is not
	   * greater than this length. This saves time but degrades compression.
	   * max_insert_length is used only for compression levels <= 3.
	   */

	  this.level = 0;     /* compression level (1..9) */
	  this.strategy = 0;  /* favor or force Huffman coding*/

	  this.good_match = 0;
	  /* Use a faster search when the previous match is longer than this */

	  this.nice_match = 0; /* Stop searching when current match exceeds this */

	              /* used by trees.c: */

	  /* Didn't use ct_data typedef below to suppress compiler warning */

	  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
	  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
	  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

	  // Use flat array of DOUBLE size, with interleaved fata,
	  // because JS does not support effective
	  this.dyn_ltree  = new common$2.Buf16(HEAP_SIZE$1 * 2);
	  this.dyn_dtree  = new common$2.Buf16((2 * D_CODES$1 + 1) * 2);
	  this.bl_tree    = new common$2.Buf16((2 * BL_CODES$1 + 1) * 2);
	  zero$1(this.dyn_ltree);
	  zero$1(this.dyn_dtree);
	  zero$1(this.bl_tree);

	  this.l_desc   = null;         /* desc. for literal tree */
	  this.d_desc   = null;         /* desc. for distance tree */
	  this.bl_desc  = null;         /* desc. for bit length tree */

	  //ush bl_count[MAX_BITS+1];
	  this.bl_count = new common$2.Buf16(MAX_BITS$1 + 1);
	  /* number of codes at each bit length for an optimal tree */

	  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
	  this.heap = new common$2.Buf16(2 * L_CODES$1 + 1);  /* heap used to build the Huffman trees */
	  zero$1(this.heap);

	  this.heap_len = 0;               /* number of elements in the heap */
	  this.heap_max = 0;               /* element of largest frequency */
	  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
	   * The same heap array is used to build all trees.
	   */

	  this.depth = new common$2.Buf16(2 * L_CODES$1 + 1); //uch depth[2*L_CODES+1];
	  zero$1(this.depth);
	  /* Depth of each subtree used as tie breaker for trees of equal frequency
	   */

	  this.l_buf = 0;          /* buffer index for literals or lengths */

	  this.lit_bufsize = 0;
	  /* Size of match buffer for literals/lengths.  There are 4 reasons for
	   * limiting lit_bufsize to 64K:
	   *   - frequencies can be kept in 16 bit counters
	   *   - if compression is not successful for the first block, all input
	   *     data is still in the window so we can still emit a stored block even
	   *     when input comes from standard input.  (This can also be done for
	   *     all blocks if lit_bufsize is not greater than 32K.)
	   *   - if compression is not successful for a file smaller than 64K, we can
	   *     even emit a stored file instead of a stored block (saving 5 bytes).
	   *     This is applicable only for zip (not gzip or zlib).
	   *   - creating new Huffman trees less frequently may not provide fast
	   *     adaptation to changes in the input data statistics. (Take for
	   *     example a binary file with poorly compressible code followed by
	   *     a highly compressible string table.) Smaller buffer sizes give
	   *     fast adaptation but have of course the overhead of transmitting
	   *     trees more frequently.
	   *   - I can't count above 4
	   */

	  this.last_lit = 0;      /* running index in l_buf */

	  this.d_buf = 0;
	  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
	   * the same number of elements. To use different lengths, an extra flag
	   * array would be necessary.
	   */

	  this.opt_len = 0;       /* bit length of current block with optimal trees */
	  this.static_len = 0;    /* bit length of current block with static trees */
	  this.matches = 0;       /* number of string matches in current block */
	  this.insert = 0;        /* bytes at end of window left to insert */


	  this.bi_buf = 0;
	  /* Output buffer. bits are inserted starting at the bottom (least
	   * significant bits).
	   */
	  this.bi_valid = 0;
	  /* Number of valid bits in bi_buf.  All bits above the last valid bit
	   * are always zero.
	   */

	  // Used for window memory init. We safely ignore it for JS. That makes
	  // sense only for pointers and memory check tools.
	  //this.high_water = 0;
	  /* High water mark offset in window for initialized bytes -- bytes above
	   * this are set to zero in order to avoid memory check warnings when
	   * longest match routines access bytes past the input.  This is then
	   * updated to the new high water mark.
	   */
	}


	function deflateResetKeep(strm) {
	  var s;

	  if (!strm || !strm.state) {
	    return err(strm, Z_STREAM_ERROR);
	  }

	  strm.total_in = strm.total_out = 0;
	  strm.data_type = Z_UNKNOWN$1;

	  s = strm.state;
	  s.pending = 0;
	  s.pending_out = 0;

	  if (s.wrap < 0) {
	    s.wrap = -s.wrap;
	    /* was made negative by deflate(..., Z_FINISH); */
	  }
	  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
	  strm.adler = (s.wrap === 2) ?
	    0  // crc32(0, Z_NULL, 0)
	  :
	    1; // adler32(0, Z_NULL, 0)
	  s.last_flush = Z_NO_FLUSH;
	  trees._tr_init(s);
	  return Z_OK;
	}


	function deflateReset(strm) {
	  var ret = deflateResetKeep(strm);
	  if (ret === Z_OK) {
	    lm_init(strm.state);
	  }
	  return ret;
	}


	function deflateSetHeader(strm, head) {
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
	  strm.state.gzhead = head;
	  return Z_OK;
	}


	function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
	  if (!strm) { // === Z_NULL
	    return Z_STREAM_ERROR;
	  }
	  var wrap = 1;

	  if (level === Z_DEFAULT_COMPRESSION) {
	    level = 6;
	  }

	  if (windowBits < 0) { /* suppress zlib wrapper */
	    wrap = 0;
	    windowBits = -windowBits;
	  }

	  else if (windowBits > 15) {
	    wrap = 2;           /* write gzip wrapper instead */
	    windowBits -= 16;
	  }


	  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
	    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
	    strategy < 0 || strategy > Z_FIXED$1) {
	    return err(strm, Z_STREAM_ERROR);
	  }


	  if (windowBits === 8) {
	    windowBits = 9;
	  }
	  /* until 256-byte window bug fixed */

	  var s = new DeflateState();

	  strm.state = s;
	  s.strm = strm;

	  s.wrap = wrap;
	  s.gzhead = null;
	  s.w_bits = windowBits;
	  s.w_size = 1 << s.w_bits;
	  s.w_mask = s.w_size - 1;

	  s.hash_bits = memLevel + 7;
	  s.hash_size = 1 << s.hash_bits;
	  s.hash_mask = s.hash_size - 1;
	  s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1);

	  s.window = new common$2.Buf8(s.w_size * 2);
	  s.head = new common$2.Buf16(s.hash_size);
	  s.prev = new common$2.Buf16(s.w_size);

	  // Don't need mem init magic for JS.
	  //s.high_water = 0;  /* nothing written to s->window yet */

	  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

	  s.pending_buf_size = s.lit_bufsize * 4;

	  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
	  //s->pending_buf = (uchf *) overlay;
	  s.pending_buf = new common$2.Buf8(s.pending_buf_size);

	  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
	  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
	  s.d_buf = 1 * s.lit_bufsize;

	  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
	  s.l_buf = (1 + 2) * s.lit_bufsize;

	  s.level = level;
	  s.strategy = strategy;
	  s.method = method;

	  return deflateReset(strm);
	}

	function deflateInit(strm, level) {
	  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
	}


	function deflate(strm, flush) {
	  var old_flush, s;
	  var beg, val; // for gzip header write only

	  if (!strm || !strm.state ||
	    flush > Z_BLOCK || flush < 0) {
	    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
	  }

	  s = strm.state;

	  if (!strm.output ||
	      (!strm.input && strm.avail_in !== 0) ||
	      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
	    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
	  }

	  s.strm = strm; /* just in case */
	  old_flush = s.last_flush;
	  s.last_flush = flush;

	  /* Write the header */
	  if (s.status === INIT_STATE) {

	    if (s.wrap === 2) { // GZIP header
	      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
	      put_byte(s, 31);
	      put_byte(s, 139);
	      put_byte(s, 8);
	      if (!s.gzhead) { // s->gzhead == Z_NULL
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, s.level === 9 ? 2 :
	                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
	                     4 : 0));
	        put_byte(s, OS_CODE);
	        s.status = BUSY_STATE;
	      }
	      else {
	        put_byte(s, (s.gzhead.text ? 1 : 0) +
	                    (s.gzhead.hcrc ? 2 : 0) +
	                    (!s.gzhead.extra ? 0 : 4) +
	                    (!s.gzhead.name ? 0 : 8) +
	                    (!s.gzhead.comment ? 0 : 16)
	        );
	        put_byte(s, s.gzhead.time & 0xff);
	        put_byte(s, (s.gzhead.time >> 8) & 0xff);
	        put_byte(s, (s.gzhead.time >> 16) & 0xff);
	        put_byte(s, (s.gzhead.time >> 24) & 0xff);
	        put_byte(s, s.level === 9 ? 2 :
	                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
	                     4 : 0));
	        put_byte(s, s.gzhead.os & 0xff);
	        if (s.gzhead.extra && s.gzhead.extra.length) {
	          put_byte(s, s.gzhead.extra.length & 0xff);
	          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
	        }
	        if (s.gzhead.hcrc) {
	          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
	        }
	        s.gzindex = 0;
	        s.status = EXTRA_STATE;
	      }
	    }
	    else // DEFLATE header
	    {
	      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
	      var level_flags = -1;

	      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
	        level_flags = 0;
	      } else if (s.level < 6) {
	        level_flags = 1;
	      } else if (s.level === 6) {
	        level_flags = 2;
	      } else {
	        level_flags = 3;
	      }
	      header |= (level_flags << 6);
	      if (s.strstart !== 0) { header |= PRESET_DICT; }
	      header += 31 - (header % 31);

	      s.status = BUSY_STATE;
	      putShortMSB(s, header);

	      /* Save the adler32 of the preset dictionary: */
	      if (s.strstart !== 0) {
	        putShortMSB(s, strm.adler >>> 16);
	        putShortMSB(s, strm.adler & 0xffff);
	      }
	      strm.adler = 1; // adler32(0L, Z_NULL, 0);
	    }
	  }

	//#ifdef GZIP
	  if (s.status === EXTRA_STATE) {
	    if (s.gzhead.extra/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */

	      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            break;
	          }
	        }
	        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
	        s.gzindex++;
	      }
	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (s.gzindex === s.gzhead.extra.length) {
	        s.gzindex = 0;
	        s.status = NAME_STATE;
	      }
	    }
	    else {
	      s.status = NAME_STATE;
	    }
	  }
	  if (s.status === NAME_STATE) {
	    if (s.gzhead.name/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	      //int val;

	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.name.length) {
	          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);

	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.gzindex = 0;
	        s.status = COMMENT_STATE;
	      }
	    }
	    else {
	      s.status = COMMENT_STATE;
	    }
	  }
	  if (s.status === COMMENT_STATE) {
	    if (s.gzhead.comment/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	      //int val;

	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.comment.length) {
	          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);

	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.status = HCRC_STATE;
	      }
	    }
	    else {
	      s.status = HCRC_STATE;
	    }
	  }
	  if (s.status === HCRC_STATE) {
	    if (s.gzhead.hcrc) {
	      if (s.pending + 2 > s.pending_buf_size) {
	        flush_pending(strm);
	      }
	      if (s.pending + 2 <= s.pending_buf_size) {
	        put_byte(s, strm.adler & 0xff);
	        put_byte(s, (strm.adler >> 8) & 0xff);
	        strm.adler = 0; //crc32(0L, Z_NULL, 0);
	        s.status = BUSY_STATE;
	      }
	    }
	    else {
	      s.status = BUSY_STATE;
	    }
	  }
	//#endif

	  /* Flush as much pending output as possible */
	  if (s.pending !== 0) {
	    flush_pending(strm);
	    if (strm.avail_out === 0) {
	      /* Since avail_out is 0, deflate will be called again with
	       * more output space, but possibly with both pending and
	       * avail_in equal to zero. There won't be anything to do,
	       * but this is not an error situation so make sure we
	       * return OK instead of BUF_ERROR at next call of deflate:
	       */
	      s.last_flush = -1;
	      return Z_OK;
	    }

	    /* Make sure there is something to do and avoid duplicate consecutive
	     * flushes. For repeated and useless calls with Z_FINISH, we keep
	     * returning Z_STREAM_END instead of Z_BUF_ERROR.
	     */
	  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
	    flush !== Z_FINISH) {
	    return err(strm, Z_BUF_ERROR);
	  }

	  /* User must not provide more input after the first FINISH: */
	  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
	    return err(strm, Z_BUF_ERROR);
	  }

	  /* Start a new block or continue the current one.
	   */
	  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
	    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
	    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
	      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
	        configuration_table[s.level].func(s, flush));

	    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
	      s.status = FINISH_STATE;
	    }
	    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
	      if (strm.avail_out === 0) {
	        s.last_flush = -1;
	        /* avoid BUF_ERROR next call, see above */
	      }
	      return Z_OK;
	      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
	       * of deflate should use the same flush parameter to make sure
	       * that the flush is complete. So we don't have to output an
	       * empty block here, this will be done at next call. This also
	       * ensures that for a very small output buffer, we emit at most
	       * one empty block.
	       */
	    }
	    if (bstate === BS_BLOCK_DONE) {
	      if (flush === Z_PARTIAL_FLUSH) {
	        trees._tr_align(s);
	      }
	      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

	        trees._tr_stored_block(s, 0, 0, false);
	        /* For a full flush, this empty block will be recognized
	         * as a special marker by inflate_sync().
	         */
	        if (flush === Z_FULL_FLUSH) {
	          /*** CLEAR_HASH(s); ***/             /* forget history */
	          zero$1(s.head); // Fill with NIL (= 0);

	          if (s.lookahead === 0) {
	            s.strstart = 0;
	            s.block_start = 0;
	            s.insert = 0;
	          }
	        }
	      }
	      flush_pending(strm);
	      if (strm.avail_out === 0) {
	        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
	        return Z_OK;
	      }
	    }
	  }
	  //Assert(strm->avail_out > 0, "bug2");
	  //if (strm.avail_out <= 0) { throw new Error("bug2");}

	  if (flush !== Z_FINISH) { return Z_OK; }
	  if (s.wrap <= 0) { return Z_STREAM_END; }

	  /* Write the trailer */
	  if (s.wrap === 2) {
	    put_byte(s, strm.adler & 0xff);
	    put_byte(s, (strm.adler >> 8) & 0xff);
	    put_byte(s, (strm.adler >> 16) & 0xff);
	    put_byte(s, (strm.adler >> 24) & 0xff);
	    put_byte(s, strm.total_in & 0xff);
	    put_byte(s, (strm.total_in >> 8) & 0xff);
	    put_byte(s, (strm.total_in >> 16) & 0xff);
	    put_byte(s, (strm.total_in >> 24) & 0xff);
	  }
	  else
	  {
	    putShortMSB(s, strm.adler >>> 16);
	    putShortMSB(s, strm.adler & 0xffff);
	  }

	  flush_pending(strm);
	  /* If avail_out is zero, the application will call deflate again
	   * to flush the rest.
	   */
	  if (s.wrap > 0) { s.wrap = -s.wrap; }
	  /* write the trailer only once! */
	  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
	}

	function deflateEnd(strm) {
	  var status;

	  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
	    return Z_STREAM_ERROR;
	  }

	  status = strm.state.status;
	  if (status !== INIT_STATE &&
	    status !== EXTRA_STATE &&
	    status !== NAME_STATE &&
	    status !== COMMENT_STATE &&
	    status !== HCRC_STATE &&
	    status !== BUSY_STATE &&
	    status !== FINISH_STATE
	  ) {
	    return err(strm, Z_STREAM_ERROR);
	  }

	  strm.state = null;

	  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
	}


	/* =========================================================================
	 * Initializes the compression dictionary from the given byte
	 * sequence without producing any compressed output.
	 */
	function deflateSetDictionary(strm, dictionary) {
	  var dictLength = dictionary.length;

	  var s;
	  var str, n;
	  var wrap;
	  var avail;
	  var next;
	  var input;
	  var tmpDict;

	  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
	    return Z_STREAM_ERROR;
	  }

	  s = strm.state;
	  wrap = s.wrap;

	  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
	    return Z_STREAM_ERROR;
	  }

	  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
	  if (wrap === 1) {
	    /* adler32(strm->adler, dictionary, dictLength); */
	    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
	  }

	  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

	  /* if dictionary would fill window, just replace the history */
	  if (dictLength >= s.w_size) {
	    if (wrap === 0) {            /* already empty otherwise */
	      /*** CLEAR_HASH(s); ***/
	      zero$1(s.head); // Fill with NIL (= 0);
	      s.strstart = 0;
	      s.block_start = 0;
	      s.insert = 0;
	    }
	    /* use the tail */
	    // dictionary = dictionary.slice(dictLength - s.w_size);
	    tmpDict = new common$2.Buf8(s.w_size);
	    common$2.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
	    dictionary = tmpDict;
	    dictLength = s.w_size;
	  }
	  /* insert dictionary into window and hash */
	  avail = strm.avail_in;
	  next = strm.next_in;
	  input = strm.input;
	  strm.avail_in = dictLength;
	  strm.next_in = 0;
	  strm.input = dictionary;
	  fill_window(s);
	  while (s.lookahead >= MIN_MATCH$1) {
	    str = s.strstart;
	    n = s.lookahead - (MIN_MATCH$1 - 1);
	    do {
	      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH$1 - 1]) & s.hash_mask;

	      s.prev[str & s.w_mask] = s.head[s.ins_h];

	      s.head[s.ins_h] = str;
	      str++;
	    } while (--n);
	    s.strstart = str;
	    s.lookahead = MIN_MATCH$1 - 1;
	    fill_window(s);
	  }
	  s.strstart += s.lookahead;
	  s.block_start = s.strstart;
	  s.insert = s.lookahead;
	  s.lookahead = 0;
	  s.match_length = s.prev_length = MIN_MATCH$1 - 1;
	  s.match_available = 0;
	  strm.next_in = next;
	  strm.input = input;
	  strm.avail_in = avail;
	  s.wrap = wrap;
	  return Z_OK;
	}


	var deflateInit_1 = deflateInit;
	var deflateInit2_1 = deflateInit2;
	var deflateReset_1 = deflateReset;
	var deflateResetKeep_1 = deflateResetKeep;
	var deflateSetHeader_1 = deflateSetHeader;
	var deflate_2 = deflate;
	var deflateEnd_1 = deflateEnd;
	var deflateSetDictionary_1 = deflateSetDictionary;
	var deflateInfo = 'pako deflate (from Nodeca project)';

	/* Not implemented
	exports.deflateBound = deflateBound;
	exports.deflateCopy = deflateCopy;
	exports.deflateParams = deflateParams;
	exports.deflatePending = deflatePending;
	exports.deflatePrime = deflatePrime;
	exports.deflateTune = deflateTune;
	*/

	var deflate_1 = {
		deflateInit: deflateInit_1,
		deflateInit2: deflateInit2_1,
		deflateReset: deflateReset_1,
		deflateResetKeep: deflateResetKeep_1,
		deflateSetHeader: deflateSetHeader_1,
		deflate: deflate_2,
		deflateEnd: deflateEnd_1,
		deflateSetDictionary: deflateSetDictionary_1,
		deflateInfo: deflateInfo
	};

	// Quick check if we can use fast array to bin string conversion
	//
	// - apply(Array) can fail on Android 2.2
	// - apply(Uint8Array) can fail on iOS 5.1 Safari
	//
	var STR_APPLY_OK = true;
	var STR_APPLY_UIA_OK = true;

	try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
	try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


	// Table with utf8 lengths (calculated by first byte of sequence)
	// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
	// because max possible codepoint is 0x10ffff
	var _utf8len = new common$2.Buf8(256);
	for (var q = 0; q < 256; q++) {
	  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
	}
	_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


	// convert string to array (typed, when possible)
	var string2buf = function (str) {
	  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

	  // count binary size
	  for (m_pos = 0; m_pos < str_len; m_pos++) {
	    c = str.charCodeAt(m_pos);
	    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
	      c2 = str.charCodeAt(m_pos + 1);
	      if ((c2 & 0xfc00) === 0xdc00) {
	        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
	        m_pos++;
	      }
	    }
	    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
	  }

	  // allocate buffer
	  buf = new common$2.Buf8(buf_len);

	  // convert
	  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
	    c = str.charCodeAt(m_pos);
	    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
	      c2 = str.charCodeAt(m_pos + 1);
	      if ((c2 & 0xfc00) === 0xdc00) {
	        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
	        m_pos++;
	      }
	    }
	    if (c < 0x80) {
	      /* one byte */
	      buf[i++] = c;
	    } else if (c < 0x800) {
	      /* two bytes */
	      buf[i++] = 0xC0 | (c >>> 6);
	      buf[i++] = 0x80 | (c & 0x3f);
	    } else if (c < 0x10000) {
	      /* three bytes */
	      buf[i++] = 0xE0 | (c >>> 12);
	      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
	      buf[i++] = 0x80 | (c & 0x3f);
	    } else {
	      /* four bytes */
	      buf[i++] = 0xf0 | (c >>> 18);
	      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
	      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
	      buf[i++] = 0x80 | (c & 0x3f);
	    }
	  }

	  return buf;
	};

	// Helper (used in 2 places)
	function buf2binstring(buf, len) {
	  // On Chrome, the arguments in a function call that are allowed is `65534`.
	  // If the length of the buffer is smaller than that, we can use this optimization,
	  // otherwise we will take a slower path.
	  if (len < 65534) {
	    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
	      return String.fromCharCode.apply(null, common$2.shrinkBuf(buf, len));
	    }
	  }

	  var result = '';
	  for (var i = 0; i < len; i++) {
	    result += String.fromCharCode(buf[i]);
	  }
	  return result;
	}


	// Convert byte array to binary string
	var buf2binstring_1 = function (buf) {
	  return buf2binstring(buf, buf.length);
	};


	// Convert binary string (typed, when possible)
	var binstring2buf = function (str) {
	  var buf = new common$2.Buf8(str.length);
	  for (var i = 0, len = buf.length; i < len; i++) {
	    buf[i] = str.charCodeAt(i);
	  }
	  return buf;
	};


	// convert array to string
	var buf2string = function (buf, max) {
	  var i, out, c, c_len;
	  var len = max || buf.length;

	  // Reserve max possible length (2 words per char)
	  // NB: by unknown reasons, Array is significantly faster for
	  //     String.fromCharCode.apply than Uint16Array.
	  var utf16buf = new Array(len * 2);

	  for (out = 0, i = 0; i < len;) {
	    c = buf[i++];
	    // quick process ascii
	    if (c < 0x80) { utf16buf[out++] = c; continue; }

	    c_len = _utf8len[c];
	    // skip 5 & 6 byte codes
	    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

	    // apply mask on first byte
	    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
	    // join the rest
	    while (c_len > 1 && i < len) {
	      c = (c << 6) | (buf[i++] & 0x3f);
	      c_len--;
	    }

	    // terminated by end of string?
	    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

	    if (c < 0x10000) {
	      utf16buf[out++] = c;
	    } else {
	      c -= 0x10000;
	      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
	      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
	    }
	  }

	  return buf2binstring(utf16buf, out);
	};


	// Calculate max possible position in utf8 buffer,
	// that will not break sequence. If that's not possible
	// - (very small limits) return max size as is.
	//
	// buf[] - utf8 bytes array
	// max   - length limit (mandatory);
	var utf8border = function (buf, max) {
	  var pos;

	  max = max || buf.length;
	  if (max > buf.length) { max = buf.length; }

	  // go back from last position, until start of sequence found
	  pos = max - 1;
	  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

	  // Very small and broken sequence,
	  // return max, because we should return something anyway.
	  if (pos < 0) { return max; }

	  // If we came to start of buffer - that means buffer is too small,
	  // return max too.
	  if (pos === 0) { return max; }

	  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
	};

	var strings = {
		string2buf: string2buf,
		buf2binstring: buf2binstring_1,
		binstring2buf: binstring2buf,
		buf2string: buf2string,
		utf8border: utf8border
	};

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	function ZStream() {
	  /* next input byte */
	  this.input = null; // JS specific, because we have no pointers
	  this.next_in = 0;
	  /* number of bytes available at input */
	  this.avail_in = 0;
	  /* total number of input bytes read so far */
	  this.total_in = 0;
	  /* next output byte should be put there */
	  this.output = null; // JS specific, because we have no pointers
	  this.next_out = 0;
	  /* remaining free space at output */
	  this.avail_out = 0;
	  /* total number of bytes output so far */
	  this.total_out = 0;
	  /* last error message, NULL if no error */
	  this.msg = ''/*Z_NULL*/;
	  /* not visible by applications */
	  this.state = null;
	  /* best guess about the data type: binary or text */
	  this.data_type = 2/*Z_UNKNOWN*/;
	  /* adler32 value of the uncompressed data */
	  this.adler = 0;
	}

	var zstream = ZStream;

	var toString$6 = Object.prototype.toString;

	/* Public constants ==========================================================*/
	/* ===========================================================================*/

	var Z_NO_FLUSH$1      = 0;
	var Z_FINISH$1        = 4;

	var Z_OK$1            = 0;
	var Z_STREAM_END$1    = 1;
	var Z_SYNC_FLUSH    = 2;

	var Z_DEFAULT_COMPRESSION$1 = -1;

	var Z_DEFAULT_STRATEGY$1    = 0;

	var Z_DEFLATED$1  = 8;

	/* ===========================================================================*/


	/**
	 * class Deflate
	 *
	 * Generic JS-style wrapper for zlib calls. If you don't need
	 * streaming behaviour - use more simple functions: [[deflate]],
	 * [[deflateRaw]] and [[gzip]].
	 **/

	/* internal
	 * Deflate.chunks -> Array
	 *
	 * Chunks of output data, if [[Deflate#onData]] not overridden.
	 **/

	/**
	 * Deflate.result -> Uint8Array|Array
	 *
	 * Compressed result, generated by default [[Deflate#onData]]
	 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
	 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
	 * push a chunk with explicit flush (call [[Deflate#push]] with
	 * `Z_SYNC_FLUSH` param).
	 **/

	/**
	 * Deflate.err -> Number
	 *
	 * Error code after deflate finished. 0 (Z_OK) on success.
	 * You will not need it in real life, because deflate errors
	 * are possible only on wrong options or bad `onData` / `onEnd`
	 * custom handlers.
	 **/

	/**
	 * Deflate.msg -> String
	 *
	 * Error message, if [[Deflate.err]] != 0
	 **/


	/**
	 * new Deflate(options)
	 * - options (Object): zlib deflate options.
	 *
	 * Creates new deflator instance with specified params. Throws exception
	 * on bad params. Supported options:
	 *
	 * - `level`
	 * - `windowBits`
	 * - `memLevel`
	 * - `strategy`
	 * - `dictionary`
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information on these.
	 *
	 * Additional options, for internal needs:
	 *
	 * - `chunkSize` - size of generated data chunks (16K by default)
	 * - `raw` (Boolean) - do raw deflate
	 * - `gzip` (Boolean) - create gzip wrapper
	 * - `to` (String) - if equal to 'string', then result will be "binary string"
	 *    (each char code [0..255])
	 * - `header` (Object) - custom header for gzip
	 *   - `text` (Boolean) - true if compressed data believed to be text
	 *   - `time` (Number) - modification time, unix timestamp
	 *   - `os` (Number) - operation system code
	 *   - `extra` (Array) - array of bytes with extra data (max 65536)
	 *   - `name` (String) - file name (binary string)
	 *   - `comment` (String) - comment (binary string)
	 *   - `hcrc` (Boolean) - true if header crc should be added
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
	 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
	 *
	 * var deflate = new pako.Deflate({ level: 3});
	 *
	 * deflate.push(chunk1, false);
	 * deflate.push(chunk2, true);  // true -> last chunk
	 *
	 * if (deflate.err) { throw new Error(deflate.err); }
	 *
	 * console.log(deflate.result);
	 * ```
	 **/
	function Deflate(options) {
	  if (!(this instanceof Deflate)) return new Deflate(options);

	  this.options = common$2.assign({
	    level: Z_DEFAULT_COMPRESSION$1,
	    method: Z_DEFLATED$1,
	    chunkSize: 16384,
	    windowBits: 15,
	    memLevel: 8,
	    strategy: Z_DEFAULT_STRATEGY$1,
	    to: ''
	  }, options || {});

	  var opt = this.options;

	  if (opt.raw && (opt.windowBits > 0)) {
	    opt.windowBits = -opt.windowBits;
	  }

	  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
	    opt.windowBits += 16;
	  }

	  this.err    = 0;      // error code, if happens (0 = Z_OK)
	  this.msg    = '';     // error message
	  this.ended  = false;  // used to avoid multiple onEnd() calls
	  this.chunks = [];     // chunks of compressed data

	  this.strm = new zstream();
	  this.strm.avail_out = 0;

	  var status = deflate_1.deflateInit2(
	    this.strm,
	    opt.level,
	    opt.method,
	    opt.windowBits,
	    opt.memLevel,
	    opt.strategy
	  );

	  if (status !== Z_OK$1) {
	    throw new Error(messages[status]);
	  }

	  if (opt.header) {
	    deflate_1.deflateSetHeader(this.strm, opt.header);
	  }

	  if (opt.dictionary) {
	    var dict;
	    // Convert data if needed
	    if (typeof opt.dictionary === 'string') {
	      // If we need to compress text, change encoding to utf8.
	      dict = strings.string2buf(opt.dictionary);
	    } else if (toString$6.call(opt.dictionary) === '[object ArrayBuffer]') {
	      dict = new Uint8Array(opt.dictionary);
	    } else {
	      dict = opt.dictionary;
	    }

	    status = deflate_1.deflateSetDictionary(this.strm, dict);

	    if (status !== Z_OK$1) {
	      throw new Error(messages[status]);
	    }

	    this._dict_set = true;
	  }
	}

	/**
	 * Deflate#push(data[, mode]) -> Boolean
	 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
	 *   converted to utf8 byte sequence.
	 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
	 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
	 *
	 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
	 * new compressed chunks. Returns `true` on success. The last data block must have
	 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
	 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
	 * can use mode Z_SYNC_FLUSH, keeping the compression context.
	 *
	 * On fail call [[Deflate#onEnd]] with error code and return false.
	 *
	 * We strongly recommend to use `Uint8Array` on input for best speed (output
	 * array format is detected automatically). Also, don't skip last param and always
	 * use the same type in your code (boolean or number). That will improve JS speed.
	 *
	 * For regular `Array`-s make sure all elements are [0..255].
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * push(chunk, false); // push one of data chunks
	 * ...
	 * push(chunk, true);  // push last chunk
	 * ```
	 **/
	Deflate.prototype.push = function (data, mode) {
	  var strm = this.strm;
	  var chunkSize = this.options.chunkSize;
	  var status, _mode;

	  if (this.ended) { return false; }

	  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH$1 : Z_NO_FLUSH$1);

	  // Convert data if needed
	  if (typeof data === 'string') {
	    // If we need to compress text, change encoding to utf8.
	    strm.input = strings.string2buf(data);
	  } else if (toString$6.call(data) === '[object ArrayBuffer]') {
	    strm.input = new Uint8Array(data);
	  } else {
	    strm.input = data;
	  }

	  strm.next_in = 0;
	  strm.avail_in = strm.input.length;

	  do {
	    if (strm.avail_out === 0) {
	      strm.output = new common$2.Buf8(chunkSize);
	      strm.next_out = 0;
	      strm.avail_out = chunkSize;
	    }
	    status = deflate_1.deflate(strm, _mode);    /* no bad return value */

	    if (status !== Z_STREAM_END$1 && status !== Z_OK$1) {
	      this.onEnd(status);
	      this.ended = true;
	      return false;
	    }
	    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH$1 || _mode === Z_SYNC_FLUSH))) {
	      if (this.options.to === 'string') {
	        this.onData(strings.buf2binstring(common$2.shrinkBuf(strm.output, strm.next_out)));
	      } else {
	        this.onData(common$2.shrinkBuf(strm.output, strm.next_out));
	      }
	    }
	  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END$1);

	  // Finalize on the last chunk.
	  if (_mode === Z_FINISH$1) {
	    status = deflate_1.deflateEnd(this.strm);
	    this.onEnd(status);
	    this.ended = true;
	    return status === Z_OK$1;
	  }

	  // callback interim results if Z_SYNC_FLUSH.
	  if (_mode === Z_SYNC_FLUSH) {
	    this.onEnd(Z_OK$1);
	    strm.avail_out = 0;
	    return true;
	  }

	  return true;
	};


	/**
	 * Deflate#onData(chunk) -> Void
	 * - chunk (Uint8Array|Array|String): output data. Type of array depends
	 *   on js engine support. When string output requested, each chunk
	 *   will be string.
	 *
	 * By default, stores data blocks in `chunks[]` property and glue
	 * those in `onEnd`. Override this handler, if you need another behaviour.
	 **/
	Deflate.prototype.onData = function (chunk) {
	  this.chunks.push(chunk);
	};


	/**
	 * Deflate#onEnd(status) -> Void
	 * - status (Number): deflate status. 0 (Z_OK) on success,
	 *   other if not.
	 *
	 * Called once after you tell deflate that the input stream is
	 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
	 * or if an error happened. By default - join collected chunks,
	 * free memory and fill `results` / `err` properties.
	 **/
	Deflate.prototype.onEnd = function (status) {
	  // On success - join
	  if (status === Z_OK$1) {
	    if (this.options.to === 'string') {
	      this.result = this.chunks.join('');
	    } else {
	      this.result = common$2.flattenChunks(this.chunks);
	    }
	  }
	  this.chunks = [];
	  this.err = status;
	  this.msg = this.strm.msg;
	};


	/**
	 * deflate(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to compress.
	 * - options (Object): zlib deflate options.
	 *
	 * Compress `data` with deflate algorithm and `options`.
	 *
	 * Supported options are:
	 *
	 * - level
	 * - windowBits
	 * - memLevel
	 * - strategy
	 * - dictionary
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information on these.
	 *
	 * Sugar (options):
	 *
	 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
	 *   negative windowBits implicitly.
	 * - `to` (String) - if equal to 'string', then result will be "binary string"
	 *    (each char code [0..255])
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
	 *
	 * console.log(pako.deflate(data));
	 * ```
	 **/
	function deflate$1(input, options) {
	  var deflator = new Deflate(options);

	  deflator.push(input, true);

	  // That will never happens, if you don't cheat with options :)
	  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }

	  return deflator.result;
	}


	/**
	 * deflateRaw(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to compress.
	 * - options (Object): zlib deflate options.
	 *
	 * The same as [[deflate]], but creates raw data, without wrapper
	 * (header and adler32 crc).
	 **/
	function deflateRaw(input, options) {
	  options = options || {};
	  options.raw = true;
	  return deflate$1(input, options);
	}


	/**
	 * gzip(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to compress.
	 * - options (Object): zlib deflate options.
	 *
	 * The same as [[deflate]], but create gzip wrapper instead of
	 * deflate one.
	 **/
	function gzip(input, options) {
	  options = options || {};
	  options.gzip = true;
	  return deflate$1(input, options);
	}


	var Deflate_1 = Deflate;
	var deflate_2$1 = deflate$1;
	var deflateRaw_1 = deflateRaw;
	var gzip_1 = gzip;

	var deflate_1$1 = {
		Deflate: Deflate_1,
		deflate: deflate_2$1,
		deflateRaw: deflateRaw_1,
		gzip: gzip_1
	};

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	// See state defs from inflate.js
	var BAD = 30;       /* got a data error -- remain here until reset */
	var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

	/*
	   Decode literal, length, and distance codes and write out the resulting
	   literal and match bytes until either not enough input or output is
	   available, an end-of-block is encountered, or a data error is encountered.
	   When large enough input and output buffers are supplied to inflate(), for
	   example, a 16K input buffer and a 64K output buffer, more than 95% of the
	   inflate execution time is spent in this routine.

	   Entry assumptions:

	        state.mode === LEN
	        strm.avail_in >= 6
	        strm.avail_out >= 258
	        start >= strm.avail_out
	        state.bits < 8

	   On return, state.mode is one of:

	        LEN -- ran out of enough output space or enough available input
	        TYPE -- reached end of block code, inflate() to interpret next block
	        BAD -- error in block data

	   Notes:

	    - The maximum input bits used by a length/distance pair is 15 bits for the
	      length code, 5 bits for the length extra, 15 bits for the distance code,
	      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
	      Therefore if strm.avail_in >= 6, then there is enough input to avoid
	      checking for available input while decoding.

	    - The maximum bytes that a single length/distance pair can output is 258
	      bytes, which is the maximum length that can be coded.  inflate_fast()
	      requires strm.avail_out >= 258 for each loop to avoid checking for
	      output space.
	 */
	var inffast = function inflate_fast(strm, start) {
	  var state;
	  var _in;                    /* local strm.input */
	  var last;                   /* have enough input while in < last */
	  var _out;                   /* local strm.output */
	  var beg;                    /* inflate()'s initial strm.output */
	  var end;                    /* while out < end, enough space available */
	//#ifdef INFLATE_STRICT
	  var dmax;                   /* maximum distance from zlib header */
	//#endif
	  var wsize;                  /* window size or zero if not using window */
	  var whave;                  /* valid bytes in the window */
	  var wnext;                  /* window write index */
	  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
	  var s_window;               /* allocated sliding window, if wsize != 0 */
	  var hold;                   /* local strm.hold */
	  var bits;                   /* local strm.bits */
	  var lcode;                  /* local strm.lencode */
	  var dcode;                  /* local strm.distcode */
	  var lmask;                  /* mask for first level of length codes */
	  var dmask;                  /* mask for first level of distance codes */
	  var here;                   /* retrieved table entry */
	  var op;                     /* code bits, operation, extra bits, or */
	                              /*  window position, window bytes to copy */
	  var len;                    /* match length, unused bytes */
	  var dist;                   /* match distance */
	  var from;                   /* where to copy match from */
	  var from_source;


	  var input, output; // JS specific, because we have no pointers

	  /* copy state to local variables */
	  state = strm.state;
	  //here = state.here;
	  _in = strm.next_in;
	  input = strm.input;
	  last = _in + (strm.avail_in - 5);
	  _out = strm.next_out;
	  output = strm.output;
	  beg = _out - (start - strm.avail_out);
	  end = _out + (strm.avail_out - 257);
	//#ifdef INFLATE_STRICT
	  dmax = state.dmax;
	//#endif
	  wsize = state.wsize;
	  whave = state.whave;
	  wnext = state.wnext;
	  s_window = state.window;
	  hold = state.hold;
	  bits = state.bits;
	  lcode = state.lencode;
	  dcode = state.distcode;
	  lmask = (1 << state.lenbits) - 1;
	  dmask = (1 << state.distbits) - 1;


	  /* decode literals and length/distances until end-of-block or not enough
	     input data or output space */

	  top:
	  do {
	    if (bits < 15) {
	      hold += input[_in++] << bits;
	      bits += 8;
	      hold += input[_in++] << bits;
	      bits += 8;
	    }

	    here = lcode[hold & lmask];

	    dolen:
	    for (;;) { // Goto emulation
	      op = here >>> 24/*here.bits*/;
	      hold >>>= op;
	      bits -= op;
	      op = (here >>> 16) & 0xff/*here.op*/;
	      if (op === 0) {                          /* literal */
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        output[_out++] = here & 0xffff/*here.val*/;
	      }
	      else if (op & 16) {                     /* length base */
	        len = here & 0xffff/*here.val*/;
	        op &= 15;                           /* number of extra bits */
	        if (op) {
	          if (bits < op) {
	            hold += input[_in++] << bits;
	            bits += 8;
	          }
	          len += hold & ((1 << op) - 1);
	          hold >>>= op;
	          bits -= op;
	        }
	        //Tracevv((stderr, "inflate:         length %u\n", len));
	        if (bits < 15) {
	          hold += input[_in++] << bits;
	          bits += 8;
	          hold += input[_in++] << bits;
	          bits += 8;
	        }
	        here = dcode[hold & dmask];

	        dodist:
	        for (;;) { // goto emulation
	          op = here >>> 24/*here.bits*/;
	          hold >>>= op;
	          bits -= op;
	          op = (here >>> 16) & 0xff/*here.op*/;

	          if (op & 16) {                      /* distance base */
	            dist = here & 0xffff/*here.val*/;
	            op &= 15;                       /* number of extra bits */
	            if (bits < op) {
	              hold += input[_in++] << bits;
	              bits += 8;
	              if (bits < op) {
	                hold += input[_in++] << bits;
	                bits += 8;
	              }
	            }
	            dist += hold & ((1 << op) - 1);
	//#ifdef INFLATE_STRICT
	            if (dist > dmax) {
	              strm.msg = 'invalid distance too far back';
	              state.mode = BAD;
	              break top;
	            }
	//#endif
	            hold >>>= op;
	            bits -= op;
	            //Tracevv((stderr, "inflate:         distance %u\n", dist));
	            op = _out - beg;                /* max distance in output */
	            if (dist > op) {                /* see if copy from window */
	              op = dist - op;               /* distance back in window */
	              if (op > whave) {
	                if (state.sane) {
	                  strm.msg = 'invalid distance too far back';
	                  state.mode = BAD;
	                  break top;
	                }

	// (!) This block is disabled in zlib defaults,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//                if (len <= op - whave) {
	//                  do {
	//                    output[_out++] = 0;
	//                  } while (--len);
	//                  continue top;
	//                }
	//                len -= op - whave;
	//                do {
	//                  output[_out++] = 0;
	//                } while (--op > whave);
	//                if (op === 0) {
	//                  from = _out - dist;
	//                  do {
	//                    output[_out++] = output[from++];
	//                  } while (--len);
	//                  continue top;
	//                }
	//#endif
	              }
	              from = 0; // window index
	              from_source = s_window;
	              if (wnext === 0) {           /* very common case */
	                from += wsize - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              else if (wnext < op) {      /* wrap around window */
	                from += wsize + wnext - op;
	                op -= wnext;
	                if (op < len) {         /* some from end of window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = 0;
	                  if (wnext < len) {  /* some from start of window */
	                    op = wnext;
	                    len -= op;
	                    do {
	                      output[_out++] = s_window[from++];
	                    } while (--op);
	                    from = _out - dist;      /* rest from output */
	                    from_source = output;
	                  }
	                }
	              }
	              else {                      /* contiguous in window */
	                from += wnext - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              while (len > 2) {
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                len -= 3;
	              }
	              if (len) {
	                output[_out++] = from_source[from++];
	                if (len > 1) {
	                  output[_out++] = from_source[from++];
	                }
	              }
	            }
	            else {
	              from = _out - dist;          /* copy direct from output */
	              do {                        /* minimum length is three */
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                len -= 3;
	              } while (len > 2);
	              if (len) {
	                output[_out++] = output[from++];
	                if (len > 1) {
	                  output[_out++] = output[from++];
	                }
	              }
	            }
	          }
	          else if ((op & 64) === 0) {          /* 2nd level distance code */
	            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	            continue dodist;
	          }
	          else {
	            strm.msg = 'invalid distance code';
	            state.mode = BAD;
	            break top;
	          }

	          break; // need to emulate goto via "continue"
	        }
	      }
	      else if ((op & 64) === 0) {              /* 2nd level length code */
	        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	        continue dolen;
	      }
	      else if (op & 32) {                     /* end-of-block */
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.mode = TYPE;
	        break top;
	      }
	      else {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break top;
	      }

	      break; // need to emulate goto via "continue"
	    }
	  } while (_in < last && _out < end);

	  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
	  len = bits >> 3;
	  _in -= len;
	  bits -= len << 3;
	  hold &= (1 << bits) - 1;

	  /* update state and return */
	  strm.next_in = _in;
	  strm.next_out = _out;
	  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
	  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
	  state.hold = hold;
	  state.bits = bits;
	  return;
	};

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.



	var MAXBITS = 15;
	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;

	var lbase = [ /* Length codes 257..285 base */
	  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
	  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
	];

	var lext = [ /* Length codes 257..285 extra */
	  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
	  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
	];

	var dbase = [ /* Distance codes 0..29 base */
	  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
	  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
	  8193, 12289, 16385, 24577, 0, 0
	];

	var dext = [ /* Distance codes 0..29 extra */
	  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
	  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
	  28, 28, 29, 29, 64, 64
	];

	var inftrees = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
	{
	  var bits = opts.bits;
	      //here = opts.here; /* table entry for duplication */

	  var len = 0;               /* a code's length in bits */
	  var sym = 0;               /* index of code symbols */
	  var min = 0, max = 0;          /* minimum and maximum code lengths */
	  var root = 0;              /* number of index bits for root table */
	  var curr = 0;              /* number of index bits for current table */
	  var drop = 0;              /* code bits to drop for sub-table */
	  var left = 0;                   /* number of prefix codes available */
	  var used = 0;              /* code entries in table used */
	  var huff = 0;              /* Huffman code */
	  var incr;              /* for incrementing code, index */
	  var fill;              /* index for replicating entries */
	  var low;               /* low bits for current root entry */
	  var mask;              /* mask for low root bits */
	  var next;             /* next available space in table */
	  var base = null;     /* base value table to use */
	  var base_index = 0;
	//  var shoextra;    /* extra bits table to use */
	  var end;                    /* use base and extra for symbol > end */
	  var count = new common$2.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
	  var offs = new common$2.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
	  var extra = null;
	  var extra_index = 0;

	  var here_bits, here_op, here_val;

	  /*
	   Process a set of code lengths to create a canonical Huffman code.  The
	   code lengths are lens[0..codes-1].  Each length corresponds to the
	   symbols 0..codes-1.  The Huffman code is generated by first sorting the
	   symbols by length from short to long, and retaining the symbol order
	   for codes with equal lengths.  Then the code starts with all zero bits
	   for the first code of the shortest length, and the codes are integer
	   increments for the same length, and zeros are appended as the length
	   increases.  For the deflate format, these bits are stored backwards
	   from their more natural integer increment ordering, and so when the
	   decoding tables are built in the large loop below, the integer codes
	   are incremented backwards.

	   This routine assumes, but does not check, that all of the entries in
	   lens[] are in the range 0..MAXBITS.  The caller must assure this.
	   1..MAXBITS is interpreted as that code length.  zero means that that
	   symbol does not occur in this code.

	   The codes are sorted by computing a count of codes for each length,
	   creating from that a table of starting indices for each length in the
	   sorted table, and then entering the symbols in order in the sorted
	   table.  The sorted table is work[], with that space being provided by
	   the caller.

	   The length counts are used for other purposes as well, i.e. finding
	   the minimum and maximum length codes, determining if there are any
	   codes at all, checking for a valid set of lengths, and looking ahead
	   at length counts to determine sub-table sizes when building the
	   decoding tables.
	   */

	  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
	  for (len = 0; len <= MAXBITS; len++) {
	    count[len] = 0;
	  }
	  for (sym = 0; sym < codes; sym++) {
	    count[lens[lens_index + sym]]++;
	  }

	  /* bound code lengths, force root to be within code lengths */
	  root = bits;
	  for (max = MAXBITS; max >= 1; max--) {
	    if (count[max] !== 0) { break; }
	  }
	  if (root > max) {
	    root = max;
	  }
	  if (max === 0) {                     /* no symbols to code at all */
	    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
	    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
	    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;


	    //table.op[opts.table_index] = 64;
	    //table.bits[opts.table_index] = 1;
	    //table.val[opts.table_index++] = 0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;

	    opts.bits = 1;
	    return 0;     /* no symbols, but wait for decoding to report error */
	  }
	  for (min = 1; min < max; min++) {
	    if (count[min] !== 0) { break; }
	  }
	  if (root < min) {
	    root = min;
	  }

	  /* check for an over-subscribed or incomplete set of lengths */
	  left = 1;
	  for (len = 1; len <= MAXBITS; len++) {
	    left <<= 1;
	    left -= count[len];
	    if (left < 0) {
	      return -1;
	    }        /* over-subscribed */
	  }
	  if (left > 0 && (type === CODES || max !== 1)) {
	    return -1;                      /* incomplete set */
	  }

	  /* generate offsets into symbol table for each length for sorting */
	  offs[1] = 0;
	  for (len = 1; len < MAXBITS; len++) {
	    offs[len + 1] = offs[len] + count[len];
	  }

	  /* sort symbols by length, by symbol order within each length */
	  for (sym = 0; sym < codes; sym++) {
	    if (lens[lens_index + sym] !== 0) {
	      work[offs[lens[lens_index + sym]]++] = sym;
	    }
	  }

	  /*
	   Create and fill in decoding tables.  In this loop, the table being
	   filled is at next and has curr index bits.  The code being used is huff
	   with length len.  That code is converted to an index by dropping drop
	   bits off of the bottom.  For codes where len is less than drop + curr,
	   those top drop + curr - len bits are incremented through all values to
	   fill the table with replicated entries.

	   root is the number of index bits for the root table.  When len exceeds
	   root, sub-tables are created pointed to by the root entry with an index
	   of the low root bits of huff.  This is saved in low to check for when a
	   new sub-table should be started.  drop is zero when the root table is
	   being filled, and drop is root when sub-tables are being filled.

	   When a new sub-table is needed, it is necessary to look ahead in the
	   code lengths to determine what size sub-table is needed.  The length
	   counts are used for this, and so count[] is decremented as codes are
	   entered in the tables.

	   used keeps track of how many table entries have been allocated from the
	   provided *table space.  It is checked for LENS and DIST tables against
	   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
	   the initial root table size constants.  See the comments in inftrees.h
	   for more information.

	   sym increments through all symbols, and the loop terminates when
	   all codes of length max, i.e. all codes, have been processed.  This
	   routine permits incomplete codes, so another loop after this one fills
	   in the rest of the decoding tables with invalid code markers.
	   */

	  /* set up for code type */
	  // poor man optimization - use if-else instead of switch,
	  // to avoid deopts in old v8
	  if (type === CODES) {
	    base = extra = work;    /* dummy value--not used */
	    end = 19;

	  } else if (type === LENS) {
	    base = lbase;
	    base_index -= 257;
	    extra = lext;
	    extra_index -= 257;
	    end = 256;

	  } else {                    /* DISTS */
	    base = dbase;
	    extra = dext;
	    end = -1;
	  }

	  /* initialize opts for loop */
	  huff = 0;                   /* starting code */
	  sym = 0;                    /* starting code symbol */
	  len = min;                  /* starting code length */
	  next = table_index;              /* current table to fill in */
	  curr = root;                /* current table index bits */
	  drop = 0;                   /* current bits to drop from code for index */
	  low = -1;                   /* trigger new sub-table when len > root */
	  used = 1 << root;          /* use root table entries */
	  mask = used - 1;            /* mask for comparing low */

	  /* check available table space */
	  if ((type === LENS && used > ENOUGH_LENS) ||
	    (type === DISTS && used > ENOUGH_DISTS)) {
	    return 1;
	  }

	  /* process all codes and make table entries */
	  for (;;) {
	    /* create table entry */
	    here_bits = len - drop;
	    if (work[sym] < end) {
	      here_op = 0;
	      here_val = work[sym];
	    }
	    else if (work[sym] > end) {
	      here_op = extra[extra_index + work[sym]];
	      here_val = base[base_index + work[sym]];
	    }
	    else {
	      here_op = 32 + 64;         /* end of block */
	      here_val = 0;
	    }

	    /* replicate for those indices with low len bits equal to huff */
	    incr = 1 << (len - drop);
	    fill = 1 << curr;
	    min = fill;                 /* save offset to next table */
	    do {
	      fill -= incr;
	      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
	    } while (fill !== 0);

	    /* backwards increment the len-bit code huff */
	    incr = 1 << (len - 1);
	    while (huff & incr) {
	      incr >>= 1;
	    }
	    if (incr !== 0) {
	      huff &= incr - 1;
	      huff += incr;
	    } else {
	      huff = 0;
	    }

	    /* go to next symbol, update count, len */
	    sym++;
	    if (--count[len] === 0) {
	      if (len === max) { break; }
	      len = lens[lens_index + work[sym]];
	    }

	    /* create new sub-table if needed */
	    if (len > root && (huff & mask) !== low) {
	      /* if first time, transition to sub-tables */
	      if (drop === 0) {
	        drop = root;
	      }

	      /* increment past last table */
	      next += min;            /* here min is 1 << curr */

	      /* determine length of next table */
	      curr = len - drop;
	      left = 1 << curr;
	      while (curr + drop < max) {
	        left -= count[curr + drop];
	        if (left <= 0) { break; }
	        curr++;
	        left <<= 1;
	      }

	      /* check for enough space */
	      used += 1 << curr;
	      if ((type === LENS && used > ENOUGH_LENS) ||
	        (type === DISTS && used > ENOUGH_DISTS)) {
	        return 1;
	      }

	      /* point entry in root table to sub-table */
	      low = huff & mask;
	      /*table.op[low] = curr;
	      table.bits[low] = root;
	      table.val[low] = next - opts.table_index;*/
	      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
	    }
	  }

	  /* fill in remaining table entry if code is incomplete (guaranteed to have
	   at most one remaining entry, since if the code is incomplete, the
	   maximum code length that was allowed to get this far is one bit) */
	  if (huff !== 0) {
	    //table.op[next + huff] = 64;            /* invalid code marker */
	    //table.bits[next + huff] = len - drop;
	    //table.val[next + huff] = 0;
	    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
	  }

	  /* set return parameters */
	  //opts.table_index += used;
	  opts.bits = root;
	  return 0;
	};

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.







	var CODES$1 = 0;
	var LENS$1 = 1;
	var DISTS$1 = 2;

	/* Public constants ==========================================================*/
	/* ===========================================================================*/


	/* Allowed flush values; see deflate() and inflate() below for details */
	//var Z_NO_FLUSH      = 0;
	//var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	//var Z_FULL_FLUSH    = 3;
	var Z_FINISH$2        = 4;
	var Z_BLOCK$1         = 5;
	var Z_TREES         = 6;


	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK$2            = 0;
	var Z_STREAM_END$2    = 1;
	var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR$1  = -2;
	var Z_DATA_ERROR$1    = -3;
	var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR$1     = -5;
	//var Z_VERSION_ERROR = -6;

	/* The deflate compression method */
	var Z_DEFLATED$2  = 8;


	/* STATES ====================================================================*/
	/* ===========================================================================*/


	var    HEAD = 1;       /* i: waiting for magic header */
	var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
	var    TIME = 3;       /* i: waiting for modification time (gzip) */
	var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
	var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
	var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
	var    NAME$2 = 7;       /* i: waiting for end of file name (gzip) */
	var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
	var    HCRC = 9;       /* i: waiting for header crc (gzip) */
	var    DICTID = 10;    /* i: waiting for dictionary check value */
	var    DICT = 11;      /* waiting for inflateSetDictionary() call */
	var        TYPE$1 = 12;      /* i: waiting for type bits, including last-flag bit */
	var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
	var        STORED = 14;    /* i: waiting for stored size (length and complement) */
	var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
	var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
	var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
	var        LENLENS = 18;   /* i: waiting for code length code lengths */
	var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
	var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
	var            LEN = 21;       /* i: waiting for length/lit/eob code */
	var            LENEXT = 22;    /* i: waiting for length extra bits */
	var            DIST = 23;      /* i: waiting for distance code */
	var            DISTEXT = 24;   /* i: waiting for distance extra bits */
	var            MATCH$3 = 25;     /* o: waiting for output space to copy string */
	var            LIT = 26;       /* o: waiting for output space to write literal */
	var    CHECK = 27;     /* i: waiting for 32-bit check value */
	var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
	var    DONE = 29;      /* finished check, done -- remain here until reset */
	var    BAD$1 = 30;       /* got a data error -- remain here until reset */
	var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
	var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

	/* ===========================================================================*/



	var ENOUGH_LENS$1 = 852;
	var ENOUGH_DISTS$1 = 592;
	//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

	var MAX_WBITS$1 = 15;
	/* 32K LZ77 window */
	var DEF_WBITS = MAX_WBITS$1;


	function zswap32(q) {
	  return  (((q >>> 24) & 0xff) +
	          ((q >>> 8) & 0xff00) +
	          ((q & 0xff00) << 8) +
	          ((q & 0xff) << 24));
	}


	function InflateState() {
	  this.mode = 0;             /* current inflate mode */
	  this.last = false;          /* true if processing last block */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.havedict = false;      /* true if dictionary provided */
	  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
	  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
	  this.check = 0;             /* protected copy of check value */
	  this.total = 0;             /* protected copy of output count */
	  // TODO: may be {}
	  this.head = null;           /* where to save gzip header information */

	  /* sliding window */
	  this.wbits = 0;             /* log base 2 of requested window size */
	  this.wsize = 0;             /* window size or zero if not using window */
	  this.whave = 0;             /* valid bytes in the window */
	  this.wnext = 0;             /* window write index */
	  this.window = null;         /* allocated sliding window, if needed */

	  /* bit accumulator */
	  this.hold = 0;              /* input bit accumulator */
	  this.bits = 0;              /* number of bits in "in" */

	  /* for string and stored block copying */
	  this.length = 0;            /* literal or length of data to copy */
	  this.offset = 0;            /* distance back to copy string from */

	  /* for table and code decoding */
	  this.extra = 0;             /* extra bits needed */

	  /* fixed and dynamic code tables */
	  this.lencode = null;          /* starting table for length/literal codes */
	  this.distcode = null;         /* starting table for distance codes */
	  this.lenbits = 0;           /* index bits for lencode */
	  this.distbits = 0;          /* index bits for distcode */

	  /* dynamic table building */
	  this.ncode = 0;             /* number of code length code lengths */
	  this.nlen = 0;              /* number of length code lengths */
	  this.ndist = 0;             /* number of distance code lengths */
	  this.have = 0;              /* number of code lengths in lens[] */
	  this.next = null;              /* next available space in codes[] */

	  this.lens = new common$2.Buf16(320); /* temporary storage for code lengths */
	  this.work = new common$2.Buf16(288); /* work area for code table building */

	  /*
	   because we don't have pointers in js, we use lencode and distcode directly
	   as buffers so we don't need codes
	  */
	  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
	  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
	  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
	  this.sane = 0;                   /* if false, allow invalid distance too far */
	  this.back = 0;                   /* bits back of last unprocessed length/lit */
	  this.was = 0;                    /* initial length of match */
	}

	function inflateResetKeep(strm) {
	  var state;

	  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
	  state = strm.state;
	  strm.total_in = strm.total_out = state.total = 0;
	  strm.msg = ''; /*Z_NULL*/
	  if (state.wrap) {       /* to support ill-conceived Java test suite */
	    strm.adler = state.wrap & 1;
	  }
	  state.mode = HEAD;
	  state.last = 0;
	  state.havedict = 0;
	  state.dmax = 32768;
	  state.head = null/*Z_NULL*/;
	  state.hold = 0;
	  state.bits = 0;
	  //state.lencode = state.distcode = state.next = state.codes;
	  state.lencode = state.lendyn = new common$2.Buf32(ENOUGH_LENS$1);
	  state.distcode = state.distdyn = new common$2.Buf32(ENOUGH_DISTS$1);

	  state.sane = 1;
	  state.back = -1;
	  //Tracev((stderr, "inflate: reset\n"));
	  return Z_OK$2;
	}

	function inflateReset(strm) {
	  var state;

	  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
	  state = strm.state;
	  state.wsize = 0;
	  state.whave = 0;
	  state.wnext = 0;
	  return inflateResetKeep(strm);

	}

	function inflateReset2(strm, windowBits) {
	  var wrap;
	  var state;

	  /* get the state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
	  state = strm.state;

	  /* extract wrap request from windowBits parameter */
	  if (windowBits < 0) {
	    wrap = 0;
	    windowBits = -windowBits;
	  }
	  else {
	    wrap = (windowBits >> 4) + 1;
	    if (windowBits < 48) {
	      windowBits &= 15;
	    }
	  }

	  /* set number of window bits, free window if different */
	  if (windowBits && (windowBits < 8 || windowBits > 15)) {
	    return Z_STREAM_ERROR$1;
	  }
	  if (state.window !== null && state.wbits !== windowBits) {
	    state.window = null;
	  }

	  /* update state and reset the rest of it */
	  state.wrap = wrap;
	  state.wbits = windowBits;
	  return inflateReset(strm);
	}

	function inflateInit2(strm, windowBits) {
	  var ret;
	  var state;

	  if (!strm) { return Z_STREAM_ERROR$1; }
	  //strm.msg = Z_NULL;                 /* in case we return an error */

	  state = new InflateState();

	  //if (state === Z_NULL) return Z_MEM_ERROR;
	  //Tracev((stderr, "inflate: allocated\n"));
	  strm.state = state;
	  state.window = null/*Z_NULL*/;
	  ret = inflateReset2(strm, windowBits);
	  if (ret !== Z_OK$2) {
	    strm.state = null/*Z_NULL*/;
	  }
	  return ret;
	}

	function inflateInit(strm) {
	  return inflateInit2(strm, DEF_WBITS);
	}


	/*
	 Return state with length and distance decoding tables and index sizes set to
	 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
	 If BUILDFIXED is defined, then instead this routine builds the tables the
	 first time it's called, and returns those tables the first time and
	 thereafter.  This reduces the size of the code by about 2K bytes, in
	 exchange for a little execution time.  However, BUILDFIXED should not be
	 used for threaded applications, since the rewriting of the tables and virgin
	 may not be thread-safe.
	 */
	var virgin = true;

	var lenfix, distfix; // We have no pointers in JS, so keep tables separate

	function fixedtables(state) {
	  /* build fixed huffman tables if first call (may not be thread safe) */
	  if (virgin) {
	    var sym;

	    lenfix = new common$2.Buf32(512);
	    distfix = new common$2.Buf32(32);

	    /* literal/length table */
	    sym = 0;
	    while (sym < 144) { state.lens[sym++] = 8; }
	    while (sym < 256) { state.lens[sym++] = 9; }
	    while (sym < 280) { state.lens[sym++] = 7; }
	    while (sym < 288) { state.lens[sym++] = 8; }

	    inftrees(LENS$1,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

	    /* distance table */
	    sym = 0;
	    while (sym < 32) { state.lens[sym++] = 5; }

	    inftrees(DISTS$1, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

	    /* do this just once */
	    virgin = false;
	  }

	  state.lencode = lenfix;
	  state.lenbits = 9;
	  state.distcode = distfix;
	  state.distbits = 5;
	}


	/*
	 Update the window with the last wsize (normally 32K) bytes written before
	 returning.  If window does not exist yet, create it.  This is only called
	 when a window is already in use, or when output has been written during this
	 inflate call, but the end of the deflate stream has not been reached yet.
	 It is also called to create a window for dictionary data when a dictionary
	 is loaded.

	 Providing output buffers larger than 32K to inflate() should provide a speed
	 advantage, since only the last 32K of output is copied to the sliding window
	 upon return from inflate(), and since all distances after the first 32K of
	 output will fall in the output data, making match copies simpler and faster.
	 The advantage may be dependent on the size of the processor's data caches.
	 */
	function updatewindow(strm, src, end, copy) {
	  var dist;
	  var state = strm.state;

	  /* if it hasn't been done already, allocate space for the window */
	  if (state.window === null) {
	    state.wsize = 1 << state.wbits;
	    state.wnext = 0;
	    state.whave = 0;

	    state.window = new common$2.Buf8(state.wsize);
	  }

	  /* copy state->wsize or less output bytes into the circular window */
	  if (copy >= state.wsize) {
	    common$2.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
	    state.wnext = 0;
	    state.whave = state.wsize;
	  }
	  else {
	    dist = state.wsize - state.wnext;
	    if (dist > copy) {
	      dist = copy;
	    }
	    //zmemcpy(state->window + state->wnext, end - copy, dist);
	    common$2.arraySet(state.window, src, end - copy, dist, state.wnext);
	    copy -= dist;
	    if (copy) {
	      //zmemcpy(state->window, end - copy, copy);
	      common$2.arraySet(state.window, src, end - copy, copy, 0);
	      state.wnext = copy;
	      state.whave = state.wsize;
	    }
	    else {
	      state.wnext += dist;
	      if (state.wnext === state.wsize) { state.wnext = 0; }
	      if (state.whave < state.wsize) { state.whave += dist; }
	    }
	  }
	  return 0;
	}

	function inflate(strm, flush) {
	  var state;
	  var input, output;          // input/output buffers
	  var next;                   /* next input INDEX */
	  var put;                    /* next output INDEX */
	  var have, left;             /* available input and output */
	  var hold;                   /* bit buffer */
	  var bits;                   /* bits in bit buffer */
	  var _in, _out;              /* save starting available input and output */
	  var copy;                   /* number of stored or match bytes to copy */
	  var from;                   /* where to copy match bytes from */
	  var from_source;
	  var here = 0;               /* current decoding table entry */
	  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
	  //var last;                   /* parent table entry */
	  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
	  var len;                    /* length to copy for repeats, bits to drop */
	  var ret;                    /* return code */
	  var hbuf = new common$2.Buf8(4);    /* buffer for gzip header crc calculation */
	  var opts;

	  var n; // temporary var for NEED_BITS

	  var order = /* permutation of code lengths */
	    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


	  if (!strm || !strm.state || !strm.output ||
	      (!strm.input && strm.avail_in !== 0)) {
	    return Z_STREAM_ERROR$1;
	  }

	  state = strm.state;
	  if (state.mode === TYPE$1) { state.mode = TYPEDO; }    /* skip check */


	  //--- LOAD() ---
	  put = strm.next_out;
	  output = strm.output;
	  left = strm.avail_out;
	  next = strm.next_in;
	  input = strm.input;
	  have = strm.avail_in;
	  hold = state.hold;
	  bits = state.bits;
	  //---

	  _in = have;
	  _out = left;
	  ret = Z_OK$2;

	  inf_leave: // goto emulation
	  for (;;) {
	    switch (state.mode) {
	      case HEAD:
	        if (state.wrap === 0) {
	          state.mode = TYPEDO;
	          break;
	        }
	        //=== NEEDBITS(16);
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
	          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          state.check = crc32_1(state.check, hbuf, 2, 0);
	          //===//

	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	          state.mode = FLAGS;
	          break;
	        }
	        state.flags = 0;           /* expect zlib header */
	        if (state.head) {
	          state.head.done = false;
	        }
	        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
	          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
	          strm.msg = 'incorrect header check';
	          state.mode = BAD$1;
	          break;
	        }
	        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED$2) {
	          strm.msg = 'unknown compression method';
	          state.mode = BAD$1;
	          break;
	        }
	        //--- DROPBITS(4) ---//
	        hold >>>= 4;
	        bits -= 4;
	        //---//
	        len = (hold & 0x0f)/*BITS(4)*/ + 8;
	        if (state.wbits === 0) {
	          state.wbits = len;
	        }
	        else if (len > state.wbits) {
	          strm.msg = 'invalid window size';
	          state.mode = BAD$1;
	          break;
	        }
	        state.dmax = 1 << len;
	        //Tracev((stderr, "inflate:   zlib header ok\n"));
	        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	        state.mode = hold & 0x200 ? DICTID : TYPE$1;
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        break;
	      case FLAGS:
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.flags = hold;
	        if ((state.flags & 0xff) !== Z_DEFLATED$2) {
	          strm.msg = 'unknown compression method';
	          state.mode = BAD$1;
	          break;
	        }
	        if (state.flags & 0xe000) {
	          strm.msg = 'unknown header flags set';
	          state.mode = BAD$1;
	          break;
	        }
	        if (state.head) {
	          state.head.text = ((hold >> 8) & 1);
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          state.check = crc32_1(state.check, hbuf, 2, 0);
	          //===//
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = TIME;
	        /* falls through */
	      case TIME:
	        //=== NEEDBITS(32); */
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (state.head) {
	          state.head.time = hold;
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC4(state.check, hold)
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          hbuf[2] = (hold >>> 16) & 0xff;
	          hbuf[3] = (hold >>> 24) & 0xff;
	          state.check = crc32_1(state.check, hbuf, 4, 0);
	          //===
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = OS;
	        /* falls through */
	      case OS:
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (state.head) {
	          state.head.xflags = (hold & 0xff);
	          state.head.os = (hold >> 8);
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          state.check = crc32_1(state.check, hbuf, 2, 0);
	          //===//
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = EXLEN;
	        /* falls through */
	      case EXLEN:
	        if (state.flags & 0x0400) {
	          //=== NEEDBITS(16); */
	          while (bits < 16) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.length = hold;
	          if (state.head) {
	            state.head.extra_len = hold;
	          }
	          if (state.flags & 0x0200) {
	            //=== CRC2(state.check, hold);
	            hbuf[0] = hold & 0xff;
	            hbuf[1] = (hold >>> 8) & 0xff;
	            state.check = crc32_1(state.check, hbuf, 2, 0);
	            //===//
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	        }
	        else if (state.head) {
	          state.head.extra = null/*Z_NULL*/;
	        }
	        state.mode = EXTRA;
	        /* falls through */
	      case EXTRA:
	        if (state.flags & 0x0400) {
	          copy = state.length;
	          if (copy > have) { copy = have; }
	          if (copy) {
	            if (state.head) {
	              len = state.head.extra_len - state.length;
	              if (!state.head.extra) {
	                // Use untyped array for more convenient processing later
	                state.head.extra = new Array(state.head.extra_len);
	              }
	              common$2.arraySet(
	                state.head.extra,
	                input,
	                next,
	                // extra field is limited to 65536 bytes
	                // - no need for additional size check
	                copy,
	                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
	                len
	              );
	              //zmemcpy(state.head.extra + len, next,
	              //        len + copy > state.head.extra_max ?
	              //        state.head.extra_max - len : copy);
	            }
	            if (state.flags & 0x0200) {
	              state.check = crc32_1(state.check, input, copy, next);
	            }
	            have -= copy;
	            next += copy;
	            state.length -= copy;
	          }
	          if (state.length) { break inf_leave; }
	        }
	        state.length = 0;
	        state.mode = NAME$2;
	        /* falls through */
	      case NAME$2:
	        if (state.flags & 0x0800) {
	          if (have === 0) { break inf_leave; }
	          copy = 0;
	          do {
	            // TODO: 2 or 1 bytes?
	            len = input[next + copy++];
	            /* use constant limit because in js we should not preallocate memory */
	            if (state.head && len &&
	                (state.length < 65536 /*state.head.name_max*/)) {
	              state.head.name += String.fromCharCode(len);
	            }
	          } while (len && copy < have);

	          if (state.flags & 0x0200) {
	            state.check = crc32_1(state.check, input, copy, next);
	          }
	          have -= copy;
	          next += copy;
	          if (len) { break inf_leave; }
	        }
	        else if (state.head) {
	          state.head.name = null;
	        }
	        state.length = 0;
	        state.mode = COMMENT;
	        /* falls through */
	      case COMMENT:
	        if (state.flags & 0x1000) {
	          if (have === 0) { break inf_leave; }
	          copy = 0;
	          do {
	            len = input[next + copy++];
	            /* use constant limit because in js we should not preallocate memory */
	            if (state.head && len &&
	                (state.length < 65536 /*state.head.comm_max*/)) {
	              state.head.comment += String.fromCharCode(len);
	            }
	          } while (len && copy < have);
	          if (state.flags & 0x0200) {
	            state.check = crc32_1(state.check, input, copy, next);
	          }
	          have -= copy;
	          next += copy;
	          if (len) { break inf_leave; }
	        }
	        else if (state.head) {
	          state.head.comment = null;
	        }
	        state.mode = HCRC;
	        /* falls through */
	      case HCRC:
	        if (state.flags & 0x0200) {
	          //=== NEEDBITS(16); */
	          while (bits < 16) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          if (hold !== (state.check & 0xffff)) {
	            strm.msg = 'header crc mismatch';
	            state.mode = BAD$1;
	            break;
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	        }
	        if (state.head) {
	          state.head.hcrc = ((state.flags >> 9) & 1);
	          state.head.done = true;
	        }
	        strm.adler = state.check = 0;
	        state.mode = TYPE$1;
	        break;
	      case DICTID:
	        //=== NEEDBITS(32); */
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        strm.adler = state.check = zswap32(hold);
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = DICT;
	        /* falls through */
	      case DICT:
	        if (state.havedict === 0) {
	          //--- RESTORE() ---
	          strm.next_out = put;
	          strm.avail_out = left;
	          strm.next_in = next;
	          strm.avail_in = have;
	          state.hold = hold;
	          state.bits = bits;
	          //---
	          return Z_NEED_DICT;
	        }
	        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	        state.mode = TYPE$1;
	        /* falls through */
	      case TYPE$1:
	        if (flush === Z_BLOCK$1 || flush === Z_TREES) { break inf_leave; }
	        /* falls through */
	      case TYPEDO:
	        if (state.last) {
	          //--- BYTEBITS() ---//
	          hold >>>= bits & 7;
	          bits -= bits & 7;
	          //---//
	          state.mode = CHECK;
	          break;
	        }
	        //=== NEEDBITS(3); */
	        while (bits < 3) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.last = (hold & 0x01)/*BITS(1)*/;
	        //--- DROPBITS(1) ---//
	        hold >>>= 1;
	        bits -= 1;
	        //---//

	        switch ((hold & 0x03)/*BITS(2)*/) {
	          case 0:                             /* stored block */
	            //Tracev((stderr, "inflate:     stored block%s\n",
	            //        state.last ? " (last)" : ""));
	            state.mode = STORED;
	            break;
	          case 1:                             /* fixed block */
	            fixedtables(state);
	            //Tracev((stderr, "inflate:     fixed codes block%s\n",
	            //        state.last ? " (last)" : ""));
	            state.mode = LEN_;             /* decode codes */
	            if (flush === Z_TREES) {
	              //--- DROPBITS(2) ---//
	              hold >>>= 2;
	              bits -= 2;
	              //---//
	              break inf_leave;
	            }
	            break;
	          case 2:                             /* dynamic block */
	            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
	            //        state.last ? " (last)" : ""));
	            state.mode = TABLE;
	            break;
	          case 3:
	            strm.msg = 'invalid block type';
	            state.mode = BAD$1;
	        }
	        //--- DROPBITS(2) ---//
	        hold >>>= 2;
	        bits -= 2;
	        //---//
	        break;
	      case STORED:
	        //--- BYTEBITS() ---// /* go to byte boundary */
	        hold >>>= bits & 7;
	        bits -= bits & 7;
	        //---//
	        //=== NEEDBITS(32); */
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
	          strm.msg = 'invalid stored block lengths';
	          state.mode = BAD$1;
	          break;
	        }
	        state.length = hold & 0xffff;
	        //Tracev((stderr, "inflate:       stored length %u\n",
	        //        state.length));
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = COPY_;
	        if (flush === Z_TREES) { break inf_leave; }
	        /* falls through */
	      case COPY_:
	        state.mode = COPY;
	        /* falls through */
	      case COPY:
	        copy = state.length;
	        if (copy) {
	          if (copy > have) { copy = have; }
	          if (copy > left) { copy = left; }
	          if (copy === 0) { break inf_leave; }
	          //--- zmemcpy(put, next, copy); ---
	          common$2.arraySet(output, input, next, copy, put);
	          //---//
	          have -= copy;
	          next += copy;
	          left -= copy;
	          put += copy;
	          state.length -= copy;
	          break;
	        }
	        //Tracev((stderr, "inflate:       stored end\n"));
	        state.mode = TYPE$1;
	        break;
	      case TABLE:
	        //=== NEEDBITS(14); */
	        while (bits < 14) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
	        //--- DROPBITS(5) ---//
	        hold >>>= 5;
	        bits -= 5;
	        //---//
	        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
	        //--- DROPBITS(5) ---//
	        hold >>>= 5;
	        bits -= 5;
	        //---//
	        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
	        //--- DROPBITS(4) ---//
	        hold >>>= 4;
	        bits -= 4;
	        //---//
	//#ifndef PKZIP_BUG_WORKAROUND
	        if (state.nlen > 286 || state.ndist > 30) {
	          strm.msg = 'too many length or distance symbols';
	          state.mode = BAD$1;
	          break;
	        }
	//#endif
	        //Tracev((stderr, "inflate:       table sizes ok\n"));
	        state.have = 0;
	        state.mode = LENLENS;
	        /* falls through */
	      case LENLENS:
	        while (state.have < state.ncode) {
	          //=== NEEDBITS(3);
	          while (bits < 3) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
	          //--- DROPBITS(3) ---//
	          hold >>>= 3;
	          bits -= 3;
	          //---//
	        }
	        while (state.have < 19) {
	          state.lens[order[state.have++]] = 0;
	        }
	        // We have separate tables & no pointers. 2 commented lines below not needed.
	        //state.next = state.codes;
	        //state.lencode = state.next;
	        // Switch to use dynamic table
	        state.lencode = state.lendyn;
	        state.lenbits = 7;

	        opts = { bits: state.lenbits };
	        ret = inftrees(CODES$1, state.lens, 0, 19, state.lencode, 0, state.work, opts);
	        state.lenbits = opts.bits;

	        if (ret) {
	          strm.msg = 'invalid code lengths set';
	          state.mode = BAD$1;
	          break;
	        }
	        //Tracev((stderr, "inflate:       code lengths ok\n"));
	        state.have = 0;
	        state.mode = CODELENS;
	        /* falls through */
	      case CODELENS:
	        while (state.have < state.nlen + state.ndist) {
	          for (;;) {
	            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
	            here_bits = here >>> 24;
	            here_op = (here >>> 16) & 0xff;
	            here_val = here & 0xffff;

	            if ((here_bits) <= bits) { break; }
	            //--- PULLBYTE() ---//
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	            //---//
	          }
	          if (here_val < 16) {
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            state.lens[state.have++] = here_val;
	          }
	          else {
	            if (here_val === 16) {
	              //=== NEEDBITS(here.bits + 2);
	              n = here_bits + 2;
	              while (bits < n) {
	                if (have === 0) { break inf_leave; }
	                have--;
	                hold += input[next++] << bits;
	                bits += 8;
	              }
	              //===//
	              //--- DROPBITS(here.bits) ---//
	              hold >>>= here_bits;
	              bits -= here_bits;
	              //---//
	              if (state.have === 0) {
	                strm.msg = 'invalid bit length repeat';
	                state.mode = BAD$1;
	                break;
	              }
	              len = state.lens[state.have - 1];
	              copy = 3 + (hold & 0x03);//BITS(2);
	              //--- DROPBITS(2) ---//
	              hold >>>= 2;
	              bits -= 2;
	              //---//
	            }
	            else if (here_val === 17) {
	              //=== NEEDBITS(here.bits + 3);
	              n = here_bits + 3;
	              while (bits < n) {
	                if (have === 0) { break inf_leave; }
	                have--;
	                hold += input[next++] << bits;
	                bits += 8;
	              }
	              //===//
	              //--- DROPBITS(here.bits) ---//
	              hold >>>= here_bits;
	              bits -= here_bits;
	              //---//
	              len = 0;
	              copy = 3 + (hold & 0x07);//BITS(3);
	              //--- DROPBITS(3) ---//
	              hold >>>= 3;
	              bits -= 3;
	              //---//
	            }
	            else {
	              //=== NEEDBITS(here.bits + 7);
	              n = here_bits + 7;
	              while (bits < n) {
	                if (have === 0) { break inf_leave; }
	                have--;
	                hold += input[next++] << bits;
	                bits += 8;
	              }
	              //===//
	              //--- DROPBITS(here.bits) ---//
	              hold >>>= here_bits;
	              bits -= here_bits;
	              //---//
	              len = 0;
	              copy = 11 + (hold & 0x7f);//BITS(7);
	              //--- DROPBITS(7) ---//
	              hold >>>= 7;
	              bits -= 7;
	              //---//
	            }
	            if (state.have + copy > state.nlen + state.ndist) {
	              strm.msg = 'invalid bit length repeat';
	              state.mode = BAD$1;
	              break;
	            }
	            while (copy--) {
	              state.lens[state.have++] = len;
	            }
	          }
	        }

	        /* handle error breaks in while */
	        if (state.mode === BAD$1) { break; }

	        /* check for end-of-block code (better have one) */
	        if (state.lens[256] === 0) {
	          strm.msg = 'invalid code -- missing end-of-block';
	          state.mode = BAD$1;
	          break;
	        }

	        /* build code tables -- note: do not change the lenbits or distbits
	           values here (9 and 6) without reading the comments in inftrees.h
	           concerning the ENOUGH constants, which depend on those values */
	        state.lenbits = 9;

	        opts = { bits: state.lenbits };
	        ret = inftrees(LENS$1, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
	        // We have separate tables & no pointers. 2 commented lines below not needed.
	        // state.next_index = opts.table_index;
	        state.lenbits = opts.bits;
	        // state.lencode = state.next;

	        if (ret) {
	          strm.msg = 'invalid literal/lengths set';
	          state.mode = BAD$1;
	          break;
	        }

	        state.distbits = 6;
	        //state.distcode.copy(state.codes);
	        // Switch to use dynamic table
	        state.distcode = state.distdyn;
	        opts = { bits: state.distbits };
	        ret = inftrees(DISTS$1, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
	        // We have separate tables & no pointers. 2 commented lines below not needed.
	        // state.next_index = opts.table_index;
	        state.distbits = opts.bits;
	        // state.distcode = state.next;

	        if (ret) {
	          strm.msg = 'invalid distances set';
	          state.mode = BAD$1;
	          break;
	        }
	        //Tracev((stderr, 'inflate:       codes ok\n'));
	        state.mode = LEN_;
	        if (flush === Z_TREES) { break inf_leave; }
	        /* falls through */
	      case LEN_:
	        state.mode = LEN;
	        /* falls through */
	      case LEN:
	        if (have >= 6 && left >= 258) {
	          //--- RESTORE() ---
	          strm.next_out = put;
	          strm.avail_out = left;
	          strm.next_in = next;
	          strm.avail_in = have;
	          state.hold = hold;
	          state.bits = bits;
	          //---
	          inffast(strm, _out);
	          //--- LOAD() ---
	          put = strm.next_out;
	          output = strm.output;
	          left = strm.avail_out;
	          next = strm.next_in;
	          input = strm.input;
	          have = strm.avail_in;
	          hold = state.hold;
	          bits = state.bits;
	          //---

	          if (state.mode === TYPE$1) {
	            state.back = -1;
	          }
	          break;
	        }
	        state.back = 0;
	        for (;;) {
	          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if (here_bits <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        if (here_op && (here_op & 0xf0) === 0) {
	          last_bits = here_bits;
	          last_op = here_op;
	          last_val = here_val;
	          for (;;) {
	            here = state.lencode[last_val +
	                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	            here_bits = here >>> 24;
	            here_op = (here >>> 16) & 0xff;
	            here_val = here & 0xffff;

	            if ((last_bits + here_bits) <= bits) { break; }
	            //--- PULLBYTE() ---//
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	            //---//
	          }
	          //--- DROPBITS(last.bits) ---//
	          hold >>>= last_bits;
	          bits -= last_bits;
	          //---//
	          state.back += last_bits;
	        }
	        //--- DROPBITS(here.bits) ---//
	        hold >>>= here_bits;
	        bits -= here_bits;
	        //---//
	        state.back += here_bits;
	        state.length = here_val;
	        if (here_op === 0) {
	          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	          //        "inflate:         literal '%c'\n" :
	          //        "inflate:         literal 0x%02x\n", here.val));
	          state.mode = LIT;
	          break;
	        }
	        if (here_op & 32) {
	          //Tracevv((stderr, "inflate:         end of block\n"));
	          state.back = -1;
	          state.mode = TYPE$1;
	          break;
	        }
	        if (here_op & 64) {
	          strm.msg = 'invalid literal/length code';
	          state.mode = BAD$1;
	          break;
	        }
	        state.extra = here_op & 15;
	        state.mode = LENEXT;
	        /* falls through */
	      case LENEXT:
	        if (state.extra) {
	          //=== NEEDBITS(state.extra);
	          n = state.extra;
	          while (bits < n) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
	          //--- DROPBITS(state.extra) ---//
	          hold >>>= state.extra;
	          bits -= state.extra;
	          //---//
	          state.back += state.extra;
	        }
	        //Tracevv((stderr, "inflate:         length %u\n", state.length));
	        state.was = state.length;
	        state.mode = DIST;
	        /* falls through */
	      case DIST:
	        for (;;) {
	          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if ((here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        if ((here_op & 0xf0) === 0) {
	          last_bits = here_bits;
	          last_op = here_op;
	          last_val = here_val;
	          for (;;) {
	            here = state.distcode[last_val +
	                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	            here_bits = here >>> 24;
	            here_op = (here >>> 16) & 0xff;
	            here_val = here & 0xffff;

	            if ((last_bits + here_bits) <= bits) { break; }
	            //--- PULLBYTE() ---//
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	            //---//
	          }
	          //--- DROPBITS(last.bits) ---//
	          hold >>>= last_bits;
	          bits -= last_bits;
	          //---//
	          state.back += last_bits;
	        }
	        //--- DROPBITS(here.bits) ---//
	        hold >>>= here_bits;
	        bits -= here_bits;
	        //---//
	        state.back += here_bits;
	        if (here_op & 64) {
	          strm.msg = 'invalid distance code';
	          state.mode = BAD$1;
	          break;
	        }
	        state.offset = here_val;
	        state.extra = (here_op) & 15;
	        state.mode = DISTEXT;
	        /* falls through */
	      case DISTEXT:
	        if (state.extra) {
	          //=== NEEDBITS(state.extra);
	          n = state.extra;
	          while (bits < n) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
	          //--- DROPBITS(state.extra) ---//
	          hold >>>= state.extra;
	          bits -= state.extra;
	          //---//
	          state.back += state.extra;
	        }
	//#ifdef INFLATE_STRICT
	        if (state.offset > state.dmax) {
	          strm.msg = 'invalid distance too far back';
	          state.mode = BAD$1;
	          break;
	        }
	//#endif
	        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
	        state.mode = MATCH$3;
	        /* falls through */
	      case MATCH$3:
	        if (left === 0) { break inf_leave; }
	        copy = _out - left;
	        if (state.offset > copy) {         /* copy from window */
	          copy = state.offset - copy;
	          if (copy > state.whave) {
	            if (state.sane) {
	              strm.msg = 'invalid distance too far back';
	              state.mode = BAD$1;
	              break;
	            }
	// (!) This block is disabled in zlib defaults,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//          Trace((stderr, "inflate.c too far\n"));
	//          copy -= state.whave;
	//          if (copy > state.length) { copy = state.length; }
	//          if (copy > left) { copy = left; }
	//          left -= copy;
	//          state.length -= copy;
	//          do {
	//            output[put++] = 0;
	//          } while (--copy);
	//          if (state.length === 0) { state.mode = LEN; }
	//          break;
	//#endif
	          }
	          if (copy > state.wnext) {
	            copy -= state.wnext;
	            from = state.wsize - copy;
	          }
	          else {
	            from = state.wnext - copy;
	          }
	          if (copy > state.length) { copy = state.length; }
	          from_source = state.window;
	        }
	        else {                              /* copy from output */
	          from_source = output;
	          from = put - state.offset;
	          copy = state.length;
	        }
	        if (copy > left) { copy = left; }
	        left -= copy;
	        state.length -= copy;
	        do {
	          output[put++] = from_source[from++];
	        } while (--copy);
	        if (state.length === 0) { state.mode = LEN; }
	        break;
	      case LIT:
	        if (left === 0) { break inf_leave; }
	        output[put++] = state.length;
	        left--;
	        state.mode = LEN;
	        break;
	      case CHECK:
	        if (state.wrap) {
	          //=== NEEDBITS(32);
	          while (bits < 32) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            // Use '|' instead of '+' to make sure that result is signed
	            hold |= input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          _out -= left;
	          strm.total_out += _out;
	          state.total += _out;
	          if (_out) {
	            strm.adler = state.check =
	                /*UPDATE(state.check, put - _out, _out);*/
	                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

	          }
	          _out = left;
	          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
	          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
	            strm.msg = 'incorrect data check';
	            state.mode = BAD$1;
	            break;
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	          //Tracev((stderr, "inflate:   check matches trailer\n"));
	        }
	        state.mode = LENGTH;
	        /* falls through */
	      case LENGTH:
	        if (state.wrap && state.flags) {
	          //=== NEEDBITS(32);
	          while (bits < 32) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          if (hold !== (state.total & 0xffffffff)) {
	            strm.msg = 'incorrect length check';
	            state.mode = BAD$1;
	            break;
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	          //Tracev((stderr, "inflate:   length matches trailer\n"));
	        }
	        state.mode = DONE;
	        /* falls through */
	      case DONE:
	        ret = Z_STREAM_END$2;
	        break inf_leave;
	      case BAD$1:
	        ret = Z_DATA_ERROR$1;
	        break inf_leave;
	      case MEM:
	        return Z_MEM_ERROR;
	      case SYNC:
	        /* falls through */
	      default:
	        return Z_STREAM_ERROR$1;
	    }
	  }

	  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

	  /*
	     Return from inflate(), updating the total counts and the check value.
	     If there was no progress during the inflate() call, return a buffer
	     error.  Call updatewindow() to create and/or update the window state.
	     Note: a memory error from inflate() is non-recoverable.
	   */

	  //--- RESTORE() ---
	  strm.next_out = put;
	  strm.avail_out = left;
	  strm.next_in = next;
	  strm.avail_in = have;
	  state.hold = hold;
	  state.bits = bits;
	  //---

	  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD$1 &&
	                      (state.mode < CHECK || flush !== Z_FINISH$2))) {
	    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
	  }
	  _in -= strm.avail_in;
	  _out -= strm.avail_out;
	  strm.total_in += _in;
	  strm.total_out += _out;
	  state.total += _out;
	  if (state.wrap && _out) {
	    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
	      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
	  }
	  strm.data_type = state.bits + (state.last ? 64 : 0) +
	                    (state.mode === TYPE$1 ? 128 : 0) +
	                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
	  if (((_in === 0 && _out === 0) || flush === Z_FINISH$2) && ret === Z_OK$2) {
	    ret = Z_BUF_ERROR$1;
	  }
	  return ret;
	}

	function inflateEnd(strm) {

	  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
	    return Z_STREAM_ERROR$1;
	  }

	  var state = strm.state;
	  if (state.window) {
	    state.window = null;
	  }
	  strm.state = null;
	  return Z_OK$2;
	}

	function inflateGetHeader(strm, head) {
	  var state;

	  /* check state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
	  state = strm.state;
	  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

	  /* save header structure */
	  state.head = head;
	  head.done = false;
	  return Z_OK$2;
	}

	function inflateSetDictionary(strm, dictionary) {
	  var dictLength = dictionary.length;

	  var state;
	  var dictid;
	  var ret;

	  /* check state */
	  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR$1; }
	  state = strm.state;

	  if (state.wrap !== 0 && state.mode !== DICT) {
	    return Z_STREAM_ERROR$1;
	  }

	  /* check for correct dictionary identifier */
	  if (state.mode === DICT) {
	    dictid = 1; /* adler32(0, null, 0)*/
	    /* dictid = adler32(dictid, dictionary, dictLength); */
	    dictid = adler32_1(dictid, dictionary, dictLength, 0);
	    if (dictid !== state.check) {
	      return Z_DATA_ERROR$1;
	    }
	  }
	  /* copy dictionary to window using updatewindow(), which will amend the
	   existing dictionary if appropriate */
	  ret = updatewindow(strm, dictionary, dictLength, dictLength);
	  if (ret) {
	    state.mode = MEM;
	    return Z_MEM_ERROR;
	  }
	  state.havedict = 1;
	  // Tracev((stderr, "inflate:   dictionary set\n"));
	  return Z_OK$2;
	}

	var inflateReset_1 = inflateReset;
	var inflateReset2_1 = inflateReset2;
	var inflateResetKeep_1 = inflateResetKeep;
	var inflateInit_1 = inflateInit;
	var inflateInit2_1 = inflateInit2;
	var inflate_2 = inflate;
	var inflateEnd_1 = inflateEnd;
	var inflateGetHeader_1 = inflateGetHeader;
	var inflateSetDictionary_1 = inflateSetDictionary;
	var inflateInfo = 'pako inflate (from Nodeca project)';

	/* Not implemented
	exports.inflateCopy = inflateCopy;
	exports.inflateGetDictionary = inflateGetDictionary;
	exports.inflateMark = inflateMark;
	exports.inflatePrime = inflatePrime;
	exports.inflateSync = inflateSync;
	exports.inflateSyncPoint = inflateSyncPoint;
	exports.inflateUndermine = inflateUndermine;
	*/

	var inflate_1 = {
		inflateReset: inflateReset_1,
		inflateReset2: inflateReset2_1,
		inflateResetKeep: inflateResetKeep_1,
		inflateInit: inflateInit_1,
		inflateInit2: inflateInit2_1,
		inflate: inflate_2,
		inflateEnd: inflateEnd_1,
		inflateGetHeader: inflateGetHeader_1,
		inflateSetDictionary: inflateSetDictionary_1,
		inflateInfo: inflateInfo
	};

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	var constants$1 = {

	  /* Allowed flush values; see deflate() and inflate() below for details */
	  Z_NO_FLUSH:         0,
	  Z_PARTIAL_FLUSH:    1,
	  Z_SYNC_FLUSH:       2,
	  Z_FULL_FLUSH:       3,
	  Z_FINISH:           4,
	  Z_BLOCK:            5,
	  Z_TREES:            6,

	  /* Return codes for the compression/decompression functions. Negative values
	  * are errors, positive values are used for special but normal events.
	  */
	  Z_OK:               0,
	  Z_STREAM_END:       1,
	  Z_NEED_DICT:        2,
	  Z_ERRNO:           -1,
	  Z_STREAM_ERROR:    -2,
	  Z_DATA_ERROR:      -3,
	  //Z_MEM_ERROR:     -4,
	  Z_BUF_ERROR:       -5,
	  //Z_VERSION_ERROR: -6,

	  /* compression levels */
	  Z_NO_COMPRESSION:         0,
	  Z_BEST_SPEED:             1,
	  Z_BEST_COMPRESSION:       9,
	  Z_DEFAULT_COMPRESSION:   -1,


	  Z_FILTERED:               1,
	  Z_HUFFMAN_ONLY:           2,
	  Z_RLE:                    3,
	  Z_FIXED:                  4,
	  Z_DEFAULT_STRATEGY:       0,

	  /* Possible values of the data_type field (though see inflate()) */
	  Z_BINARY:                 0,
	  Z_TEXT:                   1,
	  //Z_ASCII:                1, // = Z_TEXT (deprecated)
	  Z_UNKNOWN:                2,

	  /* The deflate compression method */
	  Z_DEFLATED:               8
	  //Z_NULL:                 null // Use -1 or null inline, depending on var type
	};

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	function GZheader() {
	  /* true if compressed data believed to be text */
	  this.text       = 0;
	  /* modification time */
	  this.time       = 0;
	  /* extra flags (not used when writing a gzip file) */
	  this.xflags     = 0;
	  /* operating system */
	  this.os         = 0;
	  /* pointer to extra field or Z_NULL if none */
	  this.extra      = null;
	  /* extra field length (valid if extra != Z_NULL) */
	  this.extra_len  = 0; // Actually, we don't need it in JS,
	                       // but leave for few code modifications

	  //
	  // Setup limits is not necessary because in js we should not preallocate memory
	  // for inflate use constant limit in 65536 bytes
	  //

	  /* space at extra (only when reading header) */
	  // this.extra_max  = 0;
	  /* pointer to zero-terminated file name or Z_NULL */
	  this.name       = '';
	  /* space at name (only when reading header) */
	  // this.name_max   = 0;
	  /* pointer to zero-terminated comment or Z_NULL */
	  this.comment    = '';
	  /* space at comment (only when reading header) */
	  // this.comm_max   = 0;
	  /* true if there was or will be a header crc */
	  this.hcrc       = 0;
	  /* true when done reading gzip header (not used when writing a gzip file) */
	  this.done       = false;
	}

	var gzheader = GZheader;

	var toString$7 = Object.prototype.toString;

	/**
	 * class Inflate
	 *
	 * Generic JS-style wrapper for zlib calls. If you don't need
	 * streaming behaviour - use more simple functions: [[inflate]]
	 * and [[inflateRaw]].
	 **/

	/* internal
	 * inflate.chunks -> Array
	 *
	 * Chunks of output data, if [[Inflate#onData]] not overridden.
	 **/

	/**
	 * Inflate.result -> Uint8Array|Array|String
	 *
	 * Uncompressed result, generated by default [[Inflate#onData]]
	 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
	 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
	 * push a chunk with explicit flush (call [[Inflate#push]] with
	 * `Z_SYNC_FLUSH` param).
	 **/

	/**
	 * Inflate.err -> Number
	 *
	 * Error code after inflate finished. 0 (Z_OK) on success.
	 * Should be checked if broken data possible.
	 **/

	/**
	 * Inflate.msg -> String
	 *
	 * Error message, if [[Inflate.err]] != 0
	 **/


	/**
	 * new Inflate(options)
	 * - options (Object): zlib inflate options.
	 *
	 * Creates new inflator instance with specified params. Throws exception
	 * on bad params. Supported options:
	 *
	 * - `windowBits`
	 * - `dictionary`
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information on these.
	 *
	 * Additional options, for internal needs:
	 *
	 * - `chunkSize` - size of generated data chunks (16K by default)
	 * - `raw` (Boolean) - do raw inflate
	 * - `to` (String) - if equal to 'string', then result will be converted
	 *   from utf8 to utf16 (javascript) string. When string output requested,
	 *   chunk length can differ from `chunkSize`, depending on content.
	 *
	 * By default, when no options set, autodetect deflate/gzip data format via
	 * wrapper header.
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
	 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
	 *
	 * var inflate = new pako.Inflate({ level: 3});
	 *
	 * inflate.push(chunk1, false);
	 * inflate.push(chunk2, true);  // true -> last chunk
	 *
	 * if (inflate.err) { throw new Error(inflate.err); }
	 *
	 * console.log(inflate.result);
	 * ```
	 **/
	function Inflate(options) {
	  if (!(this instanceof Inflate)) return new Inflate(options);

	  this.options = common$2.assign({
	    chunkSize: 16384,
	    windowBits: 0,
	    to: ''
	  }, options || {});

	  var opt = this.options;

	  // Force window size for `raw` data, if not set directly,
	  // because we have no header for autodetect.
	  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
	    opt.windowBits = -opt.windowBits;
	    if (opt.windowBits === 0) { opt.windowBits = -15; }
	  }

	  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
	  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
	      !(options && options.windowBits)) {
	    opt.windowBits += 32;
	  }

	  // Gzip header has no info about windows size, we can do autodetect only
	  // for deflate. So, if window size not set, force it to max when gzip possible
	  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
	    // bit 3 (16) -> gzipped data
	    // bit 4 (32) -> autodetect gzip/deflate
	    if ((opt.windowBits & 15) === 0) {
	      opt.windowBits |= 15;
	    }
	  }

	  this.err    = 0;      // error code, if happens (0 = Z_OK)
	  this.msg    = '';     // error message
	  this.ended  = false;  // used to avoid multiple onEnd() calls
	  this.chunks = [];     // chunks of compressed data

	  this.strm   = new zstream();
	  this.strm.avail_out = 0;

	  var status  = inflate_1.inflateInit2(
	    this.strm,
	    opt.windowBits
	  );

	  if (status !== constants$1.Z_OK) {
	    throw new Error(messages[status]);
	  }

	  this.header = new gzheader();

	  inflate_1.inflateGetHeader(this.strm, this.header);

	  // Setup dictionary
	  if (opt.dictionary) {
	    // Convert data if needed
	    if (typeof opt.dictionary === 'string') {
	      opt.dictionary = strings.string2buf(opt.dictionary);
	    } else if (toString$7.call(opt.dictionary) === '[object ArrayBuffer]') {
	      opt.dictionary = new Uint8Array(opt.dictionary);
	    }
	    if (opt.raw) { //In raw mode we need to set the dictionary early
	      status = inflate_1.inflateSetDictionary(this.strm, opt.dictionary);
	      if (status !== constants$1.Z_OK) {
	        throw new Error(messages[status]);
	      }
	    }
	  }
	}

	/**
	 * Inflate#push(data[, mode]) -> Boolean
	 * - data (Uint8Array|Array|ArrayBuffer|String): input data
	 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
	 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
	 *
	 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
	 * new output chunks. Returns `true` on success. The last data block must have
	 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
	 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
	 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
	 *
	 * On fail call [[Inflate#onEnd]] with error code and return false.
	 *
	 * We strongly recommend to use `Uint8Array` on input for best speed (output
	 * format is detected automatically). Also, don't skip last param and always
	 * use the same type in your code (boolean or number). That will improve JS speed.
	 *
	 * For regular `Array`-s make sure all elements are [0..255].
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * push(chunk, false); // push one of data chunks
	 * ...
	 * push(chunk, true);  // push last chunk
	 * ```
	 **/
	Inflate.prototype.push = function (data, mode) {
	  var strm = this.strm;
	  var chunkSize = this.options.chunkSize;
	  var dictionary = this.options.dictionary;
	  var status, _mode;
	  var next_out_utf8, tail, utf8str;

	  // Flag to properly process Z_BUF_ERROR on testing inflate call
	  // when we check that all output data was flushed.
	  var allowBufError = false;

	  if (this.ended) { return false; }
	  _mode = (mode === ~~mode) ? mode : ((mode === true) ? constants$1.Z_FINISH : constants$1.Z_NO_FLUSH);

	  // Convert data if needed
	  if (typeof data === 'string') {
	    // Only binary strings can be decompressed on practice
	    strm.input = strings.binstring2buf(data);
	  } else if (toString$7.call(data) === '[object ArrayBuffer]') {
	    strm.input = new Uint8Array(data);
	  } else {
	    strm.input = data;
	  }

	  strm.next_in = 0;
	  strm.avail_in = strm.input.length;

	  do {
	    if (strm.avail_out === 0) {
	      strm.output = new common$2.Buf8(chunkSize);
	      strm.next_out = 0;
	      strm.avail_out = chunkSize;
	    }

	    status = inflate_1.inflate(strm, constants$1.Z_NO_FLUSH);    /* no bad return value */

	    if (status === constants$1.Z_NEED_DICT && dictionary) {
	      status = inflate_1.inflateSetDictionary(this.strm, dictionary);
	    }

	    if (status === constants$1.Z_BUF_ERROR && allowBufError === true) {
	      status = constants$1.Z_OK;
	      allowBufError = false;
	    }

	    if (status !== constants$1.Z_STREAM_END && status !== constants$1.Z_OK) {
	      this.onEnd(status);
	      this.ended = true;
	      return false;
	    }

	    if (strm.next_out) {
	      if (strm.avail_out === 0 || status === constants$1.Z_STREAM_END || (strm.avail_in === 0 && (_mode === constants$1.Z_FINISH || _mode === constants$1.Z_SYNC_FLUSH))) {

	        if (this.options.to === 'string') {

	          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

	          tail = strm.next_out - next_out_utf8;
	          utf8str = strings.buf2string(strm.output, next_out_utf8);

	          // move tail
	          strm.next_out = tail;
	          strm.avail_out = chunkSize - tail;
	          if (tail) { common$2.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

	          this.onData(utf8str);

	        } else {
	          this.onData(common$2.shrinkBuf(strm.output, strm.next_out));
	        }
	      }
	    }

	    // When no more input data, we should check that internal inflate buffers
	    // are flushed. The only way to do it when avail_out = 0 - run one more
	    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
	    // Here we set flag to process this error properly.
	    //
	    // NOTE. Deflate does not return error in this case and does not needs such
	    // logic.
	    if (strm.avail_in === 0 && strm.avail_out === 0) {
	      allowBufError = true;
	    }

	  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== constants$1.Z_STREAM_END);

	  if (status === constants$1.Z_STREAM_END) {
	    _mode = constants$1.Z_FINISH;
	  }

	  // Finalize on the last chunk.
	  if (_mode === constants$1.Z_FINISH) {
	    status = inflate_1.inflateEnd(this.strm);
	    this.onEnd(status);
	    this.ended = true;
	    return status === constants$1.Z_OK;
	  }

	  // callback interim results if Z_SYNC_FLUSH.
	  if (_mode === constants$1.Z_SYNC_FLUSH) {
	    this.onEnd(constants$1.Z_OK);
	    strm.avail_out = 0;
	    return true;
	  }

	  return true;
	};


	/**
	 * Inflate#onData(chunk) -> Void
	 * - chunk (Uint8Array|Array|String): output data. Type of array depends
	 *   on js engine support. When string output requested, each chunk
	 *   will be string.
	 *
	 * By default, stores data blocks in `chunks[]` property and glue
	 * those in `onEnd`. Override this handler, if you need another behaviour.
	 **/
	Inflate.prototype.onData = function (chunk) {
	  this.chunks.push(chunk);
	};


	/**
	 * Inflate#onEnd(status) -> Void
	 * - status (Number): inflate status. 0 (Z_OK) on success,
	 *   other if not.
	 *
	 * Called either after you tell inflate that the input stream is
	 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
	 * or if an error happened. By default - join collected chunks,
	 * free memory and fill `results` / `err` properties.
	 **/
	Inflate.prototype.onEnd = function (status) {
	  // On success - join
	  if (status === constants$1.Z_OK) {
	    if (this.options.to === 'string') {
	      // Glue & convert here, until we teach pako to send
	      // utf8 aligned strings to onData
	      this.result = this.chunks.join('');
	    } else {
	      this.result = common$2.flattenChunks(this.chunks);
	    }
	  }
	  this.chunks = [];
	  this.err = status;
	  this.msg = this.strm.msg;
	};


	/**
	 * inflate(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * Decompress `data` with inflate/ungzip and `options`. Autodetect
	 * format via wrapper header by default. That's why we don't provide
	 * separate `ungzip` method.
	 *
	 * Supported options are:
	 *
	 * - windowBits
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information.
	 *
	 * Sugar (options):
	 *
	 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
	 *   negative windowBits implicitly.
	 * - `to` (String) - if equal to 'string', then result will be converted
	 *   from utf8 to utf16 (javascript) string. When string output requested,
	 *   chunk length can differ from `chunkSize`, depending on content.
	 *
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
	 *   , output;
	 *
	 * try {
	 *   output = pako.inflate(input);
	 * } catch (err)
	 *   console.log(err);
	 * }
	 * ```
	 **/
	function inflate$1(input, options) {
	  var inflator = new Inflate(options);

	  inflator.push(input, true);

	  // That will never happens, if you don't cheat with options :)
	  if (inflator.err) { throw inflator.msg || messages[inflator.err]; }

	  return inflator.result;
	}


	/**
	 * inflateRaw(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * The same as [[inflate]], but creates raw data, without wrapper
	 * (header and adler32 crc).
	 **/
	function inflateRaw(input, options) {
	  options = options || {};
	  options.raw = true;
	  return inflate$1(input, options);
	}


	/**
	 * ungzip(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * Just shortcut to [[inflate]], because it autodetects format
	 * by header.content. Done for convenience.
	 **/


	var Inflate_1 = Inflate;
	var inflate_2$1 = inflate$1;
	var inflateRaw_1 = inflateRaw;
	var ungzip  = inflate$1;

	var inflate_1$1 = {
		Inflate: Inflate_1,
		inflate: inflate_2$1,
		inflateRaw: inflateRaw_1,
		ungzip: ungzip
	};

	var assign    = common$2.assign;





	var pako = {};

	assign(pako, deflate_1$1, inflate_1$1, constants$1);

	var pako_1 = pako;

	function _createSuper$o(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$p(); return function () { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$p() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

	var UnableToExecuteFn = /*#__PURE__*/function (_Error) {
	  inherits(UnableToExecuteFn, _Error);

	  var _super = _createSuper$o(UnableToExecuteFn);

	  function UnableToExecuteFn(message, error) {
	    var _this;

	    classCallCheck(this, UnableToExecuteFn);

	    _this = _super.call(this, message);

	    defineProperty(assertThisInitialized(_this), "error", void 0);

	    defineProperty(assertThisInitialized(_this), "name", void 0);

	    _this.error = error;
	    _this.name = 'UnableToExecuteFn';
	    Object.setPrototypeOf(assertThisInitialized(_this), UnableToExecuteFn.prototype);
	    return _this;
	  }

	  return UnableToExecuteFn;
	}( /*#__PURE__*/wrapNativeSuper(Error));

	function _createSuper$p(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$q(); return function () { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$q() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

	var UnableToParseYAML = /*#__PURE__*/function (_Error) {
	  inherits(UnableToParseYAML, _Error);

	  var _super = _createSuper$p(UnableToParseYAML);

	  function UnableToParseYAML(message, error) {
	    var _this;

	    classCallCheck(this, UnableToParseYAML);

	    _this = _super.call(this, message);

	    defineProperty(assertThisInitialized(_this), "error", void 0);

	    defineProperty(assertThisInitialized(_this), "name", void 0);

	    _this.error = error;
	    _this.name = 'UnableToParseYAML';
	    Object.setPrototypeOf(assertThisInitialized(_this), UnableToParseYAML.prototype);
	    return _this;
	  }

	  return UnableToParseYAML;
	}( /*#__PURE__*/wrapNativeSuper(Error));

	function _createSuper$q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$r(); return function () { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$r() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

	var UnableToRetrieveYAML = /*#__PURE__*/function (_Error) {
	  inherits(UnableToRetrieveYAML, _Error);

	  var _super = _createSuper$q(UnableToRetrieveYAML);

	  function UnableToRetrieveYAML(message, error) {
	    var _this;

	    classCallCheck(this, UnableToRetrieveYAML);

	    _this = _super.call(this, message);

	    defineProperty(assertThisInitialized(_this), "error", void 0);

	    defineProperty(assertThisInitialized(_this), "name", void 0);

	    _this.error = error;
	    _this.name = 'UnableToRetrieveYAML';
	    Object.setPrototypeOf(assertThisInitialized(_this), UnableToRetrieveYAML.prototype);
	    return _this;
	  }

	  return UnableToRetrieveYAML;
	}( /*#__PURE__*/wrapNativeSuper(Error));

	function _createSuper$r(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$s(); return function () { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$s() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

	var UnableToLocateValue = /*#__PURE__*/function (_Error) {
	  inherits(UnableToLocateValue, _Error);

	  var _super = _createSuper$r(UnableToLocateValue);

	  function UnableToLocateValue(message, error) {
	    var _this;

	    classCallCheck(this, UnableToLocateValue);

	    _this = _super.call(this, message);

	    defineProperty(assertThisInitialized(_this), "error", void 0);

	    defineProperty(assertThisInitialized(_this), "name", void 0);

	    _this.error = error;
	    _this.name = 'UnableToLocateValue';
	    Object.setPrototypeOf(assertThisInitialized(_this), UnableToLocateValue.prototype);
	    return _this;
	  }

	  return UnableToLocateValue;
	}( /*#__PURE__*/wrapNativeSuper(Error));

	function _createSuper$s(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$t(); return function () { var Super = getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn(this, result); }; }

	function _isNativeReflectConstruct$t() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

	var UnableToLoadConfig = /*#__PURE__*/function (_Error) {
	  inherits(UnableToLoadConfig, _Error);

	  var _super = _createSuper$s(UnableToLoadConfig);

	  function UnableToLoadConfig(message, error) {
	    var _this;

	    classCallCheck(this, UnableToLoadConfig);

	    _this = _super.call(this, message);

	    defineProperty(assertThisInitialized(_this), "error", void 0);

	    defineProperty(assertThisInitialized(_this), "name", void 0);

	    _this.error = error;
	    _this.name = 'UnableToLoadConfig';
	    Object.setPrototypeOf(assertThisInitialized(_this), UnableToLoadConfig.prototype);
	    return _this;
	  }

	  return UnableToLoadConfig;
	}( /*#__PURE__*/wrapNativeSuper(Error));

	var compareUint8Arrays = function compareUint8Arrays(u8a1, u8a2) {
	  if (u8a1.length !== u8a2.length) return false;

	  for (var i = 0; i < u8a1.length; i++) {
	    if (u8a1[i] !== u8a2[i]) {
	      return false;
	    }
	  }

	  return true;
	};
	var gzip$1 = function gzip(data) {
	  return pako_1.gzip(data);
	};
	var ungzip$1 = function ungzip(data) {
	  return pako_1.ungzip(data);
	};
	/**
	 * 
	 * @param item any
	 * @returns    boolean
	 * - checks if given value is a valid object {}
	 */

	function isObject$5(item) {
	  if (item === null) return false;
	  if (item === undefined) return false;
	  return item && _typeof_1(item) === 'object' && !Array.isArray(item);
	}
	function mergeDeep(target, source) {
	  var output = Object.assign({}, target);

	  if (isObject$5(target) && isObject$5(source)) {
	    Object.keys(source).forEach(function (key) {
	      if (isObject$5(source[key])) {
	        if (!(key in target)) {
	          Object.assign(output, defineProperty({}, key, source[key]));
	        } else if (isObject$5(target[key])) {
	          output[key] = mergeDeep(target[key], source[key]);
	        } else {
	          output[key] = source[key];
	        }
	      } else {
	        Object.assign(output, defineProperty({}, key, source[key]));
	      }
	    });
	  }

	  return output;
	} //TODO: write unit tests

	var defaultResponseCatcher = function defaultResponseCatcher(response) {
	  return response;
	};

	var defaultErrorCatcher = function defaultErrorCatcher(error) {
	  var code = getErrorCode(error.name);

	  if (code === -1 && error.name !== 'UNKNOW_ERROR') {
	    throw error;
	  } else {
	    throw new AiTmedError({
	      code: code,
	      message: error.message
	    });
	  }
	};

	var Store$1 = /*#__PURE__*/function () {
	  function Store(_ref) {
	    var _this = this;

	    var apiVersion = _ref.apiVersion,
	        apiHost = _ref.apiHost,
	        env = _ref.env,
	        configUrl = _ref.configUrl;

	    classCallCheck(this, Store);

	    defineProperty(this, "_env", void 0);

	    defineProperty(this, "level2SDK", void 0);

	    defineProperty(this, "utils", void 0);

	    defineProperty(this, "responseCatcher", defaultResponseCatcher);

	    defineProperty(this, "errorCatcher", defaultErrorCatcher);

	    this._env = env;
	    this.level2SDK = new SDK({
	      apiVersion: apiVersion,
	      apiHost: apiHost,
	      env: env,
	      configUrl: configUrl
	    });

	    var idToBase64 = function idToBase64(id) {
	      if (typeof id === 'string') {
	        return id;
	      } else {
	        return _this.level2SDK.utilServices.uint8ArrayToBase64(id);
	      }
	    };

	    var idToUint8Array = function idToUint8Array(id) {
	      if (typeof id === 'string') {
	        return _this.level2SDK.utilServices.base64ToUint8Array(id);
	      } else {
	        return id;
	      }
	    };

	    this.utils = {
	      idToBase64: idToBase64,
	      idToUint8Array: idToUint8Array,
	      compareUint8Arrays: compareUint8Arrays
	    };
	  }

	  createClass(Store, [{
	    key: "getConfig",
	    value: function getConfig() {
	      return this.level2SDK.getConfigData();
	    }
	    /**
	     * @param catcher if null, reset the catcher to be default
	     */

	  }, {
	    key: "setResponseCatcher",
	    value: function setResponseCatcher() {
	      var catcher = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultResponseCatcher;

	      if (this.env === 'development') {
	        this.responseCatcher = catcher;
	      }
	    }
	    /**
	     * @param catcher if null, reset the catcher to be default
	     */

	  }, {
	    key: "setErrorCatcher",
	    value: function setErrorCatcher() {
	      var catcher = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultErrorCatcher;

	      if (this.env === 'development') {
	        this.errorCatcher = catcher;
	      }
	    }
	  }, {
	    key: "apiVersion",
	    set: function set(value) {
	      this.level2SDK.apiVersion = value;
	    },
	    get: function get() {
	      return this.level2SDK.apiVersion;
	    }
	  }, {
	    key: "env",
	    set: function set(value) {
	      this.level2SDK.env = value;
	    },
	    get: function get() {
	      return this.level2SDK.env;
	    }
	  }, {
	    key: "apiHost",
	    get: function get() {
	      return this.level2SDK.apiHost;
	    },
	    set: function set(value) {
	      this.level2SDK.apiHost = value;
	    }
	  }, {
	    key: "configUrl",
	    get: function get() {
	      return this.level2SDK.configUrl;
	    },
	    set: function set(value) {
	      this.level2SDK.configUrl = value;
	    }
	  }]);

	  return Store;
	}();

	var store$3 = new Store$1({
	  env: 'development',
	  configUrl: 'https://public.aitmed.com/config'
	});

	var retrieveVertex = /*#__PURE__*/function () {
	  var _ref = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(id) {
	    var response;
	    return regenerator.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            _context.next = 2;
	            return store$3.level2SDK.vertexServices.retrieveVertex({
	              idList: [id]
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 2:
	            response = _context.sent;
	            return _context.abrupt("return", response && Array.isArray(response.data) && response.data.length > 0 ? response.data[0] : null);

	          case 4:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee);
	  }));

	  return function retrieveVertex(_x) {
	    return _ref.apply(this, arguments);
	  };
	}();

	var retrieveEdge = /*#__PURE__*/function () {
	  var _ref2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(id) {
	    var response;
	    return regenerator.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            _context2.next = 2;
	            return store$3.level2SDK.edgeServices.retrieveEdge({
	              idList: [id]
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 2:
	            response = _context2.sent;
	            return _context2.abrupt("return", response && Array.isArray(response.data) && response.data.length > 0 ? response.data[0] : null);

	          case 4:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, _callee2);
	  }));

	  return function retrieveEdge(_x2) {
	    return _ref2.apply(this, arguments);
	  };
	}();

	var retrieveDocument = /*#__PURE__*/function () {
	  var _ref3 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(id) {
	    var response;
	    return regenerator.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            _context3.next = 2;
	            return store$3.level2SDK.documentServices.retrieveDocument({
	              idList: [id]
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 2:
	            response = _context3.sent;
	            return _context3.abrupt("return", response && Array.isArray(response.data) && response.data.length > 0 ? response.data[0] : null);

	          case 4:
	          case "end":
	            return _context3.stop();
	        }
	      }
	    }, _callee3);
	  }));

	  return function retrieveDocument(_x3) {
	    return _ref3.apply(this, arguments);
	  };
	}();

	var setBit = function setBit(target, value, bit) {
	  return value ? target | 1 << bit : target & ~(1 << bit);
	};
	var getBit = function getBit(target, bit) {
	  return !!(target & 1 << bit) ? 1 : 0;
	};

	var TOTAL_BITS = 32; // DOC FLAGS

	var FLAG_BITS = 6;
	var IS_ON_SERVER = 0;
	var IS_GZIP = 1;
	var IS_BINARY = 2;
	var IS_ENCRYPTED = 3;
	var HAS_EXTRA_KEY = 4;
	var IS_EDITABLE = 5; // DOC Application Data Type

	var DATA_TYPE_START = 17;
	var DATA_TYPE_LIST = ['data', 'profile', 'vital']; // DOC Media Type

	var MEDIA_TYPE = 27; // 31 ~ 27: 5

	var MEDIA_TYPE_BITS = TOTAL_BITS - MEDIA_TYPE;
	var MEDIA_TYPE_LIST = ['others', 'application', 'audio', 'font', 'image', 'message', 'model', 'multipart', 'text', 'video'];

	var DType = /*#__PURE__*/function () {
	  // DOC FLAGS
	  // DOC Application Data Type
	  // DOC Media Type
	  function DType() {
	    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	    classCallCheck(this, DType);

	    defineProperty(this, "_flags", 0);

	    defineProperty(this, "_dataType", 0);

	    defineProperty(this, "_mediaType", 0);

	    this.value = value;
	  }

	  createClass(DType, [{
	    key: "getFlags",
	    // DOC FLAGS
	    value: function getFlags() {
	      return {
	        isOnServer: this.isOnServer,
	        isGzip: this.isGzip,
	        isBinary: this.isBinary,
	        isEncrypted: this.isEncrypted,
	        hasExtraKey: this.hasExtraKey,
	        isEditable: this.isEditable
	      };
	    }
	  }, {
	    key: "getDataType",
	    value: function getDataType() {
	      return DATA_TYPE_LIST[this._dataType];
	    } // Media Type

	  }, {
	    key: "setMediaType",
	    value: function setMediaType(mediaType) {
	      var type = MEDIA_TYPE_LIST.findIndex(function (header) {
	        var val = RegExp("^".concat(header, "/")).test(mediaType);
	        return val;
	      });
	      this._mediaType = type === -1 ? 0 : type;
	    }
	  }, {
	    key: "getMediaType",
	    value: function getMediaType() {
	      return MEDIA_TYPE_LIST[this.mediaType];
	    }
	  }, {
	    key: "value",
	    set: function set(value) {
	      // flags
	      this.flags = value << TOTAL_BITS - FLAG_BITS >>> TOTAL_BITS - FLAG_BITS; // data type

	      this.dataType = value << MEDIA_TYPE_BITS >>> DATA_TYPE_START + MEDIA_TYPE_BITS; // media type

	      this.mediaType = value >>> MEDIA_TYPE;
	    },
	    get: function get() {
	      // merger media type
	      var tmpValue = this._mediaType << MEDIA_TYPE; // merge data type

	      tmpValue |= this._dataType << DATA_TYPE_START; // merge flags

	      tmpValue |= this.flags;
	      return tmpValue;
	    }
	  }, {
	    key: "flags",
	    set: function set(value) {
	      this.isOnServer = !!getBit(value, IS_ON_SERVER);
	      this.isGzip = !!getBit(value, IS_GZIP);
	      this.isBinary = !!getBit(value, IS_BINARY);
	      this.isEncrypted = !!getBit(value, IS_ENCRYPTED);
	      this.hasExtraKey = !!getBit(value, HAS_EXTRA_KEY);
	      this.isEditable = !!getBit(value, IS_EDITABLE);
	    },
	    get: function get() {
	      return this._flags;
	    }
	  }, {
	    key: "isOnServer",
	    set: function set(value) {
	      this._flags = setBit(this._flags, value, IS_ON_SERVER);
	    },
	    get: function get() {
	      return !!getBit(this._flags, IS_ON_SERVER);
	    }
	  }, {
	    key: "isGzip",
	    set: function set(value) {
	      this._flags = setBit(this._flags, value, IS_GZIP);
	    },
	    get: function get() {
	      return !!getBit(this._flags, IS_GZIP);
	    }
	  }, {
	    key: "isBinary",
	    set: function set(value) {
	      this._flags = setBit(this._flags, value, IS_BINARY);
	    },
	    get: function get() {
	      return !!getBit(this._flags, IS_BINARY);
	    }
	  }, {
	    key: "isEncrypted",
	    set: function set(value) {
	      this._flags = setBit(this._flags, value, IS_ENCRYPTED);
	    },
	    get: function get() {
	      return !!getBit(this._flags, IS_ENCRYPTED);
	    }
	  }, {
	    key: "hasExtraKey",
	    set: function set(value) {
	      this._flags = setBit(this._flags, value, HAS_EXTRA_KEY);
	    },
	    get: function get() {
	      return !!getBit(this._flags, HAS_EXTRA_KEY);
	    }
	  }, {
	    key: "isEditable",
	    set: function set(value) {
	      this._flags = setBit(this._flags, value, IS_EDITABLE);
	    },
	    get: function get() {
	      return !!getBit(this._flags, IS_EDITABLE);
	    } // Application Data Type

	  }, {
	    key: "dataType",
	    set: function set(_type) {
	      // const type = _type < 0 || _type >= DATA_TYPE_LIST.length ? 0 : _type
	      this._dataType = _type;
	    },
	    get: function get() {
	      return this._dataType;
	    }
	  }, {
	    key: "mediaType",
	    set: function set(_type) {
	      var type = _type < 0 || _type >= MEDIA_TYPE_LIST.length ? 0 : _type;
	      this._mediaType = type;
	    },
	    get: function get() {
	      return this._mediaType;
	    }
	  }]);

	  return DType;
	}();

	function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
	var CONTENT_SIZE_LIMIT = 32768;
	/**
	 * @param content: string | Blob
	 * @param type: text/plain | application/json | text/html | text/markdown | image/* | application/pdf | video/* | string
	 * @returns Blob
	 */

	var contentToBlob = function contentToBlob(content) {
	  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text/plain';

	  /* Convert content to be blob */
	  var blob;

	  if (typeof content === 'string') {
	    blob = new Blob([content], {
	      type: type
	    });
	  } else if (content instanceof Blob) {
	    blob = content;
	  } else {
	    try {
	      var jsonStr = JSON.stringify(content);
	      blob = new Blob([jsonStr], {
	        type: 'application/json'
	      });
	    } catch (error) {
	      throw new AiTmedError({
	        name: 'NOTE_CONTENT_INVALID',
	        message: error.message
	      });
	    }
	  }

	  return blob;
	};
	/**
	 *
	 * @param data: Uint8Array | Blob
	 * @param besak?: string | Uint8Array
	 * @returns Promise<obj>
	 * @returns obj.data: Uint8Array
	 * @returns obj.isEncrypt: boolean
	 */

	var produceEncryptData = /*#__PURE__*/function () {
	  var _ref = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(_data, esak, publicKeyOfReceiver) {
	    var data, isEncrypt;
	    return regenerator.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            if (!(_data instanceof Blob)) {
	              _context.next = 6;
	              break;
	            }

	            _context.next = 3;
	            return store$3.level2SDK.utilServices.blobToUint8Array(_data);

	          case 3:
	            _context.t0 = _context.sent;
	            _context.next = 7;
	            break;

	          case 6:
	            _context.t0 = _data;

	          case 7:
	            data = _context.t0;
	            isEncrypt = false;

	            if (!(typeof esak !== 'undefined' && esak !== '' && publicKeyOfReceiver)) {
	              _context.next = 19;
	              break;
	            }

	            _context.prev = 10;
	            _context.next = 13;
	            return store$3.level2SDK.commonServices.encryptData(esak, publicKeyOfReceiver, data);

	          case 13:
	            data = _context.sent;
	            isEncrypt = true;
	            _context.next = 19;
	            break;

	          case 17:
	            _context.prev = 17;
	            _context.t1 = _context["catch"](10);

	          case 19:
	            return _context.abrupt("return", {
	              data: data,
	              isEncrypt: isEncrypt
	            });

	          case 20:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee, null, [[10, 17]]);
	  }));

	  return function produceEncryptData(_x, _x2, _x3) {
	    return _ref.apply(this, arguments);
	  };
	}();
	/**
	 *
	 * @param _data Uint8Array | Blob
	 * @returns Promise<obj>
	 * @returns obj.data: Uint8Array
	 * @returns obj.isGzip: boolean
	 */

	var produceGzipData = /*#__PURE__*/function () {
	  var _ref2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(_data) {
	    var u8a, data, isGzip;
	    return regenerator.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            if (!(_data instanceof Blob)) {
	              _context2.next = 6;
	              break;
	            }

	            _context2.next = 3;
	            return store$3.level2SDK.utilServices.blobToUint8Array(_data);

	          case 3:
	            _context2.t0 = _context2.sent;
	            _context2.next = 7;
	            break;

	          case 6:
	            _context2.t0 = _data;

	          case 7:
	            u8a = _context2.t0;
	            data = gzip$1(u8a);
	            isGzip = data.length < u8a.length;
	            return _context2.abrupt("return", {
	              data: isGzip ? data : u8a,
	              isGzip: isGzip
	            });

	          case 11:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, _callee2);
	  }));

	  return function produceGzipData(_x4) {
	    return _ref2.apply(this, arguments);
	  };
	}();
	/**
	 *
	 * @param document: Doc
	 * @param edge?: Edge
	 * @returns Promise<Note>
	 */

	var documentToNote = /*#__PURE__*/function () {
	  var _ref4 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(_ref3) {
	    var document, _edge, esakOfCurrentUser, edge, name, contentType, deat, isOldDataStructure, dType, content, isBroken, error, data, response, edgeHasBesak, edgeHasEesak, esak, publicKeyOfReceiver, pkLocalStorage, _pkLocalStorage, blob, jsonStr;

	    return regenerator.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            document = _ref3.document, _edge = _ref3._edge, esakOfCurrentUser = _ref3.esakOfCurrentUser;

	            if (!(typeof _edge === 'undefined')) {
	              _context3.next = 7;
	              break;
	            }

	            _context3.next = 4;
	            return retrieveEdge(document.eid);

	          case 4:
	            _context3.t0 = _context3.sent;
	            _context3.next = 8;
	            break;

	          case 7:
	            _context3.t0 = _edge;

	          case 8:
	            edge = _context3.t0;

	            if (!(edge === null)) {
	              _context3.next = 11;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'UNKNOW_ERROR',
	              message: 'Note -> documentToNote -> retrieveEdge -> edge is null'
	            });

	          case 11:
	            //TODO
	            //currently commented since does not allow comparison between shared notebook
	            //and docs from root notebook
	            // if (
	            //   !store.utils.compareUint8Arrays(
	            //     <Uint8Array>edge.eid,
	            //     <Uint8Array>document.eid,
	            //   )
	            // ) {
	            //   throw new AiTmedError({ name: 'NOTEBOOK_ID_NOT_MATCH' })
	            // }
	            name = document.name;
	            contentType = parseInt(name.type) === 0 ? 'text/plain' : name.type;
	            deat = document.deat; // DType

	            isOldDataStructure = typeof name.isOnS3 !== 'undefined' || typeof name.isGzip !== 'undefined' || typeof name.isBinary !== 'undefined' || typeof name.isEncrypt !== 'undefined' || typeof name.edit_mode !== 'undefined';
	            dType = isOldDataStructure ? new DType() : new DType(document.type);

	            if (isOldDataStructure) {
	              if (typeof name.isOnS3 !== 'undefined') dType.isOnServer = !name.isOnS3;else dType.isOnServer = true;
	              if (typeof name.isGzip !== 'undefined') dType.isGzip = name.isGzip;
	              if (typeof name.isBinary !== 'undefined') dType.isBinary = name.isBinary;
	              if (typeof name.isEncrypt !== 'undefined') dType.isEncrypted = name.isEncrypt;
	              if (typeof name.edit_mode !== 'undefined') dType.isEditable = !!name.edit_mode;
	              dType.setMediaType(name.type);
	            } // Get data


	            content = null, isBroken = false, error = null;
	            _context3.prev = 18;

	            if (!dType.isOnServer) {
	              _context3.next = 29;
	              break;
	            }

	            if (!(name.data !== undefined)) {
	              _context3.next = 26;
	              break;
	            }

	            _context3.next = 23;
	            return store$3.level2SDK.utilServices.base64ToUint8Array(name.data);

	          case 23:
	            data = _context3.sent;
	            _context3.next = 27;
	            break;

	          case 26:
	            throw new AiTmedError({
	              name: 'UNKNOW_ERROR',
	              message: 'name.data is undefined'
	            });

	          case 27:
	            _context3.next = 46;
	            break;

	          case 29:
	            if (!(deat !== null && deat.url)) {
	              _context3.next = 45;
	              break;
	            }

	            _context3.next = 32;
	            return store$3.level2SDK.documentServices.downloadDocumentFromS3({
	              url: deat.url
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 32:
	            response = _context3.sent;

	            if (response) {
	              _context3.next = 35;
	              break;
	            }

	            throw 'no response';

	          case 35:
	            if (!dType.isBinary) {
	              _context3.next = 39;
	              break;
	            }

	            _context3.t1 = response.data;
	            _context3.next = 42;
	            break;

	          case 39:
	            _context3.next = 41;
	            return store$3.level2SDK.utilServices.base64ToUint8Array(response.data);

	          case 41:
	            _context3.t1 = _context3.sent;

	          case 42:
	            data = _context3.t1;
	            _context3.next = 46;
	            break;

	          case 45:
	            throw 'deat.url is missing';

	          case 46:
	            // Decryption
	            edgeHasBesak = edge.besak && edge.besak !== '';
	            edgeHasEesak = edge.eesak && edge.eesak !== '';

	            if (!(dType.isEncrypted && (edgeHasBesak || edgeHasEesak))) {
	              _context3.next = 71;
	              break;
	            }

	            if (esakOfCurrentUser) {
	              esak = esakOfCurrentUser;
	            } else {
	              esak = edgeHasBesak ? edge.besak : edge.eesak;
	            }

	            if (!edge.sig) {
	              _context3.next = 57;
	              break;
	            }

	            if (edge.sig instanceof Uint8Array) {
	              publicKeyOfReceiver = store$3.level2SDK.utilServices.uint8ArrayToBase64(edge.sig);
	            } else {
	              publicKeyOfReceiver = edge.sig;
	            }

	            _context3.next = 54;
	            return store$3.level2SDK.commonServices.decryptData(esak, publicKeyOfReceiver, data);

	          case 54:
	            data = _context3.sent;
	            _context3.next = 71;
	            break;

	          case 57:
	            if (!(!edge.sig && edge.type === 10001)) {
	              _context3.next = 65;
	              break;
	            }

	            pkLocalStorage = localStorage.getItem('pk');
	            publicKeyOfReceiver = pkLocalStorage ? pkLocalStorage : '';
	            _context3.next = 62;
	            return store$3.level2SDK.commonServices.decryptData(esak, publicKeyOfReceiver, data);

	          case 62:
	            data = _context3.sent;
	            _context3.next = 71;
	            break;

	          case 65:
	            if (!(edge.type === 10000)) {
	              _context3.next = 71;
	              break;
	            }

	            _pkLocalStorage = localStorage.getItem('pk');
	            publicKeyOfReceiver = _pkLocalStorage ? _pkLocalStorage : '';
	            _context3.next = 70;
	            return store$3.level2SDK.commonServices.decryptData(esak, publicKeyOfReceiver, data);

	          case 70:
	            data = _context3.sent;

	          case 71:
	            // Ungzip
	            if (dType.isGzip) data = ungzip$1(data);
	            _context3.next = 74;
	            return store$3.level2SDK.utilServices.uint8ArrayToBlob(data, contentType);

	          case 74:
	            blob = _context3.sent;

	            if (!/^text\//.test(blob.type)) {
	              _context3.next = 81;
	              break;
	            }

	            _context3.next = 78;
	            return new Response(blob).text();

	          case 78:
	            content = _context3.sent;
	            _context3.next = 95;
	            break;

	          case 81:
	            if (!(blob.type === 'application/json')) {
	              _context3.next = 94;
	              break;
	            }

	            _context3.next = 84;
	            return new Response(blob).text();

	          case 84:
	            jsonStr = _context3.sent;
	            _context3.prev = 85;
	            content = JSON.parse(jsonStr);
	            _context3.next = 92;
	            break;

	          case 89:
	            _context3.prev = 89;
	            _context3.t2 = _context3["catch"](85);
	            throw new AiTmedError({
	              name: 'UNKNOW_ERROR',
	              message: 'Note -> utils -> documentToNote -> JSON.parse failed'
	            });

	          case 92:
	            _context3.next = 95;
	            break;

	          case 94:
	            content = blob;

	          case 95:
	            _context3.next = 102;
	            break;

	          case 97:
	            _context3.prev = 97;
	            _context3.t3 = _context3["catch"](18);

	            if (typeof _context3.t3 === 'string') {
	              error = new AiTmedError({
	                name: 'DOWNLOAD_FROM_S3_FAIL',
	                message: "Note -> documentToNote -> ".concat(_context3.t3)
	              });
	            } else {
	              error = _context3.t3;
	            }

	            content = null;
	            isBroken = true;

	          case 102:
	            return _context3.abrupt("return", {
	              id: store$3.utils.idToBase64(document.id),
	              owner_id: store$3.utils.idToBase64(edge.bvid),
	              notebook_id: store$3.utils.idToBase64(document.eid),
	              info: {
	                title: name.title,
	                type: contentType,
	                content: content,
	                tags: name.tags || []
	              },
	              created_at: document.ctime * 1000,
	              modified_at: document.mtime * 1000,
	              isEditable: dType.isEditable,
	              isEncrypt: dType.isEncrypted,
	              isGzip: dType.isGzip,
	              isOnServer: dType.isOnServer,
	              size: document.size,
	              isBroken: isBroken,
	              error: error
	            });

	          case 103:
	          case "end":
	            return _context3.stop();
	        }
	      }
	    }, _callee3, null, [[18, 97], [85, 89]]);
	  }));

	  return function documentToNote(_x5) {
	    return _ref4.apply(this, arguments);
	  };
	}();
	/**
	 *
	 * @param id: Uint8Array | string
	 * @param _edge?: Edge
	 * @returns Promise<Note>
	 */

	var retrieveNote = /*#__PURE__*/function () {
	  var _ref5 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(id, _edge) {
	    var document, note;
	    return regenerator.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            _context4.next = 2;
	            return retrieveDocument(id);

	          case 2:
	            document = _context4.sent;

	            if (document) {
	              _context4.next = 5;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'NOT_A_NOTE'
	            });

	          case 5:
	            _context4.next = 7;
	            return documentToNote({
	              document: document,
	              _edge: _edge
	            });

	          case 7:
	            note = _context4.sent;
	            return _context4.abrupt("return", note);

	          case 9:
	          case "end":
	            return _context4.stop();
	        }
	      }
	    }, _callee4);
	  }));

	  return function retrieveNote(_x6, _x7) {
	    return _ref5.apply(this, arguments);
	  };
	}();
	/**
	 * @param id: string | Uint8Array
	 * @param fields
	 * @param fields.notebook_id?: string
	 * @param fields.title?: string
	 * @param fields.content?: string | Blob
	 * @param type?: text/plain | application/json | text/html | text/markdown | image/* | application/pdf | video/* | string
	 * @param fields.tags?: string[]
	 * @param save?: boolean
	 * @returns Promise<Note>
	 */

	var updateNote = /*#__PURE__*/function () {
	  var _ref7 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(id, _ref6) {
	    var notebook_id,
	        title,
	        content,
	        type,
	        tags,
	        save,
	        document,
	        edge,
	        params,
	        name,
	        tagsSet,
	        isOldDataStructure,
	        dType,
	        note,
	        response,
	        blob,
	        _yield$produceGzipDat,
	        gzipData,
	        isGzip,
	        _yield$produceEncrypt,
	        data,
	        isEncrypt,
	        bs64Data,
	        _response,
	        _response$data,
	        _id,
	        deat,
	        _args5 = arguments;

	    return regenerator.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            notebook_id = _ref6.notebook_id, title = _ref6.title, content = _ref6.content, type = _ref6.type, tags = _ref6.tags;
	            save = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : false;
	            _context5.next = 4;
	            return retrieveDocument(id);

	          case 4:
	            document = _context5.sent;

	            if (document) {
	              _context5.next = 7;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'NOT_A_NOTE'
	            });

	          case 7:
	            if (!(typeof notebook_id !== 'undefined')) {
	              _context5.next = 13;
	              break;
	            }

	            _context5.next = 10;
	            return retrieveEdge(notebook_id);

	          case 10:
	            edge = _context5.sent;
	            _context5.next = 16;
	            break;

	          case 13:
	            _context5.next = 15;
	            return retrieveEdge(document.eid);

	          case 15:
	            edge = _context5.sent;

	          case 16:
	            if (edge) {
	              _context5.next = 18;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'NOTEBOOK_NOT_EXIST'
	            });

	          case 18:
	            if (store$3.utils.compareUint8Arrays(edge.eid, document.eid)) {
	              _context5.next = 20;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'NOTEBOOK_ID_NOT_MATCH'
	            });

	          case 20:
	            // Update Params
	            params = {
	              id: document.id,
	              eid: edge.eid
	            };
	            if (save) params.fid = document.id; // Update name

	            name = document.name;
	            if (typeof title !== 'undefined') name.title = title;

	            if (typeof tags !== 'undefined') {
	              tagsSet = new Set([].concat(toConsumableArray(name.tags), toConsumableArray(tags)));
	              name.tags = Array.from(tagsSet);
	            } // DType


	            isOldDataStructure = typeof name.isOnS3 !== 'undefined' || typeof name.isGzip !== 'undefined' || typeof name.isBinary !== 'undefined' || typeof name.isEncrypt !== 'undefined' || typeof name.edit_mode !== 'undefined';
	            dType = isOldDataStructure ? new DType() : new DType(document.type);

	            if (isOldDataStructure) {
	              if (typeof name.isOnS3 !== 'undefined') {
	                dType.isOnServer = !name.isOnS3;
	                delete name.isOnS3;
	              }

	              if (typeof name.isGzip !== 'undefined') {
	                dType.isGzip = name.isGzip;
	                delete name.isGzip;
	              }

	              if (typeof name.isBinary !== 'undefined') {
	                dType.isBinary = name.isBinary;
	                delete name.isBinary;
	              }

	              if (typeof name.isEncrypt !== 'undefined') {
	                dType.isEncrypted = name.isEncrypt;
	                delete name.isEncrypt;
	              }

	              if (typeof name.edit_mode !== 'undefined') {
	                dType.isEditable = !!name.edit_mode;
	                delete name.edit_mode;
	              }

	              dType.setMediaType(name.type);
	            }

	            if (!(typeof content === 'undefined')) {
	              _context5.next = 40;
	              break;
	            }

	            // Does not need to update content
	            params.name = name;
	            _context5.next = 32;
	            return store$3.level2SDK.documentServices.updateDocument(_objectSpread$5(_objectSpread$5({}, params), {}, {
	              type: dType.value
	            })).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 32:
	            response = _context5.sent;

	            if (!(!response || response.code !== 0)) {
	              _context5.next = 35;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'UNKNOW_ERROR',
	              message: 'Note -> update -> updateDocument -> no response'
	            });

	          case 35:
	            _context5.next = 37;
	            return retrieveNote(document.id, edge);

	          case 37:
	            note = _context5.sent;
	            _context5.next = 78;
	            break;

	          case 40:
	            _context5.next = 42;
	            return contentToBlob(content, type);

	          case 42:
	            blob = _context5.sent;
	            _context5.next = 45;
	            return produceGzipData(blob);

	          case 45:
	            _yield$produceGzipDat = _context5.sent;
	            gzipData = _yield$produceGzipDat.data;
	            isGzip = _yield$produceGzipDat.isGzip;
	            dType.isGzip = isGzip;
	            dType.isOnServer = gzipData.length < CONTENT_SIZE_LIMIT; // Encryption

	            _context5.next = 52;
	            return produceEncryptData(gzipData, edge.besak);

	          case 52:
	            _yield$produceEncrypt = _context5.sent;
	            data = _yield$produceEncrypt.data;
	            isEncrypt = _yield$produceEncrypt.isEncrypt;
	            dType.isEncrypted = isEncrypt;
	            _context5.next = 58;
	            return store$3.level2SDK.utilServices.uint8ArrayToBase64(data);

	          case 58:
	            bs64Data = _context5.sent;
	            dType.isBinary = false;
	            name.type = blob.type;
	            params.size = blob.size;

	            if (dType.isOnServer) {
	              name.data = bs64Data;
	            } else {
	              if (typeof name.data !== 'undefined') delete name.data;
	            }

	            params.name = name; // Create new DOC

	            _context5.next = 66;
	            return store$3.level2SDK.documentServices.createDocument({
	              eid: edge.eid,
	              type: dType.value,
	              name: name,
	              size: blob.size
	            });

	          case 66:
	            _response = _context5.sent;

	            if (!(!_response || _response.code !== 0)) {
	              _context5.next = 69;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'UNKNOW_ERROR',
	              message: 'Note -> update -> updateDocument -> no response'
	            });

	          case 69:
	            _response$data = _response.data, _id = _response$data.id, deat = _response$data.deat;

	            if (!(deat !== null && deat && deat.url && deat.sig)) {
	              _context5.next = 73;
	              break;
	            }

	            _context5.next = 73;
	            return store$3.level2SDK.documentServices.uploadDocumentToS3({
	              url: deat.url,
	              sig: deat.sig,
	              data: bs64Data
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 73:
	            _context5.next = 75;
	            return store$3.level2SDK.documentServices.deleteDocument([document.id]).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 75:
	            _context5.next = 77;
	            return retrieveNote(_id, edge);

	          case 77:
	            note = _context5.sent;

	          case 78:
	            return _context5.abrupt("return", note);

	          case 79:
	          case "end":
	            return _context5.stop();
	        }
	      }
	    }, _callee5);
	  }));

	  return function updateNote(_x8, _x9) {
	    return _ref7.apply(this, arguments);
	  };
	}();

	var listDocsFilter = function listDocsFilter(document, _ref8) {
	  var dataType = _ref8.dataType,
	      mediaType = _ref8.mediaType,
	      options = objectWithoutProperties(_ref8, ["dataType", "mediaType"]);

	  var dType = new DType(document.type);

	  if (dataType !== undefined) {
	    if (typeof dataType === 'number' && dataType !== dType.dataType) {
	      return false;
	    } else if (typeof dataType !== 'number') {
	      if (dataType === 'profile') {
	        var name = document.name;

	        if (name.title !== 'profile' || name.type !== 'application/json') {
	          return false;
	        }
	      } else {
	        if (dataType !== dType.getDataType()) return false;
	      }
	    }
	  }

	  if (mediaType !== undefined) {
	    if (typeof mediaType === 'number' && mediaType !== dType.mediaType) {
	      return false;
	    } else if (typeof mediaType !== 'number' && mediaType !== dType.getMediaType()) {
	      return false;
	    }
	  }

	  for (var key in options) {
	    var value = options[key];
	    var dTypeValue = dType[key];

	    if (value !== undefined && dTypeValue !== undefined) {
	      if (value !== dTypeValue) return false;
	    }
	  }

	  return true;
	};
	/**
	 *
	 * @param edge: Edge
	 * @param options: NoteUtilsTypes.ListDocsOptions
	 * @param options.shared?: Boolean
	 * @param options.count?: number
	 * @param options.sort_by?: 0 | 1 | 2
	 *
	 * @param options.isOnServer?: boolean
	 * @param options.isGzip?: boolean
	 * @param options.isBinary?: boolean
	 * @param options.isEncrypted?: boolean
	 * @param options.hasExtraKey?: boolean
	 * @param options.isEditable?: boolean
	 *
	 * @param options.dataType?: number
	 * @param options.mediaType?: number
	 *
	 * @returns Promise<Doc[]>
	 */


	var listDocs = /*#__PURE__*/function () {
	  var _ref9 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6(edge) {
	    var options,
	        _options$shared,
	        shared,
	        _options$count,
	        _options$sort_by,
	        otherOptions,
	        idOfRootNotebook,
	        response,
	        documents,
	        _args6 = arguments;

	    return regenerator.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            options = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};
	            _options$shared = options.shared, shared = _options$shared === void 0 ? false : _options$shared, _options$count = options.count, _options$sort_by = options.sort_by, otherOptions = objectWithoutProperties(options, ["shared", "count", "sort_by"]);

	            if (shared) {
	              idOfRootNotebook = edge.refid;
	            } else {
	              idOfRootNotebook = edge.eid;
	            }

	            _context6.next = 5;
	            return store$3.level2SDK.documentServices.retrieveDocument({
	              idList: [idOfRootNotebook],
	              options: {
	                xfname: 'eid'
	              }
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 5:
	            response = _context6.sent;

	            if (!(!response || !response.data || !Array.isArray(response.data))) {
	              _context6.next = 8;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'UNKNOW_ERROR',
	              message: 'Note -> list -> retrieveDocument -> no response'
	            });

	          case 8:
	            documents = response.data.filter(function (document) {
	              return listDocsFilter(document, otherOptions);
	            });
	            return _context6.abrupt("return", documents);

	          case 10:
	          case "end":
	            return _context6.stop();
	        }
	      }
	    }, _callee6);
	  }));

	  return function listDocs(_x10) {
	    return _ref9.apply(this, arguments);
	  };
	}();

	function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _createForOfIteratorHelper$e(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$f(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$f(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$f(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$f(o, minLen); }

	function _arrayLikeToArray$f(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	/**
	 * @param params
	 * @param params.notebook_id: string
	 * @param params.title: string
	 * @param params.content: string | Blob
	 * @param params.type: 0 | 1 | 2 | 3 | 10 | 11 | 12
	 * @param params.tags?: string[]
	 * @param params.dataType?: number
	 * @returns Promise<Note>
	 */

	var create = /*#__PURE__*/function () {
	  var _ref2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(_ref) {
	    var notebook_id, title, _ref$tags, tags, content, type, _ref$dataType, dataType, edge, dType, blob, _yield$produceGzipDat, gzipData, isGzip, esak, publicKeyOfReceiver, _yield$produceEncrypt, data, isEncrypt, bs64Data, name, response, document, deat, note;

	    return regenerator.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            notebook_id = _ref.notebook_id, title = _ref.title, _ref$tags = _ref.tags, tags = _ref$tags === void 0 ? [] : _ref$tags, content = _ref.content, type = _ref.type, _ref$dataType = _ref.dataType, dataType = _ref$dataType === void 0 ? 0 : _ref$dataType;
	            _context.next = 3;
	            return retrieveEdge(notebook_id);

	          case 3:
	            edge = _context.sent;

	            if (edge) {
	              _context.next = 6;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'NOTEBOOK_NOT_EXIST'
	            });

	          case 6:
	            dType = new DType();
	            dType.dataType = dataType; // Permission

	            dType.isEditable = true; // Content to Blob

	            _context.next = 11;
	            return contentToBlob(content, type);

	          case 11:
	            blob = _context.sent;
	            dType.setMediaType(blob.type); // Gzip

	            _context.next = 15;
	            return produceGzipData(blob);

	          case 15:
	            _yield$produceGzipDat = _context.sent;
	            gzipData = _yield$produceGzipDat.data;
	            isGzip = _yield$produceGzipDat.isGzip;
	            dType.isGzip = isGzip;
	            dType.isOnServer = gzipData.length < CONTENT_SIZE_LIMIT; // Encryption

	            esak = '';
	            publicKeyOfReceiver = '';

	            if (!(edge.besak && edge.sig)) {
	              _context.next = 33;
	              break;
	            }

	            esak = edge.besak;

	            if (!(edge.sig instanceof Uint8Array)) {
	              _context.next = 30;
	              break;
	            }

	            _context.next = 27;
	            return store$3.level2SDK.utilServices.uint8ArrayToBase64(edge.sig);

	          case 27:
	            publicKeyOfReceiver = _context.sent;
	            _context.next = 31;
	            break;

	          case 30:
	            publicKeyOfReceiver = edge.sig;

	          case 31:
	            _context.next = 42;
	            break;

	          case 33:
	            if (!(edge.eesak && edge.sig)) {
	              _context.next = 42;
	              break;
	            }

	            esak = edge.eesak;

	            if (!(edge.sig instanceof Uint8Array)) {
	              _context.next = 41;
	              break;
	            }

	            _context.next = 38;
	            return store$3.level2SDK.utilServices.uint8ArrayToBase64(edge.sig);

	          case 38:
	            publicKeyOfReceiver = _context.sent;
	            _context.next = 42;
	            break;

	          case 41:
	            publicKeyOfReceiver = edge.sig;

	          case 42:
	            _context.next = 44;
	            return produceEncryptData(gzipData, esak, publicKeyOfReceiver);

	          case 44:
	            _yield$produceEncrypt = _context.sent;
	            data = _yield$produceEncrypt.data;
	            isEncrypt = _yield$produceEncrypt.isEncrypt;
	            dType.isEncrypted = isEncrypt;
	            _context.next = 50;
	            return store$3.level2SDK.utilServices.uint8ArrayToBase64(data);

	          case 50:
	            bs64Data = _context.sent;
	            dType.isBinary = false;
	            name = {
	              title: title,
	              tags: tags,
	              type: blob.type
	            }; // data must be base64 in name field

	            if (dType.isOnServer) name.data = bs64Data;
	            _context.next = 56;
	            return store$3.level2SDK.documentServices.createDocument({
	              eid: edge.eid,
	              type: dType.value,
	              name: name,
	              size: blob.size
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 56:
	            response = _context.sent;

	            if (!(!response || !response.data)) {
	              _context.next = 59;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'UNKNOW_ERROR',
	              message: 'Note -> create -> createDocument -> no response'
	            });

	          case 59:
	            document = response.data;
	            deat = document.deat;

	            if (!(!dType.isOnServer && deat !== null && deat && deat.url && deat.sig)) {
	              _context.next = 64;
	              break;
	            }

	            _context.next = 64;
	            return store$3.level2SDK.documentServices.uploadDocumentToS3({
	              url: deat.url,
	              sig: deat.sig,
	              data: bs64Data
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 64:
	            _context.next = 66;
	            return retrieveNote(document.id);

	          case 66:
	            note = _context.sent;
	            return _context.abrupt("return", note);

	          case 68:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee);
	  }));

	  return function create(_x) {
	    return _ref2.apply(this, arguments);
	  };
	}();
	/**
	 * @param id: string | Uint8Array
	 */

	var retrieve = /*#__PURE__*/function () {
	  var _ref3 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(id) {
	    var note;
	    return regenerator.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            _context2.next = 2;
	            return retrieveNote(id);

	          case 2:
	            note = _context2.sent;
	            return _context2.abrupt("return", note);

	          case 4:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, _callee2);
	  }));

	  return function retrieve(_x2) {
	    return _ref3.apply(this, arguments);
	  };
	}();
	/**
	 * @param id: string | Uint8Array
	 * @returns Promise<Note>
	 */

	var remove = /*#__PURE__*/function () {
	  var _ref4 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(id) {
	    var note;
	    return regenerator.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            _context3.next = 2;
	            return retrieve(id);

	          case 2:
	            note = _context3.sent;
	            _context3.next = 5;
	            return store$3.level2SDK.documentServices.deleteDocument([note.id]).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 5:
	            return _context3.abrupt("return", note);

	          case 6:
	          case "end":
	            return _context3.stop();
	        }
	      }
	    }, _callee3);
	  }));

	  return function remove(_x3) {
	    return _ref4.apply(this, arguments);
	  };
	}();
	/**
	 * @param id: string
	 * @param params
	 * @param params.notebook_id?: string
	 * @param params.title?: string
	 * @param params.content?: string | Blob
	 * @param params.tags?: string[]
	 * @returns Promise<Note>
	 */

	var update = /*#__PURE__*/function () {
	  var _ref5 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(id, fields) {
	    var note;
	    return regenerator.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            _context4.next = 2;
	            return updateNote(id, fields, false);

	          case 2:
	            note = _context4.sent;
	            return _context4.abrupt("return", note);

	          case 4:
	          case "end":
	            return _context4.stop();
	        }
	      }
	    }, _callee4);
	  }));

	  return function update(_x4, _x5) {
	    return _ref5.apply(this, arguments);
	  };
	}();
	/**
	 * @param id: string
	 * @param params
	 * @param params.notebook_id?: string
	 * @param params.title?: string
	 * @param params.content?: string | Blob
	 * @param params.tags?: string[]
	 * @returns Promise<Note>
	 */

	var save = /*#__PURE__*/function () {
	  var _ref6 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(id, fields) {
	    var note;
	    return regenerator.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            _context5.next = 2;
	            return updateNote(id, fields, true);

	          case 2:
	            note = _context5.sent;
	            return _context5.abrupt("return", note);

	          case 4:
	          case "end":
	            return _context5.stop();
	        }
	      }
	    }, _callee5);
	  }));

	  return function save(_x6, _x7) {
	    return _ref6.apply(this, arguments);
	  };
	}();
	/**
	 * @param notebook_id
	 * @param options
	 * @param options.shared?: Boolean
	 * @param options.types?: (NoteTypes | NoteFileTypes)[]
	 * @param options.tags?: string[]
	 * @param options.count?: number
	 * @param options.edit_mode?: number
	 * @param options.sort_by?: 0 | 1 | 2
	 */

	var list = /*#__PURE__*/function () {
	  var _ref7 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6(notebook_id, options) {
	    var edge, documents, ids, mapper, _iterator, _step, document, note;

	    return regenerator.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            _context6.next = 2;
	            return retrieveEdge(notebook_id);

	          case 2:
	            edge = _context6.sent;

	            if (edge) {
	              _context6.next = 5;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'NOTEBOOK_NOT_EXIST'
	            });

	          case 5:
	            _context6.next = 7;
	            return listDocs(edge, options);

	          case 7:
	            documents = _context6.sent;
	            ids = [];
	            mapper = {};
	            _iterator = _createForOfIteratorHelper$e(documents);
	            _context6.prev = 11;

	            _iterator.s();

	          case 13:
	            if ((_step = _iterator.n()).done) {
	              _context6.next = 22;
	              break;
	            }

	            document = _step.value;
	            _context6.next = 17;
	            return documentToNote({
	              document: document,
	              edge: edge
	            });

	          case 17:
	            note = _context6.sent;
	            ids.push(note.id);
	            mapper[note.id] = note;

	          case 20:
	            _context6.next = 13;
	            break;

	          case 22:
	            _context6.next = 27;
	            break;

	          case 24:
	            _context6.prev = 24;
	            _context6.t0 = _context6["catch"](11);

	            _iterator.e(_context6.t0);

	          case 27:
	            _context6.prev = 27;

	            _iterator.f();

	            return _context6.finish(27);

	          case 30:
	            return _context6.abrupt("return", {
	              ids: ids,
	              mapper: mapper
	            });

	          case 31:
	          case "end":
	            return _context6.stop();
	        }
	      }
	    }, _callee6, null, [[11, 24, 27, 30]]);
	  }));

	  return function list(_x8, _x9) {
	    return _ref7.apply(this, arguments);
	  };
	}();
	/**
	 * @param notebook_id
	 * @param options
	 * @param options.tags?: string[]
	 * @param options.count?: number
	 * @param options.edit_mode?: number
	 * @param options.sort_by?: 0 | 1 | 2
	 */

	var listSharedNotes = /*#__PURE__*/function () {
	  var _ref8 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8(rootNotebookId, options) {
	    var _yield$store$level2SD, edges, _yield$store$level2SD2, rootEdge, sharedNotebooksWithRootNoteBook, ids, mapper, vidOfCurrentUserB64, esakOfCurrentUser;

	    return regenerator.wrap(function _callee8$(_context8) {
	      while (1) {
	        switch (_context8.prev = _context8.next) {
	          case 0:
	            _context8.next = 2;
	            return store$3.level2SDK.edgeServices.retrieveEdge({
	              idList: [rootNotebookId],
	              options: _objectSpread$6(_objectSpread$6({}, options), {}, {
	                type: 10001,
	                xfname: 'refid'
	              })
	            });

	          case 2:
	            _yield$store$level2SD = _context8.sent;
	            edges = _yield$store$level2SD.data;
	            _context8.next = 6;
	            return store$3.level2SDK.edgeServices.retrieveEdge({
	              idList: [rootNotebookId]
	            });

	          case 6:
	            _yield$store$level2SD2 = _context8.sent;
	            rootEdge = _yield$store$level2SD2.data;

	            if (edges) {
	              _context8.next = 10;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'NOTEBOOK_NOT_EXIST'
	            });

	          case 10:
	            sharedNotebooksWithRootNoteBook = [].concat(toConsumableArray(edges), toConsumableArray(rootEdge));
	            ids = [];
	            mapper = {};

	            if (!sharedNotebooksWithRootNoteBook.length) {
	              _context8.next = 18;
	              break;
	            }

	            vidOfCurrentUserB64 = localStorage.getItem('user_vid');
	            esakOfCurrentUser = sharedNotebooksWithRootNoteBook.filter(function (edge) {
	              var vidOfCurrentUserUint8Array = store$3.level2SDK.utilServices.uint8ArrayToBase64(edge.evid);
	              return vidOfCurrentUserB64 === vidOfCurrentUserUint8Array;
	            }).map(function (edge) {
	              return edge.eesak;
	            }).pop();
	            _context8.next = 18;
	            return Promise.all(sharedNotebooksWithRootNoteBook.map( /*#__PURE__*/function () {
	              var _ref9 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7(edge) {
	                var documents, _iterator2, _step2, document, note;

	                return regenerator.wrap(function _callee7$(_context7) {
	                  while (1) {
	                    switch (_context7.prev = _context7.next) {
	                      case 0:
	                        _context7.next = 2;
	                        return listDocs(edge, options);

	                      case 2:
	                        documents = _context7.sent;
	                        _iterator2 = _createForOfIteratorHelper$e(documents);
	                        _context7.prev = 4;

	                        _iterator2.s();

	                      case 6:
	                        if ((_step2 = _iterator2.n()).done) {
	                          _context7.next = 15;
	                          break;
	                        }

	                        document = _step2.value;
	                        _context7.next = 10;
	                        return documentToNote({
	                          document: document,
	                          edge: edge,
	                          esakOfCurrentUser: esakOfCurrentUser
	                        });

	                      case 10:
	                        note = _context7.sent;
	                        ids.push(note.id);
	                        mapper[note.id] = note;

	                      case 13:
	                        _context7.next = 6;
	                        break;

	                      case 15:
	                        _context7.next = 20;
	                        break;

	                      case 17:
	                        _context7.prev = 17;
	                        _context7.t0 = _context7["catch"](4);

	                        _iterator2.e(_context7.t0);

	                      case 20:
	                        _context7.prev = 20;

	                        _iterator2.f();

	                        return _context7.finish(20);

	                      case 23:
	                        return _context7.abrupt("return", documents);

	                      case 24:
	                      case "end":
	                        return _context7.stop();
	                    }
	                  }
	                }, _callee7, null, [[4, 17, 20, 23]]);
	              }));

	              return function (_x12) {
	                return _ref9.apply(this, arguments);
	              };
	            }())).then(function () {
	              return {
	                ids: ids,
	                mapper: mapper
	              };
	            })["catch"](function () {
	              throw new AiTmedError({
	                name: 'DECRYPTING_NOTES_FAIL'
	              });
	            });

	          case 18:
	            return _context8.abrupt("return", {
	              ids: ids,
	              mapper: mapper
	            });

	          case 19:
	          case "end":
	            return _context8.stop();
	        }
	      }
	    }, _callee8);
	  }));

	  return function listSharedNotes(_x10, _x11) {
	    return _ref8.apply(this, arguments);
	  };
	}();
	/**
	 * Todo:
	 * 1. retrieveDocument with id - check the note is exist or not
	 * 2.
	 * @param id
	 * @param invite_phone_number
	 * @param edit_mode
	 */
	// export async function share(
	//   id: string | Uint8Array,
	//   invite_phone_number: string,
	//   edit_mode: number,
	// ): Promise<void> {
	//   console.log('Note->share', id, invite_phone_number, edit_mode)
	// }

	/**
	 * Todo:
	 * 1. retrieveDocument with id - check the note is exist or not
	 * 2.
	 * @param id
	 * @param invited_phone_number
	 */
	// export async function unshare(
	//   id: string | Uint8Array,
	//   invited_phone_number: string,
	// ): Promise<void> {
	//   console.log('Note->unshare', id, invited_phone_number)
	// }

	var Note = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create,
		retrieve: retrieve,
		remove: remove,
		update: update,
		save: save,
		list: list,
		listSharedNotes: listSharedNotes
	});

	function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
	/**
	 *
	 * @param document: Doc
	 * @param edge?: Edge
	 * @returns Promise<Note>
	 */

	var documentToNote$1 = /*#__PURE__*/function () {
	  var _ref2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(_ref) {
	    var document, _edge, esakOfCurrentUser, edge, name, contentType, deat, isOldDataStructure, dType, content, error, data, response, edgeHasBesak, edgeHasEesak, esak, publicKeyOfReceiver, pkLocalStorage, _pkLocalStorage, blob, jsonStr;

	    return regenerator.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            document = _ref.document, _edge = _ref._edge, esakOfCurrentUser = _ref.esakOfCurrentUser;

	            if (!(typeof _edge === 'undefined')) {
	              _context.next = 7;
	              break;
	            }

	            _context.next = 4;
	            return retrieveEdge(document.eid);

	          case 4:
	            _context.t0 = _context.sent;
	            _context.next = 8;
	            break;

	          case 7:
	            _context.t0 = _edge;

	          case 8:
	            edge = _context.t0;

	            if (!(edge === null)) {
	              _context.next = 11;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'UNKNOW_ERROR',
	              message: 'Note -> documentToNote -> retrieveEdge -> edge is null'
	            });

	          case 11:
	            //TODO
	            //currently commented since does not allow comparison between shared notebook
	            //and docs from root notebook
	            // if (
	            //   !store.utils.compareUint8Arrays(
	            //     <Uint8Array>edge.eid,
	            //     <Uint8Array>document.eid,
	            //   )
	            // ) {
	            //   throw new AiTmedError({ name: 'NOTEBOOK_ID_NOT_MATCH' })
	            // }
	            name = document.name;
	            contentType = parseInt(name.type) === 0 ? 'text/plain' : name.type;
	            deat = document.deat; // DType

	            isOldDataStructure = typeof name.isOnS3 !== 'undefined' || typeof name.isGzip !== 'undefined' || typeof name.isBinary !== 'undefined' || typeof name.isEncrypt !== 'undefined' || typeof name.edit_mode !== 'undefined';
	            dType = isOldDataStructure ? new DType() : new DType(document.type);

	            if (isOldDataStructure) {
	              if (typeof name.isOnS3 !== 'undefined') dType.isOnServer = !name.isOnS3;else dType.isOnServer = true;
	              if (typeof name.isGzip !== 'undefined') dType.isGzip = name.isGzip;
	              if (typeof name.isBinary !== 'undefined') dType.isBinary = name.isBinary;
	              if (typeof name.isEncrypt !== 'undefined') dType.isEncrypted = name.isEncrypt;
	              if (typeof name.edit_mode !== 'undefined') dType.isEditable = !!name.edit_mode;
	              dType.setMediaType(name.type);
	            } // Get data


	            content = null, error = null;
	            _context.prev = 18;

	            if (!dType.isOnServer) {
	              _context.next = 29;
	              break;
	            }

	            if (!(name.data !== undefined)) {
	              _context.next = 26;
	              break;
	            }

	            _context.next = 23;
	            return store$3.level2SDK.utilServices.base64ToUint8Array(name.data);

	          case 23:
	            data = _context.sent;
	            _context.next = 27;
	            break;

	          case 26:
	            throw new AiTmedError({
	              name: 'UNKNOW_ERROR',
	              message: 'name.data is undefined'
	            });

	          case 27:
	            _context.next = 46;
	            break;

	          case 29:
	            if (!(deat !== null && deat.url)) {
	              _context.next = 45;
	              break;
	            }

	            _context.next = 32;
	            return store$3.level2SDK.documentServices.downloadDocumentFromS3({
	              url: deat.url
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 32:
	            response = _context.sent;

	            if (response) {
	              _context.next = 35;
	              break;
	            }

	            throw 'no response';

	          case 35:
	            if (!dType.isBinary) {
	              _context.next = 39;
	              break;
	            }

	            _context.t1 = response.data;
	            _context.next = 42;
	            break;

	          case 39:
	            _context.next = 41;
	            return store$3.level2SDK.utilServices.base64ToUint8Array(response.data);

	          case 41:
	            _context.t1 = _context.sent;

	          case 42:
	            data = _context.t1;
	            _context.next = 46;
	            break;

	          case 45:
	            throw 'deat.url is missing';

	          case 46:
	            // Decryption
	            edgeHasBesak = edge.besak && edge.besak !== '';
	            edgeHasEesak = edge.eesak && edge.eesak !== '';

	            if (!(dType.isEncrypted && (edgeHasBesak || edgeHasEesak))) {
	              _context.next = 71;
	              break;
	            }

	            if (esakOfCurrentUser) {
	              esak = esakOfCurrentUser;
	            } else {
	              esak = edgeHasBesak ? edge.besak : edge.eesak;
	            }

	            if (!edge.sig) {
	              _context.next = 57;
	              break;
	            }

	            if (edge.sig instanceof Uint8Array) {
	              publicKeyOfReceiver = store$3.level2SDK.utilServices.uint8ArrayToBase64(edge.sig);
	            } else {
	              publicKeyOfReceiver = edge.sig;
	            }

	            _context.next = 54;
	            return store$3.level2SDK.commonServices.decryptData(esak, publicKeyOfReceiver, data);

	          case 54:
	            data = _context.sent;
	            _context.next = 71;
	            break;

	          case 57:
	            if (!(!edge.sig && edge.type === 10001)) {
	              _context.next = 65;
	              break;
	            }

	            pkLocalStorage = localStorage.getItem('pk');
	            publicKeyOfReceiver = pkLocalStorage ? pkLocalStorage : '';
	            _context.next = 62;
	            return store$3.level2SDK.commonServices.decryptData(esak, publicKeyOfReceiver, data);

	          case 62:
	            data = _context.sent;
	            _context.next = 71;
	            break;

	          case 65:
	            if (!(edge.type === 10000)) {
	              _context.next = 71;
	              break;
	            }

	            _pkLocalStorage = localStorage.getItem('pk');
	            publicKeyOfReceiver = _pkLocalStorage ? _pkLocalStorage : '';
	            _context.next = 70;
	            return store$3.level2SDK.commonServices.decryptData(esak, publicKeyOfReceiver, data);

	          case 70:
	            data = _context.sent;

	          case 71:
	            // Ungzip
	            if (dType.isGzip) data = ungzip$1(data);
	            _context.next = 74;
	            return store$3.level2SDK.utilServices.uint8ArrayToBlob(data, contentType);

	          case 74:
	            blob = _context.sent;

	            if (!/^text\//.test(blob.type)) {
	              _context.next = 81;
	              break;
	            }

	            _context.next = 78;
	            return new Response(blob).text();

	          case 78:
	            content = _context.sent;
	            _context.next = 95;
	            break;

	          case 81:
	            if (!(blob.type === 'application/json')) {
	              _context.next = 94;
	              break;
	            }

	            _context.next = 84;
	            return new Response(blob).text();

	          case 84:
	            jsonStr = _context.sent;
	            _context.prev = 85;
	            content = JSON.parse(jsonStr);
	            _context.next = 92;
	            break;

	          case 89:
	            _context.prev = 89;
	            _context.t2 = _context["catch"](85);
	            throw new AiTmedError({
	              name: 'UNKNOW_ERROR',
	              message: 'Note -> utils -> documentToNote -> JSON.parse failed'
	            });

	          case 92:
	            _context.next = 95;
	            break;

	          case 94:
	            content = blob;

	          case 95:
	            _context.next = 102;
	            break;

	          case 97:
	            _context.prev = 97;
	            _context.t3 = _context["catch"](18);

	            if (typeof _context.t3 === 'string') {
	              error = new AiTmedError({
	                name: 'DOWNLOAD_FROM_S3_FAIL',
	                message: "Note -> documentToNote -> ".concat(_context.t3)
	              });
	            } else {
	              error = _context.t3;
	            }

	            content = null;

	          case 102:
	            return _context.abrupt("return", _objectSpread$7(_objectSpread$7({}, document), {}, {
	              name: {
	                title: name.title,
	                type: contentType,
	                content: content,
	                tags: name.tags || []
	              },
	              created_at: document.ctime * 1000,
	              modified_at: document.mtime * 1000,
	              type: {
	                isOnServer: dType.isOnServer,
	                isZipped: dType.isGzip,
	                isBinary: dType.isBinary,
	                isEncrypted: dType.isEncrypted,
	                isEditable: dType.isEditable,
	                applicationDataType: dType.dataType,
	                mediaType: dType.mediaType,
	                size: document.size
	              }
	            }));

	          case 103:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee, null, [[18, 97], [85, 89]]);
	  }));

	  return function documentToNote(_x) {
	    return _ref2.apply(this, arguments);
	  };
	}();

	/**
	 * @param params
	 * @param params.edge_id: string
	 * @param params.title: string
	 * @param params.content: string | Blob
	 * @param params.type: 0 | 1 | 2 | 3 | 10 | 11 | 12
	 * @param params.tags?: string[]
	 * @param params.dataType?: number
	 * @returns Promise<Note>
	 */

	var create$1 = /*#__PURE__*/function () {
	  var _ref2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(_ref) {
	    var edge_id, title, _ref$tags, tags, content, type, _ref$dataType, dataType, edge, dType, blob, _yield$produceGzipDat, gzipData, isGzip, esak, publicKeyOfReceiver, _yield$produceEncrypt, data, isEncrypt, bs64Data, name, response, document, deat, note;

	    return regenerator.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            edge_id = _ref.edge_id, title = _ref.title, _ref$tags = _ref.tags, tags = _ref$tags === void 0 ? [] : _ref$tags, content = _ref.content, type = _ref.type, _ref$dataType = _ref.dataType, dataType = _ref$dataType === void 0 ? 0 : _ref$dataType;
	            _context.next = 3;
	            return retrieveEdge(edge_id);

	          case 3:
	            edge = _context.sent;

	            if (edge) {
	              _context.next = 6;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'NOTEBOOK_NOT_EXIST'
	            });

	          case 6:
	            dType = new DType();
	            dType.dataType = dataType; // Permission

	            dType.isEditable = true; // Content to Blob

	            _context.next = 11;
	            return contentToBlob(content, type);

	          case 11:
	            blob = _context.sent;
	            dType.setMediaType(blob.type); // Gzip

	            _context.next = 15;
	            return produceGzipData(blob);

	          case 15:
	            _yield$produceGzipDat = _context.sent;
	            gzipData = _yield$produceGzipDat.data;
	            isGzip = _yield$produceGzipDat.isGzip;
	            dType.isGzip = isGzip;
	            dType.isOnServer = gzipData.length < CONTENT_SIZE_LIMIT; // Encryption

	            esak = '';
	            publicKeyOfReceiver = '';

	            if (!(edge.besak && edge.sig)) {
	              _context.next = 33;
	              break;
	            }

	            esak = edge.besak;

	            if (!(edge.sig instanceof Uint8Array)) {
	              _context.next = 30;
	              break;
	            }

	            _context.next = 27;
	            return store$3.level2SDK.utilServices.uint8ArrayToBase64(edge.sig);

	          case 27:
	            publicKeyOfReceiver = _context.sent;
	            _context.next = 31;
	            break;

	          case 30:
	            publicKeyOfReceiver = edge.sig;

	          case 31:
	            _context.next = 42;
	            break;

	          case 33:
	            if (!(edge.eesak && edge.sig)) {
	              _context.next = 42;
	              break;
	            }

	            esak = edge.eesak;

	            if (!(edge.sig instanceof Uint8Array)) {
	              _context.next = 41;
	              break;
	            }

	            _context.next = 38;
	            return store$3.level2SDK.utilServices.uint8ArrayToBase64(edge.sig);

	          case 38:
	            publicKeyOfReceiver = _context.sent;
	            _context.next = 42;
	            break;

	          case 41:
	            publicKeyOfReceiver = edge.sig;

	          case 42:
	            _context.next = 44;
	            return produceEncryptData(gzipData, esak, publicKeyOfReceiver);

	          case 44:
	            _yield$produceEncrypt = _context.sent;
	            data = _yield$produceEncrypt.data;
	            isEncrypt = _yield$produceEncrypt.isEncrypt;
	            dType.isEncrypted = isEncrypt;
	            _context.next = 50;
	            return store$3.level2SDK.utilServices.uint8ArrayToBase64(data);

	          case 50:
	            bs64Data = _context.sent;
	            dType.isBinary = false;
	            name = {
	              title: title,
	              tags: tags,
	              type: blob.type
	            }; // data must be base64 in name field

	            if (dType.isOnServer) name.data = bs64Data;
	            _context.next = 56;
	            return store$3.level2SDK.documentServices.createDocument({
	              eid: edge.eid,
	              type: dType.value,
	              name: name,
	              size: blob.size
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 56:
	            response = _context.sent;

	            if (!(!response || !response.data)) {
	              _context.next = 59;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'UNKNOW_ERROR',
	              message: 'Note -> create -> createDocument -> no response'
	            });

	          case 59:
	            document = response.data;
	            deat = document.deat;

	            if (!(!dType.isOnServer && deat !== null && deat && deat.url && deat.sig)) {
	              _context.next = 64;
	              break;
	            }

	            _context.next = 64;
	            return store$3.level2SDK.documentServices.uploadDocumentToS3({
	              url: deat.url,
	              sig: deat.sig,
	              data: bs64Data
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 64:
	            _context.next = 66;
	            return documentToNote$1({
	              document: document
	            });

	          case 66:
	            note = _context.sent;
	            return _context.abrupt("return", note);

	          case 68:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee);
	  }));

	  return function create(_x) {
	    return _ref2.apply(this, arguments);
	  };
	}();
	/**
	 *
	 * @param id: Uint8Array | string
	 * @param _edge?: Edge
	 * @returns Promise<Note>
	 */
	//TODO: refactor to account for retrieving using edge and xfname:eid

	var retrieve$1 = /*#__PURE__*/function () {
	  var _ref3 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(id, _edge) {
	    var document, note;
	    return regenerator.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            _context2.next = 2;
	            return retrieveDocument(id);

	          case 2:
	            document = _context2.sent;

	            if (document) {
	              _context2.next = 5;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'NOT_A_NOTE'
	            });

	          case 5:
	            _context2.next = 7;
	            return documentToNote$1({
	              document: document,
	              _edge: _edge
	            });

	          case 7:
	            note = _context2.sent;
	            return _context2.abrupt("return", note);

	          case 9:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, _callee2);
	  }));

	  return function retrieve(_x2, _x3) {
	    return _ref3.apply(this, arguments);
	  };
	}();

	var Document$3 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create$1,
		retrieve: retrieve$1
	});

	function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	var eTypes;

	(function (eTypes) {
	  eTypes[eTypes["ROOT"] = 10000] = "ROOT";
	  eTypes[eTypes["NOTEBOOK"] = 10001] = "NOTEBOOK";
	  eTypes[eTypes["INVITE"] = 1050] = "INVITE";
	  eTypes[eTypes["REJECT_INVITE"] = 1052] = "REJECT_INVITE";
	  eTypes[eTypes["ACCEPT_INVITE"] = 1060] = "ACCEPT_INVITE";
	  eTypes[eTypes["AUTHORIZE_INVITE"] = 1070] = "AUTHORIZE_INVITE";
	  eTypes[eTypes["AUTHORIZE_INVITE_INDEPENDENT"] = 1071] = "AUTHORIZE_INVITE_INDEPENDENT";
	  eTypes[eTypes["INBOX"] = 10002] = "INBOX";
	})(eTypes || (eTypes = {}));

	var _Object$keys$reduce = Object.keys(eTypes).reduce(function (acc, cur) {
	  if (typeof eTypes[cur] === 'number') {
	    acc[0] = _objectSpread$8(_objectSpread$8({}, acc[0]), {}, defineProperty({}, cur, parseInt(eTypes[cur])));
	    acc[2].push(cur);
	  } else {
	    acc[1] = _objectSpread$8(_objectSpread$8({}, acc[1]), {}, defineProperty({}, cur, eTypes[cur]));
	    acc[3].push(parseInt(cur));
	  }

	  return acc;
	}, [{}, {}, [], []]),
	    _Object$keys$reduce2 = slicedToArray(_Object$keys$reduce, 4),
	    typeMapper = _Object$keys$reduce2[0],
	    codeMapper = _Object$keys$reduce2[1],
	    typeList = _Object$keys$reduce2[2],
	    codeList = _Object$keys$reduce2[3];

	/**
	 * Convert edge object to notebook object
	 * @param edge: Edge
	 * @returns NotebookType
	 */
	var edgeToNotebook = function edgeToNotebook(edge) {
	  if (edge.type !== eTypes.NOTEBOOK && edge.type !== eTypes.ROOT) {
	    throw new AiTmedError({
	      name: 'NOT_A_NOTEBOOk'
	    });
	  }

	  var info;

	  if (_typeof_1(edge.name) === 'object') {
	    info = edge.name;
	  } else if (edge.name && typeof edge.name === 'string') {
	    try {
	      info = JSON.parse(edge.name);
	    } catch (error) {
	      throw new AiTmedError({
	        name: 'UNKNOW_ERROR',
	        message: 'Notebook -> edgeToNotebook -> JSON.parse edge.name failed'
	      });
	    }
	  } else {
	    info = {};
	  }

	  var notebook = {
	    id: store$3.utils.idToBase64(edge.eid),
	    owner_id: store$3.utils.idToBase64(edge.bvid),
	    info: info,
	    refid: store$3.utils.idToBase64(edge.refid),
	    created_at: edge.ctime * 1000,
	    modified_at: edge.mtime * 1000,
	    isEncrypt: edge.besak.length > 0 || edge.eesak.length > 0,
	    type: edge.type
	  };
	  return notebook;
	};
	/**
	 *
	 * @param id: Uint8Array | string
	 * @returns Promise<NotebookType>
	 */

	var retrieveNotebook = /*#__PURE__*/function () {
	  var _ref = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(id) {
	    var edge;
	    return regenerator.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            _context.next = 2;
	            return retrieveEdge(id);

	          case 2:
	            edge = _context.sent;

	            if (edge) {
	              _context.next = 5;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'NOTEBOOK_NOT_EXIST'
	            });

	          case 5:
	            return _context.abrupt("return", edgeToNotebook(edge));

	          case 6:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee);
	  }));

	  return function retrieveNotebook(_x) {
	    return _ref.apply(this, arguments);
	  };
	}();
	var listEdges = /*#__PURE__*/function () {
	  var _ref2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
	    var params,
	        _params$shared,
	        _params$count,
	        count,
	        _params$edit_mode,
	        _params$sort_by,
	        sort_by,
	        _params$type,
	        type,
	        _params$xfname,
	        xfname,
	        isEncrypt,
	        _params$loid,
	        loid,
	        _params$obfname,
	        obfname,
	        scondition,
	        condition,
	        response,
	        edges,
	        _args2 = arguments;

	    return regenerator.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            params = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
	            _params$shared = params.shared, _params$count = params.count, count = _params$count === void 0 ? 10 : _params$count, _params$edit_mode = params.edit_mode, _params$sort_by = params.sort_by, sort_by = _params$sort_by === void 0 ? 0 : _params$sort_by, _params$type = params.type, type = _params$type === void 0 ? eTypes.NOTEBOOK : _params$type, _params$xfname = params.xfname, xfname = _params$xfname === void 0 ? 'bvid' : _params$xfname, isEncrypt = params.isEncrypt, _params$loid = params.loid, loid = _params$loid === void 0 ? '' : _params$loid, _params$obfname = params.obfname, obfname = _params$obfname === void 0 ? 'mtime' : _params$obfname, scondition = params.scondition;

	            if (codeList.includes(type)) {
	              _context2.next = 4;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'NOTEBOOK_TYPE_INVALID'
	            });

	          case 4:
	            condition = [];

	            if (typeof scondition !== 'undefined') {
	              condition.push(scondition);
	            }

	            if (isEncrypt === true) condition.push('besak is not null');else if (isEncrypt === false) condition.push('besak is null');
	            _context2.next = 9;
	            return store$3.level2SDK.edgeServices.retrieveEdge({
	              idList: [],
	              options: {
	                xfname: xfname,
	                type: type,
	                asc: !!sort_by,
	                scondition: condition.join(' and '),
	                maxcount: count,
	                loid: loid,
	                obfname: obfname
	              }
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 9:
	            response = _context2.sent;

	            if (!(!response || !response.data || !Array.isArray(response.data))) {
	              _context2.next = 12;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'UNKNOW_ERROR',
	              message: 'Notebook -> utils -> listEdges -> no response'
	            });

	          case 12:
	            edges = response.data;
	            return _context2.abrupt("return", edges);

	          case 14:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, _callee2);
	  }));

	  return function listEdges() {
	    return _ref2.apply(this, arguments);
	  };
	}();

	function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	/**
	 * @param params string
	 * @param params.title: string
	 * @param params.description?: string
	 * @param params.isEncrypt: boolean
	 *
	 * @returns Promise<Notebook>
	 */
	var create$2 = /*#__PURE__*/function () {
	  var _ref2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(_ref) {
	    var title, _ref$description, description, _ref$type, type, _ref$isEncrypt, isEncrypt, edges, response;

	    return regenerator.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            title = _ref.title, _ref$description = _ref.description, description = _ref$description === void 0 ? '' : _ref$description, _ref$type = _ref.type, type = _ref$type === void 0 ? eTypes.NOTEBOOK : _ref$type, _ref$isEncrypt = _ref.isEncrypt, isEncrypt = _ref$isEncrypt === void 0 ? false : _ref$isEncrypt;

	            if (codeList.includes(type)) {
	              _context.next = 3;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'NOTEBOOK_TYPE_INVALID'
	            });

	          case 3:
	            if (!(type === eTypes.ROOT)) {
	              _context.next = 9;
	              break;
	            }

	            _context.next = 6;
	            return listEdges({
	              type: eTypes.ROOT
	            });

	          case 6:
	            edges = _context.sent;

	            if (!(edges.length > 0)) {
	              _context.next = 9;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'ROOT_NOTEBOOK_EXIST'
	            });

	          case 9:
	            _context.next = 11;
	            return store$3.level2SDK.edgeServices.createEdge({
	              type: type,
	              name: {
	                title: title,
	                description: description,
	                edit_mode: 7
	              },
	              isEncrypt: isEncrypt
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 11:
	            response = _context.sent;

	            if (response) {
	              _context.next = 14;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'UNKNOW_ERROR',
	              message: 'Notebook -> create -> createEdge -> no response'
	            });

	          case 14:
	            return _context.abrupt("return", edgeToNotebook(response.data));

	          case 15:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee);
	  }));

	  return function create(_x) {
	    return _ref2.apply(this, arguments);
	  };
	}();
	/**
	 * @param id: string
	 * @returns Promise<Notebook>
	 */


	var remove$1 = /*#__PURE__*/function () {
	  var _ref3 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(id) {
	    var notebook;
	    return regenerator.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            _context2.next = 2;
	            return retrieveNotebook(id);

	          case 2:
	            notebook = _context2.sent;

	            if (!(notebook.type === eTypes.ROOT)) {
	              _context2.next = 5;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'ROOT_NOTEBOOK_CANNOT_BE_REMOVED'
	            });

	          case 5:
	            _context2.next = 7;
	            return store$3.level2SDK.edgeServices.deleteEdge([id]).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 7:
	            return _context2.abrupt("return", notebook);

	          case 8:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, _callee2);
	  }));

	  return function remove(_x2) {
	    return _ref3.apply(this, arguments);
	  };
	}();
	/**
	 * @param id: string
	 * @param fields
	 * @param fields.title?: string
	 * @param fields.description?: string
	 * @returns Promise<Notebook>
	 */


	var update$1 = /*#__PURE__*/function () {
	  var _ref4 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(id, fields) {
	    var edge, response, notebook;
	    return regenerator.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            _context3.next = 2;
	            return retrieveEdge(id);

	          case 2:
	            edge = _context3.sent;

	            if (edge) {
	              _context3.next = 5;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'NOTEBOOK_NOT_EXIST'
	            });

	          case 5:
	            _context3.next = 7;
	            return store$3.level2SDK.edgeServices.updateEdge({
	              id: edge.eid,
	              bvid: edge.bvid,
	              type: edge.type,
	              besak: edge.besak,
	              name: _objectSpread$9(_objectSpread$9({}, edge.name), fields)
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 7:
	            response = _context3.sent;

	            if (!(!response || !response.data)) {
	              _context3.next = 10;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'UNKNOW_ERROR',
	              message: 'Notebook -> update -> updateEdge -> no response'
	            });

	          case 10:
	            _context3.next = 12;
	            return retrieveNotebook(edge.eid);

	          case 12:
	            notebook = _context3.sent;
	            return _context3.abrupt("return", notebook);

	          case 14:
	          case "end":
	            return _context3.stop();
	        }
	      }
	    }, _callee3);
	  }));

	  return function update(_x3, _x4) {
	    return _ref4.apply(this, arguments);
	  };
	}();
	/**
	 * @param id: string
	 * @returns Promise<Notebook>
	 */


	var retrieve$2 = /*#__PURE__*/function () {
	  var _ref5 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(id) {
	    var notebook;
	    return regenerator.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            _context4.next = 2;
	            return retrieveNotebook(id);

	          case 2:
	            notebook = _context4.sent;
	            return _context4.abrupt("return", notebook);

	          case 4:
	          case "end":
	            return _context4.stop();
	        }
	      }
	    }, _callee4);
	  }));

	  return function retrieve(_x5) {
	    return _ref5.apply(this, arguments);
	  };
	}();
	/**
	 * @param param
	 * @param param.shared?: Boolean
	 * @param param.count?: number
	 * @param param.edit_mode?: number
	 * @param param.sort_by?: 0 | 1 | 2
	 * @returns response
	 * @returns response.ids: string[]
	 * @returns response.mapper: Record<string, Notebook>
	 */


	var list$1 = /*#__PURE__*/function () {
	  var _ref6 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5() {
	    var params,
	        edges,
	        result,
	        _args5 = arguments;
	    return regenerator.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            params = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};
	            _context5.next = 3;
	            return listEdges(params);

	          case 3:
	            edges = _context5.sent;
	            result = edges.reduce(function (acc, edge) {
	              var notebook = edgeToNotebook(edge);
	              acc.ids.push(notebook.id);
	              acc.mapper[notebook.id] = notebook;
	              return acc;
	            }, {
	              ids: [],
	              mapper: {}
	            });
	            return _context5.abrupt("return", result);

	          case 6:
	          case "end":
	            return _context5.stop();
	        }
	      }
	    }, _callee5);
	  }));

	  return function list() {
	    return _ref6.apply(this, arguments);
	  };
	}(); // /**
	//  * @param param
	//  * @param param.: number
	//  * @param param.count?: number
	//  * @param param.obfname?: string -field name to order by (e.g ctime, mtime)
	//  * @param param.sort_by?: 0 | 1 | 2
	//  * @returns response
	//  * @returns response.ids: string[]
	//  * @returns response.mapper: Record<string, Notebook>
	//  * 
	//  * -list of notebooks shared with user
	//  */
	// const listSharedNotebooks: NotebookTypes.ListSharedNotebooks = async (params = {}) => {
	//   const edges = await listEdges({ type: 10001, xfname: 'evid', ...params })
	//   let result
	//   result = edges.reduce<NotebookTypes.ListReturn>(
	//     (acc, edge) => {
	//       const notebook = edgeToNotebook(edge)
	//       acc.ids.push(notebook.id)
	//       acc.mapper[notebook.id] = notebook
	//       return acc
	//     },
	//     { ids: [], mapper: {} },
	//   )
	//   return result
	// }
	// /**
	//  * @param param
	//  * @param param.count?: number 
	//  * @param param.obfname?: string -field name to order by (e.g ctime, mtime)
	//  * @param param.fromMe? boolean -if true xfname = bvid (i.e query all invites created by user) 
	//  * @param param.sort_by?:  0 | 1 | 2
	//  * @returns response
	//  * @returns response.ids: string[]
	//  * @returns response.mapper: Record<string, Invite>
	//  */
	// const listInvites: NotebookTypes.ListInvites = async (params) => {
	//   let xfname = 'evid'
	//   if (params && params.fromMe) {
	//     xfname = 'bvid'
	//   }
	//   const edges = await listEdges({ type: 1050, xfname, ...params })
	//   let result
	//   result = edges.reduce<NotebookTypes.ListInvitesReturn>(
	//     (acc, edge) => {
	//       const invite = edgeToInvite(edge)
	//       acc.ids.push(invite.id)
	//       acc.mapper[invite.id] = invite
	//       return acc
	//     },
	//     { ids: [], mapper: {} },
	//   )
	//   return result
	// }
	// /**
	//  * @param param
	//  * @param param.count?: number
	//  * @param param.obfname?: string -field name to order by (e.g ctime, mtime)
	//  * @param param.fromMe? boolean -if true xfname = bvid (i.e query all accedtedInvites created by user) 
	//  * @param param.sort_by?:  0 | 1 | 2
	//  * @returns response
	//  * @returns response.ids: string[]
	//  * @returns response.mapper: Record<string, Invite>
	//  */
	// const listAcceptedInvites: NotebookTypes.ListAcceptedInvites = async (params) => {
	//   let xfname = 'evid'
	//   if (params && params.fromMe) {
	//     xfname = 'bvid'
	//   }
	//   const edges = await listEdges({ type: 10060, xfname, ...params })
	//   let result
	//   result = edges.reduce<NotebookTypes.ListAcceptedInvitesReturn>(
	//     (acc, edge) => {
	//       const acceptedInvite = edgeToAcceptedInvite(edge)
	//       acc.ids.push(acceptedInvite.id)
	//       acc.mapper[acceptedInvite.id] = acceptedInvite
	//       return acc
	//     },
	//     { ids: [], mapper: {} },
	//   )
	//   return result
	// }
	// /**
	//  * 
	//  * @param params
	//  * @param params.info Record<string, any> -notebook/invitation details
	//  * @param params.notebookId string | Uint8Array -the id of the notebook being shared
	//  * @param params.directedToId string | Uint8Array -the vid of the receiver of the invitation
	//  * 
	//  * @returns Promise<Notebook>
	//  */
	// const createInvite: NotebookTypes.CreateInvite = async ({ info, notebookId, directedToId }) => {
	//   const invite = await Invite.create({ info, refid: notebookId, directedToId })
	//   return invite
	// }
	// /**
	//  * 
	//  * @param param
	//  * @param params.info Record<string, any> -invitation/notebook details
	//  * @param params.inviteId string | Uint8Array -edge id of the invitation being responded to
	//  * @param params.directedToId string | Uint8Array -vid of the sender of the invitation(receiver of the acceptance)
	//  * 
	//  * @returns Promise<Notebook>
	//  */
	// const acceptInvite: NotebookTypes.AcceptInvite = async ({ info, inviteId, directedToId }) => {
	//   const acceptedInvite = await Invite.accept({ info, inviteId, directedToId })
	//   return acceptedInvite
	// }
	// /**
	//  * 
	//  * @param param
	//  * @param params.notebookInfo Record<string, any> -invitation/notebook details
	//  * @param params.acceptanceId string | Uint8Array -edge id of the acceptedInvitation edge
	//  * @param params.directedToId string | Uint8Array -evid of the receive of the invitation(user that accepted invitation)
	//  * 
	//  * @returns Promise<Notebook>
	//  */
	// const authorizeEvent: NotebookTypes.AuthorizeEvent = async ({
	//   info,
	//   acceptanceId,
	//   directedToId
	// }) => {
	//   const authorizedEdge = await Invite.authorize({ info, acceptanceId, directedToId })
	//   return edgeToNotebook(authorizedEdge)
	// }

	/**
	 * Todo:
	 * 1. retrieveEdge - check the id is exist or not
	 * 2.
	 * @param id: string
	 * @param invite_phone_number: string
	 * @param edit_mode: number
	 */
	//  export const share = (
	//   id: string,
	//   invite_phone_number: string,
	//   edit_mode: number,
	// ): Promise<void> => {
	//   console.log('Notebook->share', id, invite_phone_number, edit_mode)
	// }

	/**
	 * Todo:
	 * 1. retrieveEdge - check the id is exist or not
	 * 2.
	 * @param id: string
	 * @param invited_phone_number: string
	 */
	// export const unshare = (
	//   id: string,
	//   invited_phone_number: string,
	// ): Promise<void> => {
	//   console.log('Notebook->unshare', id, invited_phone_number)
	// }

	var Notebook = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create$2,
		remove: remove$1,
		update: update$1,
		retrieve: retrieve$2,
		list: list$1
	});

	function ownKeys$a(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$a(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$a(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
	var decodeUID = function decodeUID(uid) {
	  var lastIOfPlus = uid.lastIndexOf('+');

	  if (lastIOfPlus < 0) {
	    throw new AiTmedError({
	      name: 'UID_INVALID'
	    });
	  }

	  return {
	    userId: uid.slice(0, lastIOfPlus),
	    phone_number: uid.slice(lastIOfPlus)
	  };
	};
	var generateUser = /*#__PURE__*/function () {
	  var _ref = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(edge, profile) {
	    var id, response, vertex, name, _decodeUID, userId, phone_number;

	    return regenerator.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            id = store$3.utils.idToBase64(edge.bvid);
	            _context.next = 3;
	            return store$3.level2SDK.vertexServices.retrieveVertex({
	              idList: [id]
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 3:
	            response = _context.sent;

	            if (!(!response || response.code !== 0)) {
	              _context.next = 6;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'UNKNOW_ERROR',
	              message: 'Account -> utils -> generateUser -> no response'
	            });

	          case 6:
	            vertex = response.data[0];
	            name = vertex.name !== null && vertex.name !== undefined ? vertex.name : {
	              name: ''
	            };
	            _decodeUID = decodeUID(vertex.uid), userId = _decodeUID.userId, phone_number = _decodeUID.phone_number;
	            return _context.abrupt("return", {
	              id: id,
	              name: name.name,
	              userId: userId,
	              phone_number: phone_number,
	              profile: profile || null
	            });

	          case 10:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee);
	  }));

	  return function generateUser(_x, _x2) {
	    return _ref.apply(this, arguments);
	  };
	}();
	var createRootEdge = /*#__PURE__*/function () {
	  var _ref2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
	    var notebook;
	    return regenerator.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            _context2.next = 2;
	            return Notebook.create({
	              title: 'root',
	              isEncrypt: true,
	              type: eTypes.ROOT
	            });

	          case 2:
	            notebook = _context2.sent;
	            return _context2.abrupt("return", notebook);

	          case 4:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, _callee2);
	  }));

	  return function createRootEdge() {
	    return _ref2.apply(this, arguments);
	  };
	}();
	var retrieveRootEdge = /*#__PURE__*/function () {
	  var _ref3 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
	    var edges;
	    return regenerator.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            _context3.next = 2;
	            return listEdges({
	              type: eTypes.ROOT
	            });

	          case 2:
	            edges = _context3.sent;

	            if (!(edges.length <= 0)) {
	              _context3.next = 5;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'ROOT_NOTEBOOK_NOT_EXIST'
	            });

	          case 5:
	            return _context3.abrupt("return", edges[0]);

	          case 6:
	          case "end":
	            return _context3.stop();
	        }
	      }
	    }, _callee3);
	  }));

	  return function retrieveRootEdge() {
	    return _ref3.apply(this, arguments);
	  };
	}();
	var createProfile = /*#__PURE__*/function () {
	  var _ref5 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(rootId, _ref4) {
	    var profile_photo, _profile, profile, profilePhotoNote, note;

	    return regenerator.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            profile_photo = _ref4.profile_photo, _profile = objectWithoutProperties(_ref4, ["profile_photo"]);
	            profile = _profile; // Upload Profile Photo

	            if (!profile_photo) {
	              _context4.next = 9;
	              break;
	            }

	            if (/^image/.test(profile_photo.type)) {
	              _context4.next = 5;
	              break;
	            }

	            throw new AiTmedError({
	              name: 'PROFILE_PHOTO_INVALID'
	            });

	          case 5:
	            _context4.next = 7;
	            return Note.create({
	              notebook_id: rootId,
	              title: 'profile_photo',
	              content: profile_photo
	            });

	          case 7:
	            profilePhotoNote = _context4.sent;
	            profile.profile_photo = profilePhotoNote.id;

	          case 9:
	            _context4.next = 11;
	            return Note.create({
	              notebook_id: rootId,
	              title: 'profile',
	              content: profile,
	              dataType: 1
	            });

	          case 11:
	            note = _context4.sent;
	            return _context4.abrupt("return", note);

	          case 13:
	          case "end":
	            return _context4.stop();
	        }
	      }
	    }, _callee4);
	  }));

	  return function createProfile(_x3, _x4) {
	    return _ref5.apply(this, arguments);
	  };
	}();
	var removeProfile = /*#__PURE__*/function () {
	  var _ref6 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(id, note) {
	    var profile;
	    return regenerator.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            profile = note.info.content; // Remove Profile Photo

	            if (!(profile && profile.profile_photo)) {
	              _context5.next = 4;
	              break;
	            }

	            _context5.next = 4;
	            return store$3.level2SDK.documentServices.deleteDocument([profile.profile_photo]).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 4:
	            _context5.next = 6;
	            return store$3.level2SDK.documentServices.deleteDocument([id]).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 6:
	          case "end":
	            return _context5.stop();
	        }
	      }
	    }, _callee5);
	  }));

	  return function removeProfile(_x5, _x6) {
	    return _ref6.apply(this, arguments);
	  };
	}();
	var retrieveProfile = /*#__PURE__*/function () {
	  var _ref7 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6(rootId) {
	    var notes, noteId, profileInDoc, profile_photo, restProfile, profile, profilePhotoNote, content;
	    return regenerator.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            _context6.next = 2;
	            return Note.list(rootId, {
	              dataType: 'profile'
	            });

	          case 2:
	            notes = _context6.sent;

	            if (!(notes.ids.length <= 0)) {
	              _context6.next = 5;
	              break;
	            }

	            return _context6.abrupt("return", null);

	          case 5:
	            noteId = notes.ids[0];
	            profileInDoc = notes.mapper[noteId].info.content;

	            if (profileInDoc) {
	              _context6.next = 9;
	              break;
	            }

	            return _context6.abrupt("return", null);

	          case 9:
	            profile_photo = profileInDoc.profile_photo, restProfile = objectWithoutProperties(profileInDoc, ["profile_photo"]);
	            profile = _objectSpread$a({}, restProfile); // Retrieve Profile Photo

	            if (!profile_photo) {
	              _context6.next = 17;
	              break;
	            }

	            _context6.next = 14;
	            return Note.retrieve(profile_photo);

	          case 14:
	            profilePhotoNote = _context6.sent;
	            content = profilePhotoNote.info.content;

	            if (content && content instanceof Blob) {
	              profile.profile_photo = content;
	            }

	          case 17:
	            return _context6.abrupt("return", {
	              noteId: noteId,
	              profile: profile
	            });

	          case 18:
	          case "end":
	            return _context6.stop();
	        }
	      }
	    }, _callee6);
	  }));

	  return function retrieveProfile(_x7) {
	    return _ref7.apply(this, arguments);
	  };
	}();

	function ownKeys$b(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$b(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$b(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$b(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _createForOfIteratorHelper$f(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$g(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$g(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$g(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$g(o, minLen); }

	function _arrayLikeToArray$g(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	/**
	 * @param phone_number: string
	 * @returns Promise<string>
	 */

	var requestVerificationCode = /*#__PURE__*/function () {
	  var _ref = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(phone_number) {
	    var response;
	    return regenerator.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            _context.next = 2;
	            return store$3.level2SDK.Account.requestVerificationCode({
	              phone_number: phone_number
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 2:
	            response = _context.sent;
	            return _context.abrupt("return", response && response.data && response.data.verification_code);

	          case 4:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee);
	  }));

	  return function requestVerificationCode(_x) {
	    return _ref.apply(this, arguments);
	  };
	}();
	/**
	 * @param phone_number: string
	 * @param password: string
	 * @param verification_code: string
	 */

	var create$3 = /*#__PURE__*/function () {
	  var _ref2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(phone_number, password, verification_code, name) {
	    var _yield$store$level2SD, data;

	    return regenerator.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            _context2.next = 2;
	            return store$3.level2SDK.Account.createUser({
	              phone_number: phone_number,
	              password: password,
	              verification_code: verification_code,
	              userInfo: name
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 2:
	            _yield$store$level2SD = _context2.sent;
	            data = _yield$store$level2SD.data;
	            _context2.next = 6;
	            return createRootEdge();

	          case 6:
	            return _context2.abrupt("return", data);

	          case 7:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, _callee2);
	  }));

	  return function create(_x2, _x3, _x4, _x5) {
	    return _ref2.apply(this, arguments);
	  };
	}();
	/**
	 *
	 * @param phone_number: string
	 * @param verification_code: string
	 * @param password: string
	 */

	var login = /*#__PURE__*/function () {
	  var _ref3 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(phone_number, password, verification_code) {
	    var user, userVertex;
	    return regenerator.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            _context3.next = 2;
	            return loginByVerificationCode(phone_number, verification_code);

	          case 2:
	            _context3.next = 4;
	            return loginByPassword(password);

	          case 4:
	            user = _context3.sent;

	            if (!user.id) {
	              _context3.next = 12;
	              break;
	            }

	            _context3.next = 8;
	            return retrieveVertex(user.id);

	          case 8:
	            userVertex = _context3.sent;
	            return _context3.abrupt("return", userVertex);

	          case 12:
	            return _context3.abrupt("return", user);

	          case 13:
	          case "end":
	            return _context3.stop();
	        }
	      }
	    }, _callee3);
	  }));

	  return function login(_x6, _x7, _x8) {
	    return _ref3.apply(this, arguments);
	  };
	}();
	/**
	 * This method is only able to be used after login new device (loginByVerificationCode)
	 * @param password: string
	 */

	var loginByPassword = /*#__PURE__*/function () {
	  var _ref4 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(password) {
	    var user, userVertex;
	    return regenerator.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            _context4.next = 2;
	            return store$3.level2SDK.Account.login({
	              password: password
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 2:
	            _context4.next = 4;
	            return retrieve$3();

	          case 4:
	            user = _context4.sent;

	            if (!user.id) {
	              _context4.next = 12;
	              break;
	            }

	            _context4.next = 8;
	            return retrieveVertex(user.id);

	          case 8:
	            userVertex = _context4.sent;
	            return _context4.abrupt("return", userVertex);

	          case 12:
	            return _context4.abrupt("return", user);

	          case 13:
	          case "end":
	            return _context4.stop();
	        }
	      }
	    }, _callee4);
	  }));

	  return function loginByPassword(_x9) {
	    return _ref4.apply(this, arguments);
	  };
	}();
	/**
	 * @param phone_number: string
	 * @param verification_code: string
	 */

	var loginByVerificationCode = /*#__PURE__*/function () {
	  var _ref5 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(phone_number, verification_code) {
	    return regenerator.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            _context5.next = 2;
	            return store$3.level2SDK.Account.loginNewDevice({
	              phone_number: phone_number,
	              verification_code: verification_code
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 2:
	          case "end":
	            return _context5.stop();
	        }
	      }
	    }, _callee5);
	  }));

	  return function loginByVerificationCode(_x10, _x11) {
	    return _ref5.apply(this, arguments);
	  };
	}();
	/**
	 * @returns Status
	 * Status.code:
	 *  0 - LOGGED_IN
	 *  1 - LOGGED_OUT
	 */

	var logout = /*#__PURE__*/function () {
	  var _ref6 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6() {
	    var clean,
	        status,
	        latestStatus,
	        _args6 = arguments;
	    return regenerator.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            clean = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : false;

	            if (!clean) {
	              _context6.next = 5;
	              break;
	            }

	            store$3.level2SDK.Account.logoutClean();
	            _context6.next = 11;
	            break;

	          case 5:
	            _context6.next = 7;
	            return getStatus();

	          case 7:
	            status = _context6.sent;

	            if (!(status.code === 1)) {
	              _context6.next = 10;
	              break;
	            }

	            return _context6.abrupt("return", status);

	          case 10:
	            store$3.level2SDK.Account.logout();

	          case 11:
	            _context6.next = 13;
	            return getStatus();

	          case 13:
	            latestStatus = _context6.sent;
	            return _context6.abrupt("return", latestStatus);

	          case 15:
	          case "end":
	            return _context6.stop();
	        }
	      }
	    }, _callee6);
	  }));

	  return function logout() {
	    return _ref6.apply(this, arguments);
	  };
	}();
	/**
	 * Todo:
	 *    waiting for backend to support verificating the verification code
	 * @param phone_number: string
	 * @param new_phone_number: string
	 * @param verification_code: string
	 * @returns Promise<User>
	 */

	/*
	export const updatePhoneNumber = async (
	  phone_number: string,
	  new_phone_number: string,
	  verification_code: string,
	): Promise<AccountTypes.User> => {
	  console.log(
	    'Account->updatePhoneNumber',
	    phone_number,
	    new_phone_number,
	    verification_code,
	  )

	  return mockUser
	}
	*/

	/**
	 * @param param
	 * @param param.old_password: string
	 * @param param.new_password: string
	 */

	var updatePassword$1 = /*#__PURE__*/function () {
	  var _ref7 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7(old_password, new_password) {
	    return regenerator.wrap(function _callee7$(_context7) {
	      while (1) {
	        switch (_context7.prev = _context7.next) {
	          case 0:
	            _context7.next = 2;
	            return store$3.level2SDK.Account.changePasswordWithOldPassword({
	              oldPassword: old_password,
	              newPassword: new_password
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 2:
	          case "end":
	            return _context7.stop();
	        }
	      }
	    }, _callee7);
	  }));

	  return function updatePassword(_x12, _x13) {
	    return _ref7.apply(this, arguments);
	  };
	}();
	/**
	 * @param param
	 * @param param.phone_number: string
	 * @param param.verification_code: string
	 * @param param.new_password: string
	 */

	var updatePasswordByVerificationCode = /*#__PURE__*/function () {
	  var _ref9 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8(_ref8) {
	    var phone_number, verification_code, new_password;
	    return regenerator.wrap(function _callee8$(_context8) {
	      while (1) {
	        switch (_context8.prev = _context8.next) {
	          case 0:
	            phone_number = _ref8.phone_number, verification_code = _ref8.verification_code, new_password = _ref8.new_password;
	            _context8.next = 3;
	            return store$3.level2SDK.Account.changePasswordWithVerificationCode({
	              phone_number: phone_number,
	              verification_code: verification_code,
	              password: new_password
	            }).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 3:
	          case "end":
	            return _context8.stop();
	        }
	      }
	    }, _callee8);
	  }));

	  return function updatePasswordByVerificationCode(_x14) {
	    return _ref9.apply(this, arguments);
	  };
	}();
	/**
	 * @param profile: AccountTypes.Profile
	 *
	 * @param profile.first_name: string
	 * @param profile.middle_name?: string
	 * @param profile.last_name: string
	 *
	 * @param profile.gender: 'MALE' | 'FEMALE' | 'PNS'
	 * @param profile.birthday: number
	 * @param profile.languages?: string[]
	 *
	 * @param profile.profile_photo?: string
	 *
	 * @returns Promise<User>
	 */

	var updateProfile = /*#__PURE__*/function () {
	  var _ref10 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee9(profile) {
	    var root, notes, _iterator, _step, noteId, user;

	    return regenerator.wrap(function _callee9$(_context9) {
	      while (1) {
	        switch (_context9.prev = _context9.next) {
	          case 0:
	            _context9.next = 2;
	            return retrieveRootEdge();

	          case 2:
	            root = _context9.sent;
	            _context9.next = 5;
	            return Note.list(root.eid, {
	              dataType: 'profile'
	            });

	          case 5:
	            notes = _context9.sent;
	            _iterator = _createForOfIteratorHelper$f(notes.ids);
	            _context9.prev = 7;

	            _iterator.s();

	          case 9:
	            if ((_step = _iterator.n()).done) {
	              _context9.next = 15;
	              break;
	            }

	            noteId = _step.value;
	            _context9.next = 13;
	            return removeProfile(noteId, notes.mapper[noteId]);

	          case 13:
	            _context9.next = 9;
	            break;

	          case 15:
	            _context9.next = 20;
	            break;

	          case 17:
	            _context9.prev = 17;
	            _context9.t0 = _context9["catch"](7);

	            _iterator.e(_context9.t0);

	          case 20:
	            _context9.prev = 20;

	            _iterator.f();

	            return _context9.finish(20);

	          case 23:
	            _context9.next = 25;
	            return createProfile(root.eid, profile);

	          case 25:
	            _context9.next = 27;
	            return retrieve$3();

	          case 27:
	            user = _context9.sent;
	            return _context9.abrupt("return", user);

	          case 29:
	          case "end":
	            return _context9.stop();
	        }
	      }
	    }, _callee9, null, [[7, 17, 20, 23]]);
	  }));

	  return function updateProfile(_x15) {
	    return _ref10.apply(this, arguments);
	  };
	}();
	/**
	 * @returns Promise<User>
	 */

	var retrieve$3 = /*#__PURE__*/function () {
	  var _ref11 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee10() {
	    var root, profile, user;
	    return regenerator.wrap(function _callee10$(_context10) {
	      while (1) {
	        switch (_context10.prev = _context10.next) {
	          case 0:
	            _context10.next = 2;
	            return retrieveRootEdge();

	          case 2:
	            root = _context10.sent;
	            _context10.next = 5;
	            return retrieveProfile(root.eid);

	          case 5:
	            profile = _context10.sent;
	            _context10.next = 8;
	            return generateUser(root, profile ? profile.profile : null);

	          case 8:
	            user = _context10.sent;
	            return _context10.abrupt("return", user);

	          case 10:
	          case "end":
	            return _context10.stop();
	        }
	      }
	    }, _callee10);
	  }));

	  return function retrieve() {
	    return _ref11.apply(this, arguments);
	  };
	}();
	/**
	 * @returns Promise<User>
	 */

	var remove$2 = /*#__PURE__*/function () {
	  var _ref12 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee11() {
	    var user, edge, notes, _iterator2, _step2, noteId;

	    return regenerator.wrap(function _callee11$(_context11) {
	      while (1) {
	        switch (_context11.prev = _context11.next) {
	          case 0:
	            _context11.next = 2;
	            return retrieve$3();

	          case 2:
	            user = _context11.sent;
	            _context11.next = 5;
	            return retrieveRootEdge();

	          case 5:
	            edge = _context11.sent;
	            _context11.next = 8;
	            return Note.list(edge.eid);

	          case 8:
	            notes = _context11.sent;
	            // Remove all note under root edge
	            _iterator2 = _createForOfIteratorHelper$f(notes.ids);
	            _context11.prev = 10;

	            _iterator2.s();

	          case 12:
	            if ((_step2 = _iterator2.n()).done) {
	              _context11.next = 18;
	              break;
	            }

	            noteId = _step2.value;
	            _context11.next = 16;
	            return store$3.level2SDK.documentServices.deleteDocument([noteId]).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 16:
	            _context11.next = 12;
	            break;

	          case 18:
	            _context11.next = 23;
	            break;

	          case 20:
	            _context11.prev = 20;
	            _context11.t0 = _context11["catch"](10);

	            _iterator2.e(_context11.t0);

	          case 23:
	            _context11.prev = 23;

	            _iterator2.f();

	            return _context11.finish(23);

	          case 26:
	            _context11.next = 28;
	            return store$3.level2SDK.edgeServices.deleteEdge([edge.eid]).then(store$3.responseCatcher)["catch"](store$3.errorCatcher);

	          case 28:
	            _context11.next = 30;
	            return store$3.level2SDK.vertexServices.deleteVertex([edge.bvid]);

	          case 30:
	            _context11.next = 32;
	            return logout(true);

	          case 32:
	            return _context11.abrupt("return", user);

	          case 33:
	          case "end":
	            return _context11.stop();
	        }
	      }
	    }, _callee11, null, [[10, 20, 23, 26]]);
	  }));

	  return function remove() {
	    return _ref12.apply(this, arguments);
	  };
	}();
	/**
	 * @returns Status
	 * Status.code:
	 *  0 - LOGGED_IN
	 *  1 - LOGGED_OUT
	 *  2 - NEW_DEVICE
	 * Status.userId: string
	 * Status.code: string
	 */

	var getStatus = /*#__PURE__*/function () {
	  var _ref13 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee12() {
	    var status, uid, utf8Uid, _accountUtils$decodeU, userId, phone_number;

	    return regenerator.wrap(function _callee12$(_context12) {
	      while (1) {
	        switch (_context12.prev = _context12.next) {
	          case 0:
	            _context12.next = 2;
	            return store$3.level2SDK.Account.getStatus();

	          case 2:
	            status = _context12.sent;
	            _context12.prev = 3;
	            uid = localStorage.getItem('uid');

	            if (!(uid === null)) {
	              _context12.next = 7;
	              break;
	            }

	            throw new Error('uid is null');

	          case 7:
	            utf8Uid = store$3.level2SDK.utilServices.base64ToUTF8(uid);
	            _accountUtils$decodeU = decodeUID(utf8Uid), userId = _accountUtils$decodeU.userId, phone_number = _accountUtils$decodeU.phone_number;
	            return _context12.abrupt("return", _objectSpread$b(_objectSpread$b({}, status), {}, {
	              userId: userId,
	              phone_number: phone_number
	            }));

	          case 12:
	            _context12.prev = 12;
	            _context12.t0 = _context12["catch"](3);
	            return _context12.abrupt("return", _objectSpread$b(_objectSpread$b({}, status), {}, {
	              userId: '',
	              phone_number: ''
	            }));

	          case 15:
	          case "end":
	            return _context12.stop();
	        }
	      }
	    }, _callee12, null, [[3, 12]]);
	  }));

	  return function getStatus() {
	    return _ref13.apply(this, arguments);
	  };
	}();
	/**
	 * 
	 * @param password string
	 * @returns boolean
	 */

	var verifyUserPassword = function verifyUserPassword(password) {
	  try {
	    var _store$level2SDK$Acco = store$3.level2SDK.Account.verifyUserPassword({
	      password: password
	    }),
	        _store$level2SDK$Acco2 = slicedToArray(_store$level2SDK$Acco, 1),
	        isPasswordValid = _store$level2SDK$Acco2[0];

	    if (isPasswordValid) return true;
	  } catch (error) {
	    if (error.name = 'PASSWORD_INVALID') {
	      return false;
	    }
	  }

	  return false;
	};

	var Account$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		requestVerificationCode: requestVerificationCode,
		create: create$3,
		login: login,
		loginByPassword: loginByPassword,
		loginByVerificationCode: loginByVerificationCode,
		logout: logout,
		updatePassword: updatePassword$1,
		updatePasswordByVerificationCode: updatePasswordByVerificationCode,
		updateProfile: updateProfile,
		retrieve: retrieve$3,
		remove: remove$2,
		getStatus: getStatus,
		verifyUserPassword: verifyUserPassword
	});

	function _createForOfIteratorHelper$g(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$h(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$h(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$h(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$h(o, minLen); }

	function _arrayLikeToArray$h(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function ownKeys$c(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$c(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$c(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$c(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
	/**
	 * 
	 * @param edge 
	 * @returns edge
	 */

	function replaceEidWithId(edge) {
	  var output = Object.assign({}, edge);
	  var _output = output,
	      eid = _output.eid;

	  if (eid) {
	    var b64Id = store$3.utils.idToBase64(eid);
	    output = _objectSpread$c(_objectSpread$c({}, output), {}, {
	      id: b64Id
	    });
	    delete output.eid;
	    return output;
	  } else {
	    return edge;
	  }
	}
	/**
	 * 
	 * @param PopulateKeysArgs {}
	 * @param PopulateKeysArgs.source Record<string, any>
	 * @param PopulateKeysArgs.lookFor string
	 * @param PopulateKeysArgs.locations Record<string, any>[]
	 * @returns Record<string, any>
	 * - merges source object with objects in locations where keys match lookFor
	 */


	function populateKeys(_ref) {
	  var source = _ref.source,
	      lookFor = _ref.lookFor,
	      locations = _ref.locations;

	  var output = cloneDeep_1(source);

	  Object.keys(output).forEach(function (key) {
	    if (key.startsWith(lookFor)) {
	      var parent = {};
	      var currKey = key;

	      if (lookFor === '..') {
	        currKey = currKey.slice(1);
	      }

	      var _iterator = _createForOfIteratorHelper$g(locations),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var location = _step.value;

	          try {
	            var res = lookUp(currKey, location);

	            if (res) {
	              parent = res;
	            }
	          } catch (error) {
	            if (error instanceof UnableToLocateValue) {
	              continue;
	            } else {
	              throw error;
	            }
	          }
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }

	      if (Object.keys(parent).length && output[key]) {
	        var mergedObjects = mergeDeep(populateKeys({
	          source: parent,
	          lookFor: lookFor,
	          locations: locations
	        }), populateKeys({
	          source: output[key],
	          lookFor: lookFor,
	          locations: locations
	        }));
	        output = _objectSpread$c(_objectSpread$c({}, output), mergedObjects);
	        delete output[key];
	      } else if (Object.keys(parent).length) {
	        //TODO: test why it is undefined when .Edge:""
	        //check SignUp page
	        var _mergedObjects = populateKeys({
	          source: parent,
	          lookFor: lookFor,
	          locations: locations
	        }); //TODO: pending unit test


	        output = mergeDeep(_mergedObjects, output);
	        delete output[key];
	      }
	    } else if (isObject$5(output[key])) {
	      output[key] = populateKeys({
	        source: output[key],
	        lookFor: lookFor,
	        locations: locations
	      });
	    } else if (Array.isArray(output[key])) {
	      output[key] = output[key].map(function (elem) {
	        if (isObject$5(elem)) {
	          return populateKeys({
	            source: elem,
	            lookFor: lookFor,
	            locations: locations
	          });
	        }

	        return elem;
	      });
	    }
	  });
	  return output;
	}
	/**
	 * 
	 * @param directions string -dot notation leading to location of value
	 * @param location - Record<string, any> -place to look for value
	 * @returns any - whatever value that was attached to the location object at the given directions
	 * @throws UnableToLocateValue if value is not found given the directions and location
	 */


	function lookUp(directions, location) {
	  var arr = directions.split('.');

	  try {
	    var res = arr.slice(1).reduce(function (o, key) {
	      return o[key];
	    }, location);
	    return res;
	  } catch (error) {
	    throw new UnableToLocateValue('value not found', error);
	  }
	}
	/**
	 * 
	 * @param item string | Record<string, any>
	 * @returns boolean
	 * -takes in an object or string and checks whether or not the item has been populated
	 */


	function isPopulated(item) {
	  var itemCopy = cloneDeep_1(item);

	  var isPop = true;

	  if (isObject$5(itemCopy)) {
	    for (var _i = 0, _Object$keys = Object.keys(itemCopy); _i < _Object$keys.length; _i++) {
	      var key = _Object$keys[_i];
	      if (!isPop) return isPop;

	      if (isObject$5(itemCopy[key])) {
	        isPop = isPopulated(itemCopy[key]);
	      } else if (Array.isArray(itemCopy[key])) {
	        isPop = itemCopy[key].forEach(function (elem) {
	          if (isObject$5(elem)) {
	            isPop = isPopulated(elem);
	          } else if (typeof elem === 'string') {
	            if (elem.startsWith('.') || elem.startsWith('..')) {
	              isPop = false;
	            }
	          }
	        });
	      } else if (typeof itemCopy[key] === 'string') {
	        var currVal = itemCopy[key].toString();

	        if (currVal.startsWith('.') || currVal.startsWith('..')) {
	          isPop = false;
	        }
	      }
	    }
	  }

	  return isPop;
	}
	/**
	 * 
	 * @param cadlObject Record<string, any>
	 * @param dispatch Function
	 * @returns Record<string,any>
	 */


	function attachFns(_ref2) {
	  var cadlObject = _ref2.cadlObject,
	      dispatch = _ref2.dispatch;
	  //the localRoot object is the page object
	  var localRoot = cadlObject; //we need the pageName to use as a key to store the data
	  //when using the dataKey

	  var pageName;

	  if (Object.keys(cadlObject).length > 1) {
	    pageName = 'Global';
	  } else {
	    pageName = Object.keys(cadlObject)[0];
	  }

	  return attachFnsHelper({
	    pageName: pageName,
	    cadlObject: cadlObject,
	    dispatch: dispatch
	  });

	  function attachFnsHelper(_ref3) {
	    var pageName = _ref3.pageName,
	        cadlObject = _ref3.cadlObject,
	        dispatch = _ref3.dispatch;

	    //traverse through the page object and look for the api keyword
	    var output = cloneDeep_1(cadlObject);

	    if (isObject$5(output)) {
	      Object.keys(output).forEach(function (key) {
	        if (isObject$5(output[key])) {
	          output[key] = attachFnsHelper({
	            pageName: pageName,
	            cadlObject: output[key],
	            dispatch: dispatch
	          });
	        } else if (Array.isArray(output[key])) {
	          output[key] = output[key].map(function (elem) {
	            if (isObject$5(elem)) return attachFnsHelper({
	              pageName: pageName,
	              cadlObject: elem,
	              dispatch: dispatch
	            });
	            return elem;
	          });
	        } else if (typeof output[key] === 'string' && key === 'api') {
	          //when api keyword is found we attach the corresponding ecos function to the current output which should be the value of get or store 

	          /**
	           * get:output
	           * store:output
	           */
	          var _output2 = output,
	              api = _output2.api;
	          var apiSplit = api.split('.');
	          var apiType = apiSplit[0];

	          switch (apiType) {
	            case 're':
	              {
	                var getFn = function getFn(output) {
	                  return /*#__PURE__*/asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
	                    var _cloneDeep2, api, dataKey, id, maxcount, type, sCondition, options, res, idList, _yield$store$level2SD, data;

	                    return regenerator.wrap(function _callee$(_context) {
	                      while (1) {
	                        switch (_context.prev = _context.next) {
	                          case 0:
	                            _cloneDeep2 = cloneDeep_1(output), api = _cloneDeep2.api, dataKey = _cloneDeep2.dataKey, id = _cloneDeep2.id, maxcount = _cloneDeep2.maxcount, type = _cloneDeep2.type, sCondition = _cloneDeep2.sCondition, options = objectWithoutProperties(_cloneDeep2, ["api", "dataKey", "id", "maxcount", "type", "sCondition"]);
	                            res = [];
	                            idList = [];

	                            if (id) {
	                              idList = Array.isArray(id) ? toConsumableArray(id) : [id];
	                            }

	                            if (maxcount) {
	                              options.maxcount = parseInt(maxcount);
	                            }

	                            if (type) {
	                              options.type = parseInt(type);
	                            }

	                            if (sCondition) {
	                              options.scondition = sCondition;
	                            }

	                            _context.prev = 7;
	                            console.log('%cGet Edge Request', 'background: purple; color: white; display: block;', {
	                              idList: idList,
	                              options: _objectSpread$c({}, options)
	                            });
	                            _context.next = 11;
	                            return store$3.level2SDK.edgeServices.retrieveEdge({
	                              idList: idList,
	                              options: _objectSpread$c({}, options)
	                            });

	                          case 11:
	                            _yield$store$level2SD = _context.sent;
	                            data = _yield$store$level2SD.data;
	                            res = data;
	                            _context.next = 19;
	                            break;

	                          case 16:
	                            _context.prev = 16;
	                            _context.t0 = _context["catch"](7);
	                            throw _context.t0;

	                          case 19:
	                            if (res.length > 0) {
	                              res = res.map(function (edge) {
	                                return replaceEidWithId(edge);
	                              });
	                              console.log('%cGet Edge Response', 'background: purple; color: white; display: block;', res);
	                              dispatch({
	                                type: 'update-data',
	                                //TODO: handle case for data is an array or an object
	                                payload: {
	                                  pageName: pageName,
	                                  dataKey: dataKey,
	                                  data: res
	                                }
	                              });
	                            } //TODO:handle else case


	                            return _context.abrupt("return", res);

	                          case 21:
	                          case "end":
	                            return _context.stop();
	                        }
	                      }
	                    }, _callee, null, [[7, 16]]);
	                  }));
	                };

	                output = getFn(output);
	                break;
	              }

	            case 'ce':
	              {
	                var storeFn = function storeFn(output) {
	                  return /*#__PURE__*/function () {
	                    var _ref5 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(name) {
	                      var _cloneDeep3, dataKey, _dispatch, deat, id, currentVal, parsedType, mergedVal, res, _yield$store$level2SD2, data, _yield$store$level2SD3, _data, replacedEidWithId;

	                      return regenerator.wrap(function _callee2$(_context2) {
	                        while (1) {
	                          switch (_context2.prev = _context2.next) {
	                            case 0:
	                              _cloneDeep3 = cloneDeep_1(output), dataKey = _cloneDeep3.dataKey; // const pathArr = dataKey.split('.')
	                              //get current object name value

	                              _dispatch = dispatch({
	                                type: 'get-data',
	                                payload: {
	                                  pageName: pageName,
	                                  dataKey: dataKey
	                                }
	                              }), deat = _dispatch.deat, id = _dispatch.id, currentVal = objectWithoutProperties(_dispatch, ["deat", "id"]); //TODO: remove when backend fixes message type problem

	                              if (currentVal.name && currentVal.name.message) {
	                                currentVal.name.message = "temp";
	                              } //merging existing name field and incoming name field


	                              parsedType = parseInt(currentVal.type);
	                              mergedVal = _objectSpread$c(_objectSpread$c({}, currentVal), {}, {
	                                type: parsedType
	                              });

	                              if (name) {
	                                mergedVal = mergeDeep(mergedVal, {
	                                  name: name
	                                });
	                              } // mergedVal.type = parseInt(mergedVal.type)


	                              if (!(id && !id.startsWith('.'))) {
	                                _context2.next = 22;
	                                break;
	                              }

	                              _context2.prev = 7;
	                              console.log('%cUpdate Edge Request', 'background: purple; color: white; display: block;', _objectSpread$c(_objectSpread$c({}, mergedVal), {}, {
	                                id: id
	                              }));
	                              _context2.next = 11;
	                              return store$3.level2SDK.edgeServices.updateEdge(_objectSpread$c(_objectSpread$c({}, mergedVal), {}, {
	                                id: id
	                              }));

	                            case 11:
	                              _yield$store$level2SD2 = _context2.sent;
	                              data = _yield$store$level2SD2.data;
	                              res = data;
	                              console.log('%cUpdate Edge Response', 'background: purple; color: white; display: block;', res);
	                              _context2.next = 20;
	                              break;

	                            case 17:
	                              _context2.prev = 17;
	                              _context2.t0 = _context2["catch"](7);
	                              throw _context2.t0;

	                            case 20:
	                              _context2.next = 35;
	                              break;

	                            case 22:
	                              _context2.prev = 22;
	                              console.log('%cCreate Edge Request', 'background: purple; color: white; display: block;', _objectSpread$c(_objectSpread$c({}, mergedVal), {}, {
	                                id: id
	                              }));
	                              _context2.next = 26;
	                              return store$3.level2SDK.edgeServices.createEdge(_objectSpread$c({}, mergedVal));

	                            case 26:
	                              _yield$store$level2SD3 = _context2.sent;
	                              _data = _yield$store$level2SD3.data;
	                              res = _data;
	                              console.log('%cCreate Edge Response', 'background: purple; color: white; display: block;', res);
	                              _context2.next = 35;
	                              break;

	                            case 32:
	                              _context2.prev = 32;
	                              _context2.t1 = _context2["catch"](22);
	                              throw _context2.t1;

	                            case 35:
	                              if (!res) {
	                                _context2.next = 40;
	                                break;
	                              }

	                              replacedEidWithId = replaceEidWithId(res);
	                              dispatch({
	                                type: 'update-data',
	                                //TODO: handle case for data is an array or an object
	                                payload: {
	                                  pageName: pageName,
	                                  dataKey: dataKey,
	                                  data: replacedEidWithId
	                                }
	                              }); //dispatch action to update state that is dependant of this response
	                              //TODO: optimize by updating a slice rather than entire object

	                              dispatch({
	                                type: 'populate',
	                                payload: {
	                                  pageName: pageName
	                                }
	                              });
	                              return _context2.abrupt("return", res);

	                            case 40:
	                              return _context2.abrupt("return", null);

	                            case 41:
	                            case "end":
	                              return _context2.stop();
	                          }
	                        }
	                      }, _callee2, null, [[7, 17], [22, 32]]);
	                    }));

	                    return function (_x) {
	                      return _ref5.apply(this, arguments);
	                    };
	                  }();
	                };

	                output = ["".concat(output.dataKey, ".name"), storeFn(output)];
	                break;
	              }

	            case 'rd':
	              {
	                var _getFn = function _getFn(output) {
	                  return /*#__PURE__*/asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
	                    var res, _cloneDeep4, api, dataKey, ids, rest, data;

	                    return regenerator.wrap(function _callee4$(_context4) {
	                      while (1) {
	                        switch (_context4.prev = _context4.next) {
	                          case 0:
	                            //TODO:update to new format
	                            _cloneDeep4 = cloneDeep_1(output), api = _cloneDeep4.api, dataKey = _cloneDeep4.dataKey, ids = _cloneDeep4.ids, rest = objectWithoutProperties(_cloneDeep4, ["api", "dataKey", "ids"]);
	                            _context4.prev = 1;
	                            _context4.next = 4;
	                            return store$3.level2SDK.documentServices.retrieveDocument({
	                              idList: [ids],
	                              options: _objectSpread$c({}, rest)
	                            }).then(function (_ref7) {
	                              var data = _ref7.data;
	                              return Promise.all(data.map( /*#__PURE__*/function () {
	                                var _ref8 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(document) {
	                                  var note;
	                                  return regenerator.wrap(function _callee3$(_context3) {
	                                    while (1) {
	                                      switch (_context3.prev = _context3.next) {
	                                        case 0:
	                                          _context3.next = 2;
	                                          return documentToNote$1({
	                                            document: document
	                                          });

	                                        case 2:
	                                          note = _context3.sent;
	                                          return _context3.abrupt("return", note);

	                                        case 4:
	                                        case "end":
	                                          return _context3.stop();
	                                      }
	                                    }
	                                  }, _callee3);
	                                }));

	                                return function (_x2) {
	                                  return _ref8.apply(this, arguments);
	                                };
	                              }()));
	                            }).then(function (res) {
	                              return res;
	                            })["catch"](function (err) {
	                              console.log(err);
	                            });

	                          case 4:
	                            data = _context4.sent;
	                            res = data;
	                            _context4.next = 11;
	                            break;

	                          case 8:
	                            _context4.prev = 8;
	                            _context4.t0 = _context4["catch"](1);
	                            throw _context4.t0;

	                          case 11:
	                            if (!res) {
	                              _context4.next = 14;
	                              break;
	                            }

	                            dispatch({
	                              type: 'update-data',
	                              //TODO: handle case for data is an array or an object
	                              payload: {
	                                pageName: pageName,
	                                dataKey: dataKey,
	                                data: res
	                              }
	                            });
	                            return _context4.abrupt("return", res);

	                          case 14:
	                            return _context4.abrupt("return", null);

	                          case 15:
	                          case "end":
	                            return _context4.stop();
	                        }
	                      }
	                    }, _callee4, null, [[1, 8]]);
	                  }));
	                };

	                output = isPopulated(output) ? _getFn(output) : output;
	                break;
	              }

	            case 'cd':
	              {
	                var _storeFn = function _storeFn(output) {
	                  return /*#__PURE__*/function () {
	                    var _ref10 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(_ref9) {
	                      var data, type, _ref9$id, id, _cloneDeep5, dataKey, cloneOutput, currentVal, mergedVal, api, options, res, _yield$store$level2SD4, _data2, appDataType, eid, name, response;

	                      return regenerator.wrap(function _callee5$(_context5) {
	                        while (1) {
	                          switch (_context5.prev = _context5.next) {
	                            case 0:
	                              data = _ref9.data, type = _ref9.type, _ref9$id = _ref9.id, id = _ref9$id === void 0 ? null : _ref9$id;
	                              //TODO:update to new format after ApplyBusiness is updated
	                              //@ts-ignore
	                              _cloneDeep5 = cloneDeep_1(output), dataKey = _cloneDeep5.dataKey, cloneOutput = objectWithoutProperties(_cloneDeep5, ["dataKey"]); // const pathArr = dataKey.split('.')
	                              // const currentVal = _.get(localRoot[pageName], pathArr)

	                              currentVal = dispatch({
	                                type: 'get-data',
	                                payload: {
	                                  dataKey: dataKey,
	                                  pageName: pageName
	                                }
	                              });
	                              mergedVal = mergeDeep(currentVal, {
	                                name: {
	                                  data: data,
	                                  type: type
	                                }
	                              });
	                              api = mergedVal.api, options = objectWithoutProperties(mergedVal, ["api"]);

	                              if (!id) {
	                                _context5.next = 19;
	                                break;
	                              }

	                              _context5.prev = 6;
	                              _context5.next = 9;
	                              return store$3.level2SDK.documentServices.updateDocument(_objectSpread$c(_objectSpread$c({}, options), {}, {
	                                id: id
	                              }));

	                            case 9:
	                              _yield$store$level2SD4 = _context5.sent;
	                              _data2 = _yield$store$level2SD4.data;
	                              res = _data2;
	                              _context5.next = 17;
	                              break;

	                            case 14:
	                              _context5.prev = 14;
	                              _context5.t0 = _context5["catch"](6);
	                              throw _context5.t0;

	                            case 17:
	                              _context5.next = 30;
	                              break;

	                            case 19:
	                              _context5.prev = 19;
	                              appDataType = options.type, eid = options.eid, name = options.name;
	                              _context5.next = 23;
	                              return Document$3.create({
	                                edge_id: eid,
	                                dataType: parseInt(appDataType.applicationDataType),
	                                content: data,
	                                type: type,
	                                title: name.title
	                              });

	                            case 23:
	                              response = _context5.sent;
	                              res = response;
	                              _context5.next = 30;
	                              break;

	                            case 27:
	                              _context5.prev = 27;
	                              _context5.t1 = _context5["catch"](19);
	                              throw _context5.t1;

	                            case 30:
	                              if (!res) {
	                                _context5.next = 33;
	                                break;
	                              }

	                              dispatch({
	                                type: 'update-data',
	                                //TODO: handle case for data is an array or an object
	                                payload: {
	                                  pageName: pageName,
	                                  dataKey: dataKey,
	                                  data: res
	                                }
	                              });
	                              return _context5.abrupt("return", res);

	                            case 33:
	                              return _context5.abrupt("return", null);

	                            case 34:
	                            case "end":
	                              return _context5.stop();
	                          }
	                        }
	                      }, _callee5, null, [[6, 14], [19, 27]]);
	                    }));

	                    return function (_x3) {
	                      return _ref10.apply(this, arguments);
	                    };
	                  }();
	                };

	                output = isPopulated(output) ? _storeFn(output) : output;
	                break;
	              }

	            case 'cv':
	              {
	                var _storeFn2 = function _storeFn2(output) {
	                  return /*#__PURE__*/function () {
	                    var _ref11 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6(name) {
	                      var id,
	                          _cloneDeep6,
	                          dataKey,
	                          cloneOutput,
	                          pathArr,
	                          currentVal,
	                          mergedVal,
	                          mergedName,
	                          api,
	                          storeProp,
	                          get,
	                          options,
	                          res,
	                          _yield$store$level2SD5,
	                          data,
	                          response,
	                          _args6 = arguments;

	                      return regenerator.wrap(function _callee6$(_context6) {
	                        while (1) {
	                          switch (_context6.prev = _context6.next) {
	                            case 0:
	                              id = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : null;
	                              //TODO: update to new format
	                              _cloneDeep6 = cloneDeep_1(output), dataKey = _cloneDeep6.dataKey, cloneOutput = objectWithoutProperties(_cloneDeep6, ["dataKey"]);
	                              pathArr = dataKey.split('.');
	                              currentVal = get_1(localRoot[pageName], pathArr);
	                              mergedVal = mergeDeep(currentVal, cloneOutput);
	                              mergedName = mergeDeep({
	                                name: mergedVal
	                              }, name);
	                              api = mergedVal.api, storeProp = mergedVal.store, get = mergedVal.get, options = objectWithoutProperties(mergedVal, ["api", "store", "get"]);

	                              if (!id) {
	                                _context6.next = 21;
	                                break;
	                              }

	                              _context6.prev = 8;
	                              _context6.next = 11;
	                              return store$3.level2SDK.vertexServices.updateVertex(_objectSpread$c(_objectSpread$c({}, options), {}, {
	                                mergedName: mergedName,
	                                id: id
	                              }));

	                            case 11:
	                              _yield$store$level2SD5 = _context6.sent;
	                              data = _yield$store$level2SD5.data;
	                              res = data;
	                              _context6.next = 19;
	                              break;

	                            case 16:
	                              _context6.prev = 16;
	                              _context6.t0 = _context6["catch"](8);
	                              throw _context6.t0;

	                            case 19:
	                              _context6.next = 31;
	                              break;

	                            case 21:
	                              _context6.prev = 21;
	                              _context6.next = 24;
	                              return store$3.level2SDK.vertexServices.createVertex(_objectSpread$c(_objectSpread$c({}, options), {}, {
	                                name: name
	                              }));

	                            case 24:
	                              response = _context6.sent;
	                              res = response;
	                              _context6.next = 31;
	                              break;

	                            case 28:
	                              _context6.prev = 28;
	                              _context6.t1 = _context6["catch"](21);
	                              throw _context6.t1;

	                            case 31:
	                              if (!res) {
	                                _context6.next = 34;
	                                break;
	                              }

	                              dispatch({
	                                type: 'update-data',
	                                //TODO: handle case for data is an array or an object
	                                payload: {
	                                  pageName: pageName,
	                                  dataKey: dataKey,
	                                  data: res
	                                }
	                              });
	                              return _context6.abrupt("return", res);

	                            case 34:
	                              return _context6.abrupt("return", null);

	                            case 35:
	                            case "end":
	                              return _context6.stop();
	                          }
	                        }
	                      }, _callee6, null, [[8, 16], [21, 28]]);
	                    }));

	                    return function (_x4) {
	                      return _ref11.apply(this, arguments);
	                    };
	                  }();
	                };

	                output = isPopulated(output) ? _storeFn2(output) : output;
	                break;
	              }

	            case 'rv':
	              {
	                var _getFn2 = function _getFn2(output) {
	                  return /*#__PURE__*/asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7() {
	                    var _cloneDeep7, api, dataKey, options, res, _yield$store$level2SD6, data;

	                    return regenerator.wrap(function _callee7$(_context7) {
	                      while (1) {
	                        switch (_context7.prev = _context7.next) {
	                          case 0:
	                            _cloneDeep7 = cloneDeep_1(output), api = _cloneDeep7.api, dataKey = _cloneDeep7.dataKey, options = objectWithoutProperties(_cloneDeep7, ["api", "dataKey"]);
	                            res = [];
	                            _context7.prev = 2;
	                            _context7.next = 5;
	                            return store$3.level2SDK.vertexServices.retrieveVertex({
	                              idList: [],
	                              options: options
	                            });

	                          case 5:
	                            _yield$store$level2SD6 = _context7.sent;
	                            data = _yield$store$level2SD6.data;
	                            res = data;
	                            _context7.next = 13;
	                            break;

	                          case 10:
	                            _context7.prev = 10;
	                            _context7.t0 = _context7["catch"](2);
	                            throw _context7.t0;

	                          case 13:
	                            if (!(res.length > 0)) {
	                              _context7.next = 16;
	                              break;
	                            }

	                            dispatch({
	                              type: 'update-data',
	                              //TODO: handle case for data is an array or an object
	                              payload: {
	                                pageName: pageName,
	                                dataKey: dataKey,
	                                data: res
	                              }
	                            });
	                            return _context7.abrupt("return", res);

	                          case 16:
	                            return _context7.abrupt("return", null);

	                          case 17:
	                          case "end":
	                            return _context7.stop();
	                        }
	                      }
	                    }, _callee7, null, [[2, 10]]);
	                  }));
	                };

	                output = isPopulated(output) ? _getFn2(output) : output;
	                break;
	              }

	            case 'builtIn':
	              {
	                var pathArr = api.split('.').slice(1);
	                var builtInFnsObj = builtInFns();

	                var builtInFn = get_1(builtInFnsObj, pathArr);

	                var fn = function fn(output) {
	                  return /*#__PURE__*/function () {
	                    var _ref13 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8(input) {
	                      var _cloneDeep8, api, dataKey, pathArr, currentVal, res, data;

	                      return regenerator.wrap(function _callee8$(_context8) {
	                        while (1) {
	                          switch (_context8.prev = _context8.next) {
	                            case 0:
	                              //@ts-ignore
	                              _cloneDeep8 = cloneDeep_1(output), api = _cloneDeep8.api, dataKey = _cloneDeep8.dataKey;
	                              pathArr = dataKey.split('.');
	                              currentVal = get_1(Object.values(localRoot)[0], pathArr);
	                              _context8.prev = 3;
	                              _context8.next = 6;
	                              return builtInFn(_objectSpread$c(_objectSpread$c({}, input), {}, {
	                                name: _objectSpread$c(_objectSpread$c({}, currentVal.name), input)
	                              }));

	                            case 6:
	                              data = _context8.sent;
	                              res = data;
	                              _context8.next = 13;
	                              break;

	                            case 10:
	                              _context8.prev = 10;
	                              _context8.t0 = _context8["catch"](3);
	                              throw _context8.t0;

	                            case 13:
	                              if (!(Array.isArray(res) && res.length > 0 || isObject$5(res))) {
	                                _context8.next = 16;
	                                break;
	                              }

	                              dispatch({
	                                type: 'update-data',
	                                //TODO: handle case for data is an array or an object
	                                payload: {
	                                  pageName: pageName,
	                                  dataKey: dataKey,
	                                  data: res
	                                }
	                              });
	                              return _context8.abrupt("return", res);

	                            case 16:
	                              return _context8.abrupt("return", null);

	                            case 17:
	                            case "end":
	                              return _context8.stop();
	                          }
	                        }
	                      }, _callee8, null, [[3, 10]]);
	                    }));

	                    return function (_x5) {
	                      return _ref13.apply(this, arguments);
	                    };
	                  }();
	                };

	                output = isPopulated(output) ? fn(output) : output;
	                break;
	              }

	            case 'localSearch':
	              {
	                var _fn = function _fn(output) {
	                  return /*#__PURE__*/asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee9() {
	                    var _cloneDeep9, api, dataKey, filter, sourcePath, res, source, data;

	                    return regenerator.wrap(function _callee9$(_context9) {
	                      while (1) {
	                        switch (_context9.prev = _context9.next) {
	                          case 0:
	                            //@ts-ignore
	                            _cloneDeep9 = cloneDeep_1(output), api = _cloneDeep9.api, dataKey = _cloneDeep9.dataKey, filter = _cloneDeep9.filter, sourcePath = _cloneDeep9.source;
	                            _context9.prev = 1;
	                            source = dispatch({
	                              type: 'get-data',
	                              payload: {
	                                pageName: pageName,
	                                dataKey: sourcePath
	                              }
	                            }); //TODO: make signature more generic

	                            data = source.filter(function (elem) {
	                              //TODO: make filter more universal
	                              for (var _i2 = 0, _Object$entries = Object.entries(filter); _i2 < _Object$entries.length; _i2++) {
	                                var _Object$entries$_i = slicedToArray(_Object$entries[_i2], 2),
	                                    _key = _Object$entries$_i[0],
	                                    val = _Object$entries$_i[1];

	                                //@ts-ignore
	                                if (elem.type[_key] !== parseInt(val)) {
	                                  return false;
	                                }
	                              }

	                              return true;
	                            });
	                            res = data;
	                            _context9.next = 10;
	                            break;

	                          case 7:
	                            _context9.prev = 7;
	                            _context9.t0 = _context9["catch"](1);
	                            throw _context9.t0;

	                          case 10:
	                            if (!(Array.isArray(res) && res.length > 0)) {
	                              _context9.next = 13;
	                              break;
	                            }

	                            dispatch({
	                              type: 'update-data',
	                              //TODO: handle case for data is an array or an object
	                              payload: {
	                                pageName: pageName,
	                                dataKey: dataKey,
	                                data: res[0]
	                              }
	                            });
	                            return _context9.abrupt("return", res);

	                          case 13:
	                            return _context9.abrupt("return", null);

	                          case 14:
	                          case "end":
	                            return _context9.stop();
	                        }
	                      }
	                    }, _callee9, null, [[1, 7]]);
	                  }));
	                };

	                output = isPopulated(output) ? _fn(output) : output;
	                break;
	              }

	            default:
	              {
	                return;
	              }
	          }
	        }
	      });
	    }

	    return output;
	  }
	}
	/**
	 * @param EvalStateArgs
	 * @param EvalStateArgs.pageName string
	 * @param EvalStateArgs.updateObject Record<string, any>
	 * @param EvalStateArgs.dispatch Function
	 * @returns Function
	 *
	 *  - returns a function that is used to evalutate actionType evalObject
	 */


	function evalState(_ref15) {
	  var pageName = _ref15.pageName,
	      updateObject = _ref15.updateObject,
	      dispatch = _ref15.dispatch;
	  return /*#__PURE__*/asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee10() {
	    return regenerator.wrap(function _callee10$(_context10) {
	      while (1) {
	        switch (_context10.prev = _context10.next) {
	          case 0:
	            _context10.next = 2;
	            return dispatch({
	              type: 'eval-object',
	              payload: {
	                pageName: pageName,
	                updateObject: updateObject
	              }
	            });

	          case 2:
	            return _context10.abrupt("return");

	          case 3:
	          case "end":
	            return _context10.stop();
	        }
	      }
	    }, _callee10);
	  }));
	}
	/**
	 * @param ReplaceEvalObjectArgs
	 * @param ReplaceEvalObjectArgs.cadlObject Record<string, any>
	 * @param ReplaceEvalObjectArgs.dispatch Function
	 * @returns Record<string, any>
	 * 
	 * - replaces the eval object, if any, with a function that performs the the actions detailed in the actionType evalObject 
	 */


	function replaceEvalObject(_ref17) {
	  var pageName = _ref17.pageName,
	      cadlObject = _ref17.cadlObject,
	      dispatch = _ref17.dispatch;

	  var cadlCopy = cloneDeep_1(cadlObject);

	  Object.keys(cadlCopy).forEach(function (key) {
	    // if (key === 'update') {
	    //     cadlCopy[key] = evalState({ pageName, updateObject: cadlCopy[key], dispatch })
	    // } else 
	    if (key === 'object' && isObject$5(cadlCopy[key]) && cadlCopy.actionType === 'evalObject') {
	      cadlCopy[key] = evalState({
	        pageName: pageName,
	        updateObject: cadlCopy[key],
	        dispatch: dispatch
	      });

	      if (pageName === 'SignIn' || pageName === 'CreateNewAccount' || pageName === 'SignUp') {
	        dispatch({
	          type: 'add-fn',
	          payload: {
	            pageName: pageName,
	            fn: cadlCopy[key]
	          }
	        });
	      }
	    } else if (isObject$5(cadlCopy[key])) {
	      cadlCopy[key] = replaceEvalObject({
	        pageName: pageName,
	        cadlObject: cadlCopy[key],
	        dispatch: dispatch
	      });
	    } else if (Array.isArray(cadlCopy[key])) {
	      cadlCopy[key] = cadlCopy[key].map(function (elem) {
	        if (isObject$5(elem)) {
	          return replaceEvalObject({
	            pageName: pageName,
	            cadlObject: elem,
	            dispatch: dispatch
	          });
	        }

	        return elem;
	      });
	    }
	  });
	  return cadlCopy;
	}
	/**
	 * @param PopulateStringArgs
	 * @param PopulateStringArgs.source  string -object that has values that need to be replaced
	 * @param PopulateStringArgs.lookFor string -item to look for in object
	 * @param PopulateStringArgs.locations Record<string, any>[] -array of objects that may contain the values for the source object
	 * @param PopulateStringArgs.path string
	 * @param PopulateStringArgs.dispatch Function
	 * @param PopulateStringArgs.pageName string
	 * 
	 * @returns Record<string. any> 
	 */


	function populateString(_ref18) {
	  var source = _ref18.source,
	      lookFor = _ref18.lookFor,
	      skip = _ref18.skip,
	      locations = _ref18.locations,
	      path = _ref18.path,
	      dispatch = _ref18.dispatch,
	      pageName = _ref18.pageName;
	  if (skip && skip.includes(source)) return source;
	  if (!source.startsWith(lookFor)) return source;

	  if (dispatch && pageName && path) {
	    var pathStr = path.slice(1).join('.');
	    dispatch({
	      type: 'save-ref',
	      payload: {
	        pageName: pageName,
	        path: pathStr,
	        ref: source
	      }
	    });
	  }

	  var currVal = source;
	  var replacement;

	  if (lookFor === '_' && currVal.includes('.')) {
	    var charArr = currVal.split('');
	    var copyPath = clone_1(path) || [];
	    var currChar = charArr.shift();

	    while (currChar !== '.' && charArr.length > 0) {
	      if (currChar === '_') {
	        copyPath.pop();
	      }

	      currChar = charArr.shift();
	    }

	    replacement = '.' + copyPath.concat(charArr.join('')).join('.');
	    return replacement;
	  } else if (lookFor === '..') {
	    currVal = currVal.slice(1);
	  } else if (lookFor === '=') {
	    if (source.startsWith('=..')) {
	      currVal = currVal.slice(2);
	    } // else if (source.startsWith('=.builtIn')) {
	    //     const builtInFuncs = builtInFns()
	    //     const pathArr = source.slice(2).split('.')[1]
	    //     const fn = _.get(builtInFuncs, pathArr)
	    //     if (fn) {
	    //         replacement = fn
	    //         return replacement
	    //     }
	    // } 
	    else if (source.startsWith('=.')) {
	        currVal = currVal.slice(1);
	      }
	  }

	  if (currVal.startsWith('.')) {
	    currVal = currVal.slice(1);
	  }

	  var _iterator2 = _createForOfIteratorHelper$g(locations),
	      _step2;

	  try {
	    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	      var location = _step2.value;

	      try {
	        replacement = dotObject.pick(currVal, location); // replacement = lookUp(currVal, location)

	        if (replacement && replacement !== source) {
	          if (typeof replacement === 'string' && replacement.startsWith(lookFor)) {
	            return populateString({
	              source: replacement,
	              lookFor: lookFor,
	              skip: skip,
	              locations: locations,
	              path: path,
	              pageName: pageName,
	              dispatch: dispatch
	            });
	          } else {
	            break;
	          }
	        }
	      } catch (error) {
	        if (error instanceof UnableToLocateValue) {
	          continue;
	        } else {
	          throw error;
	        }
	      }
	    }
	  } catch (err) {
	    _iterator2.e(err);
	  } finally {
	    _iterator2.f();
	  }

	  if (replacement && replacement !== source) {
	    return replacement;
	  }

	  return source;
	}
	/**
	 * @param PopulateArrayArgs
	 * @param PopulateArrayArgs.source  any[] -object that has values that need to be replaced
	 * @param PopulateArrayArgs.lookFor string -item to look for in object
	 * @param PopulateArrayArgs.locations Record<string, any>[] -array of objects that may contain the values for the source object
	 * @param PopulateArrayArgs.path string[]
	 * @param PopulateArrayArgs.dispatch Function
	 * @param PopulateArrayArgs.pageName string
	 * 
	 * @returns any[] 
	 */


	function populateArray(_ref19) {
	  var source = _ref19.source,
	      lookFor = _ref19.lookFor,
	      skip = _ref19.skip,
	      locations = _ref19.locations,
	      path = _ref19.path,
	      dispatch = _ref19.dispatch,
	      pageName = _ref19.pageName;

	  var sourceCopy = cloneDeep_1(source);

	  var previousKey = path[path.length - 1] || '';
	  var replacement = sourceCopy.map(function (elem, i) {
	    var index = '[' + i + ']';

	    if (Array.isArray(elem)) {
	      return populateArray({
	        source: elem,
	        skip: skip,
	        lookFor: lookFor,
	        locations: locations,
	        path: path.slice(0, -1).concat(previousKey + index),
	        dispatch: dispatch,
	        pageName: pageName
	      });
	    } else if (isObject$5(elem)) {
	      if (!('actionType' in elem && elem.actionType === 'evalObject' && elem.object && isObject$5(elem.object))) {
	        return populateObject({
	          source: elem,
	          skip: skip,
	          lookFor: lookFor,
	          locations: locations,
	          path: path.slice(0, -1).concat(previousKey + index),
	          dispatch: dispatch,
	          pageName: pageName
	        });
	      }
	    } else if (typeof elem === 'string') {
	      return populateString({
	        source: elem,
	        skip: skip,
	        lookFor: lookFor,
	        locations: locations,
	        path: path.slice(0, -1).concat(previousKey + index),
	        dispatch: dispatch,
	        pageName: pageName
	      });
	    }

	    return elem;
	  });
	  return replacement;
	}
	/**
	 * @param PopulateObjectArgs
	 * @param PopulateObjectArgs.source  Record<string, any> -object that has values that need to be replaced
	 * @param PopulateObjectArgs.lookFor string -item to look for in object
	 * @param PopulateObjectArgs.locations Record<string, any>[] -array of objects that may contain the values for the source object
	 * @param PopulateObjectArgs.skip string[]
	 * @param PopulateObjectArgs.path string[]
	 * @param PopulateObjectArgs.dispatch Function
	 * @param PopulateObjectArgs.pageName string
	 * 
	 * @returns Record<string. any> 
	 */


	function populateObject(_ref20) {
	  var source = _ref20.source,
	      lookFor = _ref20.lookFor,
	      locations = _ref20.locations,
	      _ref20$skip = _ref20.skip,
	      skip = _ref20$skip === void 0 ? [] : _ref20$skip,
	      _ref20$path = _ref20.path,
	      path = _ref20$path === void 0 ? [] : _ref20$path,
	      dispatch = _ref20.dispatch,
	      pageName = _ref20.pageName;

	  var sourceCopy = cloneDeep_1(source);

	  Object.keys(sourceCopy).forEach(function (key) {
	    var index = key;

	    if (!skip.includes(key) && key !== 'dataKey') {
	      if (isObject$5(sourceCopy[key])) {
	        if (!('actionType' in sourceCopy[key] && sourceCopy[key].actionType === 'evalObject' && sourceCopy[key].object && isObject$5(sourceCopy[key].object))) {
	          sourceCopy[key] = populateObject({
	            source: sourceCopy[key],
	            lookFor: lookFor,
	            locations: locations,
	            skip: skip,
	            path: path.concat(index),
	            dispatch: dispatch,
	            pageName: pageName
	          });
	        }
	      } else if (Array.isArray(sourceCopy[key])) {
	        sourceCopy[key] = populateArray({
	          source: sourceCopy[key],
	          skip: skip,
	          lookFor: lookFor,
	          locations: locations,
	          path: path.concat(index),
	          dispatch: dispatch,
	          pageName: pageName
	        });
	      } else if (typeof sourceCopy[key] === 'string') {
	        sourceCopy[key] = populateString({
	          source: sourceCopy[key],
	          skip: skip,
	          lookFor: lookFor,
	          locations: locations,
	          path: path.concat(index),
	          dispatch: dispatch,
	          pageName: pageName
	        });
	      }
	    }
	  });
	  return sourceCopy;
	}
	/**
	 * @param dispatch Function
	 * @returns Record<string, Function>
	 */


	function builtInFns(dispatch) {
	  return {
	    createNewAccount: function createNewAccount(_ref21) {
	      return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee11() {
	        var phoneNumber, password, verificationCode, name, passPlaceHolder, vcPlaceHolder, confirmPassword, restOfName, data;
	        return regenerator.wrap(function _callee11$(_context11) {
	          while (1) {
	            switch (_context11.prev = _context11.next) {
	              case 0:
	                phoneNumber = _ref21.phoneNumber, password = _ref21.password, verificationCode = _ref21.verificationCode, name = _ref21.name;
	                passPlaceHolder = name.password, vcPlaceHolder = name.verificationCode, confirmPassword = name.confirmPassword, restOfName = objectWithoutProperties(name, ["password", "verificationCode", "confirmPassword"]);
	                _context11.next = 4;
	                return Account$1.create(phoneNumber, password, verificationCode, _objectSpread$c({}, restOfName));

	              case 4:
	                data = _context11.sent;
	                return _context11.abrupt("return", data);

	              case 6:
	              case "end":
	                return _context11.stop();
	            }
	          }
	        }, _callee11);
	      }))();
	    },
	    signIn: function signIn(_ref22) {
	      return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee12() {
	        var phoneNumber, password, verificationCode, data;
	        return regenerator.wrap(function _callee12$(_context12) {
	          while (1) {
	            switch (_context12.prev = _context12.next) {
	              case 0:
	                phoneNumber = _ref22.phoneNumber, password = _ref22.password, verificationCode = _ref22.verificationCode;
	                _context12.next = 3;
	                return Account$1.login(phoneNumber, password, verificationCode);

	              case 3:
	                data = _context12.sent;

	                if (dispatch) {
	                  dispatch({
	                    type: 'update-data',
	                    //TODO: handle case for data is an array or an object
	                    payload: {
	                      pageName: 'builtIn',
	                      dataKey: 'builtIn.UserVertex',
	                      data: data
	                    }
	                  });
	                }

	                return _context12.abrupt("return", data);

	              case 6:
	              case "end":
	                return _context12.stop();
	            }
	          }
	        }, _callee12);
	      }))();
	    },
	    loginByPassword: function loginByPassword(password) {
	      return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee13() {
	        var data;
	        return regenerator.wrap(function _callee13$(_context13) {
	          while (1) {
	            switch (_context13.prev = _context13.next) {
	              case 0:
	                _context13.next = 2;
	                return Account$1.loginByPassword(password);

	              case 2:
	                data = _context13.sent;

	                if (dispatch) {
	                  dispatch({
	                    type: 'update-data',
	                    //TODO: handle case for data is an array or an object
	                    payload: {
	                      pageName: 'builtIn',
	                      dataKey: 'builtIn.UserVertex',
	                      data: data
	                    }
	                  });
	                }

	              case 4:
	              case "end":
	                return _context13.stop();
	            }
	          }
	        }, _callee13);
	      }))();
	    },
	    currentDateTime: function () {
	      return Date.now();
	    }()
	  };
	}
	/**
	 * 
	 * @param PopulateValsArgs 
	 * @param PopulateValsArgs.source Record<string, any>
	 * @param PopulateValsArgs.lookFor string[]
	 * @param PopulateValsArgs.locations any[]
	 * @param PopulateValsArgs.skip string[]
	 * @param PopulateValsArgs.pageName string
	 * @param PopulateValsArgs.dispatch Function
	 * @returns Record<string, any>
	 */


	function populateVals(_ref23) {
	  var source = _ref23.source,
	      lookFor = _ref23.lookFor,
	      locations = _ref23.locations,
	      skip = _ref23.skip,
	      pageName = _ref23.pageName,
	      dispatch = _ref23.dispatch;

	  var sourceCopy = cloneDeep_1(source);

	  var _iterator3 = _createForOfIteratorHelper$g(lookFor),
	      _step3;

	  try {
	    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	      var symbol = _step3.value;
	      sourceCopy = populateObject({
	        source: sourceCopy,
	        lookFor: symbol,
	        skip: skip,
	        locations: locations,
	        pageName: pageName,
	        dispatch: dispatch
	      });
	    }
	  } catch (err) {
	    _iterator3.e(err);
	  } finally {
	    _iterator3.f();
	  }

	  return sourceCopy;
	}
	/**
	 * 
	 * @param source Record<string, any>
	 * @returns Record<string, any>
	 */


	function replaceUint8ArrayWithBase64(source) {
	  var sourceCopy = cloneDeep_1(source);

	  if (isObject$5(source)) {
	    Object.keys(sourceCopy).forEach(function (key) {
	      if (sourceCopy[key] instanceof Uint8Array) {
	        sourceCopy[key] = store$3.level2SDK.utilServices.uint8ArrayToBase64(sourceCopy[key]);
	      } else if (isObject$5(sourceCopy[key])) {
	        sourceCopy[key] = replaceUint8ArrayWithBase64(sourceCopy[key]);
	      } else if (Array.isArray(sourceCopy[key]) && !(sourceCopy[key] instanceof Uint8Array)) {
	        sourceCopy[key] = sourceCopy[key].map(function (elem) {
	          return replaceUint8ArrayWithBase64(elem);
	        });
	      }
	    });
	  }

	  return sourceCopy;
	}

	function _createForOfIteratorHelper$h(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$i(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$i(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$i(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$i(o, minLen); }

	function _arrayLikeToArray$i(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function ownKeys$d(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$d(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$d(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$d(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	var CADL = /*#__PURE__*/function () {
	  /**
	   * 
	   * @param CADLARGS
	   * @param CADLARGS.env string 
	   * @param CADLARGS.configUrl string 
	   * @param CADLARGS.cadlVersion 'test' | 'stable' 
	   */
	  function CADL(_ref) {
	    var env = _ref.env,
	        configUrl = _ref.configUrl,
	        cadlVersion = _ref.cadlVersion;

	    classCallCheck(this, CADL);

	    defineProperty(this, "_cadlVersion", void 0);

	    defineProperty(this, "_cadlEndpoint", void 0);

	    defineProperty(this, "_cadlBaseUrl", void 0);

	    defineProperty(this, "_baseUrl", void 0);

	    defineProperty(this, "_assetsUrl", void 0);

	    defineProperty(this, "_map", void 0);

	    defineProperty(this, "_root", {
	      actions: {},
	      refs: {}
	    });

	    defineProperty(this, "_builtIn", builtInFns(this.dispatch.bind(this)));

	    defineProperty(this, "_initCallQueue", void 0);

	    //replace default arguments
	    store$3.env = env;
	    store$3.configUrl = configUrl;
	    this._cadlVersion = cadlVersion;
	  }
	  /**
	   * @param InitArgs 
	   * @param InitArgs.BaseDataModel Record<string, any>
	   * @param InitArgs.BaseCSS Record<string, any>
	   * @param InitArgs.BasePage Record<string, any>
	   * @throws UnableToRetrieveYAML -if unable to retrieve cadlYAML
	   * @throws UnableToParseYAML -if unable to parse yaml file
	   * @throws UnableToLoadConfig -if unable to load config data
	   * 
	   * -loads config if not already loaded
	   * -sets CADL version, baseUrl, assetsUrl, and root
	   */


	  createClass(CADL, [{
	    key: "init",
	    value: function () {
	      var _init = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
	        var _ref2,
	            BaseDataModel,
	            BaseCSS,
	            BasePage,
	            config,
	            _config,
	            web,
	            cadlBaseUrl,
	            cadlMain,
	            cadlEndpointUrl,
	            cadlEndpoint,
	            _this$cadlEndpoint,
	            baseUrl,
	            assetsUrl,
	            preload,
	            processedBaseDataModel,
	            processedBaseCSS,
	            processedBasePage,
	            _iterator,
	            _step,
	            pageName,
	            rawBaseDataModel,
	            _processedBaseDataModel,
	            rawBaseCSS,
	            _processedBaseCSS,
	            rawBasePage,
	            _processedBasePage,
	            rawPage,
	            processedRawPage,
	            localStorageGlobal,
	            _args = arguments;

	        return regenerator.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _ref2 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, BaseDataModel = _ref2.BaseDataModel, BaseCSS = _ref2.BaseCSS, BasePage = _ref2.BasePage;

	                if (!this.cadlEndpoint) {
	                  _context.next = 3;
	                  break;
	                }

	                return _context.abrupt("return");

	              case 3:
	                //get config
	                config = store$3.getConfig();

	                if (!(config === null)) {
	                  _context.next = 14;
	                  break;
	                }

	                _context.prev = 5;
	                _context.next = 8;
	                return store$3.level2SDK.loadConfigData('meet');

	              case 8:
	                config = _context.sent;
	                _context.next = 14;
	                break;

	              case 11:
	                _context.prev = 11;
	                _context.t0 = _context["catch"](5);
	                throw new UnableToLoadConfig('An error occured while trying to load the config', _context.t0);

	              case 14:
	                _config = config, web = _config.web, cadlBaseUrl = _config.cadlBaseUrl, cadlMain = _config.cadlMain; //set cadlVersion

	                this.cadlVersion = web.cadlVersion[this.cadlVersion];
	                this.cadlBaseUrl = cadlBaseUrl; //set cadlEndpoint

	                cadlEndpointUrl = "".concat(this.cadlBaseUrl).concat(cadlMain);
	                _context.next = 20;
	                return this.defaultObject(cadlEndpointUrl);

	              case 20:
	                cadlEndpoint = _context.sent;
	                this.cadlEndpoint = cadlEndpoint;
	                _this$cadlEndpoint = this.cadlEndpoint, baseUrl = _this$cadlEndpoint.baseUrl, assetsUrl = _this$cadlEndpoint.assetsUrl, preload = _this$cadlEndpoint.preload; //set baseUrl and assets Url

	                this.baseUrl = baseUrl;
	                this.assetsUrl = assetsUrl; //set overrides of Base Objects

	                if (BaseDataModel) {
	                  processedBaseDataModel = this.processPopulate({
	                    source: BaseDataModel,
	                    lookFor: ['.', '..', '=']
	                  });
	                  this.root = _objectSpread$d(_objectSpread$d({}, this.root), processedBaseDataModel);
	                }

	                if (BaseCSS) {
	                  processedBaseCSS = this.processPopulate({
	                    source: BaseCSS,
	                    lookFor: ['.', '..', '=']
	                  });
	                  this.root = _objectSpread$d(_objectSpread$d({}, this.root), processedBaseCSS);
	                }

	                if (BasePage) {
	                  processedBasePage = this.processPopulate({
	                    source: BasePage,
	                    lookFor: ['.', '..', '=']
	                  });
	                  this.root = _objectSpread$d(_objectSpread$d({}, this.root), processedBasePage);
	                }

	                if (!(preload && preload.length)) {
	                  _context.next = 77;
	                  break;
	                }

	                _iterator = _createForOfIteratorHelper$h(preload);
	                _context.prev = 30;

	                _iterator.s();

	              case 32:
	                if ((_step = _iterator.n()).done) {
	                  _context.next = 69;
	                  break;
	                }

	                pageName = _step.value;
	                _context.t1 = pageName;
	                _context.next = _context.t1 === 'BaseDataModel' ? 37 : _context.t1 === 'BaseCSS' ? 45 : _context.t1 === 'BasePage' ? 53 : 61;
	                break;

	              case 37:
	                if (!BaseDataModel) {
	                  _context.next = 39;
	                  break;
	                }

	                return _context.abrupt("break", 67);

	              case 39:
	                _context.next = 41;
	                return this.getPage('BaseDataModel');

	              case 41:
	                rawBaseDataModel = _context.sent;
	                _processedBaseDataModel = this.processPopulate({
	                  source: rawBaseDataModel,
	                  lookFor: ['.', '..', '=']
	                });
	                this.root = _objectSpread$d(_objectSpread$d({}, this.root), _processedBaseDataModel);
	                return _context.abrupt("break", 67);

	              case 45:
	                if (!BaseCSS) {
	                  _context.next = 47;
	                  break;
	                }

	                return _context.abrupt("break", 67);

	              case 47:
	                _context.next = 49;
	                return this.getPage('BaseCSS');

	              case 49:
	                rawBaseCSS = _context.sent;
	                _processedBaseCSS = this.processPopulate({
	                  source: rawBaseCSS,
	                  lookFor: ['.', '..', '=']
	                });
	                this.root = _objectSpread$d(_objectSpread$d({}, this.root), _processedBaseCSS);
	                return _context.abrupt("break", 67);

	              case 53:
	                if (!BasePage) {
	                  _context.next = 55;
	                  break;
	                }

	                return _context.abrupt("break", 67);

	              case 55:
	                _context.next = 57;
	                return this.getPage('BasePage');

	              case 57:
	                rawBasePage = _context.sent;
	                _processedBasePage = this.processPopulate({
	                  source: rawBasePage,
	                  lookFor: ['.', '..', '=']
	                });
	                this.root = _objectSpread$d(_objectSpread$d({}, this.root), _processedBasePage);
	                return _context.abrupt("break", 67);

	              case 61:
	                _context.next = 63;
	                return this.getPage(pageName);

	              case 63:
	                rawPage = _context.sent;
	                processedRawPage = this.processPopulate({
	                  source: rawPage,
	                  lookFor: ['.', '..', '=']
	                });
	                this.root = _objectSpread$d(_objectSpread$d({}, this.root), processedRawPage);
	                return _context.abrupt("break", 67);

	              case 67:
	                _context.next = 32;
	                break;

	              case 69:
	                _context.next = 74;
	                break;

	              case 71:
	                _context.prev = 71;
	                _context.t2 = _context["catch"](30);

	                _iterator.e(_context.t2);

	              case 74:
	                _context.prev = 74;

	                _iterator.f();

	                return _context.finish(74);

	              case 77:
	                localStorageGlobal = localStorage.getItem('Global');

	                if (localStorageGlobal) {
	                  try {
	                    localStorageGlobal = JSON.parse(localStorageGlobal);
	                  } catch (error) {
	                    console.log(error);
	                  }

	                  this.root = _objectSpread$d(_objectSpread$d({}, this.root), {}, {
	                    Global: localStorageGlobal
	                  });
	                }

	                this.dispatch({
	                  type: 'update-map'
	                });

	              case 80:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this, [[5, 11], [30, 71, 74, 77]]);
	      }));

	      function init() {
	        return _init.apply(this, arguments);
	      }

	      return init;
	    }()
	    /**
	     * 
	     * @param pageName string
	     * @param skip string[] -denotes the keys to skip in the population process 
	     * @param options { builtIn?: Record<string, any> } -object that takes in set of options for the page
	     * 
	     * @throws UnableToRetrieveYAML -if unable to retrieve cadlYAML
	     * @throws UnableToParseYAML -if unable to parse yaml file
	     * @throws UnableToExecuteFn -if something goes wrong while executing any init function
	     * 
	     * - initiates cadlObject for page specified
	     */
	    //TODO: extract init functionality to use only runInit()

	  }, {
	    key: "initPage",
	    value: function () {
	      var _initPage = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(pageName) {
	        var skip,
	            options,
	            builtIn,
	            pageCADL,
	            processedFormData,
	            processedWithFns,
	            boundDispatch,
	            processedPage,
	            init,
	            currIndex,
	            command,
	            actionType,
	            dataKey,
	            dataObject,
	            funcName,
	            updatedPage,
	            populatedUpdatedPage,
	            populatedUpdatedPageWithFns,
	            processedComponents,
	            replaceUpdateJob2,
	            _args2 = arguments;
	        return regenerator.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                skip = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : [];
	                options = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};

	                if (this.cadlEndpoint) {
	                  _context2.next = 5;
	                  break;
	                }

	                _context2.next = 5;
	                return this.init();

	              case 5:
	                builtIn = options.builtIn;

	                if (builtIn && isObject_1(builtIn)) {
	                  this.builtIn = _objectSpread$d(_objectSpread$d({}, this.builtIn), builtIn);
	                }

	                _context2.next = 9;
	                return this.getPage(pageName);

	              case 9:
	                pageCADL = _context2.sent;

	                //FOR FORMDATA
	                //process formData
	                if (this.root[pageName]) {
	                  delete this.root[pageName]; // const cloneCurrPage = _.cloneDeep(this.root[pageName])
	                  // //TODO: test order of overrides
	                  // const mergedPage = _.merge(pageCADL, { [pageName]: cloneCurrPage })
	                  // pageCADL = mergedPage
	                }

	                processedFormData = this.processPopulate({
	                  source: pageCADL,
	                  lookFor: ['.', '..', '='],
	                  skip: ['update', 'components', 'init'].concat(toConsumableArray(skip)),
	                  withFns: true,
	                  pageName: pageName
	                }); //FOR FNS
	                //process components

	                processedWithFns = this.processPopulate({
	                  source: processedFormData,
	                  lookFor: ['.', '..', '=', '_'],
	                  skip: ['update', 'formData', 'components'].concat(toConsumableArray(skip)),
	                  withFns: true,
	                  pageName: pageName
	                }); // //replace updateObj with Fn

	                boundDispatch = this.dispatch.bind(this); // let replaceUpdateJob = replaceUpdate({ pageName, cadlObject: processedFormData, dispatch: boundDispatch })

	                processedPage = processedWithFns;
	                this.root = _objectSpread$d(_objectSpread$d({}, this.root), processedPage); //run init commands if any

	                init = Object.values(processedPage)[0].init;

	                if (!init) {
	                  _context2.next = 66;
	                  break;
	                }

	                this.initCallQueue = init.map(function (_command, index) {
	                  return index;
	                });

	              case 19:
	                if (!(this.initCallQueue.length > 0)) {
	                  _context2.next = 66;
	                  break;
	                }

	                currIndex = this.initCallQueue.shift();
	                command = init[currIndex];

	                if (!(typeof command === 'function')) {
	                  _context2.next = 33;
	                  break;
	                }

	                _context2.prev = 23;
	                _context2.next = 26;
	                return command();

	              case 26:
	                _context2.next = 31;
	                break;

	              case 28:
	                _context2.prev = 28;
	                _context2.t0 = _context2["catch"](23);
	                throw new UnableToExecuteFn("An error occured while executing ".concat(pageName, ".init"), _context2.t0);

	              case 31:
	                _context2.next = 58;
	                break;

	              case 33:
	                if (!(isObject_1(command) && 'actionType' in command)) {
	                  _context2.next = 48;
	                  break;
	                }

	                actionType = command.actionType, dataKey = command.dataKey, dataObject = command.dataObject, funcName = command.funcName;
	                _context2.t1 = actionType;
	                _context2.next = _context2.t1 === 'updateObject' ? 38 : _context2.t1 === 'builtIn' ? 40 : 45;
	                break;

	              case 38:
	                this.updateObject({
	                  dataKey: dataKey,
	                  dataObject: dataObject
	                });
	                return _context2.abrupt("break", 46);

	              case 40:
	                if (!(funcName === 'videoChat')) {
	                  _context2.next = 44;
	                  break;
	                }

	                if (!(funcName in this.builtIn && typeof this.builtIn[funcName] === 'function')) {
	                  _context2.next = 44;
	                  break;
	                }

	                _context2.next = 44;
	                return this.builtIn[funcName](command);

	              case 44:
	                return _context2.abrupt("break", 46);

	              case 45:
	                return _context2.abrupt("return");

	              case 46:
	                _context2.next = 58;
	                break;

	              case 48:
	                if (!Array.isArray(command)) {
	                  _context2.next = 58;
	                  break;
	                }

	                if (!(typeof command[0][1] === 'function')) {
	                  _context2.next = 58;
	                  break;
	                }

	                _context2.prev = 50;
	                _context2.next = 53;
	                return command[0][1]();

	              case 53:
	                _context2.next = 58;
	                break;

	              case 55:
	                _context2.prev = 55;
	                _context2.t2 = _context2["catch"](50);
	                throw new UnableToExecuteFn("An error occured while executing ".concat(pageName, ".init"), _context2.t2);

	              case 58:
	                //updating page after command has been called
	                updatedPage = this.root[pageName]; //populateObject again to populate any data that was dependant on the command call

	                populatedUpdatedPage = populateObject({
	                  source: updatedPage,
	                  lookFor: '..',
	                  skip: ['components'],
	                  locations: [this.root[pageName]]
	                });
	                populatedUpdatedPageWithFns = attachFns({
	                  cadlObject: defineProperty({}, pageName, populatedUpdatedPage),
	                  dispatch: boundDispatch
	                });
	                processedPage = populatedUpdatedPageWithFns;
	                init = Object.values(populatedUpdatedPageWithFns)[0].init;
	                this.root[pageName] = _objectSpread$d(_objectSpread$d({}, this.root[pageName]), Object.values(populatedUpdatedPageWithFns)[0]);
	                _context2.next = 19;
	                break;

	              case 66:
	                //FOR COMPONENTS
	                //process components
	                processedComponents = this.processPopulate({
	                  source: processedPage,
	                  lookFor: ['.', '..', '=', '_'],
	                  skip: ['update', 'formData'].concat(toConsumableArray(skip)),
	                  withFns: true,
	                  pageName: pageName
	                });
	                replaceUpdateJob2 = replaceEvalObject({
	                  pageName: pageName,
	                  cadlObject: processedComponents,
	                  dispatch: boundDispatch
	                });
	                this.root = _objectSpread$d(_objectSpread$d({}, this.root), replaceUpdateJob2);
	                this.dispatch({
	                  type: 'update-map'
	                });

	              case 70:
	              case "end":
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this, [[23, 28], [50, 55]]);
	      }));

	      function initPage(_x) {
	        return _initPage.apply(this, arguments);
	      }

	      return initPage;
	    }()
	    /**
	     * @param pageName string
	     * @returns CADL_OBJECT
	     * @throws UnableToRetrieveYAML -if unable to retrieve cadlYAML
	     * @throws UnableToParseYAML -if unable to parse yaml file
	     */

	  }, {
	    key: "getPage",
	    value: function () {
	      var _getPage = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(pageName) {
	        var pageCADL, url;
	        return regenerator.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                _context3.prev = 0;
	                url = "".concat(this.baseUrl).concat(pageName, "_en.yml");
	                _context3.next = 4;
	                return this.defaultObject(url);

	              case 4:
	                pageCADL = _context3.sent;
	                _context3.next = 10;
	                break;

	              case 7:
	                _context3.prev = 7;
	                _context3.t0 = _context3["catch"](0);
	                throw _context3.t0;

	              case 10:
	                return _context3.abrupt("return", pageCADL);

	              case 11:
	              case "end":
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this, [[0, 7]]);
	      }));

	      function getPage(_x2) {
	        return _getPage.apply(this, arguments);
	      }

	      return getPage;
	    }()
	    /**
	     * 
	     * @param url string
	     * @returns Promise<Record<string, any>>
	     * @throws UnableToRetrieveYAML -if unable to retrieve cadlYAML
	     * @throws UnableToParseYAML -if unable to parse yaml file
	     * 
	     * -retrieves and parses cadl yaml file
	     */

	  }, {
	    key: "defaultObject",
	    value: function () {
	      var _defaultObject = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(url) {
	        var cadlYAML, cadlObject, _yield$axios$get, data;

	        return regenerator.wrap(function _callee4$(_context4) {
	          while (1) {
	            switch (_context4.prev = _context4.next) {
	              case 0:
	                _context4.prev = 0;
	                _context4.next = 3;
	                return axios$1.get(url);

	              case 3:
	                _yield$axios$get = _context4.sent;
	                data = _yield$axios$get.data;
	                cadlYAML = data;
	                _context4.next = 11;
	                break;

	              case 8:
	                _context4.prev = 8;
	                _context4.t0 = _context4["catch"](0);
	                throw new UnableToRetrieveYAML("Unable to retrieve yaml for ".concat(url), _context4.t0);

	              case 11:
	                _context4.prev = 11;
	                cadlObject = YAML.parse(cadlYAML);
	                _context4.next = 18;
	                break;

	              case 15:
	                _context4.prev = 15;
	                _context4.t1 = _context4["catch"](11);
	                throw new UnableToParseYAML("Unable to parse yaml for ".concat(url), _context4.t1);

	              case 18:
	                return _context4.abrupt("return", cadlObject);

	              case 19:
	              case "end":
	                return _context4.stop();
	            }
	          }
	        }, _callee4, null, [[0, 8], [11, 15]]);
	      }));

	      function defaultObject(_x3) {
	        return _defaultObject.apply(this, arguments);
	      }

	      return defaultObject;
	    }()
	    /**
	     * 
	     * @param pageName string
	     * @param dataKey string
	     * @returns any
	     * 
	     * -returns data associated with given pageName and dataKey
	     */

	  }, {
	    key: "getData",
	    value: function getData(pageName, dataKey) {
	      var firstCharacter = dataKey[0];
	      var pathArr = dataKey.split('.');
	      var currentVal;

	      if (firstCharacter === firstCharacter.toUpperCase()) {
	        currentVal = get_1(this.root, pathArr);
	      } else {
	        currentVal = get_1(this.root[pageName], pathArr);
	      }

	      if (currentVal) return currentVal;
	      return dataKey;
	    }
	    /**
	     * 
	     * @param ProcessPopulateArgs 
	     * @param ProcessPopulateArgs.source  Record<string, any> -item being de-referenced
	     * @param ProcessPopulateArgs.lookFor  string[] -reference tokens to look for e.g ['.','..']
	     * @param ProcessPopulateArgs.pageName?  string
	     * @param ProcessPopulateArgs.skip?  string[] -keys that should not be de-referenced e.g ['name','country']
	     * @param ProcessPopulateArgs.withFns?  boolean -choose to attach ecos functions to the source
	     * 
	     * @returns Record<string, any> -the processed/de-referenced object
	     * 
	     * - used to populate the references 
	     */

	  }, {
	    key: "processPopulate",
	    value: function processPopulate(_ref3) {
	      var source = _ref3.source,
	          lookFor = _ref3.lookFor,
	          skip = _ref3.skip,
	          pageName = _ref3.pageName,
	          _ref3$withFns = _ref3.withFns,
	          withFns = _ref3$withFns === void 0 ? false : _ref3$withFns;

	      var sourceCopy = cloneDeep_1(source);

	      var localRoot = pageName ? sourceCopy[pageName] : sourceCopy;
	      var sourceCopyWithRootKeys = populateKeys({
	        source: sourceCopy,
	        lookFor: '.',
	        locations: [this.root, sourceCopy]
	      }); //populate the keys from the local page object

	      var sourceCopyWithLocalKeys = populateKeys({
	        source: sourceCopyWithRootKeys,
	        lookFor: '..',
	        locations: [localRoot]
	      });
	      var boundDispatch = this.dispatch.bind(this);
	      localRoot = pageName ? sourceCopyWithLocalKeys[pageName] : sourceCopyWithLocalKeys;
	      var sourceCopyWithVals = populateVals({
	        source: sourceCopyWithLocalKeys,
	        lookFor: lookFor,
	        skip: skip,
	        locations: [this.root, localRoot],
	        pageName: pageName,
	        dispatch: boundDispatch
	      });
	      localRoot = pageName ? sourceCopyWithVals[pageName] : sourceCopyWithLocalKeys;
	      var populatedResponse = sourceCopyWithVals;

	      if (withFns) {
	        populatedResponse = attachFns({
	          cadlObject: sourceCopyWithVals,
	          dispatch: boundDispatch
	        });
	      }

	      return populatedResponse;
	    }
	    /**
	     * 
	     * @param action 
	     */

	  }, {
	    key: "dispatch",
	    value: function dispatch(action) {
	      var _this = this;

	      switch (action.type) {
	        case 'populate':
	          {
	            var pageName = action.payload.pageName;

	            var pageObjectCopy = cloneDeep_1(this.root[pageName]);

	            var boundDispatch = this.dispatch.bind(this);
	            var populateWithRoot = populateObject({
	              source: pageObjectCopy,
	              lookFor: '.',
	              locations: [this.root, this.root[pageName]]
	            });
	            var populateWithSelf = populateObject({
	              source: populateWithRoot,
	              lookFor: '..',
	              locations: [this.root, this.root[pageName]]
	            });
	            var populateAfterInheriting = populateObject({
	              source: populateWithSelf,
	              lookFor: '=',
	              locations: [this.root, this.root[pageName]]
	            });
	            var withFNs = attachFns({
	              cadlObject: populateAfterInheriting,
	              dispatch: boundDispatch
	            });
	            this.root[pageName] = withFNs;
	            this.dispatch({
	              type: 'update-localStorage'
	            });
	            break;
	          }

	        case 'update-data':
	          {
	            var _action$payload = action.payload,
	                _pageName = _action$payload.pageName,
	                dataKey = _action$payload.dataKey,
	                rawData = _action$payload.data;
	            var data = replaceUint8ArrayWithBase64(rawData);
	            var firstCharacter = dataKey[0];
	            var pathArr = dataKey.split('.');

	            if (_pageName === 'builtIn') {
	              set_1(this, pathArr, data);
	            } else if (firstCharacter === firstCharacter.toUpperCase()) {
	              var currentVal = get_1(this.root, pathArr);

	              var mergedVal = mergeDeep(currentVal, data);

	              set_1(this.root, pathArr, mergedVal);
	            } else {
	              var _currentVal = get_1(this.root[_pageName], pathArr);

	              var _mergedVal; //TODO:unit test for data response shape


	              if (Array.isArray(_currentVal)) {
	                if (Array.isArray(data)) {
	                  _mergedVal = data;
	                } else {
	                  _mergedVal = [data];
	                }
	              } else {
	                _mergedVal = data;
	              }

	              set_1(this.root[_pageName], pathArr, _mergedVal);
	            }

	            this.dispatch({
	              type: 'update-localStorage'
	            });
	            return;
	          }

	        case 'get-data':
	          {
	            var _action$payload2 = action.payload,
	                _pageName2 = _action$payload2.pageName,
	                _dataKey = _action$payload2.dataKey;

	            var _pathArr = _dataKey.split('.');

	            var _currentVal2 = get_1(this.root[_pageName2], _pathArr) || get_1(this.root, _pathArr);

	            return _currentVal2;
	          }

	        case 'eval-object':
	          {
	            var _action$payload3 = action.payload,
	                _pageName3 = _action$payload3.pageName,
	                updateObject = _action$payload3.updateObject;

	            var _populateWithRoot = populateObject({
	              source: updateObject,
	              lookFor: '.',
	              locations: [this.root, this.root[_pageName3]]
	            });

	            var _populateWithSelf = populateObject({
	              source: _populateWithRoot,
	              lookFor: '..',
	              locations: [this.root, this.root[_pageName3]]
	            });

	            var _populateAfterInheriting = populateObject({
	              source: _populateWithSelf,
	              lookFor: '=',
	              locations: [this, this.root, this.root[_pageName3]]
	            });

	            Object.keys(_populateAfterInheriting).forEach( /*#__PURE__*/function () {
	              var _ref4 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(key) {
	                var trimPath, location, _pathArr2, val, _trimPath, _pathArr3, _val, _populateWithRoot2, _populateWithSelf2, _populateAfterInheriting2, _boundDispatch, withFn;

	                return regenerator.wrap(function _callee5$(_context5) {
	                  while (1) {
	                    switch (_context5.prev = _context5.next) {
	                      case 0:
	                        if (key.startsWith('=')) {
	                          _context5.next = 7;
	                          break;
	                        }

	                        if (key.startsWith('..')) {
	                          trimPath = key.substring(2, key.length - 1);
	                          location = _this.root[_pageName3];
	                        } else if (key.startsWith('.')) {
	                          trimPath = key.substring(1, key.length - 1);
	                          location = _this.root;
	                        }

	                        _pathArr2 = trimPath.split('.');
	                        val = _populateAfterInheriting[key];

	                        set_1(location, _pathArr2, val);

	                        _context5.next = 19;
	                        break;

	                      case 7:
	                        if (!key.startsWith('=')) {
	                          _context5.next = 19;
	                          break;
	                        }

	                        _trimPath = key.substring(2, key.length);
	                        _pathArr3 = _trimPath.split('.');
	                        _val = get_1(_this.root, _pathArr3) || get_1(_this.root[_pageName3], _pathArr3);
	                        _populateWithRoot2 = populateObject({
	                          source: _val,
	                          lookFor: '.',
	                          locations: [_this.root, _this.root[_pageName3]]
	                        });
	                        _populateWithSelf2 = populateObject({
	                          source: _populateWithRoot2,
	                          lookFor: '..',
	                          locations: [_this.root, _this.root[_pageName3]]
	                        });
	                        _populateAfterInheriting2 = populateObject({
	                          source: _populateWithSelf2,
	                          lookFor: '=',
	                          locations: [_this.root, _this.root[_pageName3]]
	                        });
	                        _boundDispatch = _this.dispatch.bind(_this);
	                        withFn = attachFns({
	                          cadlObject: _populateAfterInheriting2,
	                          dispatch: _boundDispatch
	                        });

	                        if (!(typeof withFn === 'function')) {
	                          _context5.next = 19;
	                          break;
	                        }

	                        _context5.next = 19;
	                        return withFn();

	                      case 19:
	                      case "end":
	                        return _context5.stop();
	                    }
	                  }
	                }, _callee5);
	              }));

	              return function (_x4) {
	                return _ref4.apply(this, arguments);
	              };
	            }()); //populates Global because this object is instantiated once 
	            //unlike pages that are instantiated multiple times and can be repopulated 
	            //when they are loaded again

	            this.dispatch({
	              type: 'populate',
	              payload: {
	                pageName: 'Global'
	              }
	            }); //update the localStorage root

	            this.dispatch({
	              type: 'update-localStorage'
	            });
	            break;
	          }

	        case 'update-localStorage':
	          {
	            var _this$root;

	            localStorage.setItem('Global', JSON.stringify((_this$root = this.root) === null || _this$root === void 0 ? void 0 : _this$root.Global));
	            break;
	          }

	        case 'update-map':
	          {
	            //TODO: consider adding update-page-map
	            this.map = dotObject.dot(this.root);
	            break;
	          }

	        case 'add-fn':
	          {
	            //actions for page currently used for signIn 
	            var _action$payload4 = action.payload,
	                _pageName4 = _action$payload4.pageName,
	                fn = _action$payload4.fn;

	            if (this.root.actions[_pageName4]) {
	              this.root.actions[_pageName4].update = fn;
	            } else {
	              this.root.actions[_pageName4] = {
	                update: fn
	              };
	            }

	            break;
	          }

	        case 'save-ref':
	          {
	            //saves path to references as object is populated
	            var _action$payload5 = action.payload,
	                _pageName5 = _action$payload5.pageName,
	                ref = _action$payload5.ref,
	                path = _action$payload5.path;

	            if (this.root.refs[_pageName5]) {
	              this.root.refs[_pageName5][path] = ref;
	            } else {
	              this.root.refs[_pageName5] = {};
	              this.root.refs[_pageName5][path] = ref;
	            }

	            break;
	          }

	        default:
	          {
	            return;
	          }
	      }
	    }
	    /**
	     * 
	     * @param UpdateObjectArgs
	     * @param UpdateObjectArgs.dataKey string
	     * @param UpdateObjectArgs.dataObject Record<string, any>
	     * @param UpdateObjectArgs.dataObjectKey string
	     * 
	     * -used for actionType updateObject
	     */

	  }, {
	    key: "updateObject",
	    value: function updateObject(_ref5) {
	      var dataKey = _ref5.dataKey,
	          dataObject = _ref5.dataObject,
	          dataObjectKey = _ref5.dataObjectKey;
	      var location = this.root;
	      var path;

	      if (dataKey.startsWith('.')) {
	        path = dataKey.substring(1, dataKey.length);
	      } else {
	        path = dataKey;
	      }

	      var pathArr = path.split('.');
	      var newVal = dataObjectKey ? dataObject[dataObjectKey] : dataObject;

	      set_1(location, pathArr, newVal);

	      this.dispatch({
	        type: 'update-localStorage'
	      });
	    }
	    /**
	     * 
	     * @param pageName string
	     * - runs the init functions of the page matching the pageName
	     */

	  }, {
	    key: "runInit",
	    value: function () {
	      var _runInit = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6(pageName) {
	        var boundDispatch, page, init, currIndex, command, actionType, dataKey, dataObject, updatedPage, populatedUpdatedPage, populatedUpdatedPageWithFns;
	        return regenerator.wrap(function _callee6$(_context6) {
	          while (1) {
	            switch (_context6.prev = _context6.next) {
	              case 0:
	                boundDispatch = this.dispatch.bind(this); //run init commands if any

	                page = this.root[pageName];
	                init = page.init;

	                if (!init) {
	                  _context6.next = 47;
	                  break;
	                }

	                this.initCallQueue = init.map(function (_command, index) {
	                  return index;
	                });

	              case 5:
	                if (!(this.initCallQueue.length > 0)) {
	                  _context6.next = 47;
	                  break;
	                }

	                currIndex = this.initCallQueue.shift();
	                command = init[currIndex];

	                if (!(typeof command === 'function')) {
	                  _context6.next = 19;
	                  break;
	                }

	                _context6.prev = 9;
	                _context6.next = 12;
	                return command();

	              case 12:
	                _context6.next = 17;
	                break;

	              case 14:
	                _context6.prev = 14;
	                _context6.t0 = _context6["catch"](9);
	                throw new UnableToExecuteFn("An error occured while executing ".concat(pageName, ".init"), _context6.t0);

	              case 17:
	                _context6.next = 39;
	                break;

	              case 19:
	                if (!(isObject_1(command) && 'actionType' in command)) {
	                  _context6.next = 29;
	                  break;
	                }

	                actionType = command.actionType, dataKey = command.dataKey, dataObject = command.dataObject;
	                _context6.t1 = actionType;
	                _context6.next = _context6.t1 === 'updateObject' ? 24 : 26;
	                break;

	              case 24:
	                this.updateObject({
	                  dataKey: dataKey,
	                  dataObject: dataObject
	                });
	                return _context6.abrupt("break", 27);

	              case 26:
	                return _context6.abrupt("return");

	              case 27:
	                _context6.next = 39;
	                break;

	              case 29:
	                if (!Array.isArray(command)) {
	                  _context6.next = 39;
	                  break;
	                }

	                if (!(typeof command[0][1] === 'function')) {
	                  _context6.next = 39;
	                  break;
	                }

	                _context6.prev = 31;
	                _context6.next = 34;
	                return command[0][1]();

	              case 34:
	                _context6.next = 39;
	                break;

	              case 36:
	                _context6.prev = 36;
	                _context6.t2 = _context6["catch"](31);
	                throw new UnableToExecuteFn("An error occured while executing ".concat(pageName, ".init"), _context6.t2);

	              case 39:
	                //updating page after command has been called
	                updatedPage = this.root[pageName]; //populateObject again to populate any data that was dependant on the command call

	                populatedUpdatedPage = populateObject({
	                  source: updatedPage,
	                  lookFor: '..',
	                  skip: ['components'],
	                  locations: [this.root[pageName]]
	                });
	                populatedUpdatedPageWithFns = attachFns({
	                  cadlObject: defineProperty({}, pageName, populatedUpdatedPage),
	                  dispatch: boundDispatch
	                });
	                page = populatedUpdatedPageWithFns;
	                init = Object.values(populatedUpdatedPageWithFns)[0].init;
	                this.root[pageName] = _objectSpread$d(_objectSpread$d({}, this.root[pageName]), Object.values(populatedUpdatedPageWithFns)[0]);
	                _context6.next = 5;
	                break;

	              case 47:
	              case "end":
	                return _context6.stop();
	            }
	          }
	        }, _callee6, this, [[9, 14], [31, 36]]);
	      }));

	      function runInit(_x5) {
	        return _runInit.apply(this, arguments);
	      }

	      return runInit;
	    }()
	    /**
	     * 
	     * @param key "user" | "meetroom"
	     * 
	     * -sets either the user or meetroom value from localStorage to the corresponding root value in memory
	     */

	  }, {
	    key: "setFromLocalStorage",
	    value: function setFromLocalStorage(key) {
	      var localStorageGlobal;

	      try {
	        var Global = localStorage.getItem('Global');

	        if (Global) {
	          localStorageGlobal = JSON.parse(Global);
	        }
	      } catch (error) {
	        console.log(error);
	      }

	      if (localStorageGlobal) {
	        switch (key) {
	          case "user":
	            {
	              var user = localStorageGlobal.currentUser.vertex;
	              this.root.Global.currentUser.vertex = user;
	              break;
	            }

	          case "meetroom":
	            {
	              var currMeetroom = localStorageGlobal.meetroom.edge;
	              this.root.Global.meetroom.edge = currMeetroom;
	              break;
	            }

	          default:
	            {
	              return;
	            }
	        }
	      }
	    }
	    /**
	     * 
	     * @param SetValueArgs
	     * @param SetValueArgs.path string
	     * @param SetValueArgs.value any
	     * 
	     * - set value to a given path. Assume the path begins at the root.
	     */

	  }, {
	    key: "setValue",
	    value: function setValue(_ref6) {
	      var path = _ref6.path,
	          value = _ref6.value;
	      var pathArr = path.split('.');

	      set_1(this.root, pathArr, value);

	      return;
	    }
	    /**
	     * 
	     * @param AddValueArgs 
	     * @param AddValueArgs.path string
	     * @param AddValueArgs.value any
	     * 
	     * - add value to a given path. Assume the path begins at the root.
	     */

	  }, {
	    key: "addValue",
	    value: function addValue(_ref7) {
	      var path = _ref7.path,
	          value = _ref7.value;
	      var pathArr = path.split('.');

	      var currVal = get_1(this.root, pathArr);

	      if (typeof currVal === 'undefined') {
	        currVal = [value];
	      } else if (Array.isArray(currVal)) {
	        currVal.push(value);
	      }

	      set_1(this.root, pathArr, currVal);

	      return;
	    }
	    /**
	     * 
	     * @param RemoveValue 
	     * @param RemoveValue.path string
	     * @param RemoveValue.Predicate Record<string, number | string>
	     * 
	     * - remove value from a given path. Assume the path begins at the root.
	     */

	  }, {
	    key: "removeValue",
	    value: function removeValue(_ref8) {
	      var path = _ref8.path,
	          predicate = _ref8.predicate;
	      var pathArr = path.split('.');

	      var currVal = get_1(this.root, pathArr);

	      if (currVal && Array.isArray(currVal)) {
	        var newVal = currVal.filter(function (elem) {
	          var passes = true;

	          for (var _i = 0, _Object$entries = Object.entries(predicate); _i < _Object$entries.length; _i++) {
	            var _Object$entries$_i = slicedToArray(_Object$entries[_i], 2),
	                key = _Object$entries$_i[0],
	                val = _Object$entries$_i[1];

	            if (elem[key] === val) {
	              passes = false;
	            }
	          }

	          return passes;
	        });

	        set_1(this.root, pathArr, newVal);
	      }
	    }
	    /**
	     * 
	     * @param ReplaceValueArgs 
	     * @param ReplaceValueArgs.path string
	     * @param ReplaceValueArgs.predicate Record<string, number | string>
	     * @param ReplaceValueArgs.value any
	     * 
	     * - replace value at a given path. Assume the path begins at the root.
	     */

	  }, {
	    key: "replaceValue",
	    value: function replaceValue(_ref9) {
	      var path = _ref9.path,
	          predicate = _ref9.predicate,
	          value = _ref9.value;
	      var pathArr = path.split('.');

	      var currVal = get_1(this.root, pathArr);

	      if (currVal && Array.isArray(currVal)) {
	        var currValCopy = toConsumableArray(currVal);

	        var valIndex = -1;

	        for (var i = 0; i < currValCopy.length; i++) {
	          for (var _i2 = 0, _Object$entries2 = Object.entries(predicate); _i2 < _Object$entries2.length; _i2++) {
	            var _Object$entries2$_i = slicedToArray(_Object$entries2[_i2], 2),
	                key = _Object$entries2$_i[0],
	                val = _Object$entries2$_i[1];

	            //TODO:refac to account for multiple conditions
	            if (currValCopy[i][key] === val) {
	              valIndex = i;
	            }
	          }
	        }

	        if (valIndex >= 0) {
	          currValCopy.splice(valIndex, 1, value);

	          set_1(this.root, pathArr, currValCopy);
	        }
	      }

	      return;
	    }
	  }, {
	    key: "resetReferences",
	    value: function resetReferences(pageName) {
	      var pageRefs = cloneDeep_1(this.root.refs[pageName]);

	      for (var _i3 = 0, _Object$entries3 = Object.entries(pageRefs); _i3 < _Object$entries3.length; _i3++) {
	        var _Object$entries3$_i = slicedToArray(_Object$entries3[_i3], 2),
	            path = _Object$entries3$_i[0],
	            ref = _Object$entries3$_i[1];

	        // let pathArr = path.split('.')
	        set_1(this.root[pageName], path, ref);
	      }
	    }
	  }, {
	    key: "getConfig",
	    value: function getConfig() {
	      return store$3.getConfig();
	    }
	    /**
	     * Only able to be set when env = development
	     * @param catcher if undefined, reset the catcher to be default
	     */

	  }, {
	    key: "setResponseCatcher",
	    value: function setResponseCatcher(catcher) {
	      store$3.setResponseCatcher(catcher);
	    }
	    /**
	     * Only able to be set when env = development
	     * @param catcher if undefined, reset the catcher to be default
	     */

	  }, {
	    key: "setErrorCatcher",
	    value: function setErrorCatcher(catcher) {
	      store$3.setErrorCatcher(catcher);
	    }
	  }, {
	    key: "cadlVersion",
	    get: function get() {
	      return this._cadlVersion;
	    },
	    set: function set(cadlVersion) {
	      this._cadlVersion = cadlVersion;
	    }
	  }, {
	    key: "cadlEndpoint",
	    get: function get() {
	      return this._cadlEndpoint;
	    },
	    set: function set(cadlEndpoint) {
	      this._cadlEndpoint = cadlEndpoint;
	    }
	  }, {
	    key: "baseUrl",
	    get: function get() {
	      return this._baseUrl;
	    },
	    set: function set(baseUrl) {
	      this._baseUrl = baseUrl.replace('${cadlBaseUrl}', this.cadlBaseUrl);
	    }
	  }, {
	    key: "cadlBaseUrl",
	    get: function get() {
	      return this._cadlBaseUrl;
	    },
	    set: function set(cadlBaseUrl) {
	      this._cadlBaseUrl = cadlBaseUrl.replace('${cadlVersion}', this.cadlVersion);
	    }
	  }, {
	    key: "assetsUrl",
	    get: function get() {
	      return this._assetsUrl;
	    },
	    set: function set(assetsUrl) {
	      this._assetsUrl = assetsUrl.replace('${cadlBaseUrl}', this.cadlBaseUrl);
	    }
	  }, {
	    key: "root",
	    get: function get() {
	      return this._root;
	    },
	    set: function set(root) {
	      this._root = root || {};
	    }
	  }, {
	    key: "builtIn",
	    get: function get() {
	      return this._builtIn;
	    },
	    set: function set(builtIn) {
	      this._builtIn = builtIn || {};
	    }
	  }, {
	    key: "apiVersion",
	    set: function set(apiVersion) {
	      store$3.apiVersion = apiVersion;
	    },
	    get: function get() {
	      return store$3.apiVersion;
	    }
	  }, {
	    key: "map",
	    set: function set(map) {
	      this._map = map;
	    },
	    get: function get() {
	      return this._map;
	    }
	  }, {
	    key: "initCallQueue",
	    set: function set(initCallQueue) {
	      this._initCallQueue = initCallQueue;
	    },
	    get: function get() {
	      return this._initCallQueue;
	    }
	  }]);

	  return CADL;
	}();

	var RootTypes;

	(function (RootTypes) {
	  RootTypes[RootTypes["docRoot"] = 10000] = "docRoot";
	})(RootTypes || (RootTypes = {}));

	var defaultConfig$1 = {
	  cadlVersion: 'test',
	  env: 'development',
	  configUrl: 'https://public.aitmed.com/config'
	};

	function ownKeys$e(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$e(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$e(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$e(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
	var testingPlayground = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
	  var cadl, vc, ed;
	  return regenerator.wrap(function _callee$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          // await test_LoginNewDevice({ phone_number: '+1 3238677306' }) // okMH+/8WSAgARxTuV7xqpA==
	          // await test_login({ password: 'letmein12' })
	          cadl = new CADL(_objectSpread$e({}, defaultConfig$1));
	          debugger;
	          _context.next = 4;
	          return cadl.init();

	        case 4:
	          debugger;
	          _context.next = 7;
	          return cadl.initPage('SignIn');

	        case 7:
	          // await cadl.initPage('CreateNewAccount')
	          debugger;
	          _context.next = 10;
	          return Account$1.requestVerificationCode('+1 7015168317');

	        case 10:
	          vc = _context.sent;
	          _context.next = 13;
	          return cadl.builtIn['signIn']({
	            password: "letmein12",
	            phoneNumber: "+1 7015168317",
	            verificationCode: vc
	          });

	        case 13:
	          debugger;
	          cadl.root.actions['SignIn'].update(); // cadl.root['CreateNewAccount'].update()

	          debugger; // await cadl.initPage('MeetingRoomInvited')
	          // debugger
	          // await cadl.runInit('MeetingRoomInvited')
	          // debugger

	          _context.next = 18;
	          return cadl.initPage('MeetingRoomCreate');

	        case 18:
	          debugger;
	          _context.next = 21;
	          return cadl.root['MeetingRoomCreate'].save[0][1]();

	        case 21:
	          debugger;
	          _context.next = 24;
	          return cadl.initPage('MeetingLobbyStart');

	        case 24:
	          debugger; // await cadl.runInit('MeetingRoomCreate')
	          // debugger
	          // cadl.updateObject({dataKey:'.Global.meetroom.edge.refid', dataObject:{id:'123'}, dataObjectKey:'id'})
	          // debugger
	          // debugger
	          // cadl.setFromLocalStorage('user')
	          // debugger
	          // cadl.setFromLocalStorage('meetroom')
	          // debugger
	          // await cadl.initPage('CreateMeeting')
	          // debugger
	          // await cadl.root['CreateMeeting'].components[1].children[2].onClick[0].object()
	          // debugger
	          // cadl.updateObject({dataKey:'.Global.meetroom.edge.name.roomName', dataObject:'hello tom'})
	          // debugger
	          // await cadl.root['MeetingLobbyStart'].components[1].children[3].onClick[0].object()

	          _context.next = 27;
	          return cadl.root['MeetingLobbyStart'].save[0][1]();

	        case 27:
	          ed = _context.sent;
	          debugger;
	          cadl.root.VideoChatObjStore.reference = ed;
	          debugger;
	          _context.next = 33;
	          return cadl.initPage('InviteeInfo01');

	        case 33:
	          debugger;
	          _context.next = 36;
	          return cadl.root['InviteeInfo01'].save[0][1]({
	            firstName: "Stan",
	            lastName: "koko"
	          });

	        case 36:
	          debugger;
	          _context.next = 39;
	          return cadl.initPage('VideoChat', [], {
	            builtIn: {
	              videoChat: function videoChat(_ref2) {
	                var roomId = _ref2.roomId,
	                    accessToken = _ref2.accessToken;
	                console.log(roomId);
	                console.log(accessToken);
	              }
	            }
	          });

	        case 39:
	          debugger;
	          _context.next = 42;
	          return cadl.initPage('MeetingLobbyClose');

	        case 42:
	          debugger;
	          cadl.setValue({
	            path: 'VideoChat.listData.participants',
	            value: [{
	              id: 1
	            }, {
	              id: 2
	            }, {
	              id: 3
	            }, {
	              id: 4
	            }]
	          });
	          debugger;
	          cadl.addValue({
	            path: 'VideoChat.listData.participants',
	            value: {
	              id: 5
	            }
	          });
	          debugger;
	          cadl.replaceValue({
	            path: 'VideoChat.listData.participants',
	            predicate: {
	              id: 5
	            },
	            value: {
	              id: 6,
	              name: 'tom'
	            }
	          });
	          debugger;
	          cadl.removeValue({
	            path: 'VideoChat.listData.participants',
	            predicate: {
	              id: 1
	            }
	          });
	          debugger;
	          console.log(cadl);
	          cadl.resetReferences('MeetingLobbyStart');
	          debugger;
	          cadl.initPage('MeetingLobbyStart', []);
	          console.log(cadl); // await cadl.initPage('InviteeInfo')
	          // debugger
	          // await cadl.root['InviteeInfo'].save[0][1]({ firstName: "Stan", lastName: "koko" })
	          // debugger
	          // await cadl.runInit('CreateMeeting')
	          // debugger
	          // await cadl.root['DashboardMeetingroom'].components[0].children[1].children[0].onClick[0].object()
	          // debugger
	          // await cadl.initPage('ApplyBusiness')
	          // debugger
	          // await cadl.root['ApplyBusiness'].formData.edgeAPI.store({ companyPhone: "+1 3431111dsdffsddsfd42essfsdfadfsdfsdsd1daf39" })
	          // debugger
	          // await cadl.root['ApplyBusiness'].formData.wciAPI.store({ type: 'text/plain', data: "+1 3009665sdsassaddsdsdsfsdfd1ffsdffsdfddaf39" })
	          // debugger
	          // await cadl.root['ApplyBusiness'].formData.w9API.store({ type: 'text/plain', data: "+1 hellow" })
	          // debugger
	          // //@ts-ignore
	          // const res = cadl.getData('CreateNewAccount', 'formData.vertex')
	          // debugger
	          // async function test_LoginNewDevice({ phone_number }) {
	          //     console.log('Testing loginNewDevice')
	          //     let verification_code
	          //     try {
	          //         verification_code = await Account.requestVerificationCode(
	          //             phone_number,
	          //         )
	          //     } catch (err) {
	          //         debugger
	          //         console.log(err)
	          //     }
	          //     try {
	          //         const loginResult = await Account.loginByVerificationCode(
	          //             phone_number,
	          //             verification_code,
	          //         ).catch((err) => {
	          //             console.log(err)
	          //             debugger
	          //         })
	          //         console.log(loginResult)
	          //     } catch (err) {
	          //         // debugger
	          //         console.log(err)
	          //     }
	          // }
	          //**************************** */
	          //**************************** */
	          //**************************** */
	          // async function test_login({ password }) {
	          //     console.log('Testing login')
	          //     try {
	          //         const loginResult = await Account.loginByPassword(
	          //             password,
	          //         )
	          //         console.log(loginResult)
	          //     } catch (err) {
	          //         console.log(err)
	          //     }
	          // }

	        case 56:
	        case "end":
	          return _context.stop();
	      }
	    }
	  }, _callee);
	}))();

	return testingPlayground;

}());
//# sourceMappingURL=bundle.js.map
